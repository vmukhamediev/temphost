import { r as react, _ as _typeof$1, a as reactIs, R as ReactDOM, b as _inherits, c as _createSuper, d as _classCallCheck, e as _createClass, j as jsx$1, f as _objectSpread2$1, t as toArray$6, s as sizeof, u as useToken, g as _slicedToArray, C as ConfigContext, h as useStyleRegister, i as genLinkStyle, k as _extends$2, l as genCommonStyle, w as warningOnce, m as React, n as generate$1, o as Context, p as _objectWithoutProperties, q as _defineProperty$1, v as jsxs, x as warning$2, F as Fragment, y as commonjsGlobal, z as _asyncToGenerator, A as _regeneratorRuntime, B as _assertThisInitialized, D as _toArray, E as _toConsumableArray, T as TinyColor, L as LocaleReceiver, G as ConfigConsumer, H as FormProvider$1, I as textEllipsis, J as resetComponent, K as resetIcon, M as canUseDom$1, N as ConfigProvider, S as SizeContext, O as DisabledContext, P as shallowequal, Q as genFocusOutline, U as clearFix, V as updateCSS$1, W as genFocusStyle, X as reactDom, Y as useForm$1, Z as DisabledContextProvider, $ as SizeContextProvider, a0 as RefForm, a1 as useLocaleReceiver, a2 as defaultLocale, a3 as Context$1, a4 as ListContext, a5 as WrapperField, a6 as List$3, a7 as useWatch, a8 as React$1, a9 as enUS, aa as ReactDOM$1, ab as getConfirmLocale, ac as globalConfig, ad as presetPrimaryColors, ae as gold, af as RULESET, ag as combine, ah as KEYFRAMES, ai as serialize, aj as copy$1, ak as replace, al as WEBKIT, am as DECLARATION, an as stringify$1, ao as compile, ap as hash, aq as charat, ar as MS, as as strlen, at as indexof, au as MOZ, av as match$1, aw as dealloc, ax as alloc, ay as next, az as token, aA as from, aB as peek, aC as delimit, aD as slice, aE as position, aF as defineMessages, aG as useIntl, aH as getDefaultExportFromCjs } from './main.26db00d4.js';

var classnames$1 = {exports: {}};

/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/

(function (module) {
	/* global define */

	(function () {

		var hasOwn = {}.hasOwnProperty;

		function classNames() {
			var classes = [];

			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;

				var argType = typeof arg;

				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg)) {
					if (arg.length) {
						var inner = classNames.apply(null, arg);
						if (inner) {
							classes.push(inner);
						}
					}
				} else if (argType === 'object') {
					if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
						classes.push(arg.toString());
						continue;
					}

					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}

			return classes.join(' ');
		}

		if (module.exports) {
			classNames.default = classNames;
			module.exports = classNames;
		} else {
			window.classNames = classNames;
		}
	}());
} (classnames$1));

const classNames$1 = classnames$1.exports;

function useMemo(getValue, condition, shouldUpdate) {
  var cacheRef = react.exports.useRef({});
  if (!('value' in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
    cacheRef.current.value = getValue();
    cacheRef.current.condition = condition;
  }
  return cacheRef.current.value;
}

function fillRef$1(ref, node) {
  if (typeof ref === 'function') {
    ref(node);
  } else if (_typeof$1(ref) === 'object' && ref && 'current' in ref) {
    ref.current = node;
  }
}
/**
 * Merge refs into one ref function to support ref passing.
 */
function composeRef$1() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(function (ref) {
    return ref;
  });
  if (refList.length <= 1) {
    return refList[0];
  }
  return function (node) {
    refs.forEach(function (ref) {
      fillRef$1(ref, node);
    });
  };
}
function useComposeRef() {
  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    refs[_key2] = arguments[_key2];
  }
  return useMemo(function () {
    return composeRef$1.apply(void 0, refs);
  }, refs, function (prev, next) {
    return prev.length === next.length && prev.every(function (ref, i) {
      return ref === next[i];
    });
  });
}
function supportRef$1(nodeOrComponent) {
  var _type$prototype, _nodeOrComponent$prot;
  var type = reactIs.exports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
  // Function component node
  if (typeof type === 'function' && !((_type$prototype = type.prototype) === null || _type$prototype === void 0 ? void 0 : _type$prototype.render)) {
    return false;
  }
  // Class component
  if (typeof nodeOrComponent === 'function' && !((_nodeOrComponent$prot = nodeOrComponent.prototype) === null || _nodeOrComponent$prot === void 0 ? void 0 : _nodeOrComponent$prot.render)) {
    return false;
  }
  return true;
}
/* eslint-enable */

/**
 * Return if a node is a DOM node. Else will return by `findDOMNode`
 */
function findDOMNode(node) {
  if (node instanceof HTMLElement) {
    return node;
  }
  return ReactDOM.findDOMNode(node);
}

/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser$1 = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof global !== 'undefined' && global.Math === Math) {
        return global;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle$1 (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser$1 || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser$1 || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement$1(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement$1(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser$1) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver$2 = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver$2.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index$1 = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver$2;
})();

var elementListeners = new Map();

function onResize(entities) {
  entities.forEach(function (entity) {
    var _elementListeners$get;

    var target = entity.target;
    (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 ? void 0 : _elementListeners$get.forEach(function (listener) {
      return listener(target);
    });
  });
} // Note: ResizeObserver polyfill not support option to measure border-box resize


var resizeObserver = new index$1(onResize); // Dev env only
// ============================== Observe ==============================

function observe(element, callback) {
  if (!elementListeners.has(element)) {
    elementListeners.set(element, new Set());
    resizeObserver.observe(element);
  }

  elementListeners.get(element).add(callback);
}
function unobserve(element, callback) {
  if (elementListeners.has(element)) {
    elementListeners.get(element).delete(callback);

    if (!elementListeners.get(element).size) {
      resizeObserver.unobserve(element);
      elementListeners.delete(element);
    }
  }
}

/**
 * Fallback to findDOMNode if origin ref do not provide any dom element
 */

var DomWrapper$1 = /*#__PURE__*/function (_React$Component) {
  _inherits(DomWrapper, _React$Component);

  var _super = _createSuper(DomWrapper);

  function DomWrapper() {
    _classCallCheck(this, DomWrapper);

    return _super.apply(this, arguments);
  }

  _createClass(DomWrapper, [{
    key: "render",
    value: function render() {
      return this.props.children;
    }
  }]);

  return DomWrapper;
}(react.exports.Component);

var CollectionContext = /*#__PURE__*/react.exports.createContext(null);
/**
 * Collect all the resize event from children ResizeObserver
 */

function Collection(_ref) {
  var children = _ref.children,
    onBatchResize = _ref.onBatchResize;
  var resizeIdRef = react.exports.useRef(0);
  var resizeInfosRef = react.exports.useRef([]);
  var onCollectionResize = react.exports.useContext(CollectionContext);
  var onResize = react.exports.useCallback(function (size, element, data) {
    resizeIdRef.current += 1;
    var currentId = resizeIdRef.current;
    resizeInfosRef.current.push({
      size: size,
      element: element,
      data: data
    });
    Promise.resolve().then(function () {
      if (currentId === resizeIdRef.current) {
        onBatchResize === null || onBatchResize === void 0 ? void 0 : onBatchResize(resizeInfosRef.current);
        resizeInfosRef.current = [];
      }
    }); // Continue bubbling if parent exist

    onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(size, element, data);
  }, [onBatchResize, onCollectionResize]);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(CollectionContext.Provider, {
      value: onResize,
      children: children
    })
  );
}

function SingleObserver(props) {
  var children = props.children,
    disabled = props.disabled;
  var elementRef = react.exports.useRef(null);
  var wrapperRef = react.exports.useRef(null);
  var onCollectionResize = react.exports.useContext(CollectionContext); // =========================== Children ===========================

  var isRenderProps = typeof children === 'function';
  var mergedChildren = isRenderProps ? children(elementRef) : children; // ============================= Size =============================

  var sizeRef = react.exports.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  }); // ============================= Ref ==============================

  var canRef = !isRenderProps && /*#__PURE__*/react.exports.isValidElement(mergedChildren) && supportRef$1(mergedChildren);
  var originRef = canRef ? mergedChildren.ref : null;
  var mergedRef = react.exports.useMemo(function () {
    return composeRef$1(originRef, elementRef);
  }, [originRef, elementRef]); // =========================== Observe ============================

  var propsRef = react.exports.useRef(props);
  propsRef.current = props; // Handler

  var onInternalResize = react.exports.useCallback(function (target) {
    var _propsRef$current = propsRef.current,
      onResize = _propsRef$current.onResize,
      data = _propsRef$current.data;
    var _target$getBoundingCl = target.getBoundingClientRect(),
      width = _target$getBoundingCl.width,
      height = _target$getBoundingCl.height;
    var offsetWidth = target.offsetWidth,
      offsetHeight = target.offsetHeight;
    /**
     * Resize observer trigger when content size changed.
     * In most case we just care about element size,
     * let's use `boundary` instead of `contentRect` here to avoid shaking.
     */

    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);
    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
      var size = {
        width: fixedWidth,
        height: fixedHeight,
        offsetWidth: offsetWidth,
        offsetHeight: offsetHeight
      };
      sizeRef.current = size; // IE is strange, right?

      var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
      var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
      var sizeInfo = _objectSpread2$1(_objectSpread2$1({}, size), {}, {
        offsetWidth: mergedOffsetWidth,
        offsetHeight: mergedOffsetHeight
      }); // Let collection know what happened

      onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(sizeInfo, target, data);
      if (onResize) {
        // defer the callback but not defer to next frame
        Promise.resolve().then(function () {
          onResize(sizeInfo, target);
        });
      }
    }
  }, []); // Dynamic observe

  react.exports.useEffect(function () {
    var currentElement = findDOMNode(elementRef.current) || findDOMNode(wrapperRef.current);
    if (currentElement && !disabled) {
      observe(currentElement, onInternalResize);
    }
    return function () {
      return unobserve(currentElement, onInternalResize);
    };
  }, [elementRef.current, disabled]); // ============================ Render ============================

  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(DomWrapper$1, {
      ref: wrapperRef,
      children: canRef ? /*#__PURE__*/react.exports.cloneElement(mergedChildren, {
        ref: mergedRef
      }) : mergedChildren
    })
  );
}

var INTERNAL_PREFIX_KEY = 'rc-observer-key';
function ResizeObserver$1(props) {
  var children = props.children;
  var childNodes = typeof children === 'function' ? [children] : toArray$6(children);
  return childNodes.map(function (child, index) {
    var key = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index);
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      react.exports.createElement(SingleObserver, {
        ...props,
        key: key
      }, child)
    );
  });
}
ResizeObserver$1.Collection = Collection;

function omit$1(obj, fields) {
  var clone = _objectSpread2$1({}, obj);
  if (Array.isArray(fields)) {
    fields.forEach(function (key) {
      delete clone[key];
    });
  }
  return clone;
}

/**
 * @param {function[]} collection
 * @return {function}
 */
function middleware (collection) {
	var length = sizeof(collection);

	return function (element, index, children, callback) {
		var output = '';

		for (var i = 0; i < length; i++)
			output += collection[i](element, index, children, callback) || '';

		return output
	}
}

/**
 * @param {function} callback
 * @return {function}
 */
function rulesheet (callback) {
	return function (element) {
		if (!element.root)
			if (element = element.return)
				callback(element);
	}
}

var Keyframe = /*#__PURE__*/function () {
  function Keyframe(name, style) {
    _classCallCheck(this, Keyframe);
    this.name = void 0;
    this.style = void 0;
    this._keyframe = true;
    this.name = name;
    this.style = style;
  }
  _createClass(Keyframe, [{
    key: "getName",
    value: function getName() {
      var hashId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      return hashId ? "".concat(hashId, "-").concat(this.name) : this.name;
    }
  }]);
  return Keyframe;
}();

var PresetColors = ['blue', 'purple', 'cyan', 'green', 'magenta', 'pink', 'red', 'orange', 'yellow', 'volcano', 'geekblue', 'lime', 'gold'];

// eslint-disable-next-line import/prefer-default-export
var operationUnit = function operationUnit(token) {
  return {
    // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
    // And Typography use this to generate link style which should not do this.
    color: token.colorLink,
    textDecoration: 'none',
    outline: 'none',
    cursor: 'pointer',
    transition: "color " + token.motionDurationSlow,
    '&:focus, &:hover': {
      color: token.colorLinkHover
    },
    '&:active': {
      color: token.colorLinkActive
    }
  };
};

var roundedArrow = function roundedArrow(width, innerRadius, outerRadius, bgColor, boxShadow) {
  var unitWidth = width / 2;
  var ax = unitWidth - outerRadius * (Math.sqrt(2) - 1);
  var ay = unitWidth;
  var bx = unitWidth + outerRadius * (1 - 1 / Math.sqrt(2));
  var by = unitWidth - outerRadius * (1 - 1 / Math.sqrt(2));
  var cx = 2 * unitWidth - innerRadius * (1 / Math.sqrt(2));
  var cy = innerRadius * (1 / Math.sqrt(2));
  var dx = 4 * unitWidth - cx;
  var dy = cy;
  var ex = 4 * unitWidth - bx;
  var ey = by;
  var fx = 4 * unitWidth - ax;
  var fy = ay;
  return {
    borderRadius: {
      _skip_check_: true,
      value: "0 0 " + innerRadius + "px"
    },
    pointerEvents: 'none',
    width: width * 2,
    height: width * 2,
    overflow: 'hidden',
    '&::after': {
      content: '""',
      position: 'absolute',
      width: width / Math.sqrt(2),
      height: width / Math.sqrt(2),
      bottom: 0,
      insetInline: 0,
      margin: 'auto',
      borderRadius: {
        _skip_check_: true,
        value: "0 0 " + innerRadius + "px 0"
      },
      transform: 'translateY(50%) rotate(-135deg)',
      boxShadow: boxShadow,
      zIndex: 0,
      background: 'transparent'
    },
    '&::before': {
      position: 'absolute',
      bottom: 0,
      insetInlineStart: 0,
      width: width * 2,
      height: width / 2,
      background: bgColor,
      clipPath: "path('M " + ax + " " + ay + " A " + outerRadius + " " + outerRadius + " 0 0 0 " + bx + " " + by + " L " + cx + " " + cy + " A " + innerRadius + " " + innerRadius + " 0 0 1 " + dx + " " + dy + " L " + ex + " " + ey + " A " + outerRadius + " " + outerRadius + " 0 0 0 " + fx + " " + fy + " Z')",
      content: '""'
    }
  };
};

function genComponentStyleHook(component, styleFn, getDefaultToken) {
  return function (prefixCls) {
    var _useToken = useToken(),
      _useToken2 = _slicedToArray(_useToken, 3),
      theme = _useToken2[0],
      token = _useToken2[1],
      hashId = _useToken2[2];
    var _useContext = react.exports.useContext(ConfigContext),
      getPrefixCls = _useContext.getPrefixCls,
      iconPrefixCls = _useContext.iconPrefixCls;
    var rootPrefixCls = getPrefixCls();
    // Generate style for all a tags in antd component.
    useStyleRegister({
      theme: theme,
      token: token,
      hashId: hashId,
      path: ['Shared', rootPrefixCls]
    }, function () {
      return [{
        // Link
        '&': genLinkStyle(token)
      }];
    });
    return [useStyleRegister({
      theme: theme,
      token: token,
      hashId: hashId,
      path: [component, prefixCls, iconPrefixCls]
    }, function () {
      var _statisticToken = statisticToken(token),
        proxyToken = _statisticToken.token,
        flush = _statisticToken.flush;
      var defaultComponentToken = typeof getDefaultToken === 'function' ? getDefaultToken(proxyToken) : getDefaultToken;
      var mergedComponentToken = _extends$2(_extends$2({}, defaultComponentToken), token[component]);
      var componentCls = "." + prefixCls;
      var mergedToken = merge$2(proxyToken, {
        componentCls: componentCls,
        prefixCls: prefixCls,
        iconCls: "." + iconPrefixCls,
        antCls: "." + rootPrefixCls
      }, mergedComponentToken);
      var styleInterpolation = styleFn(mergedToken, {
        hashId: hashId,
        prefixCls: prefixCls,
        rootPrefixCls: rootPrefixCls,
        iconPrefixCls: iconPrefixCls,
        overrideComponentToken: token[component]
      });
      flush(component, mergedComponentToken);
      return [genCommonStyle(prefixCls), styleInterpolation];
    }), hashId];
  };
}

var enableStatistic = typeof CSSINJS_STATISTIC !== 'undefined';
var recording = true;
/**
 * This function will do as `Object.assign` in production. But will use Object.defineProperty:get to
 * pass all value access in development. To support statistic field usage with alias token.
 */
function merge$2() {
  for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
    objs[_key] = arguments[_key];
  }
  /* istanbul ignore next */
  if (!enableStatistic) {
    return _extends$2.apply(void 0, [{}].concat(objs));
  }
  recording = false;
  var ret = {};
  objs.forEach(function (obj) {
    var keys = Object.keys(obj);
    keys.forEach(function (key) {
      Object.defineProperty(ret, key, {
        configurable: true,
        enumerable: true,
        get: function get() {
          return obj[key];
        }
      });
    });
  });
  recording = true;
  return ret;
}
/* istanbul ignore next */
function noop$5() {}
/** Statistic token usage case. Should use `merge` function if you do not want spread record. */
function statisticToken(token) {
  var tokenKeys;
  var proxy = token;
  var flush = noop$5;
  if (enableStatistic) {
    tokenKeys = new Set();
    proxy = new Proxy(token, {
      get: function get(obj, prop) {
        if (recording) {
          tokenKeys.add(prop);
        }
        return obj[prop];
      }
    });
    flush = function flush(componentName, componentToken) {
      ({
        global: Array.from(tokenKeys),
        component: componentToken
      });
    };
  }
  return {
    token: proxy,
    keys: tokenKeys,
    flush: flush
  };
}

var raf$1 = function raf(callback) {
  return +setTimeout(callback, 16);
};
var caf$1 = function caf(num) {
  return clearTimeout(num);
};
if (typeof window !== 'undefined' && 'requestAnimationFrame' in window) {
  raf$1 = function raf(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf$1 = function caf(handle) {
    return window.cancelAnimationFrame(handle);
  };
}
var rafUUID$1 = 0;
var rafIds$1 = new Map();
function cleanup$1(id) {
  rafIds$1.delete(id);
}
var wrapperRaf$2 = function wrapperRaf(callback) {
  var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  rafUUID$1 += 1;
  var id = rafUUID$1;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      // Clean up
      cleanup$1(id);
      // Trigger
      callback();
    } else {
      // Next raf
      var realId = raf$1(function () {
        callRef(leftTimes - 1);
      });
      // Bind real raf id
      rafIds$1.set(id, realId);
    }
  }
  callRef(times);
  return id;
};
wrapperRaf$2.cancel = function (id) {
  var realId = rafIds$1.get(id);
  cleanup$1(realId);
  return caf$1(realId);
};
const raf$2 = wrapperRaf$2;

// This icon file is generated automatically.
var CheckCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
const CheckCircleFilledSvg = CheckCircleFilled$2;

function canUseDom() {
  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
}

function contains(root, n) {
  if (!root) {
    return false;
  }
  // Use native if support
  if (root.contains) {
    return root.contains(n);
  }
  // `document.contains` not support with IE11
  var node = n;
  while (node) {
    if (node === root) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}

var APPEND_ORDER = 'data-rc-order';
var MARK_KEY = "rc-util-key";
var containerCache = new Map();
function getMark() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    mark = _ref.mark;
  if (mark) {
    return mark.startsWith('data-') ? mark : "data-".concat(mark);
  }
  return MARK_KEY;
}
function getContainer(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head = document.querySelector('head');
  return head || document.body;
}
function getOrder(prepend) {
  if (prepend === 'queue') {
    return 'prependQueue';
  }
  return prepend ? 'prepend' : 'append';
}
/**
 * Find style which inject by rc-util
 */
function findStyles(container) {
  return Array.from((containerCache.get(container) || container).children).filter(function (node) {
    return node.tagName === 'STYLE';
  });
}
function injectCSS(css) {
  var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (!canUseDom()) {
    return null;
  }
  var csp = option.csp,
    prepend = option.prepend;
  var styleNode = document.createElement('style');
  styleNode.setAttribute(APPEND_ORDER, getOrder(prepend));
  if (csp === null || csp === void 0 ? void 0 : csp.nonce) {
    styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
  }
  styleNode.innerHTML = css;
  var container = getContainer(option);
  var firstChild = container.firstChild;
  if (prepend) {
    // If is queue `prepend`, it will prepend first style and then append rest style
    if (prepend === 'queue') {
      var existStyle = findStyles(container).filter(function (node) {
        return ['prepend', 'prependQueue'].includes(node.getAttribute(APPEND_ORDER));
      });
      if (existStyle.length) {
        container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
        return styleNode;
      }
    }
    // Use `insertBefore` as `prepend`
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode(key) {
  var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var container = getContainer(option);
  return findStyles(container).find(function (node) {
    return node.getAttribute(getMark(option)) === key;
  });
}
function removeCSS(key) {
  var _existNode$parentNode;
  var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var existNode = findExistNode(key, option);
  existNode === null || existNode === void 0 ? void 0 : (_existNode$parentNode = existNode.parentNode) === null || _existNode$parentNode === void 0 ? void 0 : _existNode$parentNode.removeChild(existNode);
}
/**
 * qiankun will inject `appendChild` to insert into other
 */
function syncRealContainer(container, option) {
  var cachedRealContainer = containerCache.get(container);
  // Find real container when not cached or cached container removed
  if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
    var placeholderStyle = injectCSS('', option);
    var parentNode = placeholderStyle.parentNode;
    containerCache.set(container, parentNode);
    parentNode.removeChild(placeholderStyle);
  }
}
function updateCSS(css, key) {
  var option = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var container = getContainer(option);
  // Sync real parent
  syncRealContainer(container, option);
  var existNode = findExistNode(key, option);
  if (existNode) {
    var _option$csp, _option$csp2;
    if (((_option$csp = option.csp) === null || _option$csp === void 0 ? void 0 : _option$csp.nonce) && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
      var _option$csp3;
      existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
    }
    if (existNode.innerHTML !== css) {
      existNode.innerHTML = css;
    }
    return existNode;
  }
  var newNode = injectCSS(css, option);
  newNode.setAttribute(getMark(option), key);
  return newNode;
}

function warning$1(valid, message) {
  warningOnce(valid, "[@ant-design/icons] ".concat(message));
}
function isIconDefinition(target) {
  return _typeof$1(target) === 'object' && typeof target.name === 'string' && typeof target.theme === 'string' && (_typeof$1(target.icon) === 'object' || typeof target.icon === 'function');
}
function normalizeAttrs() {
  var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return Object.keys(attrs).reduce(function (acc, key) {
    var val = attrs[key];
    switch (key) {
      case 'class':
        acc.className = val;
        delete acc.class;
        break;
      default:
        acc[key] = val;
    }
    return acc;
  }, {});
}
function generate(node, key, rootProps) {
  if (!rootProps) {
    return /*#__PURE__*/React.createElement(node.tag, _objectSpread2$1({
      key: key
    }, normalizeAttrs(node.attrs)), (node.children || []).map(function (child, index) {
      return generate(child, "".concat(key, "-").concat(node.tag, "-").concat(index));
    }));
  }
  return /*#__PURE__*/React.createElement(node.tag, _objectSpread2$1(_objectSpread2$1({
    key: key
  }, normalizeAttrs(node.attrs)), rootProps), (node.children || []).map(function (child, index) {
    return generate(child, "".concat(key, "-").concat(node.tag, "-").concat(index));
  }));
}
function getSecondaryColor(primaryColor) {
  // choose the second color
  return generate$1(primaryColor)[0];
}
function normalizeTwoToneColors(twoToneColor) {
  if (!twoToneColor) {
    return [];
  }
  return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
}
var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
var useInsertStyles = function useInsertStyles() {
  var styleStr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : iconStyles;
  var _useContext = react.exports.useContext(Context),
    csp = _useContext.csp;
  react.exports.useEffect(function () {
    updateCSS(styleStr, '@ant-design-icons', {
      prepend: true,
      csp: csp
    });
  }, []);
};

var _excluded$M = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
var twoToneColorPalette = {
  primaryColor: '#333',
  secondaryColor: '#E6E6E6',
  calculated: false
};
function setTwoToneColors(_ref) {
  var primaryColor = _ref.primaryColor,
    secondaryColor = _ref.secondaryColor;
  twoToneColorPalette.primaryColor = primaryColor;
  twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
  twoToneColorPalette.calculated = !!secondaryColor;
}
function getTwoToneColors() {
  return _objectSpread2$1({}, twoToneColorPalette);
}
var IconBase = function IconBase(props) {
  var icon = props.icon,
    className = props.className,
    onClick = props.onClick,
    style = props.style,
    primaryColor = props.primaryColor,
    secondaryColor = props.secondaryColor,
    restProps = _objectWithoutProperties(props, _excluded$M);
  var colors = twoToneColorPalette;
  if (primaryColor) {
    colors = {
      primaryColor: primaryColor,
      secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
    };
  }
  useInsertStyles();
  warning$1(isIconDefinition(icon), "icon should be icon definiton, but got ".concat(icon));
  if (!isIconDefinition(icon)) {
    return null;
  }
  var target = icon;
  if (target && typeof target.icon === 'function') {
    target = _objectSpread2$1(_objectSpread2$1({}, target), {}, {
      icon: target.icon(colors.primaryColor, colors.secondaryColor)
    });
  }
  return generate(target.icon, "svg-".concat(target.name), _objectSpread2$1({
    className: className,
    onClick: onClick,
    style: style,
    'data-icon': target.name,
    width: '1em',
    height: '1em',
    fill: 'currentColor',
    'aria-hidden': 'true'
  }, restProps));
};
IconBase.displayName = 'IconReact';
IconBase.getTwoToneColors = getTwoToneColors;
IconBase.setTwoToneColors = setTwoToneColors;
const ReactIcon = IconBase;

function setTwoToneColor(twoToneColor) {
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor),
    _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2),
    primaryColor = _normalizeTwoToneColo2[0],
    secondaryColor = _normalizeTwoToneColo2[1];
  return ReactIcon.setTwoToneColors({
    primaryColor: primaryColor,
    secondaryColor: secondaryColor
  });
}
function getTwoToneColor() {
  var colors = ReactIcon.getTwoToneColors();
  if (!colors.calculated) {
    return colors.primaryColor;
  }
  return [colors.primaryColor, colors.secondaryColor];
}

var _excluded$L = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
setTwoToneColor('#1890ff');
var Icon$1 = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _classNames;
  var className = props.className,
    icon = props.icon,
    spin = props.spin,
    rotate = props.rotate,
    tabIndex = props.tabIndex,
    onClick = props.onClick,
    twoToneColor = props.twoToneColor,
    restProps = _objectWithoutProperties(props, _excluded$L);
  var _React$useContext = react.exports.useContext(Context),
    _React$useContext$pre = _React$useContext.prefixCls,
    prefixCls = _React$useContext$pre === void 0 ? 'anticon' : _React$useContext$pre,
    rootClassName = _React$useContext.rootClassName;
  var classString = classNames$1(rootClassName, prefixCls, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), _defineProperty$1(_classNames, "".concat(prefixCls, "-spin"), !!spin || icon.name === 'loading'), _classNames), className);
  var iconTabIndex = tabIndex;
  if (iconTabIndex === undefined && onClick) {
    iconTabIndex = -1;
  }
  var svgStyle = rotate ? {
    msTransform: "rotate(".concat(rotate, "deg)"),
    transform: "rotate(".concat(rotate, "deg)")
  } : undefined;
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor),
    _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2),
    primaryColor = _normalizeTwoToneColo2[0],
    secondaryColor = _normalizeTwoToneColo2[1];
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      ..._objectSpread2$1(_objectSpread2$1({
        role: "img",
        "aria-label": icon.name
      }, restProps), {}, {
        ref: ref,
        tabIndex: iconTabIndex,
        onClick: onClick,
        className: classString
      }),
      children: /*#__PURE__*/jsx$1(ReactIcon, {
        icon: icon,
        primaryColor: primaryColor,
        secondaryColor: secondaryColor,
        style: svgStyle
      })
    })
  );
});
Icon$1.displayName = 'AntdIcon';
Icon$1.getTwoToneColor = getTwoToneColor;
Icon$1.setTwoToneColor = setTwoToneColor;
const AntdIcon = Icon$1;

var CheckCircleFilled = function CheckCircleFilled(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: CheckCircleFilledSvg
      })
    })
  );
};
CheckCircleFilled.displayName = 'CheckCircleFilled';
const CheckCircleFilled$1 = /*#__PURE__*/react.exports.forwardRef(CheckCircleFilled);

// This icon file is generated automatically.
var CloseCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z" } }] }, "name": "close-circle", "theme": "filled" };
const CloseCircleFilledSvg = CloseCircleFilled$2;

var CloseCircleFilled = function CloseCircleFilled(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: CloseCircleFilledSvg
      })
    })
  );
};
CloseCircleFilled.displayName = 'CloseCircleFilled';
const CloseCircleFilled$1 = /*#__PURE__*/react.exports.forwardRef(CloseCircleFilled);

// This icon file is generated automatically.
var CloseOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 00203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z" } }] }, "name": "close", "theme": "outlined" };
const CloseOutlinedSvg = CloseOutlined$2;

var CloseOutlined = function CloseOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: CloseOutlinedSvg
      })
    })
  );
};
CloseOutlined.displayName = 'CloseOutlined';
const CloseOutlined$1 = /*#__PURE__*/react.exports.forwardRef(CloseOutlined);

// This icon file is generated automatically.
var ExclamationCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
const ExclamationCircleFilledSvg = ExclamationCircleFilled$2;

var ExclamationCircleFilled = function ExclamationCircleFilled(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: ExclamationCircleFilledSvg
      })
    })
  );
};
ExclamationCircleFilled.displayName = 'ExclamationCircleFilled';
const ExclamationCircleFilled$1 = /*#__PURE__*/react.exports.forwardRef(ExclamationCircleFilled);

// This icon file is generated automatically.
var InfoCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };
const InfoCircleFilledSvg = InfoCircleFilled$2;

var InfoCircleFilled = function InfoCircleFilled(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: InfoCircleFilledSvg
      })
    })
  );
};
InfoCircleFilled.displayName = 'InfoCircleFilled';
const InfoCircleFilled$1 = /*#__PURE__*/react.exports.forwardRef(InfoCircleFilled);

// Event wrapper. Copy from react source code

function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
  prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
  prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
  prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
  return prefixes;
}

function getVendorPrefixes(domSupport, win) {
  var prefixes = {
    animationend: makePrefixMap('Animation', 'AnimationEnd'),
    transitionend: makePrefixMap('Transition', 'TransitionEnd')
  };

  if (domSupport) {
    if (!('AnimationEvent' in win)) {
      delete prefixes.animationend.animation;
    }

    if (!('TransitionEvent' in win)) {
      delete prefixes.transitionend.transition;
    }
  }

  return prefixes;
}
var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== 'undefined' ? window : {});
var style = {};

if (canUseDom()) {
  var _document$createEleme = document.createElement('div');

  style = _document$createEleme.style;
}

var prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  }

  var prefixMap = vendorPrefixes[eventName];

  if (prefixMap) {
    var stylePropList = Object.keys(prefixMap);
    var len = stylePropList.length;

    for (var i = 0; i < len; i += 1) {
      var styleProp = stylePropList[i];

      if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
        prefixedEventNames[eventName] = prefixMap[styleProp];
        return prefixedEventNames[eventName];
      }
    }
  }

  return '';
}
var internalAnimationEndName = getVendorPrefixedEventName('animationend');
var internalTransitionEndName = getVendorPrefixedEventName('transitionend');
var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
var animationEndName = internalAnimationEndName || 'animationend';
var transitionEndName = internalTransitionEndName || 'transitionend';
function getTransitionName$2(transitionName, transitionType) {
  if (!transitionName) return null;

  if (_typeof$1(transitionName) === 'object') {
    var type = transitionType.replace(/-\w/g, function (match) {
      return match[1].toUpperCase();
    });
    return transitionName[type];
  }

  return "".concat(transitionName, "-").concat(transitionType);
}

var STATUS_NONE = 'none';
var STATUS_APPEAR = 'appear';
var STATUS_ENTER = 'enter';
var STATUS_LEAVE = 'leave';
var STEP_NONE = 'none';
var STEP_PREPARE = 'prepare';
var STEP_START = 'start';
var STEP_ACTIVE = 'active';
var STEP_ACTIVATED = 'end';

/**
 * Same as React.useState but `setState` accept `ignoreDestroy` param to not to setState after destroyed.
 * We do not make this auto is to avoid real memory leak.
 * Developer should confirm it's safe to ignore themselves.
 */
function useSafeState$1(defaultValue) {
  var destroyRef = react.exports.useRef(false);
  var _React$useState = react.exports.useState(defaultValue),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    value = _React$useState2[0],
    setValue = _React$useState2[1];
  react.exports.useEffect(function () {
    destroyRef.current = false;
    return function () {
      destroyRef.current = true;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }
    setValue(updater);
  }
  return [value, safeSetState];
}

var raf = function raf(callback) {
  return +setTimeout(callback, 16);
};
var caf = function caf(num) {
  return clearTimeout(num);
};
if (typeof window !== 'undefined' && 'requestAnimationFrame' in window) {
  raf = function raf(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf = function caf(handle) {
    return window.cancelAnimationFrame(handle);
  };
}
var rafUUID = 0;
var rafIds = new Map();
function cleanup(id) {
  rafIds.delete(id);
}
var wrapperRaf$1 = function wrapperRaf(callback) {
  var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  rafUUID += 1;
  var id = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      // Clean up
      cleanup(id);
      // Trigger
      callback();
    } else {
      // Next raf
      var realId = raf(function () {
        callRef(leftTimes - 1);
      });
      // Bind real raf id
      rafIds.set(id, realId);
    }
  }
  callRef(times);
  return id;
};
wrapperRaf$1.cancel = function (id) {
  var realId = rafIds.get(id);
  cleanup(realId);
  return caf(realId);
};

const useNextFrame = (function () {
  var nextFrameRef = react.exports.useRef(null);

  function cancelNextFrame() {
    wrapperRaf$1.cancel(nextFrameRef.current);
  }

  function nextFrame(callback) {
    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    cancelNextFrame();
    var nextFrameId = wrapperRaf$1(function () {
      if (delay <= 1) {
        callback({
          isCanceled: function isCanceled() {
            return nextFrameId !== nextFrameRef.current;
          }
        });
      } else {
        nextFrame(callback, delay - 1);
      }
    });
    nextFrameRef.current = nextFrameId;
  }

  react.exports.useEffect(function () {
    return function () {
      cancelNextFrame();
    };
  }, []);
  return [nextFrame, cancelNextFrame];
});

var useIsomorphicLayoutEffect = canUseDom() ? react.exports.useLayoutEffect : react.exports.useEffect;

var STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
/** Skip current step */

var SkipStep = false;
/** Current step should be update in */

var DoStep = true;
function isActive(step) {
  return step === STEP_ACTIVE || step === STEP_ACTIVATED;
}
const useStepQueue = (function (status, callback) {
  var _useState = useSafeState$1(STEP_NONE),
      _useState2 = _slicedToArray(_useState, 2),
      step = _useState2[0],
      setStep = _useState2[1];

  var _useNextFrame = useNextFrame(),
      _useNextFrame2 = _slicedToArray(_useNextFrame, 2),
      nextFrame = _useNextFrame2[0],
      cancelNextFrame = _useNextFrame2[1];

  function startQueue() {
    setStep(STEP_PREPARE, true);
  }

  useIsomorphicLayoutEffect(function () {
    if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
      var index = STEP_QUEUE.indexOf(step);
      var nextStep = STEP_QUEUE[index + 1];
      var result = callback(step);

      if (result === SkipStep) {
        // Skip when no needed
        setStep(nextStep, true);
      } else {
        // Do as frame for step update
        nextFrame(function (info) {
          function doNext() {
            // Skip since current queue is ood
            if (info.isCanceled()) return;
            setStep(nextStep, true);
          }

          if (result === true) {
            doNext();
          } else {
            // Only promise should be async
            Promise.resolve(result).then(doNext);
          }
        });
      }
    }
  }, [status, step]);
  react.exports.useEffect(function () {
    return function () {
      cancelNextFrame();
    };
  }, []);
  return [startQueue, step];
});

const useDomMotionEvents = (function (callback) {
  var cacheElementRef = react.exports.useRef(); // Cache callback

  var callbackRef = react.exports.useRef(callback);
  callbackRef.current = callback; // Internal motion event handler

  var onInternalMotionEnd = react.exports.useCallback(function (event) {
    callbackRef.current(event);
  }, []); // Remove events

  function removeMotionEvents(element) {
    if (element) {
      element.removeEventListener(transitionEndName, onInternalMotionEnd);
      element.removeEventListener(animationEndName, onInternalMotionEnd);
    }
  } // Patch events


  function patchMotionEvents(element) {
    if (cacheElementRef.current && cacheElementRef.current !== element) {
      removeMotionEvents(cacheElementRef.current);
    }

    if (element && element !== cacheElementRef.current) {
      element.addEventListener(transitionEndName, onInternalMotionEnd);
      element.addEventListener(animationEndName, onInternalMotionEnd); // Save as cache in case dom removed trigger by `motionDeadline`

      cacheElementRef.current = element;
    }
  } // Clean up when removed


  react.exports.useEffect(function () {
    return function () {
      removeMotionEvents(cacheElementRef.current);
    };
  }, []);
  return [patchMotionEvents, removeMotionEvents];
});

function useStatus(supportMotion, visible, getElement, _ref) {
  var _ref$motionEnter = _ref.motionEnter,
      motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter,
      _ref$motionAppear = _ref.motionAppear,
      motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear,
      _ref$motionLeave = _ref.motionLeave,
      motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave,
      motionDeadline = _ref.motionDeadline,
      motionLeaveImmediately = _ref.motionLeaveImmediately,
      onAppearPrepare = _ref.onAppearPrepare,
      onEnterPrepare = _ref.onEnterPrepare,
      onLeavePrepare = _ref.onLeavePrepare,
      onAppearStart = _ref.onAppearStart,
      onEnterStart = _ref.onEnterStart,
      onLeaveStart = _ref.onLeaveStart,
      onAppearActive = _ref.onAppearActive,
      onEnterActive = _ref.onEnterActive,
      onLeaveActive = _ref.onLeaveActive,
      onAppearEnd = _ref.onAppearEnd,
      onEnterEnd = _ref.onEnterEnd,
      onLeaveEnd = _ref.onLeaveEnd,
      onVisibleChanged = _ref.onVisibleChanged;

  // Used for outer render usage to avoid `visible: false & status: none` to render nothing
  var _useState = useSafeState$1(),
      _useState2 = _slicedToArray(_useState, 2),
      asyncVisible = _useState2[0],
      setAsyncVisible = _useState2[1];

  var _useState3 = useSafeState$1(STATUS_NONE),
      _useState4 = _slicedToArray(_useState3, 2),
      status = _useState4[0],
      setStatus = _useState4[1];

  var _useState5 = useSafeState$1(null),
      _useState6 = _slicedToArray(_useState5, 2),
      style = _useState6[0],
      setStyle = _useState6[1];

  var mountedRef = react.exports.useRef(false);
  var deadlineRef = react.exports.useRef(null); // =========================== Dom Node ===========================

  function getDomElement() {
    return getElement();
  } // ========================== Motion End ==========================


  var activeRef = react.exports.useRef(false);

  function onInternalMotionEnd(event) {
    var element = getDomElement();

    if (event && !event.deadline && event.target !== element) {
      // event exists
      // not initiated by deadline
      // transitionEnd not fired by inner elements
      return;
    }

    var currentActive = activeRef.current;
    var canEnd;

    if (status === STATUS_APPEAR && currentActive) {
      canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
    } else if (status === STATUS_ENTER && currentActive) {
      canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
    } else if (status === STATUS_LEAVE && currentActive) {
      canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
    } // Only update status when `canEnd` and not destroyed


    if (status !== STATUS_NONE && currentActive && canEnd !== false) {
      setStatus(STATUS_NONE, true);
      setStyle(null, true);
    }
  }

  var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd),
      _useDomMotionEvents2 = _slicedToArray(_useDomMotionEvents, 1),
      patchMotionEvents = _useDomMotionEvents2[0]; // ============================= Step =============================


  var eventHandlers = react.exports.useMemo(function () {
    var _ref2, _ref3, _ref4;

    switch (status) {
      case STATUS_APPEAR:
        return _ref2 = {}, _defineProperty$1(_ref2, STEP_PREPARE, onAppearPrepare), _defineProperty$1(_ref2, STEP_START, onAppearStart), _defineProperty$1(_ref2, STEP_ACTIVE, onAppearActive), _ref2;

      case STATUS_ENTER:
        return _ref3 = {}, _defineProperty$1(_ref3, STEP_PREPARE, onEnterPrepare), _defineProperty$1(_ref3, STEP_START, onEnterStart), _defineProperty$1(_ref3, STEP_ACTIVE, onEnterActive), _ref3;

      case STATUS_LEAVE:
        return _ref4 = {}, _defineProperty$1(_ref4, STEP_PREPARE, onLeavePrepare), _defineProperty$1(_ref4, STEP_START, onLeaveStart), _defineProperty$1(_ref4, STEP_ACTIVE, onLeaveActive), _ref4;

      default:
        return {};
    }
  }, [status]);

  var _useStepQueue = useStepQueue(status, function (newStep) {
    // Only prepare step can be skip
    if (newStep === STEP_PREPARE) {
      var onPrepare = eventHandlers[STEP_PREPARE];

      if (!onPrepare) {
        return SkipStep;
      }

      return onPrepare(getDomElement());
    } // Rest step is sync update


    // Rest step is sync update
    if (step in eventHandlers) {
      var _eventHandlers$step;

      setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
    }

    if (step === STEP_ACTIVE) {
      // Patch events when motion needed
      patchMotionEvents(getDomElement());

      if (motionDeadline > 0) {
        clearTimeout(deadlineRef.current);
        deadlineRef.current = setTimeout(function () {
          onInternalMotionEnd({
            deadline: true
          });
        }, motionDeadline);
      }
    }

    return DoStep;
  }),
      _useStepQueue2 = _slicedToArray(_useStepQueue, 2),
      startStep = _useStepQueue2[0],
      step = _useStepQueue2[1];

  var active = isActive(step);
  activeRef.current = active; // ============================ Status ============================
  // Update with new status

  useIsomorphicLayoutEffect(function () {
    setAsyncVisible(visible);
    var isMounted = mountedRef.current;
    mountedRef.current = true;

    if (!supportMotion) {
      return;
    }

    var nextStatus; // Appear

    if (!isMounted && visible && motionAppear) {
      nextStatus = STATUS_APPEAR;
    } // Enter


    if (isMounted && visible && motionEnter) {
      nextStatus = STATUS_ENTER;
    } // Leave


    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
      nextStatus = STATUS_LEAVE;
    } // Update to next status


    if (nextStatus) {
      setStatus(nextStatus);
      startStep();
    }
  }, [visible]); // ============================ Effect ============================
  // Reset when motion changed

  react.exports.useEffect(function () {
    if ( // Cancel appear
    status === STATUS_APPEAR && !motionAppear || // Cancel enter
    status === STATUS_ENTER && !motionEnter || // Cancel leave
    status === STATUS_LEAVE && !motionLeave) {
      setStatus(STATUS_NONE);
    }
  }, [motionAppear, motionEnter, motionLeave]);
  react.exports.useEffect(function () {
    return function () {
      mountedRef.current = false;
      clearTimeout(deadlineRef.current);
    };
  }, []); // Trigger `onVisibleChanged`

  var firstMountChangeRef = react.exports.useRef(false);
  react.exports.useEffect(function () {
    // [visible & motion not end] => [!visible & motion end] still need trigger onVisibleChanged
    if (asyncVisible) {
      firstMountChangeRef.current = true;
    }

    if (asyncVisible !== undefined && status === STATUS_NONE) {
      // Skip first render is invisible since it's nothing changed
      if (firstMountChangeRef.current || asyncVisible) {
        onVisibleChanged === null || onVisibleChanged === void 0 ? void 0 : onVisibleChanged(asyncVisible);
      }

      firstMountChangeRef.current = true;
    }
  }, [asyncVisible, status]); // ============================ Styles ============================

  var mergedStyle = style;

  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
    mergedStyle = _objectSpread2$1({
      transition: 'none'
    }, mergedStyle);
  }

  return [status, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
}

var DomWrapper = /*#__PURE__*/function (_React$Component) {
  _inherits(DomWrapper, _React$Component);

  var _super = _createSuper(DomWrapper);

  function DomWrapper() {
    _classCallCheck(this, DomWrapper);

    return _super.apply(this, arguments);
  }

  _createClass(DomWrapper, [{
    key: "render",
    value: function render() {
      return this.props.children;
    }
  }]);

  return DomWrapper;
}(react.exports.Component);

function genCSSMotion(config) {
  var transitionSupport = config;
  if (_typeof$1(config) === 'object') {
    transitionSupport = config.transitionSupport;
  }
  function isSupportTransition(props) {
    return !!(props.motionName && transitionSupport);
  }
  var CSSMotion = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
    var _props$visible = props.visible,
      visible = _props$visible === void 0 ? true : _props$visible,
      _props$removeOnLeave = props.removeOnLeave,
      removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave,
      forceRender = props.forceRender,
      children = props.children,
      motionName = props.motionName,
      leavedClassName = props.leavedClassName,
      eventProps = props.eventProps;
    var supportMotion = isSupportTransition(props); // Ref to the react node, it may be a HTMLElement

    var nodeRef = react.exports.useRef(); // Ref to the dom wrapper in case ref can not pass to HTMLElement

    var wrapperNodeRef = react.exports.useRef();
    function getDomElement() {
      try {
        // Here we're avoiding call for findDOMNode since it's deprecated
        // in strict mode. We're calling it only when node ref is not
        // an instance of DOM HTMLElement. Otherwise use
        // findDOMNode as a final resort
        return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
      } catch (e) {
        // Only happen when `motionDeadline` trigger but element removed.
        return null;
      }
    }
    var _useStatus = useStatus(supportMotion, visible, getDomElement, props),
      _useStatus2 = _slicedToArray(_useStatus, 4),
      status = _useStatus2[0],
      statusStep = _useStatus2[1],
      statusStyle = _useStatus2[2],
      mergedVisible = _useStatus2[3]; // Record whether content has rendered
    // Will return null for un-rendered even when `removeOnLeave={false}`

    var renderedRef = react.exports.useRef(mergedVisible);
    if (mergedVisible) {
      renderedRef.current = true;
    } // ====================== Refs ======================

    var setNodeRef = react.exports.useCallback(function (node) {
      nodeRef.current = node;
      fillRef$1(ref, node);
    }, [ref]); // ===================== Render =====================

    var motionChildren;
    var mergedProps = _objectSpread2$1(_objectSpread2$1({}, eventProps), {}, {
      visible: visible
    });
    if (!children) {
      // No children
      motionChildren = null;
    } else if (status === STATUS_NONE || !isSupportTransition(props)) {
      // Stable children
      if (mergedVisible) {
        motionChildren = children(_objectSpread2$1({}, mergedProps), setNodeRef);
      } else if (!removeOnLeave && renderedRef.current) {
        motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {
          className: leavedClassName
        }), setNodeRef);
      } else if (forceRender) {
        motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {
          style: {
            display: 'none'
          }
        }), setNodeRef);
      } else {
        motionChildren = null;
      }
    } else {
      var _classNames;

      // In motion
      var statusSuffix;
      if (statusStep === STEP_PREPARE) {
        statusSuffix = 'prepare';
      } else if (isActive(statusStep)) {
        statusSuffix = 'active';
      } else if (statusStep === STEP_START) {
        statusSuffix = 'start';
      }
      motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {
        className: classNames$1(getTransitionName$2(motionName, status), (_classNames = {}, _defineProperty$1(_classNames, getTransitionName$2(motionName, "".concat(status, "-").concat(statusSuffix)), statusSuffix), _defineProperty$1(_classNames, motionName, typeof motionName === 'string'), _classNames)),
        style: statusStyle
      }), setNodeRef);
    } // Auto inject ref if child node not have `ref` props

    if ( /*#__PURE__*/react.exports.isValidElement(motionChildren) && supportRef$1(motionChildren)) {
      var _motionChildren = motionChildren,
        originNodeRef = _motionChildren.ref;
      if (!originNodeRef) {
        motionChildren = /*#__PURE__*/react.exports.cloneElement(motionChildren, {
          ref: setNodeRef
        });
      }
    }
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(DomWrapper, {
        ref: wrapperNodeRef,
        children: motionChildren
      })
    );
  });
  CSSMotion.displayName = 'CSSMotion';
  return CSSMotion;
}
const CSSMotion = genCSSMotion(supportTransition);

var STATUS_ADD = 'add';
var STATUS_KEEP = 'keep';
var STATUS_REMOVE = 'remove';
var STATUS_REMOVED = 'removed';
function wrapKeyToObject(key) {
  var keyObj;

  if (key && _typeof$1(key) === 'object' && 'key' in key) {
    keyObj = key;
  } else {
    keyObj = {
      key: key
    };
  }

  return _objectSpread2$1(_objectSpread2$1({}, keyObj), {}, {
    key: String(keyObj.key)
  });
}
function parseKeys() {
  var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return keys.map(wrapKeyToObject);
}
function diffKeys() {
  var prevKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var currentKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var list = [];
  var currentIndex = 0;
  var currentLen = currentKeys.length;
  var prevKeyObjects = parseKeys(prevKeys);
  var currentKeyObjects = parseKeys(currentKeys); // Check prev keys to insert or keep

  prevKeyObjects.forEach(function (keyObj) {
    var hit = false;

    for (var i = currentIndex; i < currentLen; i += 1) {
      var currentKeyObj = currentKeyObjects[i];

      if (currentKeyObj.key === keyObj.key) {
        // New added keys should add before current key
        if (currentIndex < i) {
          list = list.concat(currentKeyObjects.slice(currentIndex, i).map(function (obj) {
            return _objectSpread2$1(_objectSpread2$1({}, obj), {}, {
              status: STATUS_ADD
            });
          }));
          currentIndex = i;
        }

        list.push(_objectSpread2$1(_objectSpread2$1({}, currentKeyObj), {}, {
          status: STATUS_KEEP
        }));
        currentIndex += 1;
        hit = true;
        break;
      }
    } // If not hit, it means key is removed


    if (!hit) {
      list.push(_objectSpread2$1(_objectSpread2$1({}, keyObj), {}, {
        status: STATUS_REMOVE
      }));
    }
  }); // Add rest to the list

  if (currentIndex < currentLen) {
    list = list.concat(currentKeyObjects.slice(currentIndex).map(function (obj) {
      return _objectSpread2$1(_objectSpread2$1({}, obj), {}, {
        status: STATUS_ADD
      });
    }));
  }
  /**
   * Merge same key when it remove and add again:
   *    [1 - add, 2 - keep, 1 - remove] -> [1 - keep, 2 - keep]
   */


  var keys = {};
  list.forEach(function (_ref) {
    var key = _ref.key;
    keys[key] = (keys[key] || 0) + 1;
  });
  var duplicatedKeys = Object.keys(keys).filter(function (key) {
    return keys[key] > 1;
  });
  duplicatedKeys.forEach(function (matchKey) {
    // Remove `STATUS_REMOVE` node.
    list = list.filter(function (_ref2) {
      var key = _ref2.key,
          status = _ref2.status;
      return key !== matchKey || status !== STATUS_REMOVE;
    }); // Update `STATUS_ADD` to `STATUS_KEEP`

    list.forEach(function (node) {
      if (node.key === matchKey) {
        // eslint-disable-next-line no-param-reassign
        node.status = STATUS_KEEP;
      }
    });
  });
  return list;
}

var _excluded$K = ["component", "children", "onVisibleChanged", "onAllRemoved"],
  _excluded2$8 = ["status"];
var MOTION_PROP_NAMES = ['eventProps', 'visible', 'children', 'motionName', 'motionAppear', 'motionEnter', 'motionLeave', 'motionLeaveImmediately', 'motionDeadline', 'removeOnLeave', 'leavedClassName', 'onAppearStart', 'onAppearActive', 'onAppearEnd', 'onEnterStart', 'onEnterActive', 'onEnterEnd', 'onLeaveStart', 'onLeaveActive', 'onLeaveEnd'];
/**
 * Generate a CSSMotionList component with config
 * @param transitionSupport No need since CSSMotionList no longer depends on transition support
 * @param CSSMotion CSSMotion component
 */

function genCSSMotionList(transitionSupport) {
  var CSSMotion$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CSSMotion;
  var CSSMotionList = /*#__PURE__*/function (_React$Component) {
    _inherits(CSSMotionList, _React$Component);
    var _super = _createSuper(CSSMotionList);
    function CSSMotionList() {
      var _this;
      _classCallCheck(this, CSSMotionList);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _this.state = {
        keyEntities: []
      };
      _this.removeKey = function (removeKey) {
        var keyEntities = _this.state.keyEntities;
        var nextKeyEntities = keyEntities.map(function (entity) {
          if (entity.key !== removeKey) return entity;
          return _objectSpread2$1(_objectSpread2$1({}, entity), {}, {
            status: STATUS_REMOVED
          });
        });
        _this.setState({
          keyEntities: nextKeyEntities
        });
        return nextKeyEntities.filter(function (_ref) {
          var status = _ref.status;
          return status !== STATUS_REMOVED;
        }).length;
      };
      return _this;
    }
    _createClass(CSSMotionList, [{
      key: "render",
      value: function render() {
        var _this2 = this;
        var keyEntities = this.state.keyEntities;
        var _this$props = this.props,
          component = _this$props.component,
          children = _this$props.children,
          _onVisibleChanged = _this$props.onVisibleChanged,
          onAllRemoved = _this$props.onAllRemoved,
          restProps = _objectWithoutProperties(_this$props, _excluded$K);
        var Component = component || react.exports.Fragment;
        var motionProps = {};
        MOTION_PROP_NAMES.forEach(function (prop) {
          motionProps[prop] = restProps[prop];
          delete restProps[prop];
        });
        delete restProps.keys;
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(Component, {
            ...restProps,
            children: keyEntities.map(function (_ref2) {
              var status = _ref2.status,
                eventProps = _objectWithoutProperties(_ref2, _excluded2$8);
              var visible = status === STATUS_ADD || status === STATUS_KEEP;
              return (
                /*#__PURE__*/
                /*#__PURE__*/
                react.exports.createElement(CSSMotion$1, {
                  ...motionProps,
                  key: eventProps.key,
                  visible: visible,
                  eventProps: eventProps,
                  onVisibleChanged: function onVisibleChanged(changedVisible) {
                    _onVisibleChanged === null || _onVisibleChanged === void 0 ? void 0 : _onVisibleChanged(changedVisible, {
                      key: eventProps.key
                    });
                    if (!changedVisible) {
                      var restKeysCount = _this2.removeKey(eventProps.key);
                      if (restKeysCount === 0 && onAllRemoved) {
                        onAllRemoved();
                      }
                    }
                  }
                }, children)
              );
            })
          })
        );
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref3, _ref4) {
        var keys = _ref3.keys;
        var keyEntities = _ref4.keyEntities;
        var parsedKeyObjects = parseKeys(keys);
        var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
        return {
          keyEntities: mixedKeyEntities.filter(function (entity) {
            var prevEntity = keyEntities.find(function (_ref5) {
              var key = _ref5.key;
              return entity.key === key;
            }); // Remove if already mark as removed

            if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
              return false;
            }
            return true;
          })
        };
      } // ZombieJ: Return the count of rest keys. It's safe to refactor if need more info.
    }]);

    return CSSMotionList;
  }(react.exports.Component);
  CSSMotionList.defaultProps = {
    component: 'div'
  };
  return CSSMotionList;
}
const CSSMotionList = genCSSMotionList(supportTransition);

function getDataOrAriaProps(props) {
  return Object.keys(props).reduce(function (prev, key) {
    if ((key.startsWith('data-') || key.startsWith('aria-') || key === 'role') && !key.startsWith('data-__')) {
      prev[key] = props[key];
    }
    return prev;
  }, {});
}

var isValidElement = react.exports.isValidElement;
function isFragment(child) {
  return child && isValidElement(child) && child.type === react.exports.Fragment;
}
function replaceElement(element, replacement, props) {
  if (!isValidElement(element)) {
    return replacement;
  }
  return /*#__PURE__*/react.exports.cloneElement(element, typeof props === 'function' ? props(element.props || {}) : props);
}
function cloneElement(element, props) {
  return replaceElement(element, element, props);
}

function isWindow$2(obj) {
  return obj !== null && obj !== undefined && obj === obj.window;
}
function getScroll$2(target, top) {
  var _a, _b;
  if (typeof window === 'undefined') {
    return 0;
  }
  var method = top ? 'scrollTop' : 'scrollLeft';
  var result = 0;
  if (isWindow$2(target)) {
    result = target[top ? 'pageYOffset' : 'pageXOffset'];
  } else if (target instanceof Document) {
    result = target.documentElement[method];
  } else if (target instanceof HTMLElement) {
    result = target[method];
  } else if (target) {
    // According to the type inference, the `target` is `never` type.
    // Since we configured the loose mode type checking, and supports mocking the target with such shape below::
    //    `{ documentElement: { scrollLeft: 200, scrollTop: 400 } }`,
    //    the program may falls into this branch.
    // Check the corresponding tests for details. Don't sure what is the real scenario this happens.
    result = target[method];
  }
  if (target && !isWindow$2(target) && typeof result !== 'number') {
    result = (_b = ((_a = target.ownerDocument) !== null && _a !== void 0 ? _a : target).documentElement) === null || _b === void 0 ? void 0 : _b[method];
  }
  return result;
}

// eslint-disable-next-line import/prefer-default-export
function easeInOutCubic(t, b, c, d) {
  var cc = c - b;
  t /= d / 2;
  if (t < 1) {
    return cc / 2 * t * t * t + b;
  }
  // eslint-disable-next-line no-return-assign
  return cc / 2 * ((t -= 2) * t * t + 2) + b;
}

function scrollTo$1(y) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$getContainer = options.getContainer,
    getContainer = _options$getContainer === void 0 ? function () {
      return window;
    } : _options$getContainer,
    callback = options.callback,
    _options$duration = options.duration,
    duration = _options$duration === void 0 ? 450 : _options$duration;
  var container = getContainer();
  var scrollTop = getScroll$2(container, true);
  var startTime = Date.now();
  var frameFunc = function frameFunc() {
    var timestamp = Date.now();
    var time = timestamp - startTime;
    var nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y, duration);
    if (isWindow$2(container)) {
      container.scrollTo(window.pageXOffset, nextScrollTop);
    } else if (container instanceof Document || container.constructor.name === 'HTMLDocument') {
      container.documentElement.scrollTop = nextScrollTop;
    } else {
      container.scrollTop = nextScrollTop;
    }
    if (time < duration) {
      raf$2(frameFunc);
    } else if (typeof callback === 'function') {
      callback();
    }
  };
  raf$2(frameFunc);
}

function toArray$5(children) {
  var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var ret = [];
  React.Children.forEach(children, function (child) {
    if ((child === undefined || child === null) && !option.keepEmpty) {
      return;
    }
    if (Array.isArray(child)) {
      ret = ret.concat(toArray$5(child));
    } else if (reactIs.exports.isFragment(child) && child.props) {
      ret = ret.concat(toArray$5(child.props.children, option));
    } else {
      ret.push(child);
    }
  });
  return ret;
}

function useEvent$1(callback) {
  var fnRef = react.exports.useRef();
  fnRef.current = callback;
  var memoFn = react.exports.useCallback(function () {
    var _fnRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}

/**
 * Wrap `React.useLayoutEffect` which will not throw warning message in test env
 */
var useLayoutEffect$3 = canUseDom() ? react.exports.useLayoutEffect : react.exports.useEffect;
var useLayoutUpdateEffect$1 = function useLayoutUpdateEffect(callback, deps) {
  var firstMountRef = react.exports.useRef(true);
  useLayoutEffect$3(function () {
    if (!firstMountRef.current) {
      return callback();
    }
  }, deps);
  // We tell react that first mount has passed
  useLayoutEffect$3(function () {
    firstMountRef.current = false;
    return function () {
      firstMountRef.current = true;
    };
  }, []);
};

var Source;
(function (Source) {
  Source[Source["INNER"] = 0] = "INNER";
  Source[Source["PROP"] = 1] = "PROP";
})(Source || (Source = {}));
/** We only think `undefined` is empty */
function hasValue$2(value) {
  return value !== undefined;
}
/**
 * Similar to `useState` but will use props value if provided.
 * Note that internal use rc-util `useState` hook.
 */
function useMergedState$1(defaultStateValue, option) {
  var _ref = option || {},
    defaultValue = _ref.defaultValue,
    value = _ref.value,
    onChange = _ref.onChange,
    postState = _ref.postState;
  // ======================= Init =======================
  var _useState = useSafeState$1(function () {
      var finalValue = undefined;
      var source;
      if (hasValue$2(value)) {
        finalValue = value;
        source = Source.PROP;
      } else if (hasValue$2(defaultValue)) {
        finalValue = typeof defaultValue === 'function' ? defaultValue() : defaultValue;
        source = Source.PROP;
      } else {
        finalValue = typeof defaultStateValue === 'function' ? defaultStateValue() : defaultStateValue;
        source = Source.INNER;
      }
      return [finalValue, source, finalValue];
    }),
    _useState2 = _slicedToArray(_useState, 2),
    mergedValue = _useState2[0],
    setMergedValue = _useState2[1];
  var chosenValue = hasValue$2(value) ? value : mergedValue[0];
  var postMergedValue = postState ? postState(chosenValue) : chosenValue;
  // ======================= Sync =======================
  useLayoutUpdateEffect$1(function () {
    setMergedValue(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 1),
        prevValue = _ref3[0];
      return [value, Source.PROP, prevValue];
    });
  }, [value]);
  // ====================== Update ======================
  var changeEventPrevRef = react.exports.useRef();
  var triggerChange = useEvent$1(function (updater, ignoreDestroy) {
    setMergedValue(function (prev) {
      var _prev = _slicedToArray(prev, 3),
        prevValue = _prev[0],
        prevSource = _prev[1],
        prevPrevValue = _prev[2];
      var nextValue = typeof updater === 'function' ? updater(prevValue) : updater;
      // Do nothing if value not change
      if (nextValue === prevValue) {
        return prev;
      }
      // Use prev prev value if is in a batch update to avoid missing data
      var overridePrevValue = prevSource === Source.INNER && changeEventPrevRef.current !== prevPrevValue ? prevPrevValue : prevValue;
      return [nextValue, Source.INNER, overridePrevValue];
    }, ignoreDestroy);
  });
  // ====================== Change ======================
  var onChangeFn = useEvent$1(onChange);
  useLayoutEffect$3(function () {
    var _mergedValue = _slicedToArray(mergedValue, 3),
      current = _mergedValue[0],
      source = _mergedValue[1],
      prev = _mergedValue[2];
    if (current !== prev && source === Source.INNER) {
      onChangeFn(current, prev);
      changeEventPrevRef.current = prev;
    }
  }, [mergedValue]);
  return [postMergedValue, triggerChange];
}

const isMobile = (function () {
  if (typeof navigator === 'undefined' || typeof window === 'undefined') {
    return false;
  }
  var agent = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
});

/**
 * @ignore
 * some key-codes definition and utils from closure-library
 * @author yiminghe@gmail.com
 */
var KeyCode$1 = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  /**
   * END
   */
  END: 35,
  /**
   * HOME
   */
  HOME: 36,
  /**
   * LEFT
   */
  LEFT: 37,
  /**
   * UP
   */
  UP: 38,
  /**
   * RIGHT
   */
  RIGHT: 39,
  /**
   * DOWN
   */
  DOWN: 40,
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  /**
   * DELETE
   */
  DELETE: 46,
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  /**
   * DASH
   */
  DASH: 189,
  /**
   * EQUALS
   */
  EQUALS: 187,
  /**
   * COMMA
   */
  COMMA: 188,
  /**
   * PERIOD
   */
  PERIOD: 190,
  /**
   * SLASH
   */
  SLASH: 191,
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e) {
    var keyCode = e.keyCode;
    if (e.altKey && !e.ctrlKey || e.metaKey ||
    // Function keys don't generate text
    keyCode >= KeyCode$1.F1 && keyCode <= KeyCode$1.F12) {
      return false;
    }
    // The following keys are quite harmless, even in combination with
    // CTRL, ALT or SHIFT.
    switch (keyCode) {
      case KeyCode$1.ALT:
      case KeyCode$1.CAPS_LOCK:
      case KeyCode$1.CONTEXT_MENU:
      case KeyCode$1.CTRL:
      case KeyCode$1.DOWN:
      case KeyCode$1.END:
      case KeyCode$1.ESC:
      case KeyCode$1.HOME:
      case KeyCode$1.INSERT:
      case KeyCode$1.LEFT:
      case KeyCode$1.MAC_FF_META:
      case KeyCode$1.META:
      case KeyCode$1.NUMLOCK:
      case KeyCode$1.NUM_CENTER:
      case KeyCode$1.PAGE_DOWN:
      case KeyCode$1.PAGE_UP:
      case KeyCode$1.PAUSE:
      case KeyCode$1.PRINT_SCREEN:
      case KeyCode$1.RIGHT:
      case KeyCode$1.SHIFT:
      case KeyCode$1.UP:
      case KeyCode$1.WIN_KEY:
      case KeyCode$1.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  /**
   * whether character is entered.
   */
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode$1.ZERO && keyCode <= KeyCode$1.NINE) {
      return true;
    }
    if (keyCode >= KeyCode$1.NUM_ZERO && keyCode <= KeyCode$1.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode$1.A && keyCode <= KeyCode$1.Z) {
      return true;
    }
    // Safari sends zero key code for non-latin characters.
    if (window.navigator.userAgent.indexOf('WebKit') !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode$1.SPACE:
      case KeyCode$1.QUESTION_MARK:
      case KeyCode$1.NUM_PLUS:
      case KeyCode$1.NUM_MINUS:
      case KeyCode$1.NUM_PERIOD:
      case KeyCode$1.NUM_DIVISION:
      case KeyCode$1.SEMICOLON:
      case KeyCode$1.DASH:
      case KeyCode$1.EQUALS:
      case KeyCode$1.COMMA:
      case KeyCode$1.PERIOD:
      case KeyCode$1.SLASH:
      case KeyCode$1.APOSTROPHE:
      case KeyCode$1.SINGLE_QUOTE:
      case KeyCode$1.OPEN_SQUARE_BRACKET:
      case KeyCode$1.BACKSLASH:
      case KeyCode$1.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};

/**
 * BaseSelect provide some parsed data into context.
 * You can use this hooks to get them.
 */
var BaseSelectContext = /*#__PURE__*/react.exports.createContext(null);
function useBaseProps() {
  return react.exports.useContext(BaseSelectContext);
}

/**
 * Similar with `useLock`, but this hook will always execute last value.
 * When set to `true`, it will keep `true` for a short time even if `false` is set.
 */

function useDelayReset() {
  var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

  var _React$useState = react.exports.useState(false),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      bool = _React$useState2[0],
      setBool = _React$useState2[1];

  var delayRef = react.exports.useRef(null);

  var cancelLatest = function cancelLatest() {
    window.clearTimeout(delayRef.current);
  };

  react.exports.useEffect(function () {
    return cancelLatest;
  }, []);

  var delaySetBool = function delaySetBool(value, callback) {
    cancelLatest();
    delayRef.current = window.setTimeout(function () {
      setBool(value);

      if (callback) {
        callback();
      }
    }, timeout);
  };

  return [bool, delaySetBool, cancelLatest];
}

/**
 * Locker return cached mark.
 * If set to `true`, will return `true` in a short time even if set `false`.
 * If set to `false` and then set to `true`, will change to `true`.
 * And after time duration, it will back to `null` automatically.
 */

function useLock() {
  var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 250;
  var lockRef = react.exports.useRef(null);
  var timeoutRef = react.exports.useRef(null); // Clean up

  react.exports.useEffect(function () {
    return function () {
      window.clearTimeout(timeoutRef.current);
    };
  }, []);

  function doLock(locked) {
    if (locked || lockRef.current === null) {
      lockRef.current = locked;
    }

    window.clearTimeout(timeoutRef.current);
    timeoutRef.current = window.setTimeout(function () {
      lockRef.current = null;
    }, duration);
  }

  return [function () {
    return lockRef.current;
  }, doLock];
}

function useSelectTriggerControl(elements, open, triggerOpen, customizedTrigger) {
  var propsRef = react.exports.useRef(null);
  propsRef.current = {
    open: open,
    triggerOpen: triggerOpen,
    customizedTrigger: customizedTrigger
  };
  react.exports.useEffect(function () {
    function onGlobalMouseDown(event) {
      var _propsRef$current;

      // If trigger is customized, Trigger will take control of popupVisible
      if ((_propsRef$current = propsRef.current) !== null && _propsRef$current !== void 0 && _propsRef$current.customizedTrigger) {
        return;
      }

      var target = event.target;

      if (target.shadowRoot && event.composed) {
        target = event.composedPath()[0] || target;
      }

      if (propsRef.current.open && elements().filter(function (element) {
        return element;
      }).every(function (element) {
        return !element.contains(target) && element !== target;
      })) {
        // Should trigger close
        propsRef.current.triggerOpen(false);
      }
    }

    window.addEventListener('mousedown', onGlobalMouseDown);
    return function () {
      return window.removeEventListener('mousedown', onGlobalMouseDown);
    };
  }, []);
}

var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);
/* eslint-enable max-len */
var ariaPrefix = 'aria-';
var dataPrefix = 'data-';
function match(key, prefix) {
  return key.indexOf(prefix) === 0;
}
/**
 * Picker props from exist props with filter
 * @param props Passed props
 * @param ariaOnly boolean | { aria?: boolean; data?: boolean; attr?: boolean; } filter config
 */
function pickAttrs(props) {
  var ariaOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var mergedConfig;
  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = _objectSpread2$1({}, ariaOnly);
  }
  var attrs = {};
  Object.keys(props).forEach(function (key) {
    if (
    // Aria
    mergedConfig.aria && (key === 'role' || match(key, ariaPrefix)) ||
    // Data
    mergedConfig.data && match(key, dataPrefix) ||
    // Attr
    mergedConfig.attr && propList.includes(key)) {
      attrs[key] = props[key];
    }
  });
  return attrs;
}

var _excluded$J = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"];
var UNDEFINED = undefined;
function InternalItem(props, ref) {
  var prefixCls = props.prefixCls,
    invalidate = props.invalidate,
    item = props.item,
    renderItem = props.renderItem,
    responsive = props.responsive,
    responsiveDisabled = props.responsiveDisabled,
    registerSize = props.registerSize,
    itemKey = props.itemKey,
    className = props.className,
    style = props.style,
    children = props.children,
    display = props.display,
    order = props.order,
    _props$component = props.component,
    Component = _props$component === void 0 ? 'div' : _props$component,
    restProps = _objectWithoutProperties(props, _excluded$J);
  var mergedHidden = responsive && !display; // ================================ Effect ================================

  function internalRegisterSize(width) {
    registerSize(itemKey, width);
  }
  react.exports.useEffect(function () {
    return function () {
      internalRegisterSize(null);
    };
  }, []); // ================================ Render ================================

  var childNode = renderItem && item !== UNDEFINED ? renderItem(item) : children;
  var overflowStyle;
  if (!invalidate) {
    overflowStyle = {
      opacity: mergedHidden ? 0 : 1,
      height: mergedHidden ? 0 : UNDEFINED,
      overflowY: mergedHidden ? 'hidden' : UNDEFINED,
      order: responsive ? order : UNDEFINED,
      pointerEvents: mergedHidden ? 'none' : UNDEFINED,
      position: mergedHidden ? 'absolute' : UNDEFINED
    };
  }
  var overflowProps = {};
  if (mergedHidden) {
    overflowProps['aria-hidden'] = true;
  }
  var itemNode =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(Component, {
    className: classNames$1(!invalidate && prefixCls, className),
    style: _objectSpread2$1(_objectSpread2$1({}, overflowStyle), style),
    ...overflowProps,
    ...restProps,
    ref: ref,
    children: childNode
  });
  if (responsive) {
    itemNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(ResizeObserver$1, {
      onResize: function onResize(_ref) {
        var offsetWidth = _ref.offsetWidth;
        internalRegisterSize(offsetWidth);
      },
      disabled: responsiveDisabled,
      children: itemNode
    });
  }
  return itemNode;
}
var Item$5 = /*#__PURE__*/react.exports.forwardRef(InternalItem);
Item$5.displayName = 'Item';

/**
 * State generate. Return a `setState` but it will flush all state with one render to save perf.
 * This is not a realization of `unstable_batchedUpdates`.
 */

function useBatchFrameState() {
  var _useState = useSafeState$1({}),
      _useState2 = _slicedToArray(_useState, 2),
      forceUpdate = _useState2[1];

  var statesRef = react.exports.useRef([]);
  var walkingIndex = 0;
  var beforeFrameId = 0;

  function createState(defaultValue) {
    var myIndex = walkingIndex;
    walkingIndex += 1; // Fill value if not exist yet

    if (statesRef.current.length < myIndex + 1) {
      statesRef.current[myIndex] = defaultValue;
    } // Return filled as `setState`


    var value = statesRef.current[myIndex];

    function setValue(val) {
      statesRef.current[myIndex] = typeof val === 'function' ? val(statesRef.current[myIndex]) : val;
      wrapperRaf$1.cancel(beforeFrameId); // Flush with batch

      beforeFrameId = wrapperRaf$1(function () {
        forceUpdate({}, true);
      });
    }

    return [value, setValue];
  }

  return createState;
}

var _excluded$I = ["component"],
  _excluded2$7 = ["className"],
  _excluded3$1 = ["className"];
var InternalRawItem = function InternalRawItem(props, ref) {
  var context = react.exports.useContext(OverflowContext); // Render directly when context not provided

  if (!context) {
    var _props$component = props.component,
      Component = _props$component === void 0 ? 'div' : _props$component,
      _restProps = _objectWithoutProperties(props, _excluded$I);
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(Component, {
        ..._restProps,
        ref: ref
      })
    );
  }
  var contextClassName = context.className,
    restContext = _objectWithoutProperties(context, _excluded2$7);
  var className = props.className,
    restProps = _objectWithoutProperties(props, _excluded3$1); // Do not pass context to sub item to avoid multiple measure

  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(OverflowContext.Provider, {
      value: null,
      children: /*#__PURE__*/jsx$1(Item$5, {
        ref: ref,
        className: classNames$1(contextClassName, className),
        ...restContext,
        ...restProps
      })
    })
  );
};
var RawItem = /*#__PURE__*/react.exports.forwardRef(InternalRawItem);
RawItem.displayName = 'RawItem';

var _excluded$H = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"];
var OverflowContext = /*#__PURE__*/react.exports.createContext(null);
var RESPONSIVE = 'responsive';
var INVALIDATE = 'invalidate';
function defaultRenderRest(omittedItems) {
  return "+ ".concat(omittedItems.length, " ...");
}
function Overflow(props, ref) {
  var _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-overflow' : _props$prefixCls,
    _props$data = props.data,
    data = _props$data === void 0 ? [] : _props$data,
    renderItem = props.renderItem,
    renderRawItem = props.renderRawItem,
    itemKey = props.itemKey,
    _props$itemWidth = props.itemWidth,
    itemWidth = _props$itemWidth === void 0 ? 10 : _props$itemWidth,
    ssr = props.ssr,
    style = props.style,
    className = props.className,
    maxCount = props.maxCount,
    renderRest = props.renderRest,
    renderRawRest = props.renderRawRest,
    suffix = props.suffix,
    _props$component = props.component,
    Component = _props$component === void 0 ? 'div' : _props$component,
    itemComponent = props.itemComponent,
    onVisibleChange = props.onVisibleChange,
    restProps = _objectWithoutProperties(props, _excluded$H);
  var createUseState = useBatchFrameState();
  var fullySSR = ssr === 'full';
  var _createUseState = createUseState(null),
    _createUseState2 = _slicedToArray(_createUseState, 2),
    containerWidth = _createUseState2[0],
    setContainerWidth = _createUseState2[1];
  var mergedContainerWidth = containerWidth || 0;
  var _createUseState3 = createUseState(new Map()),
    _createUseState4 = _slicedToArray(_createUseState3, 2),
    itemWidths = _createUseState4[0],
    setItemWidths = _createUseState4[1];
  var _createUseState5 = createUseState(0),
    _createUseState6 = _slicedToArray(_createUseState5, 2),
    prevRestWidth = _createUseState6[0],
    setPrevRestWidth = _createUseState6[1];
  var _createUseState7 = createUseState(0),
    _createUseState8 = _slicedToArray(_createUseState7, 2),
    restWidth = _createUseState8[0],
    setRestWidth = _createUseState8[1];
  var _createUseState9 = createUseState(0),
    _createUseState10 = _slicedToArray(_createUseState9, 2),
    suffixWidth = _createUseState10[0],
    setSuffixWidth = _createUseState10[1];
  var _useState = react.exports.useState(null),
    _useState2 = _slicedToArray(_useState, 2),
    suffixFixedStart = _useState2[0],
    setSuffixFixedStart = _useState2[1];
  var _useState3 = react.exports.useState(null),
    _useState4 = _slicedToArray(_useState3, 2),
    displayCount = _useState4[0],
    setDisplayCount = _useState4[1];
  var mergedDisplayCount = react.exports.useMemo(function () {
    if (displayCount === null && fullySSR) {
      return Number.MAX_SAFE_INTEGER;
    }
    return displayCount || 0;
  }, [displayCount, containerWidth]);
  var _useState5 = react.exports.useState(false),
    _useState6 = _slicedToArray(_useState5, 2),
    restReady = _useState6[0],
    setRestReady = _useState6[1];
  var itemPrefixCls = "".concat(prefixCls, "-item"); // Always use the max width to avoid blink

  var mergedRestWidth = Math.max(prevRestWidth, restWidth); // ================================= Data =================================

  var isResponsive = maxCount === RESPONSIVE;
  var shouldResponsive = data.length && isResponsive;
  var invalidate = maxCount === INVALIDATE;
  /**
   * When is `responsive`, we will always render rest node to get the real width of it for calculation
   */

  var showRest = shouldResponsive || typeof maxCount === 'number' && data.length > maxCount;
  var mergedData = react.exports.useMemo(function () {
    var items = data;
    if (shouldResponsive) {
      if (containerWidth === null && fullySSR) {
        items = data;
      } else {
        items = data.slice(0, Math.min(data.length, mergedContainerWidth / itemWidth));
      }
    } else if (typeof maxCount === 'number') {
      items = data.slice(0, maxCount);
    }
    return items;
  }, [data, itemWidth, containerWidth, maxCount, shouldResponsive]);
  var omittedItems = react.exports.useMemo(function () {
    if (shouldResponsive) {
      return data.slice(mergedDisplayCount + 1);
    }
    return data.slice(mergedData.length);
  }, [data, mergedData, shouldResponsive, mergedDisplayCount]); // ================================= Item =================================

  var getKey = react.exports.useCallback(function (item, index) {
    var _ref;
    if (typeof itemKey === 'function') {
      return itemKey(item);
    }
    return (_ref = itemKey && (item === null || item === void 0 ? void 0 : item[itemKey])) !== null && _ref !== void 0 ? _ref : index;
  }, [itemKey]);
  var mergedRenderItem = react.exports.useCallback(renderItem || function (item) {
    return item;
  }, [renderItem]);
  function updateDisplayCount(count, suffixFixedStartVal, notReady) {
    // React 18 will sync render even when the value is same in some case.
    // We take `mergedData` as deps which may cause dead loop if it's dynamic generate.
    // ref: https://github.com/ant-design/ant-design/issues/36559
    if (displayCount === count && (suffixFixedStartVal === undefined || suffixFixedStartVal === suffixFixedStart)) {
      return;
    }
    setDisplayCount(count);
    if (!notReady) {
      setRestReady(count < data.length - 1);
      onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(count);
    }
    if (suffixFixedStartVal !== undefined) {
      setSuffixFixedStart(suffixFixedStartVal);
    }
  } // ================================= Size =================================

  function onOverflowResize(_, element) {
    setContainerWidth(element.clientWidth);
  }
  function registerSize(key, width) {
    setItemWidths(function (origin) {
      var clone = new Map(origin);
      if (width === null) {
        clone.delete(key);
      } else {
        clone.set(key, width);
      }
      return clone;
    });
  }
  function registerOverflowSize(_, width) {
    setRestWidth(width);
    setPrevRestWidth(restWidth);
  }
  function registerSuffixSize(_, width) {
    setSuffixWidth(width);
  } // ================================ Effect ================================

  function getItemWidth(index) {
    return itemWidths.get(getKey(mergedData[index], index));
  }
  useLayoutEffect$3(function () {
    if (mergedContainerWidth && mergedRestWidth && mergedData) {
      var totalWidth = suffixWidth;
      var len = mergedData.length;
      var lastIndex = len - 1; // When data count change to 0, reset this since not loop will reach

      if (!len) {
        updateDisplayCount(0, null);
        return;
      }
      for (var i = 0; i < len; i += 1) {
        var currentItemWidth = getItemWidth(i); // Fully will always render

        if (fullySSR) {
          currentItemWidth = currentItemWidth || 0;
        } // Break since data not ready

        if (currentItemWidth === undefined) {
          updateDisplayCount(i - 1, undefined, true);
          break;
        } // Find best match

        totalWidth += currentItemWidth;
        if (
        // Only one means `totalWidth` is the final width
        lastIndex === 0 && totalWidth <= mergedContainerWidth ||
        // Last two width will be the final width
        i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth) {
          // Additional check if match the end
          updateDisplayCount(lastIndex, null);
          break;
        } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
          // Can not hold all the content to show rest
          updateDisplayCount(i - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
          break;
        }
      }
      if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
        setSuffixFixedStart(null);
      }
    }
  }, [mergedContainerWidth, itemWidths, restWidth, suffixWidth, getKey, mergedData]); // ================================ Render ================================

  var displayRest = restReady && !!omittedItems.length;
  var suffixStyle = {};
  if (suffixFixedStart !== null && shouldResponsive) {
    suffixStyle = {
      position: 'absolute',
      left: suffixFixedStart,
      top: 0
    };
  }
  var itemSharedProps = {
    prefixCls: itemPrefixCls,
    responsive: shouldResponsive,
    component: itemComponent,
    invalidate: invalidate
  }; // >>>>> Choice render fun by `renderRawItem`

  var internalRenderItemNode = renderRawItem ? function (item, index) {
    var key = getKey(item, index);
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(OverflowContext.Provider, {
        value: _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), {}, {
          order: index,
          item: item,
          itemKey: key,
          registerSize: registerSize,
          display: index <= mergedDisplayCount
        }),
        children: renderRawItem(item, index)
      }, key)
    );
  } : function (item, index) {
    var key = getKey(item, index);
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      react.exports.createElement(Item$5, {
        ...itemSharedProps,
        order: index,
        key: key,
        item: item,
        renderItem: mergedRenderItem,
        itemKey: key,
        registerSize: registerSize,
        display: index <= mergedDisplayCount
      })
    );
  }; // >>>>> Rest node

  var restNode;
  var restContextProps = {
    order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
    className: "".concat(itemPrefixCls, "-rest"),
    registerSize: registerOverflowSize,
    display: displayRest
  };
  if (!renderRawRest) {
    var mergedRenderRest = renderRest || defaultRenderRest;
    restNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Item$5, {
      ...itemSharedProps,
      ...restContextProps,
      children: typeof mergedRenderRest === 'function' ? mergedRenderRest(omittedItems) : mergedRenderRest
    });
  } else if (renderRawRest) {
    restNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(OverflowContext.Provider, {
      value: _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), restContextProps),
      children: renderRawRest(omittedItems)
    });
  }
  var overflowNode =
  /*#__PURE__*/
  /*#__PURE__*/
  jsxs(Component, {
    className: classNames$1(!invalidate && prefixCls, className),
    style: style,
    ref: ref,
    ...restProps,
    children: [mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix &&
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Item$5, {
      ...itemSharedProps,
      responsive: isResponsive,
      responsiveDisabled: !shouldResponsive,
      order: mergedDisplayCount,
      className: "".concat(itemPrefixCls, "-suffix"),
      registerSize: registerSuffixSize,
      display: true,
      style: suffixStyle,
      children: suffix
    })]
  });
  if (isResponsive) {
    overflowNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(ResizeObserver$1, {
      onResize: onOverflowResize,
      disabled: !shouldResponsive,
      children: overflowNode
    });
  }
  return overflowNode;
}
var ForwardOverflow = /*#__PURE__*/react.exports.forwardRef(Overflow);
ForwardOverflow.displayName = 'Overflow';
ForwardOverflow.Item = RawItem;
ForwardOverflow.RESPONSIVE = RESPONSIVE;
ForwardOverflow.INVALIDATE = INVALIDATE; // Convert to generic type

var TransBtn = function TransBtn(_ref) {
  var className = _ref.className,
    customizeIcon = _ref.customizeIcon,
    customizeIconProps = _ref.customizeIconProps,
    _onMouseDown = _ref.onMouseDown,
    onClick = _ref.onClick,
    children = _ref.children;
  var icon;
  if (typeof customizeIcon === 'function') {
    icon = customizeIcon(customizeIconProps);
  } else {
    icon = customizeIcon;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      className: className,
      onMouseDown: function onMouseDown(event) {
        event.preventDefault();
        if (_onMouseDown) {
          _onMouseDown(event);
        }
      },
      style: {
        userSelect: 'none',
        WebkitUserSelect: 'none'
      },
      unselectable: "on",
      onClick: onClick,
      "aria-hidden": true,
      children: icon !== undefined ? icon :
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        className: classNames$1(className.split(/\s+/).map(function (cls) {
          return "".concat(cls, "-icon");
        })),
        children: children
      })
    })
  );
};

var Input$5 = function Input(_ref, ref) {
  var _inputNode2, _inputNode2$props;
  var prefixCls = _ref.prefixCls,
    id = _ref.id,
    inputElement = _ref.inputElement,
    disabled = _ref.disabled,
    tabIndex = _ref.tabIndex,
    autoFocus = _ref.autoFocus,
    autoComplete = _ref.autoComplete,
    editable = _ref.editable,
    activeDescendantId = _ref.activeDescendantId,
    value = _ref.value,
    maxLength = _ref.maxLength,
    _onKeyDown = _ref.onKeyDown,
    _onMouseDown = _ref.onMouseDown,
    _onChange = _ref.onChange,
    onPaste = _ref.onPaste,
    _onCompositionStart = _ref.onCompositionStart,
    _onCompositionEnd = _ref.onCompositionEnd,
    open = _ref.open,
    attrs = _ref.attrs;
  var inputNode = inputElement ||
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("input", {});
  var _inputNode = inputNode,
    originRef = _inputNode.ref,
    originProps = _inputNode.props;
  var onOriginKeyDown = originProps.onKeyDown,
    onOriginChange = originProps.onChange,
    onOriginMouseDown = originProps.onMouseDown,
    onOriginCompositionStart = originProps.onCompositionStart,
    onOriginCompositionEnd = originProps.onCompositionEnd,
    style = originProps.style;
  warning$2(!('maxLength' in inputNode.props));
  inputNode = /*#__PURE__*/react.exports.cloneElement(inputNode, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
    type: 'search'
  }, originProps), {}, {
    // Override over origin props
    id: id,
    ref: composeRef$1(ref, originRef),
    disabled: disabled,
    tabIndex: tabIndex,
    autoComplete: autoComplete || 'off',
    autoFocus: autoFocus,
    className: classNames$1("".concat(prefixCls, "-selection-search-input"), (_inputNode2 = inputNode) === null || _inputNode2 === void 0 ? void 0 : (_inputNode2$props = _inputNode2.props) === null || _inputNode2$props === void 0 ? void 0 : _inputNode2$props.className),
    role: 'combobox',
    'aria-expanded': open,
    'aria-haspopup': 'listbox',
    'aria-owns': "".concat(id, "_list"),
    'aria-autocomplete': 'list',
    'aria-controls': "".concat(id, "_list"),
    'aria-activedescendant': activeDescendantId
  }, attrs), {}, {
    value: editable ? value : '',
    maxLength: maxLength,
    readOnly: !editable,
    unselectable: !editable ? 'on' : null,
    style: _objectSpread2$1(_objectSpread2$1({}, style), {}, {
      opacity: editable ? null : 0
    }),
    onKeyDown: function onKeyDown(event) {
      _onKeyDown(event);
      if (onOriginKeyDown) {
        onOriginKeyDown(event);
      }
    },
    onMouseDown: function onMouseDown(event) {
      _onMouseDown(event);
      if (onOriginMouseDown) {
        onOriginMouseDown(event);
      }
    },
    onChange: function onChange(event) {
      _onChange(event);
      if (onOriginChange) {
        onOriginChange(event);
      }
    },
    onCompositionStart: function onCompositionStart(event) {
      _onCompositionStart(event);
      if (onOriginCompositionStart) {
        onOriginCompositionStart(event);
      }
    },
    onCompositionEnd: function onCompositionEnd(event) {
      _onCompositionEnd(event);
      if (onOriginCompositionEnd) {
        onOriginCompositionEnd(event);
      }
    },
    onPaste: onPaste
  }));
  return inputNode;
};
var RefInput = /*#__PURE__*/react.exports.forwardRef(Input$5);
RefInput.displayName = 'Input';

function toArray$4(value) {
  if (Array.isArray(value)) {
    return value;
  }

  return value !== undefined ? [value] : [];
}
var isClient = typeof window !== 'undefined' && window.document && window.document.documentElement;
/** Is client side and not jsdom */

var isBrowserClient$2 = isClient;
function hasValue$1(value) {
  return value !== undefined && value !== null;
}

function isTitleType$1(title) {
  return ['string', 'number'].includes(_typeof$1(title));
}

function getTitle(item) {
  var title = undefined;

  if (item) {
    if (isTitleType$1(item.title)) {
      title = item.title.toString();
    } else if (isTitleType$1(item.label)) {
      title = item.label.toString();
    }
  }

  return title;
}

/* eslint-disable react-hooks/rules-of-hooks */
/**
 * Wrap `React.useLayoutEffect` which will not throw warning message in test env
 */

function useLayoutEffect$2(effect, deps) {
  // Never happen in test env
  if (isBrowserClient$2) {
    /* istanbul ignore next */
    react.exports.useLayoutEffect(effect, deps);
  } else {
    react.exports.useEffect(effect, deps);
  }
}
/* eslint-enable */

function itemKey$1(value) {
  var _value$key;
  return (_value$key = value.key) !== null && _value$key !== void 0 ? _value$key : value.value;
}
var onPreventMouseDown = function onPreventMouseDown(event) {
  event.preventDefault();
  event.stopPropagation();
};
var SelectSelector = function SelectSelector(props) {
  var id = props.id,
    prefixCls = props.prefixCls,
    values = props.values,
    open = props.open,
    searchValue = props.searchValue,
    autoClearSearchValue = props.autoClearSearchValue,
    inputRef = props.inputRef,
    placeholder = props.placeholder,
    disabled = props.disabled,
    mode = props.mode,
    showSearch = props.showSearch,
    autoFocus = props.autoFocus,
    autoComplete = props.autoComplete,
    activeDescendantId = props.activeDescendantId,
    tabIndex = props.tabIndex,
    removeIcon = props.removeIcon,
    maxTagCount = props.maxTagCount,
    maxTagTextLength = props.maxTagTextLength,
    _props$maxTagPlacehol = props.maxTagPlaceholder,
    maxTagPlaceholder = _props$maxTagPlacehol === void 0 ? function (omittedValues) {
      return "+ ".concat(omittedValues.length, " ...");
    } : _props$maxTagPlacehol,
    tagRender = props.tagRender,
    onToggleOpen = props.onToggleOpen,
    onRemove = props.onRemove,
    onInputChange = props.onInputChange,
    onInputPaste = props.onInputPaste,
    onInputKeyDown = props.onInputKeyDown,
    onInputMouseDown = props.onInputMouseDown,
    onInputCompositionStart = props.onInputCompositionStart,
    onInputCompositionEnd = props.onInputCompositionEnd;
  var measureRef = react.exports.useRef(null);
  var _useState = react.exports.useState(0),
    _useState2 = _slicedToArray(_useState, 2),
    inputWidth = _useState2[0],
    setInputWidth = _useState2[1];
  var _useState3 = react.exports.useState(false),
    _useState4 = _slicedToArray(_useState3, 2),
    focused = _useState4[0],
    setFocused = _useState4[1];
  var selectionPrefixCls = "".concat(prefixCls, "-selection"); // ===================== Search ======================

  var inputValue = open || mode === "multiple" && autoClearSearchValue === false || mode === 'tags' ? searchValue : '';
  var inputEditable = mode === 'tags' || mode === "multiple" && autoClearSearchValue === false || showSearch && (open || focused); // We measure width and set to the input immediately

  useLayoutEffect$2(function () {
    setInputWidth(measureRef.current.scrollWidth);
  }, [inputValue]); // ===================== Render ======================
  // >>> Render Selector Node. Includes Item & Rest

  function defaultRenderSelector(item, content, itemDisabled, closable, onClose) {
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsxs("span", {
        className: classNames$1("".concat(selectionPrefixCls, "-item"), _defineProperty$1({}, "".concat(selectionPrefixCls, "-item-disabled"), itemDisabled)),
        title: getTitle(item),
        children: [/*#__PURE__*/jsx$1("span", {
          className: "".concat(selectionPrefixCls, "-item-content"),
          children: content
        }), closable &&
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(TransBtn, {
          className: "".concat(selectionPrefixCls, "-item-remove"),
          onMouseDown: onPreventMouseDown,
          onClick: onClose,
          customizeIcon: removeIcon,
          children: "\xD7"
        })]
      })
    );
  }
  function customizeRenderSelector(value, content, itemDisabled, closable, onClose) {
    var onMouseDown = function onMouseDown(e) {
      onPreventMouseDown(e);
      onToggleOpen(!open);
    };
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        onMouseDown: onMouseDown,
        children: tagRender({
          label: content,
          value: value,
          disabled: itemDisabled,
          closable: closable,
          onClose: onClose
        })
      })
    );
  }
  function renderItem(valueItem) {
    var itemDisabled = valueItem.disabled,
      label = valueItem.label,
      value = valueItem.value;
    var closable = !disabled && !itemDisabled;
    var displayLabel = label;
    if (typeof maxTagTextLength === 'number') {
      if (typeof label === 'string' || typeof label === 'number') {
        var strLabel = String(displayLabel);
        if (strLabel.length > maxTagTextLength) {
          displayLabel = "".concat(strLabel.slice(0, maxTagTextLength), "...");
        }
      }
    }
    var onClose = function onClose(event) {
      if (event) event.stopPropagation();
      onRemove(valueItem);
    };
    return typeof tagRender === 'function' ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose) : defaultRenderSelector(valueItem, displayLabel, itemDisabled, closable, onClose);
  }
  function renderRest(omittedValues) {
    var content = typeof maxTagPlaceholder === 'function' ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
    return defaultRenderSelector({
      title: content
    }, content, false);
  } // >>> Input Node

  var inputNode =
  /*#__PURE__*/
  /*#__PURE__*/
  jsxs("div", {
    className: "".concat(selectionPrefixCls, "-search"),
    style: {
      width: inputWidth
    },
    onFocus: function onFocus() {
      setFocused(true);
    },
    onBlur: function onBlur() {
      setFocused(false);
    },
    children: [/*#__PURE__*/jsx$1(RefInput, {
      ref: inputRef,
      open: open,
      prefixCls: prefixCls,
      id: id,
      inputElement: null,
      disabled: disabled,
      autoFocus: autoFocus,
      autoComplete: autoComplete,
      editable: inputEditable,
      activeDescendantId: activeDescendantId,
      value: inputValue,
      onKeyDown: onInputKeyDown,
      onMouseDown: onInputMouseDown,
      onChange: onInputChange,
      onPaste: onInputPaste,
      onCompositionStart: onInputCompositionStart,
      onCompositionEnd: onInputCompositionEnd,
      tabIndex: tabIndex,
      attrs: pickAttrs(props, true)
    }), /*#__PURE__*/jsxs("span", {
      ref: measureRef,
      className: "".concat(selectionPrefixCls, "-search-mirror"),
      "aria-hidden": true,
      children: [inputValue, "\xA0"]
    })]
  }); // >>> Selections

  var selectionNode =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(ForwardOverflow, {
    prefixCls: "".concat(selectionPrefixCls, "-overflow"),
    data: values,
    renderItem: renderItem,
    renderRest: renderRest,
    suffix: inputNode,
    itemKey: itemKey$1,
    maxCount: maxTagCount
  });
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs(Fragment, {
      children: [selectionNode, !values.length && !inputValue &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        className: "".concat(selectionPrefixCls, "-placeholder"),
        children: placeholder
      })]
    })
  );
};

var SingleSelector = function SingleSelector(props) {
  var inputElement = props.inputElement,
    prefixCls = props.prefixCls,
    id = props.id,
    inputRef = props.inputRef,
    disabled = props.disabled,
    autoFocus = props.autoFocus,
    autoComplete = props.autoComplete,
    activeDescendantId = props.activeDescendantId,
    mode = props.mode,
    open = props.open,
    values = props.values,
    placeholder = props.placeholder,
    tabIndex = props.tabIndex,
    showSearch = props.showSearch,
    searchValue = props.searchValue,
    activeValue = props.activeValue,
    maxLength = props.maxLength,
    onInputKeyDown = props.onInputKeyDown,
    onInputMouseDown = props.onInputMouseDown,
    onInputChange = props.onInputChange,
    onInputPaste = props.onInputPaste,
    onInputCompositionStart = props.onInputCompositionStart,
    onInputCompositionEnd = props.onInputCompositionEnd;
  var _React$useState = react.exports.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    inputChanged = _React$useState2[0],
    setInputChanged = _React$useState2[1];
  var combobox = mode === 'combobox';
  var inputEditable = combobox || showSearch;
  var item = values[0];
  var inputValue = searchValue || '';
  if (combobox && activeValue && !inputChanged) {
    inputValue = activeValue;
  }
  react.exports.useEffect(function () {
    if (combobox) {
      setInputChanged(false);
    }
  }, [combobox, activeValue]); // Not show text when closed expect combobox mode

  var hasTextInput = mode !== 'combobox' && !open && !showSearch ? false : !!inputValue; // Get title

  var title = getTitle(item);
  var renderPlaceholder = function renderPlaceholder() {
    if (item) {
      return null;
    }
    var hiddenStyle = hasTextInput ? {
      visibility: 'hidden'
    } : undefined;
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        className: "".concat(prefixCls, "-selection-placeholder"),
        style: hiddenStyle,
        children: placeholder
      })
    );
  };
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs(Fragment, {
      children: [/*#__PURE__*/jsx$1("span", {
        className: "".concat(prefixCls, "-selection-search"),
        children: /*#__PURE__*/jsx$1(RefInput, {
          ref: inputRef,
          prefixCls: prefixCls,
          id: id,
          open: open,
          inputElement: inputElement,
          disabled: disabled,
          autoFocus: autoFocus,
          autoComplete: autoComplete,
          editable: inputEditable,
          activeDescendantId: activeDescendantId,
          value: inputValue,
          onKeyDown: onInputKeyDown,
          onMouseDown: onInputMouseDown,
          onChange: function onChange(e) {
            setInputChanged(true);
            onInputChange(e);
          },
          onPaste: onInputPaste,
          onCompositionStart: onInputCompositionStart,
          onCompositionEnd: onInputCompositionEnd,
          tabIndex: tabIndex,
          attrs: pickAttrs(props, true),
          maxLength: combobox ? maxLength : undefined
        })
      }), !combobox && item && !hasTextInput &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        className: "".concat(prefixCls, "-selection-item"),
        title: title,
        children: item.label
      }), renderPlaceholder()]
    })
  );
};

/** keyCode Judgment function */

function isValidateOpenKey(currentKeyCode) {
  return ![// System function button
  KeyCode$1.ESC, KeyCode$1.SHIFT, KeyCode$1.BACKSPACE, KeyCode$1.TAB, KeyCode$1.WIN_KEY, KeyCode$1.ALT, KeyCode$1.META, KeyCode$1.WIN_KEY_RIGHT, KeyCode$1.CTRL, KeyCode$1.SEMICOLON, KeyCode$1.EQUALS, KeyCode$1.CAPS_LOCK, KeyCode$1.CONTEXT_MENU, // F1-F12
  KeyCode$1.F1, KeyCode$1.F2, KeyCode$1.F3, KeyCode$1.F4, KeyCode$1.F5, KeyCode$1.F6, KeyCode$1.F7, KeyCode$1.F8, KeyCode$1.F9, KeyCode$1.F10, KeyCode$1.F11, KeyCode$1.F12].includes(currentKeyCode);
}

var Selector = function Selector(props, ref) {
  var inputRef = react.exports.useRef(null);
  var compositionStatusRef = react.exports.useRef(false);
  var prefixCls = props.prefixCls,
    open = props.open,
    mode = props.mode,
    showSearch = props.showSearch,
    tokenWithEnter = props.tokenWithEnter,
    autoClearSearchValue = props.autoClearSearchValue,
    onSearch = props.onSearch,
    onSearchSubmit = props.onSearchSubmit,
    onToggleOpen = props.onToggleOpen,
    onInputKeyDown = props.onInputKeyDown,
    domRef = props.domRef; // ======================= Ref =======================

  react.exports.useImperativeHandle(ref, function () {
    return {
      focus: function focus() {
        inputRef.current.focus();
      },
      blur: function blur() {
        inputRef.current.blur();
      }
    };
  }); // ====================== Input ======================

  var _useLock = useLock(0),
    _useLock2 = _slicedToArray(_useLock, 2),
    getInputMouseDown = _useLock2[0],
    setInputMouseDown = _useLock2[1];
  var onInternalInputKeyDown = function onInternalInputKeyDown(event) {
    var which = event.which;
    if (which === KeyCode$1.UP || which === KeyCode$1.DOWN) {
      event.preventDefault();
    }
    if (onInputKeyDown) {
      onInputKeyDown(event);
    }
    if (which === KeyCode$1.ENTER && mode === 'tags' && !compositionStatusRef.current && !open) {
      // When menu isn't open, OptionList won't trigger a value change
      // So when enter is pressed, the tag's input value should be emitted here to let selector know
      onSearchSubmit === null || onSearchSubmit === void 0 ? void 0 : onSearchSubmit(event.target.value);
    }
    if (isValidateOpenKey(which)) {
      onToggleOpen(true);
    }
  };
  /**
   * We can not use `findDOMNode` sine it will get warning,
   * have to use timer to check if is input element.
   */

  var onInternalInputMouseDown = function onInternalInputMouseDown() {
    setInputMouseDown(true);
  }; // When paste come, ignore next onChange

  var pastedTextRef = react.exports.useRef(null);
  var triggerOnSearch = function triggerOnSearch(value) {
    if (onSearch(value, true, compositionStatusRef.current) !== false) {
      onToggleOpen(true);
    }
  };
  var onInputCompositionStart = function onInputCompositionStart() {
    compositionStatusRef.current = true;
  };
  var onInputCompositionEnd = function onInputCompositionEnd(e) {
    compositionStatusRef.current = false; // Trigger search again to support `tokenSeparators` with typewriting

    if (mode !== 'combobox') {
      triggerOnSearch(e.target.value);
    }
  };
  var onInputChange = function onInputChange(event) {
    var value = event.target.value; // Pasted text should replace back to origin content

    if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
      // CRLF will be treated as a single space for input element
      var replacedText = pastedTextRef.current.replace(/[\r\n]+$/, '').replace(/\r\n/g, ' ').replace(/[\r\n]/g, ' ');
      value = value.replace(replacedText, pastedTextRef.current);
    }
    pastedTextRef.current = null;
    triggerOnSearch(value);
  };
  var onInputPaste = function onInputPaste(e) {
    var clipboardData = e.clipboardData;
    var value = clipboardData.getData('text');
    pastedTextRef.current = value;
  };
  var onClick = function onClick(_ref) {
    var target = _ref.target;
    if (target !== inputRef.current) {
      // Should focus input if click the selector
      var isIE = document.body.style.msTouchAction !== undefined;
      if (isIE) {
        setTimeout(function () {
          inputRef.current.focus();
        });
      } else {
        inputRef.current.focus();
      }
    }
  };
  var onMouseDown = function onMouseDown(event) {
    var inputMouseDown = getInputMouseDown(); // when mode is combobox, don't prevent default behavior
    // https://github.com/ant-design/ant-design/issues/37320

    if (event.target !== inputRef.current && !inputMouseDown && mode !== 'combobox') {
      event.preventDefault();
    }
    if (mode !== 'combobox' && (!showSearch || !inputMouseDown) || !open) {
      if (open && autoClearSearchValue !== false) {
        onSearch('', true, false);
      }
      onToggleOpen();
    }
  }; // ================= Inner Selector ==================

  var sharedProps = {
    inputRef: inputRef,
    onInputKeyDown: onInternalInputKeyDown,
    onInputMouseDown: onInternalInputMouseDown,
    onInputChange: onInputChange,
    onInputPaste: onInputPaste,
    onInputCompositionStart: onInputCompositionStart,
    onInputCompositionEnd: onInputCompositionEnd
  };
  var selectNode = mode === 'multiple' || mode === 'tags' ?
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(SelectSelector, {
    ...props,
    ...sharedProps
  }) :
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(SingleSelector, {
    ...props,
    ...sharedProps
  });
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      ref: domRef,
      className: "".concat(prefixCls, "-selector"),
      onClick: onClick,
      onMouseDown: onMouseDown,
      children: selectNode
    })
  );
};
var ForwardSelector = /*#__PURE__*/react.exports.forwardRef(Selector);
ForwardSelector.displayName = 'Selector';

function addEventListenerWrap(target, eventType, cb, option) {
  /* eslint camelcase: 2 */
  var callback = ReactDOM.unstable_batchedUpdates ? function run(e) {
    ReactDOM.unstable_batchedUpdates(cb, e);
  } : cb;
  if (target.addEventListener) {
    target.addEventListener(eventType, callback, option);
  }
  return {
    remove: function remove() {
      if (target.removeEventListener) {
        target.removeEventListener(eventType, callback, option);
      }
    }
  };
}

var Portal$1 = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var didUpdate = props.didUpdate,
    getContainer = props.getContainer,
    children = props.children;
  var parentRef = react.exports.useRef();
  var containerRef = react.exports.useRef();
  // Ref return nothing, only for wrapper check exist
  react.exports.useImperativeHandle(ref, function () {
    return {};
  });
  // Create container in client side with sync to avoid useEffect not get ref
  var initRef = react.exports.useRef(false);
  if (!initRef.current && canUseDom()) {
    containerRef.current = getContainer();
    parentRef.current = containerRef.current.parentNode;
    initRef.current = true;
  }
  // [Legacy] Used by `rc-trigger`
  react.exports.useEffect(function () {
    didUpdate === null || didUpdate === void 0 ? void 0 : didUpdate(props);
  });
  react.exports.useEffect(function () {
    // Restore container to original place
    // React 18 StrictMode will unmount first and mount back for effect test:
    // https://reactjs.org/blog/2022/03/29/react-v18.html#new-strict-mode-behaviors
    if (containerRef.current.parentNode === null && parentRef.current !== null) {
      parentRef.current.appendChild(containerRef.current);
    }
    return function () {
      var _containerRef$current, _containerRef$current2;
      // [Legacy] This should not be handle by Portal but parent PortalWrapper instead.
      // Since some component use `Portal` directly, we have to keep the logic here.
      (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.parentNode) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.removeChild(containerRef.current);
    };
  }, []);
  return containerRef.current ? /*#__PURE__*/ReactDOM.createPortal(children, containerRef.current) : null;
});

function isPointsEq(a1, a2, isAlignPoint) {
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }

  return a1[0] === a2[0] && a1[1] === a2[1];
}

function getAlignFromPlacement(builtinPlacements, placementStr, align) {
  var baseAlign = builtinPlacements[placementStr] || {};
  return _objectSpread2$1(_objectSpread2$1({}, baseAlign), align);
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  var points = align.points;
  var placements = Object.keys(builtinPlacements);

  for (var i = 0; i < placements.length; i += 1) {
    var placement = placements[i];

    if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) {
      return "".concat(prefixCls, "-placement-").concat(placement);
    }
  }

  return '';
}

function getMotion$2(_ref) {
  var prefixCls = _ref.prefixCls,
      motion = _ref.motion,
      animation = _ref.animation,
      transitionName = _ref.transitionName;

  if (motion) {
    return motion;
  }

  if (animation) {
    return {
      motionName: "".concat(prefixCls, "-").concat(animation)
    };
  }

  if (transitionName) {
    return {
      motionName: transitionName
    };
  }

  return null;
}

function Mask$1(props) {
  var prefixCls = props.prefixCls,
    visible = props.visible,
    zIndex = props.zIndex,
    mask = props.mask,
    maskMotion = props.maskMotion,
    maskAnimation = props.maskAnimation,
    maskTransitionName = props.maskTransitionName;
  if (!mask) {
    return null;
  }
  var motion = {};
  if (maskMotion || maskTransitionName || maskAnimation) {
    motion = _objectSpread2$1({
      motionAppear: true
    }, getMotion$2({
      motion: maskMotion,
      prefixCls: prefixCls,
      transitionName: maskTransitionName,
      animation: maskAnimation
    }));
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(CSSMotion, {
      ...motion,
      visible: visible,
      removeOnLeave: true,
      children: function (_ref) {
        var className = _ref.className;
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("div", {
            style: {
              zIndex: zIndex
            },
            className: classNames$1("".concat(prefixCls, "-mask"), className)
          })
        );
      }
    })
  );
}

const isVisible = (function (element) {
  if (!element) {
    return false;
  }
  if (element instanceof HTMLElement && element.offsetParent) {
    return true;
  }
  if (element instanceof SVGGraphicsElement && element.getBBox) {
    var _element$getBBox = element.getBBox(),
      width = _element$getBBox.width,
      height = _element$getBBox.height;
    if (width || height) {
      return true;
    }
  }
  if (element instanceof HTMLElement && element.getBoundingClientRect) {
    var _element$getBoundingC = element.getBoundingClientRect(),
      _width = _element$getBoundingC.width,
      _height = _element$getBoundingC.height;
    if (_width || _height) {
      return true;
    }
  }
  return false;
});

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

var vendorPrefix;
var jsCssMap = {
  Webkit: '-webkit-',
  Moz: '-moz-',
  // IE did it wrong again ...
  ms: '-ms-',
  O: '-o-'
};
function getVendorPrefix() {
  if (vendorPrefix !== undefined) {
    return vendorPrefix;
  }
  vendorPrefix = '';
  var style = document.createElement('p').style;
  var testProp = 'Transform';
  for (var key in jsCssMap) {
    if (key + testProp in style) {
      vendorPrefix = key;
    }
  }
  return vendorPrefix;
}
function getTransitionName$1() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : 'transitionProperty';
}
function getTransformName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : 'transform';
}
function setTransitionProperty(node, value) {
  var name = getTransitionName$1();
  if (name) {
    node.style[name] = value;
    if (name !== 'transitionProperty') {
      node.style.transitionProperty = value;
    }
  }
}
function setTransform(node, value) {
  var name = getTransformName();
  if (name) {
    node.style[name] = value;
    if (name !== 'transform') {
      node.style.transform = value;
    }
  }
}
function getTransitionProperty(node) {
  return node.style.transitionProperty || node.style[getTransitionName$1()];
}
function getTransformXY(node) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());
  if (transform && transform !== 'none') {
    var matrix = transform.replace(/[^0-9\-.,]/g, '').split(',');
    return {
      x: parseFloat(matrix[12] || matrix[4], 0),
      y: parseFloat(matrix[13] || matrix[5], 0)
    };
  }
  return {
    x: 0,
    y: 0
  };
}
var matrix2d = /matrix\((.*)\)/;
var matrix3d = /matrix3d\((.*)\)/;
function setTransformXY(node, xy) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());
  if (transform && transform !== 'none') {
    var arr;
    var match2d = transform.match(matrix2d);
    if (match2d) {
      match2d = match2d[1];
      arr = match2d.split(',').map(function (item) {
        return parseFloat(item, 10);
      });
      arr[4] = xy.x;
      arr[5] = xy.y;
      setTransform(node, "matrix(".concat(arr.join(','), ")"));
    } else {
      var match3d = transform.match(matrix3d)[1];
      arr = match3d.split(',').map(function (item) {
        return parseFloat(item, 10);
      });
      arr[12] = xy.x;
      arr[13] = xy.y;
      setTransform(node, "matrix3d(".concat(arr.join(','), ")"));
    }
  } else {
    setTransform(node, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
  }
}

var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
var getComputedStyleX;

// https://stackoverflow.com/a/3485654/3040605
function forceRelayout(elem) {
  var originalStyle = elem.style.display;
  elem.style.display = 'none';
  elem.offsetHeight; // eslint-disable-line
  elem.style.display = originalStyle;
}
function css$3(el, name, v) {
  var value = v;
  if (_typeof(name) === 'object') {
    for (var i in name) {
      if (name.hasOwnProperty(i)) {
        css$3(el, i, name[i]);
      }
    }
    return undefined;
  }
  if (typeof value !== 'undefined') {
    if (typeof value === 'number') {
      value = "".concat(value, "px");
    }
    el.style[name] = value;
    return undefined;
  }
  return getComputedStyleX(el, name);
}
function getClientPosition(elem) {
  var box;
  var x;
  var y;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  //  GBS A-Grade Browsers  getBoundingClientRect 
  box = elem.getBoundingClientRect();

  // jQuery  docElem.clientLeft/clientTop
  //  html  body /
  // ie6  html  margin  html  margin

  x = Math.floor(box.left);
  y = Math.floor(box.top);

  // In IE, most of the time, 2 extra pixels are added to the top and left
  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
  // IE6 standards mode, this border can be overridden by setting the
  // document element's border to zero -- thus, we cannot rely on the
  // offset always being 2 pixels.

  // In quirks mode, the offset can be determined by querying the body's
  // clientLeft/clientTop, but in standards mode, it is found by querying
  // the document element's clientLeft/clientTop.  Since we already called
  // getClientBoundingRect we have already forced a reflow, so it is not
  // too expensive just to query them all.

  // ie  absolute 
  //  documentElement ,quirks  body
  //  body  html   ie < 9 html  2px 
  //  ie body html  ,ie  html,body 
  //  ie  docElem.clientTop  border-top
  // ie7 html  2
  //  firefox/chrome/ie9  docElem.clientTop  border-top  0

  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x,
    top: y
  };
}
function getScroll$1(w, top) {
  var ret = w["page".concat(top ? 'Y' : 'X', "Offset")];
  var method = "scroll".concat(top ? 'Top' : 'Left');
  if (typeof ret !== 'number') {
    var d = w.document;
    // ie6,7,8 standard mode
    ret = d.documentElement[method];
    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }
  return ret;
}
function getScrollLeft(w) {
  return getScroll$1(w);
}
function getScrollTop$1(w) {
  return getScroll$1(w, true);
}
function getOffset$2(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w);
  pos.top += getScrollTop$1(w);
  return pos;
}

/**
 * A crude way of determining if an object is a window
 * @member util
 */
function isWindow$1(obj) {
  // must use == for ie8
  /* eslint eqeqeq:0 */
  return obj !== null && obj !== undefined && obj == obj.window;
}
function getDocument(node) {
  if (isWindow$1(node)) {
    return node.document;
  }
  if (node.nodeType === 9) {
    return node;
  }
  return node.ownerDocument;
}
function _getComputedStyle(elem, name, cs) {
  var computedStyle = cs;
  var val = '';
  var d = getDocument(elem);
  computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null);

  // https://github.com/kissyteam/kissy/issues/61
  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }
  return val;
}
var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), 'i');
var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = 'currentStyle';
var RUNTIME_STYLE = 'runtimeStyle';
var LEFT$1 = 'left';
var PX = 'px';
function _getComputedStyleIE(elem, name) {
  // currentStyle maybe null
  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];

  //  width/height  pixelLeft  width/height 
  // ! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook @2011-08-19
  //  ie  offset 
  // borderWidth  borderWidth 

  // From the awesome hack by Dean Edwards
  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
  // If we're not dealing with a regular pixel number
  // but a number that has a weird ending, we need to convert it to pixels
  // exclude left right for relativity
  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    // Remember the original values
    var style = elem.style;
    var left = style[LEFT$1];
    var rsLeft = elem[RUNTIME_STYLE][LEFT$1];

    // prevent flashing of content
    elem[RUNTIME_STYLE][LEFT$1] = elem[CURRENT_STYLE][LEFT$1];

    // Put in the new values to get a computed value out
    style[LEFT$1] = name === 'fontSize' ? '1em' : ret || 0;
    ret = style.pixelLeft + PX;

    // Revert the changed values
    style[LEFT$1] = left;
    elem[RUNTIME_STYLE][LEFT$1] = rsLeft;
  }
  return ret === '' ? 'auto' : ret;
}
if (typeof window !== 'undefined') {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}
function getOffsetDirection(dir, option) {
  if (dir === 'left') {
    return option.useCssRight ? 'right' : dir;
  }
  return option.useCssBottom ? 'bottom' : dir;
}
function oppositeOffsetDirection(dir) {
  if (dir === 'left') {
    return 'right';
  } else if (dir === 'right') {
    return 'left';
  } else if (dir === 'top') {
    return 'bottom';
  } else if (dir === 'bottom') {
    return 'top';
  }
}

//  elem  elem.ownerDocument 
function setLeftTop(elem, offset, option) {
  // set position first, in-case top/left are set even on static elem
  if (css$3(elem, 'position') === 'static') {
    elem.style.position = 'relative';
  }
  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection('left', option);
  var verticalProperty = getOffsetDirection('top', option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
  if (horizontalProperty !== 'left') {
    presetH = 999;
  }
  if (verticalProperty !== 'top') {
    presetV = 999;
  }
  var originalTransition = '';
  var originalOffset = getOffset$2(elem);
  if ('left' in offset || 'top' in offset) {
    originalTransition = getTransitionProperty(elem) || '';
    setTransitionProperty(elem, 'none');
  }
  if ('left' in offset) {
    elem.style[oppositeHorizontalProperty] = '';
    elem.style[horizontalProperty] = "".concat(presetH, "px");
  }
  if ('top' in offset) {
    elem.style[oppositeVerticalProperty] = '';
    elem.style[verticalProperty] = "".concat(presetV, "px");
  }
  // force relayout
  forceRelayout(elem);
  var old = getOffset$2(elem);
  var originalStyle = {};
  for (var key in offset) {
    if (offset.hasOwnProperty(key)) {
      var dir = getOffsetDirection(key, option);
      var preset = key === 'left' ? presetH : presetV;
      var off = originalOffset[key] - old[key];
      if (dir === key) {
        originalStyle[dir] = preset + off;
      } else {
        originalStyle[dir] = preset - off;
      }
    }
  }
  css$3(elem, originalStyle);
  // force relayout
  forceRelayout(elem);
  if ('left' in offset || 'top' in offset) {
    setTransitionProperty(elem, originalTransition);
  }
  var ret = {};
  for (var _key in offset) {
    if (offset.hasOwnProperty(_key)) {
      var _dir = getOffsetDirection(_key, option);
      var _off = offset[_key] - originalOffset[_key];
      if (_key === _dir) {
        ret[_dir] = originalStyle[_dir] + _off;
      } else {
        ret[_dir] = originalStyle[_dir] - _off;
      }
    }
  }
  css$3(elem, ret);
}
function setTransform$1(elem, offset) {
  var originalOffset = getOffset$2(elem);
  var originalXY = getTransformXY(elem);
  var resultXY = {
    x: originalXY.x,
    y: originalXY.y
  };
  if ('left' in offset) {
    resultXY.x = originalXY.x + offset.left - originalOffset.left;
  }
  if ('top' in offset) {
    resultXY.y = originalXY.y + offset.top - originalOffset.top;
  }
  setTransformXY(elem, resultXY);
}
function setOffset(elem, offset, option) {
  if (option.ignoreShake) {
    var oriOffset = getOffset$2(elem);
    var oLeft = oriOffset.left.toFixed(0);
    var oTop = oriOffset.top.toFixed(0);
    var tLeft = offset.left.toFixed(0);
    var tTop = offset.top.toFixed(0);
    if (oLeft === tLeft && oTop === tTop) {
      return;
    }
  }
  if (option.useCssRight || option.useCssBottom) {
    setLeftTop(elem, offset, option);
  } else if (option.useCssTransform && getTransformName() in document.body.style) {
    setTransform$1(elem, offset);
  } else {
    setLeftTop(elem, offset, option);
  }
}
function each(arr, fn) {
  for (var i = 0; i < arr.length; i++) {
    fn(arr[i]);
  }
}
function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
}
var BOX_MODELS = ['margin', 'border', 'padding'];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;
function swap(elem, options, callback) {
  var old = {};
  var style = elem.style;
  var name;

  // Remember the old values, and insert the new ones
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style[name];
      style[name] = options[name];
    }
  }
  callback.call(elem);

  // Revert the old values
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style[name] = old[name];
    }
  }
}
function getPBMWidth(elem, props, which) {
  var value = 0;
  var prop;
  var j;
  var i;
  for (j = 0; j < props.length; j++) {
    prop = props[j];
    if (prop) {
      for (i = 0; i < which.length; i++) {
        var cssProp = void 0;
        if (prop === 'border') {
          cssProp = "".concat(prop).concat(which[i], "Width");
        } else {
          cssProp = prop + which[i];
        }
        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }
  return value;
}
var domUtils = {
  getParent: function getParent(element) {
    var parent = element;
    do {
      if (parent.nodeType === 11 && parent.host) {
        parent = parent.host;
      } else {
        parent = parent.parentNode;
      }
    } while (parent && parent.nodeType !== 1 && parent.nodeType !== 9);
    return parent;
  }
};
each(['Width', 'Height'], function (name) {
  domUtils["doc".concat(name)] = function (refWin) {
    var d = refWin.document;
    return Math.max(
    // firefox chrome documentElement.scrollHeight< body.scrollHeight
    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
    d.documentElement["scroll".concat(name)],
    // quirks : documentElement.scrollHeight 
    d.body["scroll".concat(name)], domUtils["viewport".concat(name)](d));
  };
  domUtils["viewport".concat(name)] = function (win) {
    // pc browser includes scrollbar in window.innerWidth
    var prop = "client".concat(name);
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop];
    //  documentElement
    // backcompat  body
    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
  };
});

/*
 
 @param elem
 @param name
 @param {String} [extra]  'padding' : (css width) + padding
 'border' : (css width) + padding + border
 'margin' : (css width) + padding + border + margin
 */
function getWH(elem, name, ex) {
  var extra = ex;
  if (isWindow$1(elem)) {
    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  var borderBoxValue = name === 'width' ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
  var isBorderBox = isBorderBoxFn(elem);
  var cssBoxValue = 0;
  if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
    borderBoxValue = undefined;
    // Fall back to computed then un computed css if necessary
    cssBoxValue = getComputedStyleX(elem, name);
    if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    }
    // Normalize '', auto, and prepare for extra
    cssBoxValue = Math.floor(parseFloat(cssBoxValue)) || 0;
  }
  if (extra === undefined) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
  var val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ['border', 'padding'], which);
    }
    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }
    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which) : getPBMWidth(elem, ['margin'], which));
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
}
var cssShow = {
  position: 'absolute',
  visibility: 'hidden',
  display: 'block'
};

// fix #119 : https://github.com/kissyteam/kissy/issues/119
function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    args[_key2] = arguments[_key2];
  }
  var val;
  var elem = args[0];
  // in case elem is window
  // elem.offsetWidth === undefined
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(undefined, args);
  } else {
    swap(elem, cssShow, function () {
      val = getWH.apply(undefined, args);
    });
  }
  return val;
}
each(['width', 'height'], function (name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);
  domUtils["outer".concat(first)] = function (el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  domUtils[name] = function (elem, v) {
    var val = v;
    if (val !== undefined) {
      if (elem) {
        var isBorderBox = isBorderBoxFn(elem);
        if (isBorderBox) {
          val += getPBMWidth(elem, ['padding', 'border'], which);
        }
        return css$3(elem, name, val);
      }
      return undefined;
    }
    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
});
function mix(to, from) {
  for (var i in from) {
    if (from.hasOwnProperty(i)) {
      to[i] = from[i];
    }
  }
  return to;
}
var utils$1 = {
  getWindow: function getWindow(node) {
    if (node && node.document && node.setTimeout) {
      return node;
    }
    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  getDocument: getDocument,
  offset: function offset(el, value, option) {
    if (typeof value !== 'undefined') {
      setOffset(el, value, option || {});
    } else {
      return getOffset$2(el);
    }
  },
  isWindow: isWindow$1,
  each: each,
  css: css$3,
  clone: function clone(obj) {
    var i;
    var ret = {};
    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        ret[i] = obj[i];
      }
    }
    var overflow = obj.overflow;
    if (overflow) {
      for (i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret.overflow[i] = obj.overflow[i];
        }
      }
    }
    return ret;
  },
  mix: mix,
  getWindowScrollLeft: function getWindowScrollLeft(w) {
    return getScrollLeft(w);
  },
  getWindowScrollTop: function getWindowScrollTop(w) {
    return getScrollTop$1(w);
  },
  merge: function merge() {
    var ret = {};
    for (var i = 0; i < arguments.length; i++) {
      utils$1.mix(ret, i < 0 || arguments.length <= i ? undefined : arguments[i]);
    }
    return ret;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
mix(utils$1, domUtils);

/**
 * 
 */
var getParent = utils$1.getParent;
function getOffsetParent(element) {
  if (utils$1.isWindow(element) || element.nodeType === 9) {
    return null;
  }
  // ie 
  /*
   <div style="width: 50px;height: 100px;overflow: hidden">
   <div style="width: 50px;height: 100px;position: relative;" id="d6">
    6  100px  50px<br/>
   </div>
   </div>
   */
  // element.offsetParent does the right thing in ie7 and below. Return parent with layout!
  //  In other browsers it only includes elements with position absolute, relative or
  // fixed, not elements with overflow set to auto or scroll.
  //        if (UA.ie && ieMode < 8) {
  //            return element.offsetParent;
  //        }
  //  offsetParent 
  var doc = utils$1.getDocument(element);
  var body = doc.body;
  var parent;
  var positionStyle = utils$1.css(element, 'position');
  var skipStatic = positionStyle === 'fixed' || positionStyle === 'absolute';
  if (!skipStatic) {
    return element.nodeName.toLowerCase() === 'html' ? null : getParent(element);
  }
  for (parent = getParent(element); parent && parent !== body && parent.nodeType !== 9; parent = getParent(parent)) {
    positionStyle = utils$1.css(parent, 'position');
    if (positionStyle !== 'static') {
      return parent;
    }
  }
  return null;
}

var getParent$1 = utils$1.getParent;
function isAncestorFixed(element) {
  if (utils$1.isWindow(element) || element.nodeType === 9) {
    return false;
  }
  var doc = utils$1.getDocument(element);
  var body = doc.body;
  var parent = null;
  for (parent = getParent$1(element);
  //  document.documentElement 
  parent && parent !== body && parent !== doc; parent = getParent$1(parent)) {
    var positionStyle = utils$1.css(parent, 'position');
    if (positionStyle === 'fixed') {
      return true;
    }
  }
  return false;
}

/**
 * 
 */
function getVisibleRectForElement(element, alwaysByViewport) {
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el = getOffsetParent(element);
  var doc = utils$1.getDocument(element);
  var win = doc.defaultView || doc.parentWindow;
  var body = doc.body;
  var documentElement = doc.documentElement;

  // Determine the size of the visible rect by climbing the dom accounting for
  // all scrollable containers.
  while (el) {
    // clientWidth is zero for inline block elements in ie.
    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) &&
    // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    el !== body && el !== documentElement && utils$1.css(el, 'overflow') !== 'visible') {
      var pos = utils$1.offset(el);
      // add border
      pos.left += el.clientLeft;
      pos.top += el.clientTop;
      visibleRect.top = Math.max(visibleRect.top, pos.top);
      visibleRect.right = Math.min(visibleRect.right,
      // consider area without scrollBar
      pos.left + el.clientWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.left);
    } else if (el === body || el === documentElement) {
      break;
    }
    el = getOffsetParent(el);
  }

  // Set element position to fixed
  // make sure absolute element itself don't affect it's visible area
  // https://github.com/ant-design/ant-design/issues/7601
  var originalPosition = null;
  if (!utils$1.isWindow(element) && element.nodeType !== 9) {
    originalPosition = element.style.position;
    var position = utils$1.css(element, 'position');
    if (position === 'absolute') {
      element.style.position = 'fixed';
    }
  }
  var scrollX = utils$1.getWindowScrollLeft(win);
  var scrollY = utils$1.getWindowScrollTop(win);
  var viewportWidth = utils$1.viewportWidth(win);
  var viewportHeight = utils$1.viewportHeight(win);
  var documentWidth = documentElement.scrollWidth;
  var documentHeight = documentElement.scrollHeight;

  // scrollXXX on html is sync with body which means overflow: hidden on body gets wrong scrollXXX.
  // We should cut this ourself.
  var bodyStyle = window.getComputedStyle(body);
  if (bodyStyle.overflowX === 'hidden') {
    documentWidth = win.innerWidth;
  }
  if (bodyStyle.overflowY === 'hidden') {
    documentHeight = win.innerHeight;
  }

  // Reset element position after calculate the visible area
  if (element.style) {
    element.style.position = originalPosition;
  }
  if (alwaysByViewport || isAncestorFixed(element)) {
    // Clip by viewport's size.
    visibleRect.left = Math.max(visibleRect.left, scrollX);
    visibleRect.top = Math.max(visibleRect.top, scrollY);
    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
  } else {
    // Clip by document's size.
    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
  }
  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}

function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
  var pos = utils$1.clone(elFuturePos);
  var size = {
    width: elRegion.width,
    height: elRegion.height
  };
  if (overflow.adjustX && pos.left < visibleRect.left) {
    pos.left = visibleRect.left;
  }

  // Left edge inside and right edge outside viewport, try to resize it.
  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
    size.width -= pos.left + size.width - visibleRect.right;
  }

  // Right edge outside viewport, try to move it.
  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
    // 
    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
  }

  // Top edge outside viewport, try to move it.
  if (overflow.adjustY && pos.top < visibleRect.top) {
    pos.top = visibleRect.top;
  }

  // Top edge inside and bottom edge outside viewport, try to resize it.
  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
    size.height -= pos.top + size.height - visibleRect.bottom;
  }

  // Bottom edge outside viewport, try to move it.
  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
    // 
    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
  }
  return utils$1.mix(pos, size);
}

function getRegion(node) {
  var offset;
  var w;
  var h;
  if (!utils$1.isWindow(node) && node.nodeType !== 9) {
    offset = utils$1.offset(node);
    w = utils$1.outerWidth(node);
    h = utils$1.outerHeight(node);
  } else {
    var win = utils$1.getWindow(node);
    offset = {
      left: utils$1.getWindowScrollLeft(win),
      top: utils$1.getWindowScrollTop(win)
    };
    w = utils$1.viewportWidth(win);
    h = utils$1.viewportHeight(win);
  }
  offset.width = w;
  offset.height = h;
  return offset;
}

/**
 *  node  align  
 */

function getAlignOffset(region, align) {
  var V = align.charAt(0);
  var H = align.charAt(1);
  var w = region.width;
  var h = region.height;
  var x = region.left;
  var y = region.top;
  if (V === 'c') {
    y += h / 2;
  } else if (V === 'b') {
    y += h;
  }
  if (H === 'c') {
    x += w / 2;
  } else if (H === 'r') {
    x += w;
  }
  return {
    left: x,
    top: y
  };
}

function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset) {
  var p1 = getAlignOffset(refNodeRegion, points[1]);
  var p2 = getAlignOffset(elRegion, points[0]);
  var diff = [p2.left - p1.left, p2.top - p1.top];
  return {
    left: Math.round(elRegion.left - diff[0] + offset[0] - targetOffset[0]),
    top: Math.round(elRegion.top - diff[1] + offset[1] - targetOffset[1])
  };
}

/**
 * align dom node flexibly
 * @author yiminghe@gmail.com
 */

// http://yiminghe.iteye.com/blog/1124720

function isFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}
function isFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}
function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}
function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}
function flip(points, reg, map) {
  var ret = [];
  utils$1.each(points, function (p) {
    ret.push(p.replace(reg, function (m) {
      return map[m];
    }));
  });
  return ret;
}
function flipOffset(offset, index) {
  offset[index] = -offset[index];
  return offset;
}
function convertOffset(str, offsetLen) {
  var n;
  if (/%$/.test(str)) {
    n = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
  } else {
    n = parseInt(str, 10);
  }
  return n || 0;
}
function normalizeOffset(offset, el) {
  offset[0] = convertOffset(offset[0], el.width);
  offset[1] = convertOffset(offset[1], el.height);
}

/**
 * @param el
 * @param tgtRegion : { left, top, width, height }
 * @param align
 */
function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
  var points = align.points;
  var offset = align.offset || [0, 0];
  var targetOffset = align.targetOffset || [0, 0];
  var overflow = align.overflow;
  var source = align.source || el;
  offset = [].concat(offset);
  targetOffset = [].concat(targetOffset);
  overflow = overflow || {};
  var newOverflowCfg = {};
  var fail = 0;
  var alwaysByViewport = !!(overflow && overflow.alwaysByViewport);
  // 
  var visibleRect = getVisibleRectForElement(source, alwaysByViewport);
  // , left/top/width/height
  var elRegion = getRegion(source);
  //  offset 
  normalizeOffset(offset, elRegion);
  normalizeOffset(targetOffset, tgtRegion);
  // 
  var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset);
  // 
  var newElRegion = utils$1.merge(elRegion, elFuturePos);

  // 
  if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
    if (overflow.adjustX) {
      // 
      if (isFailX(elFuturePos, elRegion, visibleRect)) {
        // 
        var newPoints = flip(points, /[lr]/gi, {
          l: 'r',
          r: 'l'
        });
        // 
        var newOffset = flipOffset(offset, 0);
        var newTargetOffset = flipOffset(targetOffset, 0);
        var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);
        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = newPoints;
          offset = newOffset;
          targetOffset = newTargetOffset;
        }
      }
    }
    if (overflow.adjustY) {
      // 
      if (isFailY(elFuturePos, elRegion, visibleRect)) {
        // 
        var _newPoints = flip(points, /[tb]/gi, {
          t: 'b',
          b: 't'
        });
        // 
        var _newOffset = flipOffset(offset, 1);
        var _newTargetOffset = flipOffset(targetOffset, 1);
        var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);
        if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = _newPoints;
          offset = _newOffset;
          targetOffset = _newTargetOffset;
        }
      }
    }

    // 
    if (fail) {
      elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset);
      utils$1.mix(newElRegion, elFuturePos);
    }
    var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
    var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);
    // 
    // 1. 
    if (isStillFailX || isStillFailY) {
      var _newPoints2 = points;

      // 
      if (isStillFailX) {
        _newPoints2 = flip(points, /[lr]/gi, {
          l: 'r',
          r: 'l'
        });
      }
      if (isStillFailY) {
        _newPoints2 = flip(points, /[tb]/gi, {
          t: 'b',
          b: 't'
        });
      }
      points = _newPoints2;
      offset = align.offset || [0, 0];
      targetOffset = align.targetOffset || [0, 0];
    }
    // 2. 
    newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
    newOverflowCfg.adjustY = overflow.adjustY && isStillFailY;

    // 
    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
    }
  }

  // need judge to in case set fixed with in css on height auto element
  if (newElRegion.width !== elRegion.width) {
    utils$1.css(source, 'width', utils$1.width(source) + newElRegion.width - elRegion.width);
  }
  if (newElRegion.height !== elRegion.height) {
    utils$1.css(source, 'height', utils$1.height(source) + newElRegion.height - elRegion.height);
  }

  // https://github.com/kissyteam/kissy/issues/190
  //  left/top 
  //  <div 'relative'><el absolute></div>
  utils$1.offset(source, {
    left: newElRegion.left,
    top: newElRegion.top
  }, {
    useCssRight: align.useCssRight,
    useCssBottom: align.useCssBottom,
    useCssTransform: align.useCssTransform,
    ignoreShake: align.ignoreShake
  });
  return {
    points: points,
    offset: offset,
    targetOffset: targetOffset,
    overflow: newOverflowCfg
  };
}
/**
 *  2012-04-26 yiminghe@gmail.com
 *   - 
 *   -  resizeXX
 *
 *  2011-07-13 yiminghe@gmail.com note:
 *   - 
 **/

function isOutOfVisibleRect(target, alwaysByViewport) {
  var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
  var targetRegion = getRegion(target);
  return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
}
function alignElement(el, refNode, align) {
  var target = align.target || refNode;
  var refNodeRegion = getRegion(target);
  var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);
  return doAlign(el, refNodeRegion, align, isTargetNotOutOfVisible);
}
alignElement.__getOffsetParent = getOffsetParent;
alignElement.__getVisibleRectForElement = getVisibleRectForElement;

/**
 * `tgtPoint`: { pageX, pageY } or { clientX, clientY }.
 * If client position provided, will internal convert to page position.
 */

function alignPoint(el, tgtPoint, align) {
  var pageX;
  var pageY;
  var doc = utils$1.getDocument(el);
  var win = doc.defaultView || doc.parentWindow;
  var scrollX = utils$1.getWindowScrollLeft(win);
  var scrollY = utils$1.getWindowScrollTop(win);
  var viewportWidth = utils$1.viewportWidth(win);
  var viewportHeight = utils$1.viewportHeight(win);
  if ('pageX' in tgtPoint) {
    pageX = tgtPoint.pageX;
  } else {
    pageX = scrollX + tgtPoint.clientX;
  }
  if ('pageY' in tgtPoint) {
    pageY = tgtPoint.pageY;
  } else {
    pageY = scrollY + tgtPoint.clientY;
  }
  var tgtRegion = {
    left: pageX,
    top: pageY,
    width: 0,
    height: 0
  };
  var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight;

  // Provide default target point
  var points = [align.points[0], 'cc'];
  return doAlign(el, tgtRegion, _objectSpread2(_objectSpread2({}, align), {}, {
    points: points
  }), pointInView);
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */

function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}

var _listCacheClear = listCacheClear$1;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */

function eq$2(value, other) {
  return value === other || (value !== value && other !== other);
}

var eq_1 = eq$2;

var eq$1 = eq_1;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf$4(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

var _assocIndexOf = assocIndexOf$4;

var assocIndexOf$3 = _assocIndexOf;

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete$1(key) {
  var data = this.__data__,
      index = assocIndexOf$3(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

var _listCacheDelete = listCacheDelete$1;

var assocIndexOf$2 = _assocIndexOf;

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet$1(key) {
  var data = this.__data__,
      index = assocIndexOf$2(data, key);

  return index < 0 ? undefined : data[index][1];
}

var _listCacheGet = listCacheGet$1;

var assocIndexOf$1 = _assocIndexOf;

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}

var _listCacheHas = listCacheHas$1;

var assocIndexOf = _assocIndexOf;

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet$1(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

var _listCacheSet = listCacheSet$1;

var listCacheClear = _listCacheClear,
    listCacheDelete = _listCacheDelete,
    listCacheGet = _listCacheGet,
    listCacheHas = _listCacheHas,
    listCacheSet = _listCacheSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache$4(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype['delete'] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;

var _ListCache = ListCache$4;

var ListCache$3 = _ListCache;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear$1() {
  this.__data__ = new ListCache$3;
  this.size = 0;
}

var _stackClear = stackClear$1;

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function stackDelete$1(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

var _stackDelete = stackDelete$1;

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function stackGet$1(key) {
  return this.__data__.get(key);
}

var _stackGet = stackGet$1;

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function stackHas$1(key) {
  return this.__data__.has(key);
}

var _stackHas = stackHas$1;

/** Detect free variable `global` from Node.js. */

var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal$1;

var freeGlobal = _freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$8 = freeGlobal || freeSelf || Function('return this')();

var _root = root$8;

var root$7 = _root;

/** Built-in value references. */
var Symbol$4 = root$7.Symbol;

var _Symbol = Symbol$4;

var Symbol$3 = _Symbol;

/** Used for built-in method references. */
var objectProto$b = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$b.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$b.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$a.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

var _getRawTag = getRawTag$1;

/** Used for built-in method references. */

var objectProto$a = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$a.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}

var _objectToString = objectToString$1;

var Symbol$2 = _Symbol,
    getRawTag = _getRawTag,
    objectToString = _objectToString;

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag$4(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

var _baseGetTag = baseGetTag$4;

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */

function isObject$3(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject$3;

var baseGetTag$3 = _baseGetTag,
    isObject$2 = isObject_1;

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$1 = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction$3(value) {
  if (!isObject$2(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag$3(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}

var isFunction_1 = isFunction$3;

var root$6 = _root;

/** Used to detect overreaching core-js shims. */
var coreJsData$1 = root$6['__core-js_shared__'];

var _coreJsData = coreJsData$1;

var coreJsData = _coreJsData;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked$1(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

var _isMasked = isMasked$1;

/** Used for built-in method references. */

var funcProto$1 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

var _toSource = toSource$2;

var isFunction$2 = isFunction_1,
    isMasked = _isMasked,
    isObject$1 = isObject_1,
    toSource$1 = _toSource;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$9 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$9.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty$9).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative$1(value) {
  if (!isObject$1(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}

var _baseIsNative = baseIsNative$1;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

function getValue$1(object, key) {
  return object == null ? undefined : object[key];
}

var _getValue = getValue$1;

var baseIsNative = _baseIsNative,
    getValue = _getValue;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative$6(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

var _getNative = getNative$6;

var getNative$5 = _getNative,
    root$5 = _root;

/* Built-in method references that are verified to be native. */
var Map$4 = getNative$5(root$5, 'Map');

var _Map = Map$4;

var getNative$4 = _getNative;

/* Built-in method references that are verified to be native. */
var nativeCreate$4 = getNative$4(Object, 'create');

var _nativeCreate = nativeCreate$4;

var nativeCreate$3 = _nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}

var _hashClear = hashClear$1;

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

var _hashDelete = hashDelete$1;

var nativeCreate$2 = _nativeCreate;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$8.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? undefined : result;
  }
  return hasOwnProperty$8.call(data, key) ? data[key] : undefined;
}

var _hashGet = hashGet$1;

var nativeCreate$1 = _nativeCreate;

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$7.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$7.call(data, key);
}

var _hashHas = hashHas$1;

var nativeCreate = _nativeCreate;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

var _hashSet = hashSet$1;

var hashClear = _hashClear,
    hashDelete = _hashDelete,
    hashGet = _hashGet,
    hashHas = _hashHas,
    hashSet = _hashSet;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash$1(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash$1.prototype.clear = hashClear;
Hash$1.prototype['delete'] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;

var _Hash = Hash$1;

var Hash = _Hash,
    ListCache$2 = _ListCache,
    Map$3 = _Map;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$3 || ListCache$2),
    'string': new Hash
  };
}

var _mapCacheClear = mapCacheClear$1;

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */

function isKeyable$1(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

var _isKeyable = isKeyable$1;

var isKeyable = _isKeyable;

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

var _getMapData = getMapData$4;

var getMapData$3 = _getMapData;

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

var _mapCacheDelete = mapCacheDelete$1;

var getMapData$2 = _getMapData;

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}

var _mapCacheGet = mapCacheGet$1;

var getMapData$1 = _getMapData;

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}

var _mapCacheHas = mapCacheHas$1;

var getMapData = _getMapData;

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

var _mapCacheSet = mapCacheSet$1;

var mapCacheClear = _mapCacheClear,
    mapCacheDelete = _mapCacheDelete,
    mapCacheGet = _mapCacheGet,
    mapCacheHas = _mapCacheHas,
    mapCacheSet = _mapCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache$2(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache$2.prototype.clear = mapCacheClear;
MapCache$2.prototype['delete'] = mapCacheDelete;
MapCache$2.prototype.get = mapCacheGet;
MapCache$2.prototype.has = mapCacheHas;
MapCache$2.prototype.set = mapCacheSet;

var _MapCache = MapCache$2;

var ListCache$1 = _ListCache,
    Map$2 = _Map,
    MapCache$1 = _MapCache;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$1(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

var _stackSet = stackSet$1;

var ListCache = _ListCache,
    stackClear = _stackClear,
    stackDelete = _stackDelete,
    stackGet = _stackGet,
    stackHas = _stackHas,
    stackSet = _stackSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack$1(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack$1.prototype.clear = stackClear;
Stack$1.prototype['delete'] = stackDelete;
Stack$1.prototype.get = stackGet;
Stack$1.prototype.has = stackHas;
Stack$1.prototype.set = stackSet;

var _Stack = Stack$1;

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

var _setCacheAdd = setCacheAdd$1;

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */

function setCacheHas$1(value) {
  return this.__data__.has(value);
}

var _setCacheHas = setCacheHas$1;

var MapCache = _MapCache,
    setCacheAdd = _setCacheAdd,
    setCacheHas = _setCacheHas;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache$1(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
SetCache$1.prototype.has = setCacheHas;

var _SetCache = SetCache$1;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */

function arraySome$1(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

var _arraySome = arraySome$1;

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function cacheHas$1(cache, key) {
  return cache.has(key);
}

var _cacheHas = cacheHas$1;

var SetCache = _SetCache,
    arraySome = _arraySome,
    cacheHas = _cacheHas;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$3 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG$1) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

var _equalArrays = equalArrays$2;

var root$4 = _root;

/** Built-in value references. */
var Uint8Array$2 = root$4.Uint8Array;

var _Uint8Array = Uint8Array$2;

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */

function mapToArray$1(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

var _mapToArray = mapToArray$1;

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */

function setToArray$1(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

var _setToArray = setToArray$1;

var Symbol$1 = _Symbol,
    Uint8Array$1 = _Uint8Array,
    eq = eq_1,
    equalArrays$1 = _equalArrays,
    mapToArray = _mapToArray,
    setToArray = _setToArray;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$2 = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$1 = '[object Error]',
    mapTag$2 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$2 = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$2:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag$1:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;

    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag$1:
      return object.name == other.name && object.message == other.message;

    case regexpTag$1:
    case stringTag$1:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag$2:
      var convert = mapToArray;

    case setTag$2:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

var _equalByTag = equalByTag$1;

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */

function arrayPush$1(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

var _arrayPush = arrayPush$1;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */

var isArray$5 = Array.isArray;

var isArray_1 = isArray$5;

var arrayPush = _arrayPush,
    isArray$4 = isArray_1;

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$4(object) ? result : arrayPush(result, symbolsFunc(object));
}

var _baseGetAllKeys = baseGetAllKeys$1;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */

function arrayFilter$1(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

var _arrayFilter = arrayFilter$1;

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */

function stubArray$1() {
  return [];
}

var stubArray_1 = stubArray$1;

var arrayFilter = _arrayFilter,
    stubArray = stubArray_1;

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};

var _getSymbols = getSymbols$1;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */

function baseTimes$1(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

var _baseTimes = baseTimes$1;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */

function isObjectLike$4(value) {
  return value != null && typeof value == 'object';
}

var isObjectLike_1 = isObjectLike$4;

var baseGetTag$2 = _baseGetTag,
    isObjectLike$3 = isObjectLike_1;

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments$1(value) {
  return isObjectLike$3(value) && baseGetTag$2(value) == argsTag$2;
}

var _baseIsArguments = baseIsArguments$1;

var baseIsArguments = _baseIsArguments,
    isObjectLike$2 = isObjectLike_1;

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$5.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments$1 = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike$2(value) && hasOwnProperty$6.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

var isArguments_1 = isArguments$1;

var isBuffer$3 = {exports: {}};

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */

function stubFalse() {
  return false;
}

var stubFalse_1 = stubFalse;

(function (module, exports) {
	var root = _root,
	    stubFalse = stubFalse_1;

	/** Detect free variable `exports`. */
	var freeExports = exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	module.exports = isBuffer;
} (isBuffer$3, isBuffer$3.exports));

/** Used as references for various `Number` constants. */

var MAX_SAFE_INTEGER$2 = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex$1(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$2 : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

var _isIndex = isIndex$1;

/** Used as references for various `Number` constants. */

var MAX_SAFE_INTEGER$1 = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength$2(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}

var isLength_1 = isLength$2;

var baseGetTag$1 = _baseGetTag,
    isLength$1 = isLength_1,
    isObjectLike$1 = isObjectLike_1;

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag$1 = '[object Map]',
    numberTag = '[object Number]',
    objectTag$2 = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag = '[object String]',
    weakMapTag$1 = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag$1] = typedArrayTags[numberTag] =
typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] =
typedArrayTags[setTag$1] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag$1] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray$1(value) {
  return isObjectLike$1(value) &&
    isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];
}

var _baseIsTypedArray = baseIsTypedArray$1;

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */

function baseUnary$1(func) {
  return function(value) {
    return func(value);
  };
}

var _baseUnary = baseUnary$1;

var _nodeUtil = {exports: {}};

(function (module, exports) {
	var freeGlobal = _freeGlobal;

	/** Detect free variable `exports`. */
	var freeExports = exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    // Use `util.types` for Node.js 10+.
	    var types = freeModule && freeModule.require && freeModule.require('util').types;

	    if (types) {
	      return types;
	    }

	    // Legacy `process.binding('util')` for Node.js < 10.
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	module.exports = nodeUtil;
} (_nodeUtil, _nodeUtil.exports));

var baseIsTypedArray = _baseIsTypedArray,
    baseUnary = _baseUnary,
    nodeUtil = _nodeUtil.exports;

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray$3 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

var isTypedArray_1 = isTypedArray$3;

var baseTimes = _baseTimes,
    isArguments = isArguments_1,
    isArray$3 = isArray_1,
    isBuffer$2 = isBuffer$3.exports,
    isIndex = _isIndex,
    isTypedArray$2 = isTypedArray_1;

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$4.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys$1(value, inherited) {
  var isArr = isArray$3(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer$2(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray$2(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$5.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

var _arrayLikeKeys = arrayLikeKeys$1;

/** Used for built-in method references. */

var objectProto$3 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype$1(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$3;

  return value === proto;
}

var _isPrototype = isPrototype$1;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */

function overArg$1(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

var _overArg = overArg$1;

var overArg = _overArg;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys$1 = overArg(Object.keys, Object);

var _nativeKeys = nativeKeys$1;

var isPrototype = _isPrototype,
    nativeKeys = _nativeKeys;

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$2.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys$1(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$4.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

var _baseKeys = baseKeys$1;

var isFunction$1 = isFunction_1,
    isLength = isLength_1;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike$1(value) {
  return value != null && isLength(value.length) && !isFunction$1(value);
}

var isArrayLike_1 = isArrayLike$1;

var arrayLikeKeys = _arrayLikeKeys,
    baseKeys = _baseKeys,
    isArrayLike = isArrayLike_1;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys$1(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

var keys_1 = keys$1;

var baseGetAllKeys = _baseGetAllKeys,
    getSymbols = _getSymbols,
    keys = keys_1;

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys$1(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

var _getAllKeys = getAllKeys$1;

var getAllKeys = _getAllKeys;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$1 = 1;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$1.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$3.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

var _equalObjects = equalObjects$1;

var getNative$3 = _getNative,
    root$3 = _root;

/* Built-in method references that are verified to be native. */
var DataView$2 = getNative$3(root$3, 'DataView');

var _DataView = DataView$2;

var getNative$2 = _getNative,
    root$2 = _root;

/* Built-in method references that are verified to be native. */
var Promise$2 = getNative$2(root$2, 'Promise');

var _Promise = Promise$2;

var getNative$1 = _getNative,
    root$1 = _root;

/* Built-in method references that are verified to be native. */
var Set$2 = getNative$1(root$1, 'Set');

var _Set = Set$2;

var getNative = _getNative,
    root = _root;

/* Built-in method references that are verified to be native. */
var WeakMap$2 = getNative(root, 'WeakMap');

var _WeakMap = WeakMap$2;

var DataView$1 = _DataView,
    Map$1 = _Map,
    Promise$1 = _Promise,
    Set$1 = _Set,
    WeakMap$1 = _WeakMap,
    baseGetTag = _baseGetTag,
    toSource = _toSource;

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag$1 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView$1),
    mapCtorString = toSource(Map$1),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$1),
    weakMapCtorString = toSource(WeakMap$1);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag$1 = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView$1 && getTag$1(new DataView$1(new ArrayBuffer(1))) != dataViewTag) ||
    (Map$1 && getTag$1(new Map$1) != mapTag) ||
    (Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag) ||
    (Set$1 && getTag$1(new Set$1) != setTag) ||
    (WeakMap$1 && getTag$1(new WeakMap$1) != weakMapTag)) {
  getTag$1 = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$1 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

var _getTag = getTag$1;

var Stack = _Stack,
    equalArrays = _equalArrays,
    equalByTag = _equalByTag,
    equalObjects = _equalObjects,
    getTag = _getTag,
    isArray$2 = isArray_1,
    isBuffer$1 = isBuffer$3.exports,
    isTypedArray$1 = isTypedArray_1;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$2(object),
      othIsArr = isArray$2(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray$1(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty$2.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$2.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

var _baseIsEqualDeep = baseIsEqualDeep$1;

var baseIsEqualDeep = _baseIsEqualDeep,
    isObjectLike = isObjectLike_1;

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual$1(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$1, stack);
}

var _baseIsEqual = baseIsEqual$1;

var baseIsEqual = _baseIsEqual;

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual$1(value, other) {
  return baseIsEqual(value, other);
}

var isEqual_1 = isEqual$1;

function isSamePoint(prev, next) {
  if (prev === next) return true;
  if (!prev || !next) return false;

  if ('pageX' in next && 'pageY' in next) {
    return prev.pageX === next.pageX && prev.pageY === next.pageY;
  }

  if ('clientX' in next && 'clientY' in next) {
    return prev.clientX === next.clientX && prev.clientY === next.clientY;
  }

  return false;
}
function restoreFocus(activeElement, container) {
  // Focus back if is in the container
  if (activeElement !== document.activeElement && contains(container, activeElement) && typeof activeElement.focus === 'function') {
    activeElement.focus();
  }
}
function monitorResize(element, callback) {
  var prevWidth = null;
  var prevHeight = null;

  function onResize(_ref) {
    var _ref2 = _slicedToArray(_ref, 1),
        target = _ref2[0].target;

    if (!document.documentElement.contains(target)) return;

    var _target$getBoundingCl = target.getBoundingClientRect(),
        width = _target$getBoundingCl.width,
        height = _target$getBoundingCl.height;

    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);

    if (prevWidth !== fixedWidth || prevHeight !== fixedHeight) {
      // https://webkit.org/blog/9997/resizeobserver-in-webkit/
      Promise.resolve().then(function () {
        callback({
          width: fixedWidth,
          height: fixedHeight
        });
      });
    }

    prevWidth = fixedWidth;
    prevHeight = fixedHeight;
  }

  var resizeObserver = new index$1(onResize);

  if (element) {
    resizeObserver.observe(element);
  }

  return function () {
    resizeObserver.disconnect();
  };
}

const useBuffer = (function (callback, buffer) {
  var calledRef = React.useRef(false);
  var timeoutRef = React.useRef(null);

  function cancelTrigger() {
    window.clearTimeout(timeoutRef.current);
  }

  function trigger(force) {
    cancelTrigger();

    if (!calledRef.current || force === true) {
      if (callback() === false) {
        // Not delay since callback cancelled self
        return;
      }

      calledRef.current = true;
      timeoutRef.current = window.setTimeout(function () {
        calledRef.current = false;
      }, buffer);
    } else {
      timeoutRef.current = window.setTimeout(function () {
        calledRef.current = false;
        trigger();
      }, buffer);
    }
  }

  return [trigger, function () {
    calledRef.current = false;
    cancelTrigger();
  }];
});

function getElement(func) {
  if (typeof func !== 'function') return null;
  return func();
}

function getPoint(point) {
  if (_typeof$1(point) !== 'object' || !point) return null;
  return point;
}

var Align = function Align(_ref, ref) {
  var children = _ref.children,
      disabled = _ref.disabled,
      target = _ref.target,
      align = _ref.align,
      onAlign = _ref.onAlign,
      monitorWindowResize = _ref.monitorWindowResize,
      _ref$monitorBufferTim = _ref.monitorBufferTime,
      monitorBufferTime = _ref$monitorBufferTim === void 0 ? 0 : _ref$monitorBufferTim;
  var cacheRef = React.useRef({});
  var nodeRef = React.useRef();
  var childNode = React.Children.only(children); // ===================== Align ======================
  // We save the props here to avoid closure makes props ood

  var forceAlignPropsRef = React.useRef({});
  forceAlignPropsRef.current.disabled = disabled;
  forceAlignPropsRef.current.target = target;
  forceAlignPropsRef.current.align = align;
  forceAlignPropsRef.current.onAlign = onAlign;

  var _useBuffer = useBuffer(function () {
    var _forceAlignPropsRef$c = forceAlignPropsRef.current,
        latestDisabled = _forceAlignPropsRef$c.disabled,
        latestTarget = _forceAlignPropsRef$c.target,
        latestAlign = _forceAlignPropsRef$c.align,
        latestOnAlign = _forceAlignPropsRef$c.onAlign;

    if (!latestDisabled && latestTarget) {
      var source = nodeRef.current;
      var result;
      var element = getElement(latestTarget);
      var point = getPoint(latestTarget);
      cacheRef.current.element = element;
      cacheRef.current.point = point;
      cacheRef.current.align = latestAlign; // IE lose focus after element realign
      // We should record activeElement and restore later

      // IE lose focus after element realign
      // We should record activeElement and restore later
      var _document = document,
          activeElement = _document.activeElement; // We only align when element is visible

      // We only align when element is visible
      if (element && isVisible(element)) {
        result = alignElement(source, element, latestAlign);
      } else if (point) {
        result = alignPoint(source, point, latestAlign);
      }

      restoreFocus(activeElement, source);

      if (latestOnAlign && result) {
        latestOnAlign(source, result);
      }

      return true;
    }

    return false;
  }, monitorBufferTime),
      _useBuffer2 = _slicedToArray(_useBuffer, 2),
      _forceAlign = _useBuffer2[0],
      cancelForceAlign = _useBuffer2[1]; // ===================== Effect =====================
  // Listen for target updated


  var resizeMonitor = React.useRef({
    cancel: function cancel() {}
  }); // Listen for source updated

  var sourceResizeMonitor = React.useRef({
    cancel: function cancel() {}
  });
  React.useEffect(function () {
    var element = getElement(target);
    var point = getPoint(target);

    if (nodeRef.current !== sourceResizeMonitor.current.element) {
      sourceResizeMonitor.current.cancel();
      sourceResizeMonitor.current.element = nodeRef.current;
      sourceResizeMonitor.current.cancel = monitorResize(nodeRef.current, _forceAlign);
    }

    if (cacheRef.current.element !== element || !isSamePoint(cacheRef.current.point, point) || !isEqual_1(cacheRef.current.align, align)) {
      _forceAlign(); // Add resize observer


      if (resizeMonitor.current.element !== element) {
        resizeMonitor.current.cancel();
        resizeMonitor.current.element = element;
        resizeMonitor.current.cancel = monitorResize(element, _forceAlign);
      }
    }
  }); // Listen for disabled change

  React.useEffect(function () {
    if (!disabled) {
      _forceAlign();
    } else {
      cancelForceAlign();
    }
  }, [disabled]); // Listen for window resize

  var winResizeRef = React.useRef(null);
  React.useEffect(function () {
    if (monitorWindowResize) {
      if (!winResizeRef.current) {
        winResizeRef.current = addEventListenerWrap(window, 'resize', _forceAlign);
      }
    } else if (winResizeRef.current) {
      winResizeRef.current.remove();
      winResizeRef.current = null;
    }
  }, [monitorWindowResize]); // Clear all if unmount

  React.useEffect(function () {
    return function () {
      resizeMonitor.current.cancel();
      sourceResizeMonitor.current.cancel();
      if (winResizeRef.current) winResizeRef.current.remove();
      cancelForceAlign();
    };
  }, []); // ====================== Ref =======================

  React.useImperativeHandle(ref, function () {
    return {
      forceAlign: function forceAlign() {
        return _forceAlign(true);
      }
    };
  }); // ===================== Render =====================

  if ( /*#__PURE__*/React.isValidElement(childNode)) {
    childNode = /*#__PURE__*/React.cloneElement(childNode, {
      ref: composeRef$1(childNode.ref, nodeRef)
    });
  }

  return childNode;
};

var RcAlign = /*#__PURE__*/React.forwardRef(Align);
RcAlign.displayName = 'Align';

/**
 * Popup should follow the steps for each component work correctly:
 * measure - check for the current stretch size
 * align - let component align the position
 * aligned - re-align again in case additional className changed the size
 * afterAlign - choice next step is trigger motion or finished
 * beforeMotion - should reset motion to invisible so that CSSMotion can do normal motion
 * motion - play the motion
 * stable - everything is done
 */

var StatusQueue = ['measure', 'alignPre', 'align', null, 'motion'];
const useVisibleStatus = (function (visible, doMeasure) {
  var _useState = useSafeState$1(null),
      _useState2 = _slicedToArray(_useState, 2),
      status = _useState2[0],
      setInternalStatus = _useState2[1];

  var rafRef = react.exports.useRef();

  function setStatus(nextStatus) {
    setInternalStatus(nextStatus, true);
  }

  function cancelRaf() {
    wrapperRaf$1.cancel(rafRef.current);
  }

  function goNextStatus(callback) {
    cancelRaf();
    rafRef.current = wrapperRaf$1(function () {
      // Only align should be manually trigger
      setStatus(function (prev) {
        switch (status) {
          case 'align':
            return 'motion';

          case 'motion':
            return 'stable';
        }

        return prev;
      });
      callback === null || callback === void 0 ? void 0 : callback();
    });
  } // Init status


  react.exports.useEffect(function () {
    setStatus('measure');
  }, [visible]); // Go next status

  react.exports.useEffect(function () {
    switch (status) {
      case 'measure':
        doMeasure();
        break;
    }

    if (status) {
      rafRef.current = wrapperRaf$1( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var index, nextStatus;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                index = StatusQueue.indexOf(status);
                nextStatus = StatusQueue[index + 1];

                if (nextStatus && index !== -1) {
                  setStatus(nextStatus);
                }

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })));
    }
  }, [status]);
  react.exports.useEffect(function () {
    return function () {
      cancelRaf();
    };
  }, []);
  return [status, goNextStatus];
});

const useStretchStyle = (function (stretch) {
  var _React$useState = react.exports.useState({
    width: 0,
    height: 0
  }),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      targetSize = _React$useState2[0],
      setTargetSize = _React$useState2[1];

  function measureStretch(element) {
    setTargetSize({
      width: element.offsetWidth,
      height: element.offsetHeight
    });
  } // Merge stretch style


  var style = react.exports.useMemo(function () {
    var sizeStyle = {};

    if (stretch) {
      var width = targetSize.width,
          height = targetSize.height; // Stretch with target

      if (stretch.indexOf('height') !== -1 && height) {
        sizeStyle.height = height;
      } else if (stretch.indexOf('minHeight') !== -1 && height) {
        sizeStyle.minHeight = height;
      }

      if (stretch.indexOf('width') !== -1 && width) {
        sizeStyle.width = width;
      } else if (stretch.indexOf('minWidth') !== -1 && width) {
        sizeStyle.minWidth = width;
      }
    }

    return sizeStyle;
  }, [stretch, targetSize]);
  return [style, measureStretch];
});

var PopupInner = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var visible = props.visible,
    prefixCls = props.prefixCls,
    className = props.className,
    style = props.style,
    children = props.children,
    zIndex = props.zIndex,
    stretch = props.stretch,
    destroyPopupOnHide = props.destroyPopupOnHide,
    forceRender = props.forceRender,
    align = props.align,
    point = props.point,
    getRootDomNode = props.getRootDomNode,
    getClassNameFromAlign = props.getClassNameFromAlign,
    onAlign = props.onAlign,
    onMouseEnter = props.onMouseEnter,
    onMouseLeave = props.onMouseLeave,
    onMouseDown = props.onMouseDown,
    onTouchStart = props.onTouchStart,
    onClick = props.onClick;
  var alignRef = react.exports.useRef();
  var elementRef = react.exports.useRef();
  var _useState = react.exports.useState(),
    _useState2 = _slicedToArray(_useState, 2),
    alignedClassName = _useState2[0],
    setAlignedClassName = _useState2[1]; // ======================= Measure ========================

  var _useStretchStyle = useStretchStyle(stretch),
    _useStretchStyle2 = _slicedToArray(_useStretchStyle, 2),
    stretchStyle = _useStretchStyle2[0],
    measureStretchStyle = _useStretchStyle2[1];
  function doMeasure() {
    if (stretch) {
      measureStretchStyle(getRootDomNode());
    }
  } // ======================== Status ========================

  var _useVisibleStatus = useVisibleStatus(visible, doMeasure),
    _useVisibleStatus2 = _slicedToArray(_useVisibleStatus, 2),
    status = _useVisibleStatus2[0],
    goNextStatus = _useVisibleStatus2[1]; // ======================== Aligns ========================

  /**
   * `alignedClassName` may modify `source` size,
   * which means one time align may not move to the correct position at once.
   *
   * We will reset `alignTimes` for each status switch to `alignPre`
   * and let `rc-align` to align for multiple times to ensure get final stable place.
   * Currently we mark `alignTimes < 2` repeat align, it will increase if user report for align issue.
   * 
   * Update:
   * In React 18. `rc-align` effect of align may faster than ref called trigger `forceAlign`.
   * We adjust this to `alignTimes < 2`.
   * We need refactor `rc-align` to support mark of `forceAlign` call if this still happen.
   */

  var _useState3 = react.exports.useState(0),
    _useState4 = _slicedToArray(_useState3, 2),
    alignTimes = _useState4[0],
    setAlignTimes = _useState4[1];
  var prepareResolveRef = react.exports.useRef();
  useLayoutEffect$3(function () {
    if (status === 'alignPre') {
      setAlignTimes(0);
    }
  }, [status]); // `target` on `rc-align` can accept as a function to get the bind element or a point.
  // ref: https://www.npmjs.com/package/rc-align

  function getAlignTarget() {
    if (point) {
      return point;
    }
    return getRootDomNode;
  }
  function forceAlign() {
    var _alignRef$current;
    (_alignRef$current = alignRef.current) === null || _alignRef$current === void 0 ? void 0 : _alignRef$current.forceAlign();
  }
  function onInternalAlign(popupDomNode, matchAlign) {
    var nextAlignedClassName = getClassNameFromAlign(matchAlign);
    if (alignedClassName !== nextAlignedClassName) {
      setAlignedClassName(nextAlignedClassName);
    } // We will retry multi times to make sure that the element has been align in the right position.

    setAlignTimes(function (val) {
      return val + 1;
    });
    if (status === 'align') {
      onAlign === null || onAlign === void 0 ? void 0 : onAlign(popupDomNode, matchAlign);
    }
  } // Delay to go to next status

  useLayoutEffect$3(function () {
    if (status === 'align') {
      // Repeat until not more align needed
      if (alignTimes < 3) {
        forceAlign();
      } else {
        goNextStatus(function () {
          var _prepareResolveRef$cu;
          (_prepareResolveRef$cu = prepareResolveRef.current) === null || _prepareResolveRef$cu === void 0 ? void 0 : _prepareResolveRef$cu.call(prepareResolveRef);
        });
      }
    }
  }, [alignTimes]); // ======================== Motion ========================

  var motion = _objectSpread2$1({}, getMotion$2(props));
  ['onAppearEnd', 'onEnterEnd', 'onLeaveEnd'].forEach(function (eventName) {
    var originHandler = motion[eventName];
    motion[eventName] = function (element, event) {
      goNextStatus();
      return originHandler === null || originHandler === void 0 ? void 0 : originHandler(element, event);
    };
  });
  function onShowPrepare() {
    return new Promise(function (resolve) {
      prepareResolveRef.current = resolve;
    });
  } // Go to stable directly when motion not provided

  react.exports.useEffect(function () {
    if (!motion.motionName && status === 'motion') {
      goNextStatus();
    }
  }, [motion.motionName, status]); // ========================= Refs =========================

  react.exports.useImperativeHandle(ref, function () {
    return {
      forceAlign: forceAlign,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  }); // ======================== Render ========================

  var mergedStyle = _objectSpread2$1(_objectSpread2$1({}, stretchStyle), {}, {
    zIndex: zIndex,
    opacity: status === 'motion' || status === 'stable' || !visible ? undefined : 0,
    // Cannot interact with disappearing elements
    // https://github.com/ant-design/ant-design/issues/35051#issuecomment-1101340714
    pointerEvents: !visible && status !== 'stable' ? 'none' : undefined
  }, style); // Align status

  var alignDisabled = true;
  if (align !== null && align !== void 0 && align.points && (status === 'align' || status === 'stable')) {
    alignDisabled = false;
  }
  var childNode = children; // Wrapper when multiple children

  if (react.exports.Children.count(children) > 1) {
    childNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      className: "".concat(prefixCls, "-content"),
      children: children
    });
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(CSSMotion, {
      visible: visible,
      ref: elementRef,
      leavedClassName: "".concat(prefixCls, "-hidden"),
      ...motion,
      onAppearPrepare: onShowPrepare,
      onEnterPrepare: onShowPrepare,
      removeOnLeave: destroyPopupOnHide,
      forceRender: forceRender,
      children: function (_ref, motionRef) {
        var motionClassName = _ref.className,
          motionStyle = _ref.style;
        var mergedClassName = classNames$1(prefixCls, className, alignedClassName, motionClassName);
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(RcAlign, {
            target: getAlignTarget(),
            ref: alignRef,
            monitorWindowResize: true,
            disabled: alignDisabled,
            align: align,
            onAlign: onInternalAlign,
            children: /*#__PURE__*/jsx$1("div", {
              ref: motionRef,
              className: mergedClassName,
              onMouseEnter: onMouseEnter,
              onMouseLeave: onMouseLeave,
              onMouseDownCapture: onMouseDown,
              onTouchStartCapture: onTouchStart,
              onClick: onClick,
              style: _objectSpread2$1(_objectSpread2$1({}, motionStyle), mergedStyle),
              children: childNode
            })
          }, "popup")
        );
      }
    })
  );
});
PopupInner.displayName = 'PopupInner';

var MobilePopupInner = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var prefixCls = props.prefixCls,
    visible = props.visible,
    zIndex = props.zIndex,
    children = props.children,
    _props$mobile = props.mobile;
  _props$mobile = _props$mobile === void 0 ? {} : _props$mobile;
  var popupClassName = _props$mobile.popupClassName,
    popupStyle = _props$mobile.popupStyle,
    _props$mobile$popupMo = _props$mobile.popupMotion,
    popupMotion = _props$mobile$popupMo === void 0 ? {} : _props$mobile$popupMo,
    popupRender = _props$mobile.popupRender,
    onClick = props.onClick;
  var elementRef = react.exports.useRef(); // ========================= Refs =========================

  react.exports.useImperativeHandle(ref, function () {
    return {
      forceAlign: function forceAlign() {},
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  }); // ======================== Render ========================

  var mergedStyle = _objectSpread2$1({
    zIndex: zIndex
  }, popupStyle);
  var childNode = children; // Wrapper when multiple children

  if (react.exports.Children.count(children) > 1) {
    childNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      className: "".concat(prefixCls, "-content"),
      children: children
    });
  } // Mobile support additional render

  if (popupRender) {
    childNode = popupRender(childNode);
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(CSSMotion, {
      visible: visible,
      ref: elementRef,
      removeOnLeave: true,
      ...popupMotion,
      children: function (_ref, motionRef) {
        var motionClassName = _ref.className,
          motionStyle = _ref.style;
        var mergedClassName = classNames$1(prefixCls, popupClassName, motionClassName);
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("div", {
            ref: motionRef,
            className: mergedClassName,
            onClick: onClick,
            style: _objectSpread2$1(_objectSpread2$1({}, motionStyle), mergedStyle),
            children: childNode
          })
        );
      }
    })
  );
});
MobilePopupInner.displayName = 'MobilePopupInner';

var _excluded$G = ["visible", "mobile"];
var Popup$1 = /*#__PURE__*/react.exports.forwardRef(function (_ref, ref) {
  var visible = _ref.visible,
    mobile = _ref.mobile,
    props = _objectWithoutProperties(_ref, _excluded$G);
  var _useState = react.exports.useState(visible),
    _useState2 = _slicedToArray(_useState, 2),
    innerVisible = _useState2[0],
    serInnerVisible = _useState2[1];
  var _useState3 = react.exports.useState(false),
    _useState4 = _slicedToArray(_useState3, 2),
    inMobile = _useState4[0],
    setInMobile = _useState4[1];
  var cloneProps = _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    visible: innerVisible
  }); // We check mobile in visible changed here.
  // And this also delay set `innerVisible` to avoid popup component render flash

  react.exports.useEffect(function () {
    serInnerVisible(visible);
    if (visible && mobile) {
      setInMobile(isMobile());
    }
  }, [visible, mobile]);
  var popupNode = inMobile ?
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(MobilePopupInner, {
    ...cloneProps,
    mobile: mobile,
    ref: ref
  }) :
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(PopupInner, {
    ...cloneProps,
    ref: ref
  }); // We can use fragment directly but this may failed some selector usage. Keep as origin logic

  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("div", {
      children: [/*#__PURE__*/jsx$1(Mask$1, {
        ...cloneProps
      }), popupNode]
    })
  );
});
Popup$1.displayName = 'Popup';

var TriggerContext = /*#__PURE__*/react.exports.createContext(null);

function noop$4() {}
function returnEmptyString() {
  return '';
}
function returnDocument(element) {
  if (element) {
    return element.ownerDocument;
  }
  return window.document;
}
var ALL_HANDLERS = ['onClick', 'onMouseDown', 'onTouchStart', 'onMouseEnter', 'onMouseLeave', 'onFocus', 'onBlur', 'onContextMenu'];

/**
 * Internal usage. Do not use in your code since this will be removed.
 */
function generateTrigger(PortalComponent) {
  var Trigger = /*#__PURE__*/function (_React$Component) {
    _inherits(Trigger, _React$Component);
    var _super = _createSuper(Trigger);

    // ensure `getContainer` will be called only once
    function Trigger(props) {
      var _this;
      _classCallCheck(this, Trigger);
      _this = _super.call(this, props);
      _defineProperty$1(_assertThisInitialized(_this), "popupRef", /*#__PURE__*/react.exports.createRef());
      _defineProperty$1(_assertThisInitialized(_this), "triggerRef", /*#__PURE__*/react.exports.createRef());
      _defineProperty$1(_assertThisInitialized(_this), "portalContainer", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "attachId", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "clickOutsideHandler", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "touchOutsideHandler", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "contextMenuOutsideHandler1", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "contextMenuOutsideHandler2", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "mouseDownTimeout", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "focusTime", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "preClickTime", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "preTouchTime", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "delayTimer", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "hasPopupMouseDown", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "onMouseEnter", function (e) {
        var mouseEnterDelay = _this.props.mouseEnterDelay;
        _this.fireEvents('onMouseEnter', e);
        _this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e);
      });
      _defineProperty$1(_assertThisInitialized(_this), "onMouseMove", function (e) {
        _this.fireEvents('onMouseMove', e);
        _this.setPoint(e);
      });
      _defineProperty$1(_assertThisInitialized(_this), "onMouseLeave", function (e) {
        _this.fireEvents('onMouseLeave', e);
        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      });
      _defineProperty$1(_assertThisInitialized(_this), "onPopupMouseEnter", function () {
        _this.clearDelayTimer();
      });
      _defineProperty$1(_assertThisInitialized(_this), "onPopupMouseLeave", function (e) {
        var _this$popupRef$curren;

        // https://github.com/react-component/trigger/pull/13
        // react bug?
        if (e.relatedTarget && !e.relatedTarget.setTimeout && contains((_this$popupRef$curren = _this.popupRef.current) === null || _this$popupRef$curren === void 0 ? void 0 : _this$popupRef$curren.getElement(), e.relatedTarget)) {
          return;
        }
        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      });
      _defineProperty$1(_assertThisInitialized(_this), "onFocus", function (e) {
        _this.fireEvents('onFocus', e); // incase focusin and focusout

        _this.clearDelayTimer();
        if (_this.isFocusToShow()) {
          _this.focusTime = Date.now();
          _this.delaySetPopupVisible(true, _this.props.focusDelay);
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "onMouseDown", function (e) {
        _this.fireEvents('onMouseDown', e);
        _this.preClickTime = Date.now();
      });
      _defineProperty$1(_assertThisInitialized(_this), "onTouchStart", function (e) {
        _this.fireEvents('onTouchStart', e);
        _this.preTouchTime = Date.now();
      });
      _defineProperty$1(_assertThisInitialized(_this), "onBlur", function (e) {
        _this.fireEvents('onBlur', e);
        _this.clearDelayTimer();
        if (_this.isBlurToHide()) {
          _this.delaySetPopupVisible(false, _this.props.blurDelay);
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "onContextMenu", function (e) {
        e.preventDefault();
        _this.fireEvents('onContextMenu', e);
        _this.setPopupVisible(true, e);
      });
      _defineProperty$1(_assertThisInitialized(_this), "onContextMenuClose", function () {
        if (_this.isContextMenuToShow()) {
          _this.close();
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "onClick", function (event) {
        _this.fireEvents('onClick', event); // focus will trigger click

        if (_this.focusTime) {
          var preTime;
          if (_this.preClickTime && _this.preTouchTime) {
            preTime = Math.min(_this.preClickTime, _this.preTouchTime);
          } else if (_this.preClickTime) {
            preTime = _this.preClickTime;
          } else if (_this.preTouchTime) {
            preTime = _this.preTouchTime;
          }
          if (Math.abs(preTime - _this.focusTime) < 20) {
            return;
          }
          _this.focusTime = 0;
        }
        _this.preClickTime = 0;
        _this.preTouchTime = 0; // Only prevent default when all the action is click.
        // https://github.com/ant-design/ant-design/issues/17043
        // https://github.com/ant-design/ant-design/issues/17291

        if (_this.isClickToShow() && (_this.isClickToHide() || _this.isBlurToHide()) && event && event.preventDefault) {
          event.preventDefault();
        }
        var nextVisible = !_this.state.popupVisible;
        if (_this.isClickToHide() && !nextVisible || nextVisible && _this.isClickToShow()) {
          _this.setPopupVisible(!_this.state.popupVisible, event);
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "onPopupMouseDown", function () {
        _this.hasPopupMouseDown = true;
        clearTimeout(_this.mouseDownTimeout);
        _this.mouseDownTimeout = window.setTimeout(function () {
          _this.hasPopupMouseDown = false;
        }, 0);
        if (_this.context) {
          var _this$context;
          (_this$context = _this.context).onPopupMouseDown.apply(_this$context, arguments);
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "onDocumentClick", function (event) {
        if (_this.props.mask && !_this.props.maskClosable) {
          return;
        }
        var target = event.target;
        var root = _this.getRootDomNode();
        var popupNode = _this.getPopupDomNode();
        if (
        // mousedown on the target should also close popup when action is contextMenu.
        // https://github.com/ant-design/ant-design/issues/29853
        (!contains(root, target) || _this.isContextMenuOnly()) && !contains(popupNode, target) && !_this.hasPopupMouseDown) {
          _this.close();
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "getRootDomNode", function () {
        var getTriggerDOMNode = _this.props.getTriggerDOMNode;
        if (getTriggerDOMNode) {
          return getTriggerDOMNode(_this.triggerRef.current);
        }
        try {
          var domNode = findDOMNode(_this.triggerRef.current);
          if (domNode) {
            return domNode;
          }
        } catch (err) {// Do nothing
        }
        return ReactDOM.findDOMNode(_assertThisInitialized(_this));
      });
      _defineProperty$1(_assertThisInitialized(_this), "getPopupClassNameFromAlign", function (align) {
        var className = [];
        var _this$props = _this.props,
          popupPlacement = _this$props.popupPlacement,
          builtinPlacements = _this$props.builtinPlacements,
          prefixCls = _this$props.prefixCls,
          alignPoint = _this$props.alignPoint,
          getPopupClassNameFromAlign = _this$props.getPopupClassNameFromAlign;
        if (popupPlacement && builtinPlacements) {
          className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint));
        }
        if (getPopupClassNameFromAlign) {
          className.push(getPopupClassNameFromAlign(align));
        }
        return className.join(' ');
      });
      _defineProperty$1(_assertThisInitialized(_this), "getComponent", function () {
        var _this$props2 = _this.props,
          prefixCls = _this$props2.prefixCls,
          destroyPopupOnHide = _this$props2.destroyPopupOnHide,
          popupClassName = _this$props2.popupClassName,
          onPopupAlign = _this$props2.onPopupAlign,
          popupMotion = _this$props2.popupMotion,
          popupAnimation = _this$props2.popupAnimation,
          popupTransitionName = _this$props2.popupTransitionName,
          popupStyle = _this$props2.popupStyle,
          mask = _this$props2.mask,
          maskAnimation = _this$props2.maskAnimation,
          maskTransitionName = _this$props2.maskTransitionName,
          maskMotion = _this$props2.maskMotion,
          zIndex = _this$props2.zIndex,
          popup = _this$props2.popup,
          stretch = _this$props2.stretch,
          alignPoint = _this$props2.alignPoint,
          mobile = _this$props2.mobile,
          forceRender = _this$props2.forceRender,
          onPopupClick = _this$props2.onPopupClick;
        var _this$state = _this.state,
          popupVisible = _this$state.popupVisible,
          point = _this$state.point;
        var align = _this.getPopupAlign();
        var mouseProps = {};
        if (_this.isMouseEnterToShow()) {
          mouseProps.onMouseEnter = _this.onPopupMouseEnter;
        }
        if (_this.isMouseLeaveToHide()) {
          mouseProps.onMouseLeave = _this.onPopupMouseLeave;
        }
        mouseProps.onMouseDown = _this.onPopupMouseDown;
        mouseProps.onTouchStart = _this.onPopupMouseDown;
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(Popup$1, {
            prefixCls: prefixCls,
            destroyPopupOnHide: destroyPopupOnHide,
            visible: popupVisible,
            point: alignPoint && point,
            className: popupClassName,
            align: align,
            onAlign: onPopupAlign,
            animation: popupAnimation,
            getClassNameFromAlign: _this.getPopupClassNameFromAlign,
            ...mouseProps,
            stretch: stretch,
            getRootDomNode: _this.getRootDomNode,
            style: popupStyle,
            mask: mask,
            zIndex: zIndex,
            transitionName: popupTransitionName,
            maskAnimation: maskAnimation,
            maskTransitionName: maskTransitionName,
            maskMotion: maskMotion,
            ref: _this.popupRef,
            motion: popupMotion,
            mobile: mobile,
            forceRender: forceRender,
            onClick: onPopupClick,
            children: typeof popup === 'function' ? popup() : popup
          })
        );
      });
      _defineProperty$1(_assertThisInitialized(_this), "attachParent", function (popupContainer) {
        wrapperRaf$1.cancel(_this.attachId);
        var _this$props3 = _this.props,
          getPopupContainer = _this$props3.getPopupContainer,
          getDocument = _this$props3.getDocument;
        var domNode = _this.getRootDomNode();
        var mountNode;
        if (!getPopupContainer) {
          mountNode = getDocument(_this.getRootDomNode()).body;
        } else if (domNode || getPopupContainer.length === 0) {
          // Compatible for legacy getPopupContainer with domNode argument.
          // If no need `domNode` argument, will call directly.
          // https://codesandbox.io/s/eloquent-mclean-ss93m?file=/src/App.js
          mountNode = getPopupContainer(domNode);
        }
        if (mountNode) {
          mountNode.appendChild(popupContainer);
        } else {
          // Retry after frame render in case parent not ready
          _this.attachId = wrapperRaf$1(function () {
            _this.attachParent(popupContainer);
          });
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "getContainer", function () {
        if (!_this.portalContainer) {
          // In React.StrictMode component will call render multiple time in first mount.
          // When you want to refactor with FC, useRef will also init multiple time and
          // point to different useRef instance which will create multiple element
          // (This multiple render will not trigger effect so you can not clean up this
          // in effect). But this is safe with class component since it always point to same class instance.
          var getDocument = _this.props.getDocument;
          var popupContainer = getDocument(_this.getRootDomNode()).createElement('div'); // Make sure default popup container will never cause scrollbar appearing
          // https://github.com/react-component/trigger/issues/41

          popupContainer.style.position = 'absolute';
          popupContainer.style.top = '0';
          popupContainer.style.left = '0';
          popupContainer.style.width = '100%';
          _this.portalContainer = popupContainer;
        }
        _this.attachParent(_this.portalContainer);
        return _this.portalContainer;
      });
      _defineProperty$1(_assertThisInitialized(_this), "setPoint", function (point) {
        var alignPoint = _this.props.alignPoint;
        if (!alignPoint || !point) return;
        _this.setState({
          point: {
            pageX: point.pageX,
            pageY: point.pageY
          }
        });
      });
      _defineProperty$1(_assertThisInitialized(_this), "handlePortalUpdate", function () {
        if (_this.state.prevPopupVisible !== _this.state.popupVisible) {
          _this.props.afterPopupVisibleChange(_this.state.popupVisible);
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "triggerContextValue", {
        onPopupMouseDown: _this.onPopupMouseDown
      });
      var _popupVisible;
      if ('popupVisible' in props) {
        _popupVisible = !!props.popupVisible;
      } else {
        _popupVisible = !!props.defaultPopupVisible;
      }
      _this.state = {
        prevPopupVisible: _popupVisible,
        popupVisible: _popupVisible
      };
      ALL_HANDLERS.forEach(function (h) {
        _this["fire".concat(h)] = function (e) {
          _this.fireEvents(h, e);
        };
      });
      return _this;
    }
    _createClass(Trigger, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.componentDidUpdate();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var props = this.props;
        var state = this.state; // We must listen to `mousedown` or `touchstart`, edge case:
        // https://github.com/ant-design/ant-design/issues/5804
        // https://github.com/react-component/calendar/issues/250
        // https://github.com/react-component/trigger/issues/50

        if (state.popupVisible) {
          var currentDocument;
          if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextMenuToShow())) {
            currentDocument = props.getDocument(this.getRootDomNode());
            this.clickOutsideHandler = addEventListenerWrap(currentDocument, 'mousedown', this.onDocumentClick);
          } // always hide on mobile

          if (!this.touchOutsideHandler) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.touchOutsideHandler = addEventListenerWrap(currentDocument, 'touchstart', this.onDocumentClick);
          } // close popup when trigger type contains 'onContextMenu' and document is scrolling.

          if (!this.contextMenuOutsideHandler1 && this.isContextMenuToShow()) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.contextMenuOutsideHandler1 = addEventListenerWrap(currentDocument, 'scroll', this.onContextMenuClose);
          } // close popup when trigger type contains 'onContextMenu' and window is blur.

          if (!this.contextMenuOutsideHandler2 && this.isContextMenuToShow()) {
            this.contextMenuOutsideHandler2 = addEventListenerWrap(window, 'blur', this.onContextMenuClose);
          }
          return;
        }
        this.clearOutsideHandler();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.clearDelayTimer();
        this.clearOutsideHandler();
        clearTimeout(this.mouseDownTimeout);
        wrapperRaf$1.cancel(this.attachId);
      }
    }, {
      key: "getPopupDomNode",
      value: function getPopupDomNode() {
        var _this$popupRef$curren2;

        // for test
        return ((_this$popupRef$curren2 = this.popupRef.current) === null || _this$popupRef$curren2 === void 0 ? void 0 : _this$popupRef$curren2.getElement()) || null;
      }
    }, {
      key: "getPopupAlign",
      value: function getPopupAlign() {
        var props = this.props;
        var popupPlacement = props.popupPlacement,
          popupAlign = props.popupAlign,
          builtinPlacements = props.builtinPlacements;
        if (popupPlacement && builtinPlacements) {
          return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
        }
        return popupAlign;
      }
    }, {
      key: "setPopupVisible",
      value:
      /**
       * @param popupVisible    Show or not the popup element
       * @param event           SyntheticEvent, used for `pointAlign`
       */
      function setPopupVisible(popupVisible, event) {
        var alignPoint = this.props.alignPoint;
        var prevPopupVisible = this.state.popupVisible;
        this.clearDelayTimer();
        if (prevPopupVisible !== popupVisible) {
          if (!('popupVisible' in this.props)) {
            this.setState({
              popupVisible: popupVisible,
              prevPopupVisible: prevPopupVisible
            });
          }
          this.props.onPopupVisibleChange(popupVisible);
        } // Always record the point position since mouseEnterDelay will delay the show

        if (alignPoint && event && popupVisible) {
          this.setPoint(event);
        }
      }
    }, {
      key: "delaySetPopupVisible",
      value: function delaySetPopupVisible(visible, delayS, event) {
        var _this2 = this;
        var delay = delayS * 1000;
        this.clearDelayTimer();
        if (delay) {
          var point = event ? {
            pageX: event.pageX,
            pageY: event.pageY
          } : null;
          this.delayTimer = window.setTimeout(function () {
            _this2.setPopupVisible(visible, point);
            _this2.clearDelayTimer();
          }, delay);
        } else {
          this.setPopupVisible(visible, event);
        }
      }
    }, {
      key: "clearDelayTimer",
      value: function clearDelayTimer() {
        if (this.delayTimer) {
          clearTimeout(this.delayTimer);
          this.delayTimer = null;
        }
      }
    }, {
      key: "clearOutsideHandler",
      value: function clearOutsideHandler() {
        if (this.clickOutsideHandler) {
          this.clickOutsideHandler.remove();
          this.clickOutsideHandler = null;
        }
        if (this.contextMenuOutsideHandler1) {
          this.contextMenuOutsideHandler1.remove();
          this.contextMenuOutsideHandler1 = null;
        }
        if (this.contextMenuOutsideHandler2) {
          this.contextMenuOutsideHandler2.remove();
          this.contextMenuOutsideHandler2 = null;
        }
        if (this.touchOutsideHandler) {
          this.touchOutsideHandler.remove();
          this.touchOutsideHandler = null;
        }
      }
    }, {
      key: "createTwoChains",
      value: function createTwoChains(event) {
        var childPros = this.props.children.props;
        var props = this.props;
        if (childPros[event] && props[event]) {
          return this["fire".concat(event)];
        }
        return childPros[event] || props[event];
      }
    }, {
      key: "isClickToShow",
      value: function isClickToShow() {
        var _this$props4 = this.props,
          action = _this$props4.action,
          showAction = _this$props4.showAction;
        return action.indexOf('click') !== -1 || showAction.indexOf('click') !== -1;
      }
    }, {
      key: "isContextMenuOnly",
      value: function isContextMenuOnly() {
        var action = this.props.action;
        return action === 'contextMenu' || action.length === 1 && action[0] === 'contextMenu';
      }
    }, {
      key: "isContextMenuToShow",
      value: function isContextMenuToShow() {
        var _this$props5 = this.props,
          action = _this$props5.action,
          showAction = _this$props5.showAction;
        return action.indexOf('contextMenu') !== -1 || showAction.indexOf('contextMenu') !== -1;
      }
    }, {
      key: "isClickToHide",
      value: function isClickToHide() {
        var _this$props6 = this.props,
          action = _this$props6.action,
          hideAction = _this$props6.hideAction;
        return action.indexOf('click') !== -1 || hideAction.indexOf('click') !== -1;
      }
    }, {
      key: "isMouseEnterToShow",
      value: function isMouseEnterToShow() {
        var _this$props7 = this.props,
          action = _this$props7.action,
          showAction = _this$props7.showAction;
        return action.indexOf('hover') !== -1 || showAction.indexOf('mouseEnter') !== -1;
      }
    }, {
      key: "isMouseLeaveToHide",
      value: function isMouseLeaveToHide() {
        var _this$props8 = this.props,
          action = _this$props8.action,
          hideAction = _this$props8.hideAction;
        return action.indexOf('hover') !== -1 || hideAction.indexOf('mouseLeave') !== -1;
      }
    }, {
      key: "isFocusToShow",
      value: function isFocusToShow() {
        var _this$props9 = this.props,
          action = _this$props9.action,
          showAction = _this$props9.showAction;
        return action.indexOf('focus') !== -1 || showAction.indexOf('focus') !== -1;
      }
    }, {
      key: "isBlurToHide",
      value: function isBlurToHide() {
        var _this$props10 = this.props,
          action = _this$props10.action,
          hideAction = _this$props10.hideAction;
        return action.indexOf('focus') !== -1 || hideAction.indexOf('blur') !== -1;
      }
    }, {
      key: "forcePopupAlign",
      value: function forcePopupAlign() {
        if (this.state.popupVisible) {
          var _this$popupRef$curren3;
          (_this$popupRef$curren3 = this.popupRef.current) === null || _this$popupRef$curren3 === void 0 ? void 0 : _this$popupRef$curren3.forceAlign();
        }
      }
    }, {
      key: "fireEvents",
      value: function fireEvents(type, e) {
        var childCallback = this.props.children.props[type];
        if (childCallback) {
          childCallback(e);
        }
        var callback = this.props[type];
        if (callback) {
          callback(e);
        }
      }
    }, {
      key: "close",
      value: function close() {
        this.setPopupVisible(false);
      }
    }, {
      key: "render",
      value: function render() {
        var popupVisible = this.state.popupVisible;
        var _this$props11 = this.props,
          children = _this$props11.children,
          forceRender = _this$props11.forceRender,
          alignPoint = _this$props11.alignPoint,
          className = _this$props11.className,
          autoDestroy = _this$props11.autoDestroy;
        var child = react.exports.Children.only(children);
        var newChildProps = {
          key: 'trigger'
        }; // ============================== Visible Handlers ==============================
        // >>> ContextMenu

        if (this.isContextMenuToShow()) {
          newChildProps.onContextMenu = this.onContextMenu;
        } else {
          newChildProps.onContextMenu = this.createTwoChains('onContextMenu');
        } // >>> Click

        if (this.isClickToHide() || this.isClickToShow()) {
          newChildProps.onClick = this.onClick;
          newChildProps.onMouseDown = this.onMouseDown;
          newChildProps.onTouchStart = this.onTouchStart;
        } else {
          newChildProps.onClick = this.createTwoChains('onClick');
          newChildProps.onMouseDown = this.createTwoChains('onMouseDown');
          newChildProps.onTouchStart = this.createTwoChains('onTouchStart');
        } // >>> Hover(enter)

        if (this.isMouseEnterToShow()) {
          newChildProps.onMouseEnter = this.onMouseEnter; // Point align

          if (alignPoint) {
            newChildProps.onMouseMove = this.onMouseMove;
          }
        } else {
          newChildProps.onMouseEnter = this.createTwoChains('onMouseEnter');
        } // >>> Hover(leave)

        if (this.isMouseLeaveToHide()) {
          newChildProps.onMouseLeave = this.onMouseLeave;
        } else {
          newChildProps.onMouseLeave = this.createTwoChains('onMouseLeave');
        } // >>> Focus

        if (this.isFocusToShow() || this.isBlurToHide()) {
          newChildProps.onFocus = this.onFocus;
          newChildProps.onBlur = this.onBlur;
        } else {
          newChildProps.onFocus = this.createTwoChains('onFocus');
          newChildProps.onBlur = this.createTwoChains('onBlur');
        } // =================================== Render ===================================

        var childrenClassName = classNames$1(child && child.props && child.props.className, className);
        if (childrenClassName) {
          newChildProps.className = childrenClassName;
        }
        var cloneProps = _objectSpread2$1({}, newChildProps);
        if (supportRef$1(child)) {
          cloneProps.ref = composeRef$1(this.triggerRef, child.ref);
        }
        var trigger = /*#__PURE__*/react.exports.cloneElement(child, cloneProps);
        var portal; // prevent unmounting after it's rendered

        if (popupVisible || this.popupRef.current || forceRender) {
          portal =
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(PortalComponent, {
            getContainer: this.getContainer,
            didUpdate: this.handlePortalUpdate,
            children: this.getComponent()
          }, "portal");
        }
        if (!popupVisible && autoDestroy) {
          portal = null;
        }
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsxs(TriggerContext.Provider, {
            value: this.triggerContextValue,
            children: [trigger, portal]
          })
        );
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, prevState) {
        var popupVisible = _ref.popupVisible;
        var newState = {};
        if (popupVisible !== undefined && prevState.popupVisible !== popupVisible) {
          newState.popupVisible = popupVisible;
          newState.prevPopupVisible = prevState.popupVisible;
        }
        return newState;
      }
    }]);
    return Trigger;
  }(react.exports.Component);
  _defineProperty$1(Trigger, "contextType", TriggerContext);
  _defineProperty$1(Trigger, "defaultProps", {
    prefixCls: 'rc-trigger-popup',
    getPopupClassNameFromAlign: returnEmptyString,
    getDocument: returnDocument,
    onPopupVisibleChange: noop$4,
    afterPopupVisibleChange: noop$4,
    onPopupAlign: noop$4,
    popupClassName: '',
    mouseEnterDelay: 0,
    mouseLeaveDelay: 0.1,
    focusDelay: 0,
    blurDelay: 0.15,
    popupStyle: {},
    destroyPopupOnHide: false,
    popupAlign: {},
    defaultPopupVisible: false,
    mask: false,
    maskClosable: true,
    action: [],
    showAction: [],
    hideAction: [],
    autoDestroy: false
  });
  return Trigger;
}
const Trigger = generateTrigger(Portal$1);

var _excluded$F = ["prefixCls", "disabled", "visible", "children", "popupElement", "containerWidth", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "direction", "placement", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "getPopupContainer", "empty", "getTriggerDOMNode", "onPopupVisibleChange", "onPopupMouseEnter"];
var getBuiltInPlacements = function getBuiltInPlacements(dropdownMatchSelectWidth) {
  // Enable horizontal overflow auto-adjustment when a custom dropdown width is provided
  var adjustX = dropdownMatchSelectWidth === true ? 0 : 1;
  return {
    bottomLeft: {
      points: ['tl', 'bl'],
      offset: [0, 4],
      overflow: {
        adjustX: adjustX,
        adjustY: 1
      }
    },
    bottomRight: {
      points: ['tr', 'br'],
      offset: [0, 4],
      overflow: {
        adjustX: adjustX,
        adjustY: 1
      }
    },
    topLeft: {
      points: ['bl', 'tl'],
      offset: [0, -4],
      overflow: {
        adjustX: adjustX,
        adjustY: 1
      }
    },
    topRight: {
      points: ['br', 'tr'],
      offset: [0, -4],
      overflow: {
        adjustX: adjustX,
        adjustY: 1
      }
    }
  };
};
var SelectTrigger = function SelectTrigger(props, ref) {
  var prefixCls = props.prefixCls;
    props.disabled;
    var visible = props.visible,
    children = props.children,
    popupElement = props.popupElement,
    containerWidth = props.containerWidth,
    animation = props.animation,
    transitionName = props.transitionName,
    dropdownStyle = props.dropdownStyle,
    dropdownClassName = props.dropdownClassName,
    _props$direction = props.direction,
    direction = _props$direction === void 0 ? 'ltr' : _props$direction,
    placement = props.placement,
    dropdownMatchSelectWidth = props.dropdownMatchSelectWidth,
    dropdownRender = props.dropdownRender,
    dropdownAlign = props.dropdownAlign,
    getPopupContainer = props.getPopupContainer,
    empty = props.empty,
    getTriggerDOMNode = props.getTriggerDOMNode,
    onPopupVisibleChange = props.onPopupVisibleChange,
    onPopupMouseEnter = props.onPopupMouseEnter,
    restProps = _objectWithoutProperties(props, _excluded$F);
  var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
  var popupNode = popupElement;
  if (dropdownRender) {
    popupNode = dropdownRender(popupElement);
  }
  var builtInPlacements = react.exports.useMemo(function () {
    return getBuiltInPlacements(dropdownMatchSelectWidth);
  }, [dropdownMatchSelectWidth]); // ===================== Motion ======================

  var mergedTransitionName = animation ? "".concat(dropdownPrefixCls, "-").concat(animation) : transitionName; // ======================= Ref =======================

  var popupRef = react.exports.useRef(null);
  react.exports.useImperativeHandle(ref, function () {
    return {
      getPopupElement: function getPopupElement() {
        return popupRef.current;
      }
    };
  });
  var popupStyle = _objectSpread2$1({
    minWidth: containerWidth
  }, dropdownStyle);
  if (typeof dropdownMatchSelectWidth === 'number') {
    popupStyle.width = dropdownMatchSelectWidth;
  } else if (dropdownMatchSelectWidth) {
    popupStyle.width = containerWidth;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Trigger, {
      ...restProps,
      showAction: onPopupVisibleChange ? ['click'] : [],
      hideAction: onPopupVisibleChange ? ['click'] : [],
      popupPlacement: placement || (direction === 'rtl' ? 'bottomRight' : 'bottomLeft'),
      builtinPlacements: builtInPlacements,
      prefixCls: dropdownPrefixCls,
      popupTransitionName: mergedTransitionName,
      popup:
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("div", {
        ref: popupRef,
        onMouseEnter: onPopupMouseEnter,
        children: popupNode
      }),
      popupAlign: dropdownAlign,
      popupVisible: visible,
      getPopupContainer: getPopupContainer,
      popupClassName: classNames$1(dropdownClassName, _defineProperty$1({}, "".concat(dropdownPrefixCls, "-empty"), empty)),
      popupStyle: popupStyle,
      getTriggerDOMNode: getTriggerDOMNode,
      onPopupVisibleChange: onPopupVisibleChange,
      children: children
    })
  );
};
var RefSelectTrigger = /*#__PURE__*/react.exports.forwardRef(SelectTrigger);
RefSelectTrigger.displayName = 'SelectTrigger';

function getKey$1(data, index) {
  var key = data.key;
  var value;

  if ('value' in data) {
    value = data.value;
  }

  if (key !== null && key !== undefined) {
    return key;
  }

  if (value !== undefined) {
    return value;
  }

  return "rc-index-key-".concat(index);
}

function fillFieldNames$1(fieldNames, childrenAsData) {
  var _ref = fieldNames || {},
      label = _ref.label,
      value = _ref.value,
      options = _ref.options;

  return {
    label: label || (childrenAsData ? 'children' : 'label'),
    value: value || 'value',
    options: options || 'options'
  };
}
/**
 * Flat options into flatten list.
 * We use `optionOnly` here is aim to avoid user use nested option group.
 * Here is simply set `key` to the index if not provided.
 */

function flattenOptions(options) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      fieldNames = _ref2.fieldNames,
      childrenAsData = _ref2.childrenAsData;

  var flattenList = [];

  var _fillFieldNames = fillFieldNames$1(fieldNames, false),
      fieldLabel = _fillFieldNames.label,
      fieldValue = _fillFieldNames.value,
      fieldOptions = _fillFieldNames.options;

  function dig(list, isGroupOption) {
    list.forEach(function (data) {
      var label = data[fieldLabel];

      if (isGroupOption || !(fieldOptions in data)) {
        var value = data[fieldValue]; // Option

        flattenList.push({
          key: getKey$1(data, flattenList.length),
          groupOption: isGroupOption,
          data: data,
          label: label,
          value: value
        });
      } else {
        var grpLabel = label;

        if (grpLabel === undefined && childrenAsData) {
          grpLabel = data.label;
        } // Option Group


        flattenList.push({
          key: getKey$1(data, flattenList.length),
          group: true,
          data: data,
          label: grpLabel
        });
        dig(data[fieldOptions], true);
      }
    });
  }

  dig(options, false);
  return flattenList;
}
/**
 * Inject `props` into `option` for legacy usage
 */

function injectPropsWithOption(option) {
  var newOption = _objectSpread2$1({}, option);

  if (!('props' in newOption)) {
    Object.defineProperty(newOption, 'props', {
      get: function get() {
        warningOnce(false, 'Return type is option instead of Option instance. Please read value directly instead of reading from `props`.');
        return newOption;
      }
    });
  }

  return newOption;
}
function getSeparatedContent(text, tokens) {
  if (!tokens || !tokens.length) {
    return null;
  }

  var match = false;

  function separate(str, _ref3) {
    var _ref4 = _toArray(_ref3),
        token = _ref4[0],
        restTokens = _ref4.slice(1);

    if (!token) {
      return [str];
    }

    var list = str.split(token);
    match = match || list.length > 1;
    return list.reduce(function (prevList, unitStr) {
      return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));
    }, []).filter(function (unit) {
      return unit;
    });
  }

  var list = separate(text, tokens);
  return match ? list : null;
}

var _excluded$E = ["id", "prefixCls", "className", "showSearch", "tagRender", "direction", "omitDomProps", "displayValues", "onDisplayValuesChange", "emptyOptions", "notFoundContent", "onClear", "mode", "disabled", "loading", "getInputElement", "getRawInputElement", "open", "defaultOpen", "onDropdownVisibleChange", "activeValue", "onActiveValueChange", "activeDescendantId", "searchValue", "autoClearSearchValue", "onSearch", "onSearchSplit", "tokenSeparators", "allowClear", "showArrow", "inputIcon", "clearIcon", "OptionList", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "placement", "getPopupContainer", "showAction", "onFocus", "onBlur", "onKeyUp", "onKeyDown", "onMouseDown"];
var DEFAULT_OMIT_PROPS = ['value', 'onChange', 'removeIcon', 'placeholder', 'autoFocus', 'maxTagCount', 'maxTagTextLength', 'maxTagPlaceholder', 'choiceTransitionName', 'onInputKeyDown', 'onPopupScroll', 'tabIndex'];
function isMultiple(mode) {
  return mode === 'tags' || mode === 'multiple';
}
var BaseSelect = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _customizeRawInputEle, _classNames2;
  var id = props.id,
    prefixCls = props.prefixCls,
    className = props.className,
    showSearch = props.showSearch,
    tagRender = props.tagRender,
    direction = props.direction,
    omitDomProps = props.omitDomProps,
    displayValues = props.displayValues,
    onDisplayValuesChange = props.onDisplayValuesChange,
    emptyOptions = props.emptyOptions,
    _props$notFoundConten = props.notFoundContent,
    notFoundContent = _props$notFoundConten === void 0 ? 'Not Found' : _props$notFoundConten,
    onClear = props.onClear,
    mode = props.mode,
    disabled = props.disabled,
    loading = props.loading,
    getInputElement = props.getInputElement,
    getRawInputElement = props.getRawInputElement,
    open = props.open,
    defaultOpen = props.defaultOpen,
    onDropdownVisibleChange = props.onDropdownVisibleChange,
    activeValue = props.activeValue,
    onActiveValueChange = props.onActiveValueChange,
    activeDescendantId = props.activeDescendantId,
    searchValue = props.searchValue,
    autoClearSearchValue = props.autoClearSearchValue,
    onSearch = props.onSearch,
    onSearchSplit = props.onSearchSplit,
    tokenSeparators = props.tokenSeparators,
    allowClear = props.allowClear,
    showArrow = props.showArrow,
    inputIcon = props.inputIcon,
    clearIcon = props.clearIcon,
    OptionList = props.OptionList,
    animation = props.animation,
    transitionName = props.transitionName,
    dropdownStyle = props.dropdownStyle,
    dropdownClassName = props.dropdownClassName,
    dropdownMatchSelectWidth = props.dropdownMatchSelectWidth,
    dropdownRender = props.dropdownRender,
    dropdownAlign = props.dropdownAlign,
    placement = props.placement,
    getPopupContainer = props.getPopupContainer,
    _props$showAction = props.showAction,
    showAction = _props$showAction === void 0 ? [] : _props$showAction,
    onFocus = props.onFocus,
    onBlur = props.onBlur,
    onKeyUp = props.onKeyUp,
    onKeyDown = props.onKeyDown,
    onMouseDown = props.onMouseDown,
    restProps = _objectWithoutProperties(props, _excluded$E); // ============================== MISC ==============================

  var multiple = isMultiple(mode);
  var mergedShowSearch = (showSearch !== undefined ? showSearch : multiple) || mode === 'combobox';
  var domProps = _objectSpread2$1({}, restProps);
  DEFAULT_OMIT_PROPS.forEach(function (propName) {
    delete domProps[propName];
  });
  omitDomProps === null || omitDomProps === void 0 ? void 0 : omitDomProps.forEach(function (propName) {
    delete domProps[propName];
  }); // ============================= Mobile =============================

  var _React$useState = react.exports.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    mobile = _React$useState2[0],
    setMobile = _React$useState2[1];
  react.exports.useEffect(function () {
    // Only update on the client side
    setMobile(isMobile());
  }, []); // ============================== Refs ==============================

  var containerRef = react.exports.useRef(null);
  var selectorDomRef = react.exports.useRef(null);
  var triggerRef = react.exports.useRef(null);
  var selectorRef = react.exports.useRef(null);
  var listRef = react.exports.useRef(null);
  /** Used for component focused management */

  var _useDelayReset = useDelayReset(),
    _useDelayReset2 = _slicedToArray(_useDelayReset, 3),
    mockFocused = _useDelayReset2[0],
    setMockFocused = _useDelayReset2[1],
    cancelSetMockFocused = _useDelayReset2[2]; // =========================== Imperative ===========================

  react.exports.useImperativeHandle(ref, function () {
    var _selectorRef$current, _selectorRef$current2;
    return {
      focus: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.focus,
      blur: (_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 ? void 0 : _selectorRef$current2.blur,
      scrollTo: function scrollTo(arg) {
        var _listRef$current;
        return (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(arg);
      }
    };
  }); // ========================== Search Value ==========================

  var mergedSearchValue = react.exports.useMemo(function () {
    var _displayValues$;
    if (mode !== 'combobox') {
      return searchValue;
    }
    var val = (_displayValues$ = displayValues[0]) === null || _displayValues$ === void 0 ? void 0 : _displayValues$.value;
    return typeof val === 'string' || typeof val === 'number' ? String(val) : '';
  }, [searchValue, mode, displayValues]); // ========================== Custom Input ==========================
  // Only works in `combobox`

  var customizeInputElement = mode === 'combobox' && typeof getInputElement === 'function' && getInputElement() || null; // Used for customize replacement for `rc-cascader`

  var customizeRawInputElement = typeof getRawInputElement === 'function' && getRawInputElement();
  var customizeRawInputRef = useComposeRef(selectorDomRef, customizeRawInputElement === null || customizeRawInputElement === void 0 ? void 0 : (_customizeRawInputEle = customizeRawInputElement.props) === null || _customizeRawInputEle === void 0 ? void 0 : _customizeRawInputEle.ref); // ============================== Open ==============================

  var _useMergedState = useMergedState$1(undefined, {
      defaultValue: defaultOpen,
      value: open
    }),
    _useMergedState2 = _slicedToArray(_useMergedState, 2),
    innerOpen = _useMergedState2[0],
    setInnerOpen = _useMergedState2[1];
  var mergedOpen = innerOpen; // Not trigger `open` in `combobox` when `notFoundContent` is empty

  var emptyListContent = !notFoundContent && emptyOptions;
  if (disabled || emptyListContent && mergedOpen && mode === 'combobox') {
    mergedOpen = false;
  }
  var triggerOpen = emptyListContent ? false : mergedOpen;
  var onToggleOpen = react.exports.useCallback(function (newOpen) {
    var nextOpen = newOpen !== undefined ? newOpen : !mergedOpen;
    if (!disabled) {
      setInnerOpen(nextOpen);
      if (mergedOpen !== nextOpen) {
        onDropdownVisibleChange === null || onDropdownVisibleChange === void 0 ? void 0 : onDropdownVisibleChange(nextOpen);
      }
    }
  }, [disabled, mergedOpen, setInnerOpen, onDropdownVisibleChange]); // ============================= Search =============================

  var tokenWithEnter = react.exports.useMemo(function () {
    return (tokenSeparators || []).some(function (tokenSeparator) {
      return ['\n', '\r\n'].includes(tokenSeparator);
    });
  }, [tokenSeparators]);
  var onInternalSearch = function onInternalSearch(searchText, fromTyping, isCompositing) {
    var ret = true;
    var newSearchText = searchText;
    onActiveValueChange === null || onActiveValueChange === void 0 ? void 0 : onActiveValueChange(null); // Check if match the `tokenSeparators`

    var patchLabels = isCompositing ? null : getSeparatedContent(searchText, tokenSeparators); // Ignore combobox since it's not split-able

    if (mode !== 'combobox' && patchLabels) {
      newSearchText = '';
      onSearchSplit === null || onSearchSplit === void 0 ? void 0 : onSearchSplit(patchLabels); // Should close when paste finish

      onToggleOpen(false); // Tell Selector that break next actions

      ret = false;
    }
    if (onSearch && mergedSearchValue !== newSearchText) {
      onSearch(newSearchText, {
        source: fromTyping ? 'typing' : 'effect'
      });
    }
    return ret;
  }; // Only triggered when menu is closed & mode is tags
  // If menu is open, OptionList will take charge
  // If mode isn't tags, press enter is not meaningful when you can't see any option

  var onInternalSearchSubmit = function onInternalSearchSubmit(searchText) {
    // prevent empty tags from appearing when you click the Enter button
    if (!searchText || !searchText.trim()) {
      return;
    }
    onSearch(searchText, {
      source: 'submit'
    });
  }; // Close will clean up single mode search text

  react.exports.useEffect(function () {
    if (!mergedOpen && !multiple && mode !== 'combobox') {
      onInternalSearch('', false, false);
    }
  }, [mergedOpen]); // ============================ Disabled ============================
  // Close dropdown & remove focus state when disabled change

  react.exports.useEffect(function () {
    if (innerOpen && disabled) {
      setInnerOpen(false);
    }
    if (disabled) {
      setMockFocused(false);
    }
  }, [disabled]); // ============================ Keyboard ============================

  /**
   * We record input value here to check if can press to clean up by backspace
   * - null: Key is not down, this is reset by key up
   * - true: Search text is empty when first time backspace down
   * - false: Search text is not empty when first time backspace down
   */

  var _useLock = useLock(),
    _useLock2 = _slicedToArray(_useLock, 2),
    getClearLock = _useLock2[0],
    setClearLock = _useLock2[1]; // KeyDown

  var onInternalKeyDown = function onInternalKeyDown(event) {
    var clearLock = getClearLock();
    var which = event.which;
    if (which === KeyCode$1.ENTER) {
      // Do not submit form when type in the input
      if (mode !== 'combobox') {
        event.preventDefault();
      } // We only manage open state here, close logic should handle by list component

      if (!mergedOpen) {
        onToggleOpen(true);
      }
    }
    setClearLock(!!mergedSearchValue); // Remove value by `backspace`

    if (which === KeyCode$1.BACKSPACE && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
      var cloneDisplayValues = _toConsumableArray(displayValues);
      var removedDisplayValue = null;
      for (var i = cloneDisplayValues.length - 1; i >= 0; i -= 1) {
        var current = cloneDisplayValues[i];
        if (!current.disabled) {
          cloneDisplayValues.splice(i, 1);
          removedDisplayValue = current;
          break;
        }
      }
      if (removedDisplayValue) {
        onDisplayValuesChange(cloneDisplayValues, {
          type: 'remove',
          values: [removedDisplayValue]
        });
      }
    }
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }
    if (mergedOpen && listRef.current) {
      var _listRef$current2;
      (_listRef$current2 = listRef.current).onKeyDown.apply(_listRef$current2, [event].concat(rest));
    }
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown.apply(void 0, [event].concat(rest));
  }; // KeyUp

  var onInternalKeyUp = function onInternalKeyUp(event) {
    for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      rest[_key2 - 1] = arguments[_key2];
    }
    if (mergedOpen && listRef.current) {
      var _listRef$current3;
      (_listRef$current3 = listRef.current).onKeyUp.apply(_listRef$current3, [event].concat(rest));
    }
    onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp.apply(void 0, [event].concat(rest));
  }; // ============================ Selector ============================

  var onSelectorRemove = function onSelectorRemove(val) {
    var newValues = displayValues.filter(function (i) {
      return i !== val;
    });
    onDisplayValuesChange(newValues, {
      type: 'remove',
      values: [val]
    });
  }; // ========================== Focus / Blur ==========================

  /** Record real focus status */

  var focusRef = react.exports.useRef(false);
  var onContainerFocus = function onContainerFocus() {
    setMockFocused(true);
    if (!disabled) {
      if (onFocus && !focusRef.current) {
        onFocus.apply(void 0, arguments);
      } // `showAction` should handle `focus` if set

      if (showAction.includes('focus')) {
        onToggleOpen(true);
      }
    }
    focusRef.current = true;
  };
  var onContainerBlur = function onContainerBlur() {
    setMockFocused(false, function () {
      focusRef.current = false;
      onToggleOpen(false);
    });
    if (disabled) {
      return;
    }
    if (mergedSearchValue) {
      // `tags` mode should move `searchValue` into values
      if (mode === 'tags') {
        onSearch(mergedSearchValue, {
          source: 'submit'
        });
      } else if (mode === 'multiple') {
        // `multiple` mode only clean the search value but not trigger event
        onSearch('', {
          source: 'blur'
        });
      }
    }
    if (onBlur) {
      onBlur.apply(void 0, arguments);
    }
  }; // Give focus back of Select

  var activeTimeoutIds = [];
  react.exports.useEffect(function () {
    return function () {
      activeTimeoutIds.forEach(function (timeoutId) {
        return clearTimeout(timeoutId);
      });
      activeTimeoutIds.splice(0, activeTimeoutIds.length);
    };
  }, []);
  var onInternalMouseDown = function onInternalMouseDown(event) {
    var _triggerRef$current;
    var target = event.target;
    var popupElement = (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.getPopupElement(); // We should give focus back to selector if clicked item is not focusable

    if (popupElement && popupElement.contains(target)) {
      var timeoutId = setTimeout(function () {
        var index = activeTimeoutIds.indexOf(timeoutId);
        if (index !== -1) {
          activeTimeoutIds.splice(index, 1);
        }
        cancelSetMockFocused();
        if (!mobile && !popupElement.contains(document.activeElement)) {
          var _selectorRef$current3;
          (_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 ? void 0 : _selectorRef$current3.focus();
        }
      });
      activeTimeoutIds.push(timeoutId);
    }
    for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      restArgs[_key3 - 1] = arguments[_key3];
    }
    onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown.apply(void 0, [event].concat(restArgs));
  }; // ============================ Dropdown ============================

  var _React$useState3 = react.exports.useState(null),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    containerWidth = _React$useState4[0],
    setContainerWidth = _React$useState4[1];
  var _React$useState5 = react.exports.useState({}),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    forceUpdate = _React$useState6[1]; // We need force update here since popup dom is render async

  function onPopupMouseEnter() {
    forceUpdate({});
  }
  useLayoutEffect$3(function () {
    if (triggerOpen) {
      var _containerRef$current;
      var newWidth = Math.ceil((_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.offsetWidth);
      if (containerWidth !== newWidth && !Number.isNaN(newWidth)) {
        setContainerWidth(newWidth);
      }
    }
  }, [triggerOpen]); // Used for raw custom input trigger

  var onTriggerVisibleChange;
  if (customizeRawInputElement) {
    onTriggerVisibleChange = function onTriggerVisibleChange(newOpen) {
      onToggleOpen(newOpen);
    };
  } // Close when click on non-select element

  useSelectTriggerControl(function () {
    var _triggerRef$current2;
    return [containerRef.current, (_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : _triggerRef$current2.getPopupElement()];
  }, triggerOpen, onToggleOpen, !!customizeRawInputElement); // ============================ Context =============================

  var baseSelectContext = react.exports.useMemo(function () {
    return _objectSpread2$1(_objectSpread2$1({}, props), {}, {
      notFoundContent: notFoundContent,
      open: mergedOpen,
      triggerOpen: triggerOpen,
      id: id,
      showSearch: mergedShowSearch,
      multiple: multiple,
      toggleOpen: onToggleOpen
    });
  }, [props, notFoundContent, triggerOpen, mergedOpen, id, mergedShowSearch, multiple, onToggleOpen]); // ==================================================================
  // ==                            Render                            ==
  // ==================================================================
  // ============================= Arrow ==============================

  var mergedShowArrow = showArrow !== undefined ? showArrow : loading || !multiple && mode !== 'combobox';
  var arrowNode;
  if (mergedShowArrow) {
    arrowNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(TransBtn, {
      className: classNames$1("".concat(prefixCls, "-arrow"), _defineProperty$1({}, "".concat(prefixCls, "-arrow-loading"), loading)),
      customizeIcon: inputIcon,
      customizeIconProps: {
        loading: loading,
        searchValue: mergedSearchValue,
        open: mergedOpen,
        focused: mockFocused,
        showSearch: mergedShowSearch
      }
    });
  } // ============================= Clear ==============================

  var clearNode;
  var onClearMouseDown = function onClearMouseDown() {
    var _selectorRef$current4;
    onClear === null || onClear === void 0 ? void 0 : onClear();
    (_selectorRef$current4 = selectorRef.current) === null || _selectorRef$current4 === void 0 ? void 0 : _selectorRef$current4.focus();
    onDisplayValuesChange([], {
      type: 'clear',
      values: displayValues
    });
    onInternalSearch('', false, false);
  };
  if (!disabled && allowClear && (displayValues.length || mergedSearchValue) && !(mode === 'combobox' && mergedSearchValue === '')) {
    clearNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(TransBtn, {
      className: "".concat(prefixCls, "-clear"),
      onMouseDown: onClearMouseDown,
      customizeIcon: clearIcon,
      children: "\xD7"
    });
  } // =========================== OptionList ===========================

  var optionList =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(OptionList, {
    ref: listRef
  }); // ============================= Select =============================

  var mergedClassName = classNames$1(prefixCls, className, (_classNames2 = {}, _defineProperty$1(_classNames2, "".concat(prefixCls, "-focused"), mockFocused), _defineProperty$1(_classNames2, "".concat(prefixCls, "-multiple"), multiple), _defineProperty$1(_classNames2, "".concat(prefixCls, "-single"), !multiple), _defineProperty$1(_classNames2, "".concat(prefixCls, "-allow-clear"), allowClear), _defineProperty$1(_classNames2, "".concat(prefixCls, "-show-arrow"), mergedShowArrow), _defineProperty$1(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$1(_classNames2, "".concat(prefixCls, "-loading"), loading), _defineProperty$1(_classNames2, "".concat(prefixCls, "-open"), mergedOpen), _defineProperty$1(_classNames2, "".concat(prefixCls, "-customize-input"), customizeInputElement), _defineProperty$1(_classNames2, "".concat(prefixCls, "-show-search"), mergedShowSearch), _classNames2)); // >>> Selector

  var selectorNode =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(RefSelectTrigger, {
    ref: triggerRef,
    disabled: disabled,
    prefixCls: prefixCls,
    visible: triggerOpen,
    popupElement: optionList,
    containerWidth: containerWidth,
    animation: animation,
    transitionName: transitionName,
    dropdownStyle: dropdownStyle,
    dropdownClassName: dropdownClassName,
    direction: direction,
    dropdownMatchSelectWidth: dropdownMatchSelectWidth,
    dropdownRender: dropdownRender,
    dropdownAlign: dropdownAlign,
    placement: placement,
    getPopupContainer: getPopupContainer,
    empty: emptyOptions,
    getTriggerDOMNode: function getTriggerDOMNode() {
      return selectorDomRef.current;
    },
    onPopupVisibleChange: onTriggerVisibleChange,
    onPopupMouseEnter: onPopupMouseEnter,
    children: customizeRawInputElement ? /*#__PURE__*/react.exports.cloneElement(customizeRawInputElement, {
      ref: customizeRawInputRef
    }) :
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(ForwardSelector, {
      ...props,
      domRef: selectorDomRef,
      prefixCls: prefixCls,
      inputElement: customizeInputElement,
      ref: selectorRef,
      id: id,
      showSearch: mergedShowSearch,
      autoClearSearchValue: autoClearSearchValue,
      mode: mode,
      activeDescendantId: activeDescendantId,
      tagRender: tagRender,
      values: displayValues,
      open: mergedOpen,
      onToggleOpen: onToggleOpen,
      activeValue: activeValue,
      searchValue: mergedSearchValue,
      onSearch: onInternalSearch,
      onSearchSubmit: onInternalSearchSubmit,
      onRemove: onSelectorRemove,
      tokenWithEnter: tokenWithEnter
    })
  }); // >>> Render

  var renderNode; // Render raw

  if (customizeRawInputElement) {
    renderNode = selectorNode;
  } else {
    renderNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("div", {
      className: mergedClassName,
      ...domProps,
      ref: containerRef,
      onMouseDown: onInternalMouseDown,
      onKeyDown: onInternalKeyDown,
      onKeyUp: onInternalKeyUp,
      onFocus: onContainerFocus,
      onBlur: onContainerBlur,
      children: [mockFocused && !mergedOpen &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        style: {
          width: 0,
          height: 0,
          position: 'absolute',
          overflow: 'hidden',
          opacity: 0
        },
        "aria-live": "polite",
        children: "".concat(displayValues.map(function (_ref) {
          var label = _ref.label,
            value = _ref.value;
          return ['number', 'string'].includes(_typeof$1(label)) ? label : value;
        }).join(', '))
      }), selectorNode, arrowNode, clearNode]
    });
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(BaseSelectContext.Provider, {
      value: baseSelectContext,
      children: renderNode
    })
  );
}); // Set display name for dev

/**
 * Cache `value` related LabeledValue & options.
 */
const useCache = (function (labeledValues, valueOptions) {
  var cacheRef = react.exports.useRef({
    values: new Map(),
    options: new Map()
  });
  var filledLabeledValues = react.exports.useMemo(function () {
    var _cacheRef$current = cacheRef.current,
        prevValueCache = _cacheRef$current.values,
        prevOptionCache = _cacheRef$current.options; // Fill label by cache

    var patchedValues = labeledValues.map(function (item) {
      if (item.label === undefined) {
        var _prevValueCache$get;

        return _objectSpread2$1(_objectSpread2$1({}, item), {}, {
          label: (_prevValueCache$get = prevValueCache.get(item.value)) === null || _prevValueCache$get === void 0 ? void 0 : _prevValueCache$get.label
        });
      }

      return item;
    }); // Refresh cache

    var valueCache = new Map();
    var optionCache = new Map();
    patchedValues.forEach(function (item) {
      valueCache.set(item.value, item);
      optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
    });
    cacheRef.current.values = valueCache;
    cacheRef.current.options = optionCache;
    return patchedValues;
  }, [labeledValues, valueOptions]);
  var getOption = react.exports.useCallback(function (val) {
    return valueOptions.get(val) || cacheRef.current.options.get(val);
  }, [valueOptions]);
  return [filledLabeledValues, getOption];
});

function includes(test, search) {
  return toArray$4(test).join('').toUpperCase().includes(search);
}

const useFilterOptions = (function (options, fieldNames, searchValue, filterOption, optionFilterProp) {
  return react.exports.useMemo(function () {
    if (!searchValue || filterOption === false) {
      return options;
    }

    var fieldOptions = fieldNames.options,
        fieldLabel = fieldNames.label,
        fieldValue = fieldNames.value;
    var filteredOptions = [];
    var customizeFilter = typeof filterOption === 'function';
    var upperSearch = searchValue.toUpperCase();
    var filterFunc = customizeFilter ? filterOption : function (_, option) {
      // Use provided `optionFilterProp`
      if (optionFilterProp) {
        return includes(option[optionFilterProp], upperSearch);
      } // Auto select `label` or `value` by option type


      if (option[fieldOptions]) {
        // hack `fieldLabel` since `OptionGroup` children is not `label`
        return includes(option[fieldLabel !== 'children' ? fieldLabel : 'label'], upperSearch);
      }

      return includes(option[fieldValue], upperSearch);
    };
    var wrapOption = customizeFilter ? function (opt) {
      return injectPropsWithOption(opt);
    } : function (opt) {
      return opt;
    };
    options.forEach(function (item) {
      // Group should check child options
      if (item[fieldOptions]) {
        // Check group first
        var matchGroup = filterFunc(searchValue, wrapOption(item));

        if (matchGroup) {
          filteredOptions.push(item);
        } else {
          // Check option
          var subOptions = item[fieldOptions].filter(function (subItem) {
            return filterFunc(searchValue, wrapOption(subItem));
          });

          if (subOptions.length) {
            filteredOptions.push(_objectSpread2$1(_objectSpread2$1({}, item), {}, _defineProperty$1({}, fieldOptions, subOptions)));
          }
        }

        return;
      }

      if (filterFunc(searchValue, wrapOption(item))) {
        filteredOptions.push(item);
      }
    });
    return filteredOptions;
  }, [options, filterOption, optionFilterProp, searchValue, fieldNames]);
});

var uuid$5 = 0;
/** Is client side and not jsdom */

var isBrowserClient$1 = canUseDom();
/** Get unique id for accessibility usage */

function getUUID$1() {
  var retId; // Test never reach

  /* istanbul ignore if */

  if (isBrowserClient$1) {
    retId = uuid$5;
    uuid$5 += 1;
  } else {
    retId = 'TEST_OR_SSR';
  }

  return retId;
}
function useId$2(id) {
  // Inner id for accessibility usage. Only work in client side
  var _React$useState = react.exports.useState(),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      innerId = _React$useState2[0],
      setInnerId = _React$useState2[1];

  react.exports.useEffect(function () {
    setInnerId("rc_select_".concat(getUUID$1()));
  }, []);
  return id || innerId;
}

var _excluded$D = ["children", "value"],
    _excluded2$6 = ["children"];

function convertNodeToOption(node) {
  var _ref = node,
      key = _ref.key,
      _ref$props = _ref.props,
      children = _ref$props.children,
      value = _ref$props.value,
      restProps = _objectWithoutProperties(_ref$props, _excluded$D);

  return _objectSpread2$1({
    key: key,
    value: value !== undefined ? value : key,
    children: children
  }, restProps);
}

function convertChildrenToData(nodes) {
  var optionOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return toArray$6(nodes).map(function (node, index) {
    if (! /*#__PURE__*/react.exports.isValidElement(node) || !node.type) {
      return null;
    }

    var _ref2 = node,
        isSelectOptGroup = _ref2.type.isSelectOptGroup,
        key = _ref2.key,
        _ref2$props = _ref2.props,
        children = _ref2$props.children,
        restProps = _objectWithoutProperties(_ref2$props, _excluded2$6);

    if (optionOnly || !isSelectOptGroup) {
      return convertNodeToOption(node);
    }

    return _objectSpread2$1(_objectSpread2$1({
      key: "__RC_SELECT_GRP__".concat(key === null ? index : key, "__"),
      label: key
    }, restProps), {}, {
      options: convertChildrenToData(children)
    });
  }).filter(function (data) {
    return data;
  });
}

/**
 * Parse `children` to `options` if `options` is not provided.
 * Then flatten the `options`.
 */

function useOptions(options, children, fieldNames, optionFilterProp, optionLabelProp) {
  return react.exports.useMemo(function () {
    var mergedOptions = options;
    var childrenAsData = !options;

    if (childrenAsData) {
      mergedOptions = convertChildrenToData(children);
    }

    var valueOptions = new Map();
    var labelOptions = new Map();

    var setLabelOptions = function setLabelOptions(labelOptionsMap, option, key) {
      if (key && typeof key === 'string') {
        labelOptionsMap.set(option[key], option);
      }
    };

    function dig(optionList) {
      var isChildren = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      // for loop to speed up collection speed
      for (var i = 0; i < optionList.length; i += 1) {
        var option = optionList[i];

        if (!option[fieldNames.options] || isChildren) {
          valueOptions.set(option[fieldNames.value], option);
          setLabelOptions(labelOptions, option, fieldNames.label); // https://github.com/ant-design/ant-design/issues/35304

          setLabelOptions(labelOptions, option, optionFilterProp);
          setLabelOptions(labelOptions, option, optionLabelProp);
        } else {
          dig(option[fieldNames.options], true);
        }
      }
    }

    dig(mergedOptions);
    return {
      options: mergedOptions,
      valueOptions: valueOptions,
      labelOptions: labelOptions
    };
  }, [options, children, fieldNames, optionFilterProp, optionLabelProp]);
}

/**
 * Same as `React.useCallback` but always return a memoized function
 * but redirect to real function.
 */

function useRefFunc(callback) {
  var funcRef = react.exports.useRef();
  funcRef.current = callback;
  var cacheFn = react.exports.useCallback(function () {
    return funcRef.current.apply(funcRef, arguments);
  }, []);
  return cacheFn;
}

/* istanbul ignore file */

/** This is a placeholder, not real render in dom */
var OptGroup = function OptGroup() {
  return null;
};

OptGroup.isSelectOptGroup = true;

/* istanbul ignore file */

/** This is a placeholder, not real render in dom */
var Option$1 = function Option() {
  return null;
};

Option$1.isSelectOption = true;

function omit(obj, fields) {
  var clone = _objectSpread2$1({}, obj);
  if (Array.isArray(fields)) {
    fields.forEach(function (key) {
      delete clone[key];
    });
  }
  return clone;
}

var Filler$1 = /*#__PURE__*/react.exports.forwardRef(function (_ref, ref) {
  var height = _ref.height,
    offset = _ref.offset,
    children = _ref.children,
    prefixCls = _ref.prefixCls,
    onInnerResize = _ref.onInnerResize,
    innerProps = _ref.innerProps;
  var outerStyle = {};
  var innerStyle = {
    display: 'flex',
    flexDirection: 'column'
  };
  if (offset !== undefined) {
    outerStyle = {
      height: height,
      position: 'relative',
      overflow: 'hidden'
    };
    innerStyle = _objectSpread2$1(_objectSpread2$1({}, innerStyle), {}, {
      transform: "translateY(".concat(offset, "px)"),
      position: 'absolute',
      left: 0,
      right: 0,
      top: 0
    });
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      style: outerStyle,
      children: /*#__PURE__*/jsx$1(ResizeObserver$1, {
        onResize: function onResize(_ref2) {
          var offsetHeight = _ref2.offsetHeight;
          if (offsetHeight && onInnerResize) {
            onInnerResize();
          }
        },
        children: /*#__PURE__*/jsx$1("div", {
          style: innerStyle,
          className: classNames$1(_defineProperty$1({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
          ref: ref,
          ...innerProps,
          children: children
        })
      })
    })
  );
});
Filler$1.displayName = 'Filler';

var MIN_SIZE$1 = 20;
function getPageY$1(e) {
  return 'touches' in e ? e.touches[0].pageY : e.pageY;
}
var ScrollBar$1 = /*#__PURE__*/function (_React$Component) {
  _inherits(ScrollBar, _React$Component);
  var _super = _createSuper(ScrollBar);
  function ScrollBar() {
    var _this;
    _classCallCheck(this, ScrollBar);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.moveRaf = null;
    _this.scrollbarRef = /*#__PURE__*/react.exports.createRef();
    _this.thumbRef = /*#__PURE__*/react.exports.createRef();
    _this.visibleTimeout = null;
    _this.state = {
      dragging: false,
      pageY: null,
      startTop: null,
      visible: false
    };
    _this.delayHidden = function () {
      clearTimeout(_this.visibleTimeout);
      _this.setState({
        visible: true
      });
      _this.visibleTimeout = setTimeout(function () {
        _this.setState({
          visible: false
        });
      }, 2000);
    };
    _this.onScrollbarTouchStart = function (e) {
      e.preventDefault();
    };
    _this.onContainerMouseDown = function (e) {
      e.stopPropagation();
      e.preventDefault();
    };
    _this.patchEvents = function () {
      window.addEventListener('mousemove', _this.onMouseMove);
      window.addEventListener('mouseup', _this.onMouseUp);
      _this.thumbRef.current.addEventListener('touchmove', _this.onMouseMove);
      _this.thumbRef.current.addEventListener('touchend', _this.onMouseUp);
    };
    _this.removeEvents = function () {
      var _this$scrollbarRef$cu;
      window.removeEventListener('mousemove', _this.onMouseMove);
      window.removeEventListener('mouseup', _this.onMouseUp);
      (_this$scrollbarRef$cu = _this.scrollbarRef.current) === null || _this$scrollbarRef$cu === void 0 ? void 0 : _this$scrollbarRef$cu.removeEventListener('touchstart', _this.onScrollbarTouchStart);
      if (_this.thumbRef.current) {
        _this.thumbRef.current.removeEventListener('touchstart', _this.onMouseDown);
        _this.thumbRef.current.removeEventListener('touchmove', _this.onMouseMove);
        _this.thumbRef.current.removeEventListener('touchend', _this.onMouseUp);
      }
      wrapperRaf$1.cancel(_this.moveRaf);
    };
    _this.onMouseDown = function (e) {
      var onStartMove = _this.props.onStartMove;
      _this.setState({
        dragging: true,
        pageY: getPageY$1(e),
        startTop: _this.getTop()
      });
      onStartMove();
      _this.patchEvents();
      e.stopPropagation();
      e.preventDefault();
    };
    _this.onMouseMove = function (e) {
      var _this$state = _this.state,
        dragging = _this$state.dragging,
        pageY = _this$state.pageY,
        startTop = _this$state.startTop;
      var onScroll = _this.props.onScroll;
      wrapperRaf$1.cancel(_this.moveRaf);
      if (dragging) {
        var offsetY = getPageY$1(e) - pageY;
        var newTop = startTop + offsetY;
        var enableScrollRange = _this.getEnableScrollRange();
        var enableHeightRange = _this.getEnableHeightRange();
        var ptg = enableHeightRange ? newTop / enableHeightRange : 0;
        var newScrollTop = Math.ceil(ptg * enableScrollRange);
        _this.moveRaf = wrapperRaf$1(function () {
          onScroll(newScrollTop);
        });
      }
    };
    _this.onMouseUp = function () {
      var onStopMove = _this.props.onStopMove;
      _this.setState({
        dragging: false
      });
      onStopMove();
      _this.removeEvents();
    };
    _this.getSpinHeight = function () {
      var _this$props = _this.props,
        height = _this$props.height,
        count = _this$props.count;
      var baseHeight = height / count * 10;
      baseHeight = Math.max(baseHeight, MIN_SIZE$1);
      baseHeight = Math.min(baseHeight, height / 2);
      return Math.floor(baseHeight);
    };
    _this.getEnableScrollRange = function () {
      var _this$props2 = _this.props,
        scrollHeight = _this$props2.scrollHeight,
        height = _this$props2.height;
      return scrollHeight - height || 0;
    };
    _this.getEnableHeightRange = function () {
      var height = _this.props.height;
      var spinHeight = _this.getSpinHeight();
      return height - spinHeight || 0;
    };
    _this.getTop = function () {
      var scrollTop = _this.props.scrollTop;
      var enableScrollRange = _this.getEnableScrollRange();
      var enableHeightRange = _this.getEnableHeightRange();
      if (scrollTop === 0 || enableScrollRange === 0) {
        return 0;
      }
      var ptg = scrollTop / enableScrollRange;
      return ptg * enableHeightRange;
    };
    _this.showScroll = function () {
      var _this$props3 = _this.props,
        height = _this$props3.height,
        scrollHeight = _this$props3.scrollHeight;
      return scrollHeight > height;
    };
    return _this;
  }
  _createClass(ScrollBar, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.scrollbarRef.current.addEventListener('touchstart', this.onScrollbarTouchStart);
      this.thumbRef.current.addEventListener('touchstart', this.onMouseDown);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.scrollTop !== this.props.scrollTop) {
        this.delayHidden();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.removeEvents();
      clearTimeout(this.visibleTimeout);
    }
  }, {
    key: "render",
    value:
    // ====================== Render =======================
    function render() {
      var _this$state2 = this.state,
        dragging = _this$state2.dragging,
        visible = _this$state2.visible;
      var prefixCls = this.props.prefixCls;
      var spinHeight = this.getSpinHeight();
      var top = this.getTop();
      var canScroll = this.showScroll();
      var mergedVisible = canScroll && visible;
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("div", {
          ref: this.scrollbarRef,
          className: classNames$1("".concat(prefixCls, "-scrollbar"), _defineProperty$1({}, "".concat(prefixCls, "-scrollbar-show"), canScroll)),
          style: {
            width: 8,
            top: 0,
            bottom: 0,
            right: 0,
            position: 'absolute',
            display: mergedVisible ? null : 'none'
          },
          onMouseDown: this.onContainerMouseDown,
          onMouseMove: this.delayHidden,
          children: /*#__PURE__*/jsx$1("div", {
            ref: this.thumbRef,
            className: classNames$1("".concat(prefixCls, "-scrollbar-thumb"), _defineProperty$1({}, "".concat(prefixCls, "-scrollbar-thumb-moving"), dragging)),
            style: {
              width: '100%',
              height: spinHeight,
              top: top,
              left: 0,
              position: 'absolute',
              background: 'rgba(0, 0, 0, 0.5)',
              borderRadius: 99,
              cursor: 'pointer',
              userSelect: 'none'
            },
            onMouseDown: this.onMouseDown
          })
        })
      );
    }
  }]);
  return ScrollBar;
}(react.exports.Component);

function Item$4(_ref) {
  var children = _ref.children,
    setRef = _ref.setRef;
  var refFunc = react.exports.useCallback(function (node) {
    setRef(node);
  }, []);
  return /*#__PURE__*/react.exports.cloneElement(children, {
    ref: refFunc
  });
}

function useChildren$1(list, startIndex, endIndex, setNodeRef, renderFunc, _ref) {
  var getKey = _ref.getKey;
  return list.slice(startIndex, endIndex + 1).map(function (item, index) {
    var eleIndex = startIndex + index;
    var node = renderFunc(item, eleIndex, {
      // style: status === 'MEASURE_START' ? { visibility: 'hidden' } : {},
    });
    var key = getKey(item);
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(Item$4, {
        setRef: function setRef(ele) {
          return setNodeRef(item, ele);
        },
        children: node
      }, key)
    );
  });
}

// Firefox has low performance of map.
var CacheMap$1 = /*#__PURE__*/function () {
  function CacheMap() {
    _classCallCheck(this, CacheMap);
    this.maps = void 0;
    this.maps = Object.create(null);
  }
  _createClass(CacheMap, [{
    key: "set",
    value: function set(key, value) {
      this.maps[key] = value;
    }
  }, {
    key: "get",
    value: function get(key) {
      return this.maps[key];
    }
  }]);
  return CacheMap;
}();

function useHeights$1(getKey, onItemAdd, onItemRemove) {
  var _React$useState = react.exports.useState(0),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    updatedMark = _React$useState2[0],
    setUpdatedMark = _React$useState2[1];
  var instanceRef = react.exports.useRef(new Map());
  var heightsRef = react.exports.useRef(new CacheMap$1());
  var collectRafRef = react.exports.useRef();
  function cancelRaf() {
    wrapperRaf$1.cancel(collectRafRef.current);
  }
  function collectHeight() {
    cancelRaf();
    collectRafRef.current = wrapperRaf$1(function () {
      instanceRef.current.forEach(function (element, key) {
        if (element && element.offsetParent) {
          var htmlElement = findDOMNode(element);
          var offsetHeight = htmlElement.offsetHeight;
          if (heightsRef.current.get(key) !== offsetHeight) {
            heightsRef.current.set(key, htmlElement.offsetHeight);
          }
        }
      });
      // Always trigger update mark to tell parent that should re-calculate heights when resized
      setUpdatedMark(function (c) {
        return c + 1;
      });
    });
  }
  function setInstanceRef(item, instance) {
    var key = getKey(item);
    var origin = instanceRef.current.get(key);
    if (instance) {
      instanceRef.current.set(key, instance);
      collectHeight();
    } else {
      instanceRef.current.delete(key);
    }
    // Instance changed
    if (!origin !== !instance) {
      if (instance) {
        onItemAdd === null || onItemAdd === void 0 ? void 0 : onItemAdd(item);
      } else {
        onItemRemove === null || onItemRemove === void 0 ? void 0 : onItemRemove(item);
      }
    }
  }
  react.exports.useEffect(function () {
    return cancelRaf;
  }, []);
  return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
}

function useScrollTo$1(containerRef, data, heights, itemHeight, getKey, collectHeight, syncScrollTop, triggerFlash) {
  var scrollRef = react.exports.useRef();
  return function (arg) {
    // When not argument provided, we think dev may want to show the scrollbar
    if (arg === null || arg === undefined) {
      triggerFlash();
      return;
    }
    // Normal scroll logic
    wrapperRaf$1.cancel(scrollRef.current);
    if (typeof arg === 'number') {
      syncScrollTop(arg);
    } else if (arg && _typeof$1(arg) === 'object') {
      var index;
      var align = arg.align;
      if ('index' in arg) {
        index = arg.index;
      } else {
        index = data.findIndex(function (item) {
          return getKey(item) === arg.key;
        });
      }
      var _arg$offset = arg.offset,
        offset = _arg$offset === void 0 ? 0 : _arg$offset;
      // We will retry 3 times in case dynamic height shaking
      var syncScroll = function syncScroll(times, targetAlign) {
        if (times < 0 || !containerRef.current) return;
        var height = containerRef.current.clientHeight;
        var needCollectHeight = false;
        var newTargetAlign = targetAlign;
        // Go to next frame if height not exist
        if (height) {
          var mergedAlign = targetAlign || align;
          // Get top & bottom
          var stackTop = 0;
          var itemTop = 0;
          var itemBottom = 0;
          var maxLen = Math.min(data.length, index);
          for (var i = 0; i <= maxLen; i += 1) {
            var key = getKey(data[i]);
            itemTop = stackTop;
            var cacheHeight = heights.get(key);
            itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);
            stackTop = itemBottom;
            if (i === index && cacheHeight === undefined) {
              needCollectHeight = true;
            }
          }
          // Scroll to
          var targetTop = null;
          switch (mergedAlign) {
            case 'top':
              targetTop = itemTop - offset;
              break;
            case 'bottom':
              targetTop = itemBottom - height + offset;
              break;
            default:
              {
                var scrollTop = containerRef.current.scrollTop;
                var scrollBottom = scrollTop + height;
                if (itemTop < scrollTop) {
                  newTargetAlign = 'top';
                } else if (itemBottom > scrollBottom) {
                  newTargetAlign = 'bottom';
                }
              }
          }
          if (targetTop !== null && targetTop !== containerRef.current.scrollTop) {
            syncScrollTop(targetTop);
          }
        }
        // We will retry since element may not sync height as it described
        scrollRef.current = wrapperRaf$1(function () {
          if (needCollectHeight) {
            collectHeight();
          }
          syncScroll(times - 1, newTargetAlign);
        }, 2); // Delay 2 to wait for List collect heights
      };

      syncScroll(3);
    }
  };
}

/**
 * Get index with specific start index one by one. e.g.
 * min: 3, max: 9, start: 6
 *
 * Return index is:
 * [0]: 6
 * [1]: 7
 * [2]: 5
 * [3]: 8
 * [4]: 4
 * [5]: 9
 * [6]: 3
 */
/**
 * We assume that 2 list has only 1 item diff and others keeping the order.
 * So we can use dichotomy algorithm to find changed one.
 */
function findListDiffIndex$1(originList, targetList, getKey) {
  var originLen = originList.length;
  var targetLen = targetList.length;
  var shortList;
  var longList;
  if (originLen === 0 && targetLen === 0) {
    return null;
  }
  if (originLen < targetLen) {
    shortList = originList;
    longList = targetList;
  } else {
    shortList = targetList;
    longList = originList;
  }
  var notExistKey = {
    __EMPTY_ITEM__: true
  };
  function getItemKey(item) {
    if (item !== undefined) {
      return getKey(item);
    }
    return notExistKey;
  }
  // Loop to find diff one
  var diffIndex = null;
  var multiple = Math.abs(originLen - targetLen) !== 1;
  for (var i = 0; i < longList.length; i += 1) {
    var shortKey = getItemKey(shortList[i]);
    var longKey = getItemKey(longList[i]);
    if (shortKey !== longKey) {
      diffIndex = i;
      multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
      break;
    }
  }
  return diffIndex === null ? null : {
    index: diffIndex,
    multiple: multiple
  };
}

function useDiffItem$1(data, getKey, onDiff) {
  var _React$useState = react.exports.useState(data),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    prevData = _React$useState2[0],
    setPrevData = _React$useState2[1];
  var _React$useState3 = react.exports.useState(null),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    diffItem = _React$useState4[0],
    setDiffItem = _React$useState4[1];
  react.exports.useEffect(function () {
    var diff = findListDiffIndex$1(prevData || [], data || [], getKey);
    if ((diff === null || diff === void 0 ? void 0 : diff.index) !== undefined) {
      onDiff === null || onDiff === void 0 ? void 0 : onDiff(diff.index);
      setDiffItem(data[diff.index]);
    }
    setPrevData(data);
  }, [data]);
  return [diffItem];
}

var isFF$1 = (typeof navigator === "undefined" ? "undefined" : _typeof$1(navigator)) === 'object' && /Firefox/i.test(navigator.userAgent);

const useOriginScroll$1 = (function (isScrollAtTop, isScrollAtBottom) {
  // Do lock for a wheel when scrolling
  var lockRef = react.exports.useRef(false);
  var lockTimeoutRef = react.exports.useRef(null);
  function lockScroll() {
    clearTimeout(lockTimeoutRef.current);
    lockRef.current = true;
    lockTimeoutRef.current = setTimeout(function () {
      lockRef.current = false;
    }, 50);
  }
  // Pass to ref since global add is in closure
  var scrollPingRef = react.exports.useRef({
    top: isScrollAtTop,
    bottom: isScrollAtBottom
  });
  scrollPingRef.current.top = isScrollAtTop;
  scrollPingRef.current.bottom = isScrollAtBottom;
  return function (deltaY) {
    var smoothOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var originScroll =
    // Pass origin wheel when on the top
    deltaY < 0 && scrollPingRef.current.top ||
    // Pass origin wheel when on the bottom
    deltaY > 0 && scrollPingRef.current.bottom;
    if (smoothOffset && originScroll) {
      // No need lock anymore when it's smooth offset from touchMove interval
      clearTimeout(lockTimeoutRef.current);
      lockRef.current = false;
    } else if (!originScroll || lockRef.current) {
      lockScroll();
    }
    return !lockRef.current && originScroll;
  };
});

function useFrameWheel$1(inVirtual, isScrollAtTop, isScrollAtBottom, onWheelDelta) {
  var offsetRef = react.exports.useRef(0);
  var nextFrameRef = react.exports.useRef(null);
  // Firefox patch
  var wheelValueRef = react.exports.useRef(null);
  var isMouseScrollRef = react.exports.useRef(false);
  // Scroll status sync
  var originScroll = useOriginScroll$1(isScrollAtTop, isScrollAtBottom);
  function onWheel(event) {
    if (!inVirtual) return;
    wrapperRaf$1.cancel(nextFrameRef.current);
    var deltaY = event.deltaY;
    offsetRef.current += deltaY;
    wheelValueRef.current = deltaY;
    // Do nothing when scroll at the edge, Skip check when is in scroll
    if (originScroll(deltaY)) return;
    // Proxy of scroll events
    if (!isFF$1) {
      event.preventDefault();
    }
    nextFrameRef.current = wrapperRaf$1(function () {
      // Patch a multiple for Firefox to fix wheel number too small
      // ref: https://github.com/ant-design/ant-design/issues/26372#issuecomment-679460266
      var patchMultiple = isMouseScrollRef.current ? 10 : 1;
      onWheelDelta(offsetRef.current * patchMultiple);
      offsetRef.current = 0;
    });
  }
  // A patch for firefox
  function onFireFoxScroll(event) {
    if (!inVirtual) return;
    isMouseScrollRef.current = event.detail === wheelValueRef.current;
  }
  return [onWheel, onFireFoxScroll];
}

var SMOOTH_PTG$1 = 14 / 15;
function useMobileTouchMove$1(inVirtual, listRef, callback) {
  var touchedRef = react.exports.useRef(false);
  var touchYRef = react.exports.useRef(0);
  var elementRef = react.exports.useRef(null);
  // Smooth scroll
  var intervalRef = react.exports.useRef(null);
  /* eslint-disable prefer-const */
  var cleanUpEvents;
  var onTouchMove = function onTouchMove(e) {
    if (touchedRef.current) {
      var currentY = Math.ceil(e.touches[0].pageY);
      var offsetY = touchYRef.current - currentY;
      touchYRef.current = currentY;
      if (callback(offsetY)) {
        e.preventDefault();
      }
      // Smooth interval
      clearInterval(intervalRef.current);
      intervalRef.current = setInterval(function () {
        offsetY *= SMOOTH_PTG$1;
        if (!callback(offsetY, true) || Math.abs(offsetY) <= 0.1) {
          clearInterval(intervalRef.current);
        }
      }, 16);
    }
  };
  var onTouchEnd = function onTouchEnd() {
    touchedRef.current = false;
    cleanUpEvents();
  };
  var onTouchStart = function onTouchStart(e) {
    cleanUpEvents();
    if (e.touches.length === 1 && !touchedRef.current) {
      touchedRef.current = true;
      touchYRef.current = Math.ceil(e.touches[0].pageY);
      elementRef.current = e.target;
      elementRef.current.addEventListener('touchmove', onTouchMove);
      elementRef.current.addEventListener('touchend', onTouchEnd);
    }
  };
  cleanUpEvents = function cleanUpEvents() {
    if (elementRef.current) {
      elementRef.current.removeEventListener('touchmove', onTouchMove);
      elementRef.current.removeEventListener('touchend', onTouchEnd);
    }
  };
  useLayoutEffect$3(function () {
    if (inVirtual) {
      listRef.current.addEventListener('touchstart', onTouchStart);
    }
    return function () {
      var _listRef$current;
      (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.removeEventListener('touchstart', onTouchStart);
      cleanUpEvents();
      clearInterval(intervalRef.current);
    };
  }, [inVirtual]);
}

var _excluded$C = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "component", "onScroll", "onVisibleChange", "innerProps"];
var EMPTY_DATA$2 = [];
var ScrollStyle$1 = {
  overflowY: 'auto',
  overflowAnchor: 'none'
};
function RawList$1(props, ref) {
  var _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-virtual-list' : _props$prefixCls,
    className = props.className,
    height = props.height,
    itemHeight = props.itemHeight,
    _props$fullHeight = props.fullHeight,
    fullHeight = _props$fullHeight === void 0 ? true : _props$fullHeight,
    style = props.style,
    data = props.data,
    children = props.children,
    itemKey = props.itemKey,
    virtual = props.virtual,
    _props$component = props.component,
    Component = _props$component === void 0 ? 'div' : _props$component,
    onScroll = props.onScroll,
    onVisibleChange = props.onVisibleChange,
    innerProps = props.innerProps,
    restProps = _objectWithoutProperties(props, _excluded$C);
  // ================================= MISC =================================
  var useVirtual = !!(virtual !== false && height && itemHeight);
  var inVirtual = useVirtual && data && itemHeight * data.length > height;
  var _useState = react.exports.useState(0),
    _useState2 = _slicedToArray(_useState, 2),
    scrollTop = _useState2[0],
    setScrollTop = _useState2[1];
  var _useState3 = react.exports.useState(false),
    _useState4 = _slicedToArray(_useState3, 2),
    scrollMoving = _useState4[0],
    setScrollMoving = _useState4[1];
  var mergedClassName = classNames$1(prefixCls, className);
  var mergedData = data || EMPTY_DATA$2;
  var componentRef = react.exports.useRef();
  var fillerInnerRef = react.exports.useRef();
  var scrollBarRef = react.exports.useRef(); // Hack on scrollbar to enable flash call
  // =============================== Item Key ===============================
  var getKey = react.exports.useCallback(function (item) {
    if (typeof itemKey === 'function') {
      return itemKey(item);
    }
    return item === null || item === void 0 ? void 0 : item[itemKey];
  }, [itemKey]);
  var sharedConfig = {
    getKey: getKey
  };
  // ================================ Scroll ================================
  function syncScrollTop(newTop) {
    setScrollTop(function (origin) {
      var value;
      if (typeof newTop === 'function') {
        value = newTop(origin);
      } else {
        value = newTop;
      }
      var alignedTop = keepInRange(value);
      componentRef.current.scrollTop = alignedTop;
      return alignedTop;
    });
  }
  // ================================ Legacy ================================
  // Put ref here since the range is generate by follow
  var rangeRef = react.exports.useRef({
    start: 0,
    end: mergedData.length
  });
  var diffItemRef = react.exports.useRef();
  var _useDiffItem = useDiffItem$1(mergedData, getKey),
    _useDiffItem2 = _slicedToArray(_useDiffItem, 1),
    diffItem = _useDiffItem2[0];
  diffItemRef.current = diffItem;
  // ================================ Height ================================
  var _useHeights = useHeights$1(getKey, null, null),
    _useHeights2 = _slicedToArray(_useHeights, 4),
    setInstanceRef = _useHeights2[0],
    collectHeight = _useHeights2[1],
    heights = _useHeights2[2],
    heightUpdatedMark = _useHeights2[3];
  // ========================== Visible Calculation =========================
  var _React$useMemo = react.exports.useMemo(function () {
      if (!useVirtual) {
        return {
          scrollHeight: undefined,
          start: 0,
          end: mergedData.length - 1,
          offset: undefined
        };
      }
      // Always use virtual scroll bar in avoid shaking
      if (!inVirtual) {
        var _fillerInnerRef$curre;
        return {
          scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
          start: 0,
          end: mergedData.length - 1,
          offset: undefined
        };
      }
      var itemTop = 0;
      var startIndex;
      var startOffset;
      var endIndex;
      var dataLen = mergedData.length;
      for (var i = 0; i < dataLen; i += 1) {
        var item = mergedData[i];
        var key = getKey(item);
        var cacheHeight = heights.get(key);
        var currentItemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);
        // Check item top in the range
        if (currentItemBottom >= scrollTop && startIndex === undefined) {
          startIndex = i;
          startOffset = itemTop;
        }
        // Check item bottom in the range. We will render additional one item for motion usage
        if (currentItemBottom > scrollTop + height && endIndex === undefined) {
          endIndex = i;
        }
        itemTop = currentItemBottom;
      }
      // When scrollTop at the end but data cut to small count will reach this
      if (startIndex === undefined) {
        startIndex = 0;
        startOffset = 0;
        endIndex = Math.ceil(height / itemHeight);
      }
      if (endIndex === undefined) {
        endIndex = mergedData.length - 1;
      }
      // Give cache to improve scroll experience
      endIndex = Math.min(endIndex + 1, mergedData.length);
      return {
        scrollHeight: itemTop,
        start: startIndex,
        end: endIndex,
        offset: startOffset
      };
    }, [inVirtual, useVirtual, scrollTop, mergedData, heightUpdatedMark, height]),
    scrollHeight = _React$useMemo.scrollHeight,
    start = _React$useMemo.start,
    end = _React$useMemo.end,
    offset = _React$useMemo.offset;
  rangeRef.current.start = start;
  rangeRef.current.end = end;
  // =============================== In Range ===============================
  var maxScrollHeight = scrollHeight - height;
  var maxScrollHeightRef = react.exports.useRef(maxScrollHeight);
  maxScrollHeightRef.current = maxScrollHeight;
  function keepInRange(newScrollTop) {
    var newTop = newScrollTop;
    if (!Number.isNaN(maxScrollHeightRef.current)) {
      newTop = Math.min(newTop, maxScrollHeightRef.current);
    }
    newTop = Math.max(newTop, 0);
    return newTop;
  }
  var isScrollAtTop = scrollTop <= 0;
  var isScrollAtBottom = scrollTop >= maxScrollHeight;
  var originScroll = useOriginScroll$1(isScrollAtTop, isScrollAtBottom);
  // ================================ Scroll ================================
  function onScrollBar(newScrollTop) {
    var newTop = newScrollTop;
    syncScrollTop(newTop);
  }
  // When data size reduce. It may trigger native scroll event back to fit scroll position
  function onFallbackScroll(e) {
    var newScrollTop = e.currentTarget.scrollTop;
    if (newScrollTop !== scrollTop) {
      syncScrollTop(newScrollTop);
    }
    // Trigger origin onScroll
    onScroll === null || onScroll === void 0 ? void 0 : onScroll(e);
  }
  // Since this added in global,should use ref to keep update
  var _useFrameWheel = useFrameWheel$1(useVirtual, isScrollAtTop, isScrollAtBottom, function (offsetY) {
      syncScrollTop(function (top) {
        var newTop = top + offsetY;
        return newTop;
      });
    }),
    _useFrameWheel2 = _slicedToArray(_useFrameWheel, 2),
    onRawWheel = _useFrameWheel2[0],
    onFireFoxScroll = _useFrameWheel2[1];
  // Mobile touch move
  useMobileTouchMove$1(useVirtual, componentRef, function (deltaY, smoothOffset) {
    if (originScroll(deltaY, smoothOffset)) {
      return false;
    }
    onRawWheel({
      preventDefault: function preventDefault() {},
      deltaY: deltaY
    });
    return true;
  });
  useLayoutEffect$3(function () {
    // Firefox only
    function onMozMousePixelScroll(e) {
      if (useVirtual) {
        e.preventDefault();
      }
    }
    componentRef.current.addEventListener('wheel', onRawWheel);
    componentRef.current.addEventListener('DOMMouseScroll', onFireFoxScroll);
    componentRef.current.addEventListener('MozMousePixelScroll', onMozMousePixelScroll);
    return function () {
      if (componentRef.current) {
        componentRef.current.removeEventListener('wheel', onRawWheel);
        componentRef.current.removeEventListener('DOMMouseScroll', onFireFoxScroll);
        componentRef.current.removeEventListener('MozMousePixelScroll', onMozMousePixelScroll);
      }
    };
  }, [useVirtual]);
  // ================================= Ref ==================================
  var scrollTo = useScrollTo$1(componentRef, mergedData, heights, itemHeight, getKey, collectHeight, syncScrollTop, function () {
    var _scrollBarRef$current;
    (_scrollBarRef$current = scrollBarRef.current) === null || _scrollBarRef$current === void 0 ? void 0 : _scrollBarRef$current.delayHidden();
  });
  react.exports.useImperativeHandle(ref, function () {
    return {
      scrollTo: scrollTo
    };
  });
  // ================================ Effect ================================
  /** We need told outside that some list not rendered */
  useLayoutEffect$3(function () {
    if (onVisibleChange) {
      var renderList = mergedData.slice(start, end + 1);
      onVisibleChange(renderList, mergedData);
    }
  }, [start, end, mergedData]);
  // ================================ Render ================================
  var listChildren = useChildren$1(mergedData, start, end, setInstanceRef, children, sharedConfig);
  var componentStyle = null;
  if (height) {
    componentStyle = _objectSpread2$1(_defineProperty$1({}, fullHeight ? 'height' : 'maxHeight', height), ScrollStyle$1);
    if (useVirtual) {
      componentStyle.overflowY = 'hidden';
      if (scrollMoving) {
        componentStyle.pointerEvents = 'none';
      }
    }
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("div", {
      style: _objectSpread2$1(_objectSpread2$1({}, style), {}, {
        position: 'relative'
      }),
      className: mergedClassName,
      ...restProps,
      children: [/*#__PURE__*/jsx$1(Component, {
        className: "".concat(prefixCls, "-holder"),
        style: componentStyle,
        ref: componentRef,
        onScroll: onFallbackScroll,
        children: /*#__PURE__*/jsx$1(Filler$1, {
          prefixCls: prefixCls,
          height: scrollHeight,
          offset: offset,
          onInnerResize: collectHeight,
          ref: fillerInnerRef,
          innerProps: innerProps,
          children: listChildren
        })
      }), useVirtual &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(ScrollBar$1, {
        ref: scrollBarRef,
        prefixCls: prefixCls,
        scrollTop: scrollTop,
        height: height,
        scrollHeight: scrollHeight,
        count: mergedData.length,
        onScroll: onScrollBar,
        onStartMove: function onStartMove() {
          setScrollMoving(true);
        },
        onStopMove: function onStopMove() {
          setScrollMoving(false);
        }
      })]
    })
  );
}
var List$2 = /*#__PURE__*/react.exports.forwardRef(RawList$1);
List$2.displayName = 'List';

var SelectContext = /*#__PURE__*/react.exports.createContext(null);

/* istanbul ignore file */
function isPlatformMac() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}

var _excluded$B = ["disabled", "title", "children", "style", "className"];
function isTitleType(content) {
  return typeof content === 'string' || typeof content === 'number';
}
/**
 * Using virtual list of option display.
 * Will fallback to dom if use customize render.
 */

var OptionList = function OptionList(_, ref) {
  var _useBaseProps = useBaseProps(),
    prefixCls = _useBaseProps.prefixCls,
    id = _useBaseProps.id,
    open = _useBaseProps.open,
    multiple = _useBaseProps.multiple,
    mode = _useBaseProps.mode,
    searchValue = _useBaseProps.searchValue,
    toggleOpen = _useBaseProps.toggleOpen,
    notFoundContent = _useBaseProps.notFoundContent,
    onPopupScroll = _useBaseProps.onPopupScroll;
  var _React$useContext = react.exports.useContext(SelectContext),
    flattenOptions = _React$useContext.flattenOptions,
    onActiveValue = _React$useContext.onActiveValue,
    defaultActiveFirstOption = _React$useContext.defaultActiveFirstOption,
    onSelect = _React$useContext.onSelect,
    menuItemSelectedIcon = _React$useContext.menuItemSelectedIcon,
    rawValues = _React$useContext.rawValues,
    fieldNames = _React$useContext.fieldNames,
    virtual = _React$useContext.virtual,
    listHeight = _React$useContext.listHeight,
    listItemHeight = _React$useContext.listItemHeight;
  var itemPrefixCls = "".concat(prefixCls, "-item");
  var memoFlattenOptions = useMemo(function () {
    return flattenOptions;
  }, [open, flattenOptions], function (prev, next) {
    return next[0] && prev[1] !== next[1];
  }); // =========================== List ===========================

  var listRef = react.exports.useRef(null);
  var onListMouseDown = function onListMouseDown(event) {
    event.preventDefault();
  };
  var scrollIntoView = function scrollIntoView(args) {
    if (listRef.current) {
      listRef.current.scrollTo(typeof args === 'number' ? {
        index: args
      } : args);
    }
  }; // ========================== Active ==========================

  var getEnabledActiveIndex = function getEnabledActiveIndex(index) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var len = memoFlattenOptions.length;
    for (var i = 0; i < len; i += 1) {
      var current = (index + i * offset + len) % len;
      var _memoFlattenOptions$c = memoFlattenOptions[current],
        group = _memoFlattenOptions$c.group,
        data = _memoFlattenOptions$c.data;
      if (!group && !data.disabled) {
        return current;
      }
    }
    return -1;
  };
  var _React$useState = react.exports.useState(function () {
      return getEnabledActiveIndex(0);
    }),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    activeIndex = _React$useState2[0],
    setActiveIndex = _React$useState2[1];
  var setActive = function setActive(index) {
    var fromKeyboard = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    setActiveIndex(index);
    var info = {
      source: fromKeyboard ? 'keyboard' : 'mouse'
    }; // Trigger active event

    var flattenItem = memoFlattenOptions[index];
    if (!flattenItem) {
      onActiveValue(null, -1, info);
      return;
    }
    onActiveValue(flattenItem.value, index, info);
  }; // Auto active first item when list length or searchValue changed

  react.exports.useEffect(function () {
    setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
  }, [memoFlattenOptions.length, searchValue]); // https://github.com/ant-design/ant-design/issues/34975

  var isSelected = react.exports.useCallback(function (value) {
    return rawValues.has(value) && mode !== 'combobox';
  }, [mode, _toConsumableArray(rawValues).toString(), rawValues.size]); // Auto scroll to item position in single mode

  react.exports.useEffect(function () {
    /**
     * React will skip `onChange` when component update.
     * `setActive` function will call root accessibility state update which makes re-render.
     * So we need to delay to let Input component trigger onChange first.
     */
    var timeoutId = setTimeout(function () {
      if (!multiple && open && rawValues.size === 1) {
        var value = Array.from(rawValues)[0];
        var index = memoFlattenOptions.findIndex(function (_ref) {
          var data = _ref.data;
          return data.value === value;
        });
        if (index !== -1) {
          setActive(index);
          scrollIntoView(index);
        }
      }
    }); // Force trigger scrollbar visible when open

    if (open) {
      var _listRef$current;
      (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(undefined);
    }
    return function () {
      return clearTimeout(timeoutId);
    };
  }, [open, searchValue]); // ========================== Values ==========================

  var onSelectValue = function onSelectValue(value) {
    if (value !== undefined) {
      onSelect(value, {
        selected: !rawValues.has(value)
      });
    } // Single mode should always close by select

    if (!multiple) {
      toggleOpen(false);
    }
  }; // ========================= Keyboard =========================

  react.exports.useImperativeHandle(ref, function () {
    return {
      onKeyDown: function onKeyDown(event) {
        var which = event.which,
          ctrlKey = event.ctrlKey;
        switch (which) {
          // >>> Arrow keys & ctrl + n/p on Mac
          case KeyCode$1.N:
          case KeyCode$1.P:
          case KeyCode$1.UP:
          case KeyCode$1.DOWN:
            {
              var offset = 0;
              if (which === KeyCode$1.UP) {
                offset = -1;
              } else if (which === KeyCode$1.DOWN) {
                offset = 1;
              } else if (isPlatformMac() && ctrlKey) {
                if (which === KeyCode$1.N) {
                  offset = 1;
                } else if (which === KeyCode$1.P) {
                  offset = -1;
                }
              }
              if (offset !== 0) {
                var nextActiveIndex = getEnabledActiveIndex(activeIndex + offset, offset);
                scrollIntoView(nextActiveIndex);
                setActive(nextActiveIndex, true);
              }
              break;
            }
          // >>> Select

          case KeyCode$1.ENTER:
            {
              // value
              var item = memoFlattenOptions[activeIndex];
              if (item && !item.data.disabled) {
                onSelectValue(item.value);
              } else {
                onSelectValue(undefined);
              }
              if (open) {
                event.preventDefault();
              }
              break;
            }
          // >>> Close

          case KeyCode$1.ESC:
            {
              toggleOpen(false);
              if (open) {
                event.stopPropagation();
              }
            }
        }
      },
      onKeyUp: function onKeyUp() {},
      scrollTo: function scrollTo(index) {
        scrollIntoView(index);
      }
    };
  }); // ========================== Render ==========================

  if (memoFlattenOptions.length === 0) {
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("div", {
        role: "listbox",
        id: "".concat(id, "_list"),
        className: "".concat(itemPrefixCls, "-empty"),
        onMouseDown: onListMouseDown,
        children: notFoundContent
      })
    );
  }
  var omitFieldNameList = Object.keys(fieldNames).map(function (key) {
    return fieldNames[key];
  });
  var getLabel = function getLabel(item) {
    return item.label;
  };
  function getItemAriaProps(item, index) {
    var group = item.group;
    return {
      role: group ? 'presentation' : 'option',
      id: "".concat(id, "_list_").concat(index)
    };
  }
  var renderItem = function renderItem(index) {
    var item = memoFlattenOptions[index];
    if (!item) return null;
    var itemData = item.data || {};
    var value = itemData.value;
    var group = item.group;
    var attrs = pickAttrs(itemData, true);
    var mergedLabel = getLabel(item);
    return item ?
    /*#__PURE__*/
    /*#__PURE__*/
    react.exports.createElement("div", {
      "aria-label": typeof mergedLabel === 'string' && !group ? mergedLabel : null,
      ...attrs,
      key: index,
      ...getItemAriaProps(item, index),
      "aria-selected": isSelected(value)
    }, value) : null;
  };
  var a11yProps = {
    role: 'listbox',
    id: "".concat(id, "_list")
  };
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs(Fragment, {
      children: [virtual &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsxs("div", {
        ...a11yProps,
        style: {
          height: 0,
          width: 0,
          overflow: 'hidden'
        },
        children: [renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)]
      }), /*#__PURE__*/jsx$1(List$2, {
        itemKey: "key",
        ref: listRef,
        data: memoFlattenOptions,
        height: listHeight,
        itemHeight: listItemHeight,
        fullHeight: false,
        onMouseDown: onListMouseDown,
        onScroll: onPopupScroll,
        virtual: virtual,
        innerProps: virtual ? null : a11yProps,
        children: function (item, itemIndex) {
          var _classNames;
          var group = item.group,
            groupOption = item.groupOption,
            data = item.data,
            label = item.label,
            value = item.value;
          var key = data.key; // Group

          if (group) {
            var _data$title;
            var groupTitle = (_data$title = data.title) !== null && _data$title !== void 0 ? _data$title : isTitleType(label) ? label.toString() : undefined;
            return (
              /*#__PURE__*/
              /*#__PURE__*/
              jsx$1("div", {
                className: classNames$1(itemPrefixCls, "".concat(itemPrefixCls, "-group")),
                title: groupTitle,
                children: label !== undefined ? label : key
              })
            );
          }
          var disabled = data.disabled,
            title = data.title;
            data.children;
            var style = data.style,
            className = data.className,
            otherProps = _objectWithoutProperties(data, _excluded$B);
          var passedProps = omit(otherProps, omitFieldNameList); // Option

          var selected = isSelected(value);
          var optionPrefixCls = "".concat(itemPrefixCls, "-option");
          var optionClassName = classNames$1(itemPrefixCls, optionPrefixCls, className, (_classNames = {}, _defineProperty$1(_classNames, "".concat(optionPrefixCls, "-grouped"), groupOption), _defineProperty$1(_classNames, "".concat(optionPrefixCls, "-active"), activeIndex === itemIndex && !disabled), _defineProperty$1(_classNames, "".concat(optionPrefixCls, "-disabled"), disabled), _defineProperty$1(_classNames, "".concat(optionPrefixCls, "-selected"), selected), _classNames));
          var mergedLabel = getLabel(item);
          var iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === 'function' || selected; // https://github.com/ant-design/ant-design/issues/34145

          var content = typeof mergedLabel === 'number' ? mergedLabel : mergedLabel || value; // https://github.com/ant-design/ant-design/issues/26717

          var optionTitle = isTitleType(content) ? content.toString() : undefined;
          if (title !== undefined) {
            optionTitle = title;
          }
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            jsxs("div", {
              ...pickAttrs(passedProps),
              ...(!virtual ? getItemAriaProps(item, itemIndex) : {}),
              "aria-selected": selected,
              className: optionClassName,
              title: optionTitle,
              onMouseMove: function onMouseMove() {
                if (activeIndex === itemIndex || disabled) {
                  return;
                }
                setActive(itemIndex);
              },
              onClick: function onClick() {
                if (!disabled) {
                  onSelectValue(value);
                }
              },
              style: style,
              children: [/*#__PURE__*/jsx$1("div", {
                className: "".concat(optionPrefixCls, "-content"),
                children: content
              }), /*#__PURE__*/react.exports.isValidElement(menuItemSelectedIcon) || selected, iconVisible &&
              /*#__PURE__*/
              /*#__PURE__*/
              jsx$1(TransBtn, {
                className: "".concat(itemPrefixCls, "-option-state"),
                customizeIcon: menuItemSelectedIcon,
                customizeIconProps: {
                  isSelected: selected
                },
                children: selected ? '' : null
              })]
            })
          );
        }
      })]
    })
  );
};
var RefOptionList = /*#__PURE__*/react.exports.forwardRef(OptionList);
RefOptionList.displayName = 'OptionList';

var _excluded$A = ["id", "mode", "prefixCls", "backfill", "fieldNames", "inputValue", "searchValue", "onSearch", "autoClearSearchValue", "onSelect", "onDeselect", "dropdownMatchSelectWidth", "filterOption", "filterSort", "optionFilterProp", "optionLabelProp", "options", "children", "defaultActiveFirstOption", "menuItemSelectedIcon", "virtual", "listHeight", "listItemHeight", "value", "defaultValue", "labelInValue", "onChange"];
var OMIT_DOM_PROPS = ['inputValue'];
function isRawValue(value) {
  return !value || _typeof$1(value) !== 'object';
}
var Select$4 = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var id = props.id,
    mode = props.mode,
    _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-select' : _props$prefixCls,
    backfill = props.backfill,
    fieldNames = props.fieldNames,
    inputValue = props.inputValue,
    searchValue = props.searchValue,
    onSearch = props.onSearch,
    _props$autoClearSearc = props.autoClearSearchValue,
    autoClearSearchValue = _props$autoClearSearc === void 0 ? true : _props$autoClearSearc,
    onSelect = props.onSelect,
    onDeselect = props.onDeselect,
    _props$dropdownMatchS = props.dropdownMatchSelectWidth,
    dropdownMatchSelectWidth = _props$dropdownMatchS === void 0 ? true : _props$dropdownMatchS,
    filterOption = props.filterOption,
    filterSort = props.filterSort,
    optionFilterProp = props.optionFilterProp,
    optionLabelProp = props.optionLabelProp,
    options = props.options,
    children = props.children,
    defaultActiveFirstOption = props.defaultActiveFirstOption,
    menuItemSelectedIcon = props.menuItemSelectedIcon,
    virtual = props.virtual,
    _props$listHeight = props.listHeight,
    listHeight = _props$listHeight === void 0 ? 200 : _props$listHeight,
    _props$listItemHeight = props.listItemHeight,
    listItemHeight = _props$listItemHeight === void 0 ? 20 : _props$listItemHeight,
    value = props.value,
    defaultValue = props.defaultValue,
    labelInValue = props.labelInValue,
    onChange = props.onChange,
    restProps = _objectWithoutProperties(props, _excluded$A);
  var mergedId = useId$2(id);
  var multiple = isMultiple(mode);
  var childrenAsData = !!(!options && children);
  var mergedFilterOption = react.exports.useMemo(function () {
    if (filterOption === undefined && mode === 'combobox') {
      return false;
    }
    return filterOption;
  }, [filterOption, mode]); // ========================= FieldNames =========================

  var mergedFieldNames = react.exports.useMemo(function () {
    return fillFieldNames$1(fieldNames, childrenAsData);
  }, /* eslint-disable react-hooks/exhaustive-deps */
  [
  // We stringify fieldNames to avoid unnecessary re-renders.
  JSON.stringify(fieldNames), childrenAsData]
  /* eslint-enable react-hooks/exhaustive-deps */); // =========================== Search ===========================

  var _useMergedState = useMergedState$1('', {
      value: searchValue !== undefined ? searchValue : inputValue,
      postState: function postState(search) {
        return search || '';
      }
    }),
    _useMergedState2 = _slicedToArray(_useMergedState, 2),
    mergedSearchValue = _useMergedState2[0],
    setSearchValue = _useMergedState2[1]; // =========================== Option ===========================

  var parsedOptions = useOptions(options, children, mergedFieldNames, optionFilterProp, optionLabelProp);
  var valueOptions = parsedOptions.valueOptions,
    labelOptions = parsedOptions.labelOptions,
    mergedOptions = parsedOptions.options; // ========================= Wrap Value =========================

  var convert2LabelValues = react.exports.useCallback(function (draftValues) {
    // Convert to array
    var valueList = toArray$4(draftValues); // Convert to labelInValue type

    return valueList.map(function (val) {
      var rawValue;
      var rawLabel;
      var rawKey;
      var rawDisabled;
      var rawTitle; // Fill label & value

      if (isRawValue(val)) {
        rawValue = val;
      } else {
        var _val$value;
        rawKey = val.key;
        rawLabel = val.label;
        rawValue = (_val$value = val.value) !== null && _val$value !== void 0 ? _val$value : rawKey;
      }
      var option = valueOptions.get(rawValue);
      if (option) {
        var _option$key;

        // Fill missing props
        if (rawLabel === undefined) rawLabel = option === null || option === void 0 ? void 0 : option[optionLabelProp || mergedFieldNames.label];
        if (rawKey === undefined) rawKey = (_option$key = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key !== void 0 ? _option$key : rawValue;
        rawDisabled = option === null || option === void 0 ? void 0 : option.disabled;
        rawTitle = option === null || option === void 0 ? void 0 : option.title; // Warning if label not same as provided
      }
      return {
        label: rawLabel,
        value: rawValue,
        key: rawKey,
        disabled: rawDisabled,
        title: rawTitle
      };
    });
  }, [mergedFieldNames, optionLabelProp, valueOptions]); // =========================== Values ===========================

  var _useMergedState3 = useMergedState$1(defaultValue, {
      value: value
    }),
    _useMergedState4 = _slicedToArray(_useMergedState3, 2),
    internalValue = _useMergedState4[0],
    setInternalValue = _useMergedState4[1]; // Merged value with LabelValueType

  var rawLabeledValues = react.exports.useMemo(function () {
    var _values$;
    var values = convert2LabelValues(internalValue); // combobox no need save value when it's no value

    if (mode === 'combobox' && !((_values$ = values[0]) !== null && _values$ !== void 0 && _values$.value)) {
      return [];
    }
    return values;
  }, [internalValue, convert2LabelValues, mode]); // Fill label with cache to avoid option remove

  var _useCache = useCache(rawLabeledValues, valueOptions),
    _useCache2 = _slicedToArray(_useCache, 2),
    mergedValues = _useCache2[0],
    getMixedOption = _useCache2[1];
  var displayValues = react.exports.useMemo(function () {
    // `null` need show as placeholder instead
    // https://github.com/ant-design/ant-design/issues/25057
    if (!mode && mergedValues.length === 1) {
      var firstValue = mergedValues[0];
      if (firstValue.value === null && (firstValue.label === null || firstValue.label === undefined)) {
        return [];
      }
    }
    return mergedValues.map(function (item) {
      var _item$label;
      return _objectSpread2$1(_objectSpread2$1({}, item), {}, {
        label: (_item$label = item.label) !== null && _item$label !== void 0 ? _item$label : item.value
      });
    });
  }, [mode, mergedValues]);
  /** Convert `displayValues` to raw value type set */

  var rawValues = react.exports.useMemo(function () {
    return new Set(mergedValues.map(function (val) {
      return val.value;
    }));
  }, [mergedValues]);
  react.exports.useEffect(function () {
    if (mode === 'combobox') {
      var _mergedValues$;
      var strValue = (_mergedValues$ = mergedValues[0]) === null || _mergedValues$ === void 0 ? void 0 : _mergedValues$.value;
      setSearchValue(hasValue$1(strValue) ? String(strValue) : '');
    }
  }, [mergedValues]); // ======================= Display Option =======================
  // Create a placeholder item if not exist in `options`

  var createTagOption = useRefFunc(function (val, label) {
    var _ref;
    var mergedLabel = label !== null && label !== void 0 ? label : val;
    return _ref = {}, _defineProperty$1(_ref, mergedFieldNames.value, val), _defineProperty$1(_ref, mergedFieldNames.label, mergedLabel), _ref;
  }); // Fill tag as option if mode is `tags`

  var filledTagOptions = react.exports.useMemo(function () {
    if (mode !== 'tags') {
      return mergedOptions;
    } // >>> Tag mode

    var cloneOptions = _toConsumableArray(mergedOptions); // Check if value exist in options (include new patch item)

    var existOptions = function existOptions(val) {
      return valueOptions.has(val);
    }; // Fill current value as option

    _toConsumableArray(mergedValues).sort(function (a, b) {
      return a.value < b.value ? -1 : 1;
    }).forEach(function (item) {
      var val = item.value;
      if (!existOptions(val)) {
        cloneOptions.push(createTagOption(val, item.label));
      }
    });
    return cloneOptions;
  }, [createTagOption, mergedOptions, valueOptions, mergedValues, mode]);
  var filteredOptions = useFilterOptions(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, optionFilterProp); // Fill options with search value if needed

  var filledSearchOptions = react.exports.useMemo(function () {
    if (mode !== 'tags' || !mergedSearchValue || filteredOptions.some(function (item) {
      return item[optionFilterProp || 'value'] === mergedSearchValue;
    })) {
      return filteredOptions;
    } // Fill search value as option

    return [createTagOption(mergedSearchValue)].concat(_toConsumableArray(filteredOptions));
  }, [createTagOption, optionFilterProp, mode, filteredOptions, mergedSearchValue]);
  var orderedFilteredOptions = react.exports.useMemo(function () {
    if (!filterSort) {
      return filledSearchOptions;
    }
    return _toConsumableArray(filledSearchOptions).sort(function (a, b) {
      return filterSort(a, b);
    });
  }, [filledSearchOptions, filterSort]);
  var displayOptions = react.exports.useMemo(function () {
    return flattenOptions(orderedFilteredOptions, {
      fieldNames: mergedFieldNames,
      childrenAsData: childrenAsData
    });
  }, [orderedFilteredOptions, mergedFieldNames, childrenAsData]); // =========================== Change ===========================

  var triggerChange = function triggerChange(values) {
    var labeledValues = convert2LabelValues(values);
    setInternalValue(labeledValues);
    if (onChange && (
    // Trigger event only when value changed
    labeledValues.length !== mergedValues.length || labeledValues.some(function (newVal, index) {
      var _mergedValues$index;
      return ((_mergedValues$index = mergedValues[index]) === null || _mergedValues$index === void 0 ? void 0 : _mergedValues$index.value) !== (newVal === null || newVal === void 0 ? void 0 : newVal.value);
    }))) {
      var returnValues = labelInValue ? labeledValues : labeledValues.map(function (v) {
        return v.value;
      });
      var returnOptions = labeledValues.map(function (v) {
        return injectPropsWithOption(getMixedOption(v.value));
      });
      onChange(
      // Value
      multiple ? returnValues : returnValues[0],
      // Option
      multiple ? returnOptions : returnOptions[0]);
    }
  }; // ======================= Accessibility ========================

  var _React$useState = react.exports.useState(null),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    activeValue = _React$useState2[0],
    setActiveValue = _React$useState2[1];
  var _React$useState3 = react.exports.useState(0),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    accessibilityIndex = _React$useState4[0],
    setAccessibilityIndex = _React$useState4[1];
  var mergedDefaultActiveFirstOption = defaultActiveFirstOption !== undefined ? defaultActiveFirstOption : mode !== 'combobox';
  var onActiveValue = react.exports.useCallback(function (active, index) {
    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$source = _ref2.source,
      source = _ref2$source === void 0 ? 'keyboard' : _ref2$source;
    setAccessibilityIndex(index);
    if (backfill && mode === 'combobox' && active !== null && source === 'keyboard') {
      setActiveValue(String(active));
    }
  }, [backfill, mode]); // ========================= OptionList =========================

  var triggerSelect = function triggerSelect(val, selected, type) {
    var getSelectEnt = function getSelectEnt() {
      var _option$key2;
      var option = getMixedOption(val);
      return [labelInValue ? {
        label: option === null || option === void 0 ? void 0 : option[mergedFieldNames.label],
        value: val,
        key: (_option$key2 = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key2 !== void 0 ? _option$key2 : val
      } : val, injectPropsWithOption(option)];
    };
    if (selected && onSelect) {
      var _getSelectEnt = getSelectEnt(),
        _getSelectEnt2 = _slicedToArray(_getSelectEnt, 2),
        wrappedValue = _getSelectEnt2[0],
        _option = _getSelectEnt2[1];
      onSelect(wrappedValue, _option);
    } else if (!selected && onDeselect && type !== 'clear') {
      var _getSelectEnt3 = getSelectEnt(),
        _getSelectEnt4 = _slicedToArray(_getSelectEnt3, 2),
        _wrappedValue = _getSelectEnt4[0],
        _option2 = _getSelectEnt4[1];
      onDeselect(_wrappedValue, _option2);
    }
  }; // Used for OptionList selection

  var onInternalSelect = useRefFunc(function (val, info) {
    var cloneValues; // Single mode always trigger select only with option list

    var mergedSelect = multiple ? info.selected : true;
    if (mergedSelect) {
      cloneValues = multiple ? [].concat(_toConsumableArray(mergedValues), [val]) : [val];
    } else {
      cloneValues = mergedValues.filter(function (v) {
        return v.value !== val;
      });
    }
    triggerChange(cloneValues);
    triggerSelect(val, mergedSelect); // Clean search value if single or configured

    if (mode === 'combobox') {
      // setSearchValue(String(val));
      setActiveValue('');
    } else if (!isMultiple || autoClearSearchValue) {
      setSearchValue('');
      setActiveValue('');
    }
  }); // ======================= Display Change =======================
  // BaseSelect display values change

  var onDisplayValuesChange = function onDisplayValuesChange(nextValues, info) {
    triggerChange(nextValues);
    var type = info.type,
      values = info.values;
    if (type === 'remove' || type === 'clear') {
      values.forEach(function (item) {
        triggerSelect(item.value, false, type);
      });
    }
  }; // =========================== Search ===========================

  var onInternalSearch = function onInternalSearch(searchText, info) {
    setSearchValue(searchText);
    setActiveValue(null); // [Submit] Tag mode should flush input

    if (info.source === 'submit') {
      var formatted = (searchText || '').trim(); // prevent empty tags from appearing when you click the Enter button

      if (formatted) {
        var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), [formatted])));
        triggerChange(newRawValues);
        triggerSelect(formatted, true);
        setSearchValue('');
      }
      return;
    }
    if (info.source !== 'blur') {
      if (mode === 'combobox') {
        triggerChange(searchText);
      }
      onSearch === null || onSearch === void 0 ? void 0 : onSearch(searchText);
    }
  };
  var onInternalSearchSplit = function onInternalSearchSplit(words) {
    var patchValues = words;
    if (mode !== 'tags') {
      patchValues = words.map(function (word) {
        var opt = labelOptions.get(word);
        return opt === null || opt === void 0 ? void 0 : opt.value;
      }).filter(function (val) {
        return val !== undefined;
      });
    }
    var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), _toConsumableArray(patchValues))));
    triggerChange(newRawValues);
    newRawValues.forEach(function (newRawValue) {
      triggerSelect(newRawValue, true);
    });
  }; // ========================== Context ===========================

  var selectContext = react.exports.useMemo(function () {
    var realVirtual = virtual !== false && dropdownMatchSelectWidth !== false;
    return _objectSpread2$1(_objectSpread2$1({}, parsedOptions), {}, {
      flattenOptions: displayOptions,
      onActiveValue: onActiveValue,
      defaultActiveFirstOption: mergedDefaultActiveFirstOption,
      onSelect: onInternalSelect,
      menuItemSelectedIcon: menuItemSelectedIcon,
      rawValues: rawValues,
      fieldNames: mergedFieldNames,
      virtual: realVirtual,
      listHeight: listHeight,
      listItemHeight: listItemHeight,
      childrenAsData: childrenAsData
    });
  }, [parsedOptions, displayOptions, onActiveValue, mergedDefaultActiveFirstOption, onInternalSelect, menuItemSelectedIcon, rawValues, mergedFieldNames, virtual, dropdownMatchSelectWidth, listHeight, listItemHeight, childrenAsData]); // ========================== Warning ===========================
  // ==                          Render                          ==
  // ==============================================================

  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(SelectContext.Provider, {
      value: selectContext,
      children: /*#__PURE__*/jsx$1(BaseSelect, {
        ...restProps,
        id: mergedId,
        prefixCls: prefixCls,
        ref: ref,
        omitDomProps: OMIT_DOM_PROPS,
        mode: mode,
        displayValues: displayValues,
        onDisplayValuesChange: onDisplayValuesChange,
        searchValue: mergedSearchValue,
        onSearch: onInternalSearch,
        autoClearSearchValue: autoClearSearchValue,
        onSearchSplit: onInternalSearchSplit,
        dropdownMatchSelectWidth: dropdownMatchSelectWidth,
        OptionList: RefOptionList,
        emptyOptions: !displayOptions.length,
        activeValue: activeValue,
        activeDescendantId: "".concat(mergedId, "_list_").concat(accessibilityIndex)
      })
    })
  );
});
var TypedSelect = Select$4;
TypedSelect.Option = Option$1;
TypedSelect.OptGroup = OptGroup;

var Empty$2 = function Empty() {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("svg", {
      width: "184",
      height: "152",
      viewBox: "0 0 184 152",
      xmlns: "http://www.w3.org/2000/svg",
      children: /*#__PURE__*/jsxs("g", {
        fill: "none",
        fillRule: "evenodd",
        children: [/*#__PURE__*/jsxs("g", {
          transform: "translate(24 31.67)",
          children: [/*#__PURE__*/jsx$1("ellipse", {
            fillOpacity: ".8",
            fill: "#F5F5F7",
            cx: "67.797",
            cy: "106.89",
            rx: "67.797",
            ry: "12.668"
          }), /*#__PURE__*/jsx$1("path", {
            d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
            fill: "#AEB8C2"
          }), /*#__PURE__*/jsx$1("path", {
            d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
            fill: "url(#linearGradient-1)",
            transform: "translate(13.56)"
          }), /*#__PURE__*/jsx$1("path", {
            d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
            fill: "#F5F5F7"
          }), /*#__PURE__*/jsx$1("path", {
            d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
            fill: "#DCE0E6"
          })]
        }), /*#__PURE__*/jsx$1("path", {
          d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
          fill: "#DCE0E6"
        }), /*#__PURE__*/jsxs("g", {
          transform: "translate(149.65 15.383)",
          fill: "#FFF",
          children: [/*#__PURE__*/jsx$1("ellipse", {
            cx: "20.654",
            cy: "3.167",
            rx: "2.849",
            ry: "2.815"
          }), /*#__PURE__*/jsx$1("path", {
            d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
          })]
        })]
      })
    })
  );
};
const DefaultEmptyImg = Empty$2;

var Simple = function Simple() {
  var _useToken = useToken(),
    _useToken2 = _slicedToArray(_useToken, 2),
    token = _useToken2[1];
  var colorFill = token.colorFill,
    colorFillTertiary = token.colorFillTertiary,
    colorFillQuaternary = token.colorFillQuaternary,
    colorBgContainer = token.colorBgContainer;
  var _useMemo = react.exports.useMemo(function () {
      return {
        borderColor: new TinyColor(colorFill).onBackground(colorBgContainer).toHexString(),
        shadowColor: new TinyColor(colorFillTertiary).onBackground(colorBgContainer).toHexString(),
        contentColor: new TinyColor(colorFillQuaternary).onBackground(colorBgContainer).toHexString()
      };
    }, [colorFill, colorFillTertiary, colorFillQuaternary, colorBgContainer]),
    borderColor = _useMemo.borderColor,
    shadowColor = _useMemo.shadowColor,
    contentColor = _useMemo.contentColor;
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("svg", {
      width: "64",
      height: "41",
      viewBox: "0 0 64 41",
      xmlns: "http://www.w3.org/2000/svg",
      children: /*#__PURE__*/jsxs("g", {
        transform: "translate(0 1)",
        fill: "none",
        fillRule: "evenodd",
        children: [/*#__PURE__*/jsx$1("ellipse", {
          fill: shadowColor,
          cx: "32",
          cy: "33",
          rx: "32",
          ry: "7"
        }), /*#__PURE__*/jsxs("g", {
          fillRule: "nonzero",
          stroke: borderColor,
          children: [/*#__PURE__*/jsx$1("path", {
            d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
          }), /*#__PURE__*/jsx$1("path", {
            d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
            fill: contentColor
          })]
        })]
      })
    })
  );
};
const SimpleEmptyImg = Simple;

// ============================== Shared ==============================
var genSharedEmptyStyle = function genSharedEmptyStyle(token) {
  var _componentCls;
  var componentCls = token.componentCls,
    margin = token.margin,
    marginXS = token.marginXS,
    marginXL = token.marginXL,
    fontSize = token.fontSize,
    lineHeight = token.lineHeight;
  return _defineProperty$1({}, componentCls, (_componentCls = {
    marginInline: marginXS,
    fontSize: fontSize,
    lineHeight: lineHeight,
    textAlign: 'center'
  }, _defineProperty$1(_componentCls, componentCls + "-image", {
    height: token.emptyImgHeight,
    marginBottom: marginXS,
    opacity: token.opacityImage,
    img: {
      height: '100%'
    },
    svg: {
      height: '100%',
      margin: 'auto'
    }
  }), _defineProperty$1(_componentCls, componentCls + "-footer", {
    marginTop: margin
  }), _defineProperty$1(_componentCls, '&-normal', _defineProperty$1({
    marginBlock: marginXL,
    color: token.colorTextDisabled
  }, componentCls + "-image", {
    height: token.emptyImgHeightMD
  })), _defineProperty$1(_componentCls, '&-small', _defineProperty$1({
    marginBlock: marginXS,
    color: token.colorTextDisabled
  }, componentCls + "-image", {
    height: token.emptyImgHeightSM
  })), _componentCls));
};
// ============================== Export ==============================
const useStyle$n = genComponentStyleHook('Empty', function (token) {
  var componentCls = token.componentCls,
    controlHeightLG = token.controlHeightLG;
  var emptyToken = merge$2(token, {
    emptyImgCls: componentCls + "-img",
    emptyImgHeight: controlHeightLG * 2.5,
    emptyImgHeightMD: controlHeightLG,
    emptyImgHeightSM: controlHeightLG * 0.875
  });
  return [genSharedEmptyStyle(emptyToken)];
});

var __rest$O = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var defaultEmptyImg =
/*#__PURE__*/
/*#__PURE__*/
jsx$1(DefaultEmptyImg, {});
var simpleEmptyImg =
/*#__PURE__*/
/*#__PURE__*/
jsx$1(SimpleEmptyImg, {});
var Empty = function Empty(_a) {
  var className = _a.className,
    customizePrefixCls = _a.prefixCls,
    _a$image = _a.image,
    image = _a$image === void 0 ? defaultEmptyImg : _a$image,
    description = _a.description,
    children = _a.children,
    imageStyle = _a.imageStyle,
    restProps = __rest$O(_a, ["className", "prefixCls", "image", "description", "children", "imageStyle"]);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var prefixCls = getPrefixCls('empty', customizePrefixCls);
  var _useStyle = useStyle$n(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(LocaleReceiver, {
    componentName: "Empty",
    children: function (locale) {
      var _classNames;
      var des = typeof description !== 'undefined' ? description : locale.description;
      var alt = typeof des === 'string' ? des : 'empty';
      var imageNode = null;
      if (typeof image === 'string') {
        imageNode =
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("img", {
          alt: alt,
          src: image
        });
      } else {
        imageNode = image;
      }
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsxs("div", {
          className: classNames$1(hashId, prefixCls, (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-normal", image === simpleEmptyImg), _defineProperty$1(_classNames, prefixCls + "-rtl", direction === 'rtl'), _classNames), className),
          ...restProps,
          children: [/*#__PURE__*/jsx$1("div", {
            className: prefixCls + "-image",
            style: imageStyle,
            children: imageNode
          }), des &&
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("div", {
            className: prefixCls + "-description",
            children: des
          }), children &&
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("div", {
            className: prefixCls + "-footer",
            children: children
          })]
        })
      );
    }
  }));
};
Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
const Empty$1 = Empty;

var defaultRenderEmpty = function defaultRenderEmpty(componentName) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(ConfigConsumer, {
      children: function (_ref) {
        var getPrefixCls = _ref.getPrefixCls;
        var prefix = getPrefixCls('empty');
        switch (componentName) {
          case 'Table':
          case 'List':
            return (
              /*#__PURE__*/
              /*#__PURE__*/
              jsx$1(Empty$1, {
                image: Empty$1.PRESENTED_IMAGE_SIMPLE
              })
            );
          case 'Select':
          case 'TreeSelect':
          case 'Cascader':
          case 'Transfer':
          case 'Mentions':
            return (
              /*#__PURE__*/
              /*#__PURE__*/
              jsx$1(Empty$1, {
                image: Empty$1.PRESENTED_IMAGE_SIMPLE,
                className: prefix + "-small"
              })
            );
          /* istanbul ignore next */
          default:
            // Should never hit if we take all the component into consider.
            return (
              /*#__PURE__*/
              /*#__PURE__*/
              jsx$1(Empty$1, {})
            );
        }
      }
    })
  );
};
const defaultRenderEmpty$1 = defaultRenderEmpty;

var FormContext = /*#__PURE__*/react.exports.createContext({
  labelAlign: 'right',
  vertical: false,
  itemRef: function itemRef() {}
});
var NoStyleItemContext = /*#__PURE__*/react.exports.createContext(null);
var FormProvider = function FormProvider(props) {
  var providerProps = omit$1(props, ['prefixCls']);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(FormProvider$1, {
      ...providerProps
    })
  );
};
var FormItemPrefixContext = /*#__PURE__*/react.exports.createContext({
  prefixCls: ''
});
var FormItemInputContext = /*#__PURE__*/react.exports.createContext({});
var NoFormStyle = function NoFormStyle(_ref) {
  var children = _ref.children,
    status = _ref.status,
    override = _ref.override;
  var formItemInputContext = react.exports.useContext(FormItemInputContext);
  var newFormItemInputContext = react.exports.useMemo(function () {
    var newContext = _extends$2({}, formItemInputContext);
    if (override) {
      delete newContext.isFormItemInput;
    }
    if (status) {
      delete newContext.status;
      delete newContext.hasFeedback;
      delete newContext.feedbackIcon;
    }
    return newContext;
  }, [status, override, formItemInputContext]);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(FormItemInputContext.Provider, {
      value: newFormItemInputContext,
      children: children
    })
  );
};

// ================== Collapse Motion ==================
var getCollapsedHeight = function getCollapsedHeight() {
  return {
    height: 0,
    opacity: 0
  };
};
var getRealHeight = function getRealHeight(node) {
  var scrollHeight = node.scrollHeight;
  return {
    height: scrollHeight,
    opacity: 1
  };
};
var getCurrentHeight = function getCurrentHeight(node) {
  return {
    height: node ? node.offsetHeight : 0
  };
};
var skipOpacityTransition = function skipOpacityTransition(_, event) {
  return (event === null || event === void 0 ? void 0 : event.deadline) === true || event.propertyName === 'height';
};
var initCollapseMotion = function initCollapseMotion() {
  var rootCls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'ant';
  return {
    motionName: rootCls + "-motion-collapse",
    onAppearStart: getCollapsedHeight,
    onEnterStart: getCollapsedHeight,
    onAppearActive: getRealHeight,
    onEnterActive: getRealHeight,
    onLeaveStart: getCurrentHeight,
    onLeaveActive: getCollapsedHeight,
    onAppearEnd: skipOpacityTransition,
    onEnterEnd: skipOpacityTransition,
    onLeaveEnd: skipOpacityTransition,
    motionDeadline: 500
  };
};
var getTransitionDirection = function getTransitionDirection(placement) {
  if (placement !== undefined && (placement === 'topLeft' || placement === 'topRight')) {
    return "slide-down";
  }
  return "slide-up";
};
var getTransitionName = function getTransitionName(rootPrefixCls, motion, transitionName) {
  if (transitionName !== undefined) {
    return transitionName;
  }
  return rootPrefixCls + "-" + motion;
};
const initCollapseMotion$1 = initCollapseMotion;

function getStatusClassNames(prefixCls, status, hasFeedback) {
  var _classNames;
  return classNames$1((_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-status-success", status === 'success'), _defineProperty$1(_classNames, prefixCls + "-status-warning", status === 'warning'), _defineProperty$1(_classNames, prefixCls + "-status-error", status === 'error'), _defineProperty$1(_classNames, prefixCls + "-status-validating", status === 'validating'), _defineProperty$1(_classNames, prefixCls + "-has-feedback", hasFeedback), _classNames));
}
var getMergedStatus = function getMergedStatus(contextStatus, customStatus) {
  return customStatus || contextStatus;
};

// This icon file is generated automatically.
var CheckOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
const CheckOutlinedSvg = CheckOutlined$2;

var CheckOutlined = function CheckOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: CheckOutlinedSvg
      })
    })
  );
};
CheckOutlined.displayName = 'CheckOutlined';
const CheckOutlined$1 = /*#__PURE__*/react.exports.forwardRef(CheckOutlined);

// This icon file is generated automatically.
var DownOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, "name": "down", "theme": "outlined" };
const DownOutlinedSvg = DownOutlined$2;

var DownOutlined = function DownOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: DownOutlinedSvg
      })
    })
  );
};
DownOutlined.displayName = 'DownOutlined';
const DownOutlined$1 = /*#__PURE__*/react.exports.forwardRef(DownOutlined);

// This icon file is generated automatically.
var LoadingOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
const LoadingOutlinedSvg = LoadingOutlined$2;

var LoadingOutlined = function LoadingOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: LoadingOutlinedSvg
      })
    })
  );
};
LoadingOutlined.displayName = 'LoadingOutlined';
const LoadingOutlined$1 = /*#__PURE__*/react.exports.forwardRef(LoadingOutlined);

// This icon file is generated automatically.
var SearchOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
const SearchOutlinedSvg = SearchOutlined$2;

var SearchOutlined = function SearchOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: SearchOutlinedSvg
      })
    })
  );
};
SearchOutlined.displayName = 'SearchOutlined';
const SearchOutlined$1 = /*#__PURE__*/react.exports.forwardRef(SearchOutlined);

function getIcons(_ref) {
  var suffixIcon = _ref.suffixIcon,
    clearIcon = _ref.clearIcon,
    menuItemSelectedIcon = _ref.menuItemSelectedIcon,
    removeIcon = _ref.removeIcon,
    loading = _ref.loading,
    multiple = _ref.multiple,
    hasFeedback = _ref.hasFeedback,
    prefixCls = _ref.prefixCls,
    showArrow = _ref.showArrow,
    feedbackIcon = _ref.feedbackIcon;
  // Clear Icon
  var mergedClearIcon = clearIcon !== null && clearIcon !== void 0 ? clearIcon :
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(CloseCircleFilled$1, {});
  // Validation Feedback Icon
  var getSuffixIconNode = function getSuffixIconNode(arrowIcon) {
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsxs(Fragment, {
        children: [showArrow !== false && arrowIcon, hasFeedback && feedbackIcon]
      })
    );
  };
  // Arrow item icon
  var mergedSuffixIcon = null;
  if (suffixIcon !== undefined) {
    mergedSuffixIcon = getSuffixIconNode(suffixIcon);
  } else if (loading) {
    mergedSuffixIcon = getSuffixIconNode(
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(LoadingOutlined$1, {
      spin: true
    }));
  } else {
    var iconCls = prefixCls + "-suffix";
    mergedSuffixIcon = function mergedSuffixIcon(_ref2) {
      var open = _ref2.open,
        showSearch = _ref2.showSearch;
      if (open && showSearch) {
        return getSuffixIconNode(
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(SearchOutlined$1, {
          className: iconCls
        }));
      }
      return getSuffixIconNode(
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(DownOutlined$1, {
        className: iconCls
      }));
    };
  }
  // Checked item icon
  var mergedItemIcon = null;
  if (menuItemSelectedIcon !== undefined) {
    mergedItemIcon = menuItemSelectedIcon;
  } else if (multiple) {
    mergedItemIcon =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(CheckOutlined$1, {});
  } else {
    mergedItemIcon = null;
  }
  var mergedRemoveIcon = null;
  if (removeIcon !== undefined) {
    mergedRemoveIcon = removeIcon;
  } else {
    mergedRemoveIcon =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(CloseOutlined$1, {});
  }
  return {
    clearIcon: mergedClearIcon,
    suffixIcon: mergedSuffixIcon,
    itemIcon: mergedItemIcon,
    removeIcon: mergedRemoveIcon
  };
}

var initMotionCommon = function initMotionCommon(duration) {
  return {
    animationDuration: duration,
    animationFillMode: 'both'
  };
};
// FIXME: origin less code seems same as initMotionCommon. Maybe we can safe remove
var initMotionCommonLeave = function initMotionCommonLeave(duration) {
  return {
    animationDuration: duration,
    animationFillMode: 'both'
  };
};
var initMotion = function initMotion(motionCls, inKeyframes, outKeyframes, duration) {
  var _ref;
  var sameLevel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var sameLevelPrefix = sameLevel ? '&' : '';
  return _ref = {}, _defineProperty$1(_ref, "\n      " + sameLevelPrefix + motionCls + "-enter,\n      " + sameLevelPrefix + motionCls + "-appear\n    ", _extends$2(_extends$2({}, initMotionCommon(duration)), {
    animationPlayState: 'paused'
  })), _defineProperty$1(_ref, "" + sameLevelPrefix + motionCls + "-leave", _extends$2(_extends$2({}, initMotionCommonLeave(duration)), {
    animationPlayState: 'paused'
  })), _defineProperty$1(_ref, "\n      " + sameLevelPrefix + motionCls + "-enter" + motionCls + "-enter-active,\n      " + sameLevelPrefix + motionCls + "-appear" + motionCls + "-appear-active\n    ", {
    animationName: inKeyframes,
    animationPlayState: 'running'
  }), _defineProperty$1(_ref, "" + sameLevelPrefix + motionCls + "-leave" + motionCls + "-leave-active", {
    animationName: outKeyframes,
    animationPlayState: 'running',
    pointerEvents: 'none'
  }), _ref;
};

var fadeIn = new Keyframe('antFadeIn', {
  '0%': {
    opacity: 0
  },
  '100%': {
    opacity: 1
  }
});
var fadeOut = new Keyframe('antFadeOut', {
  '0%': {
    opacity: 1
  },
  '100%': {
    opacity: 0
  }
});
var initFadeMotion = function initFadeMotion(token) {
  var _ref;
  var sameLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var antCls = token.antCls;
  var motionCls = antCls + "-fade";
  var sameLevelPrefix = sameLevel ? '&' : '';
  return [initMotion(motionCls, fadeIn, fadeOut, token.motionDurationMid, sameLevel), (_ref = {}, _defineProperty$1(_ref, "\n        " + sameLevelPrefix + motionCls + "-enter,\n        " + sameLevelPrefix + motionCls + "-appear\n      ", {
    opacity: 0,
    animationTimingFunction: 'linear'
  }), _defineProperty$1(_ref, "" + sameLevelPrefix + motionCls + "-leave", {
    animationTimingFunction: 'linear'
  }), _ref)];
};

var moveDownIn = new Keyframe('antMoveDownIn', {
  '0%': {
    transform: 'translate3d(0, 100%, 0)',
    transformOrigin: '0 0',
    opacity: 0
  },
  '100%': {
    transform: 'translate3d(0, 0, 0)',
    transformOrigin: '0 0',
    opacity: 1
  }
});
var moveDownOut = new Keyframe('antMoveDownOut', {
  '0%': {
    transform: 'translate3d(0, 0, 0)',
    transformOrigin: '0 0',
    opacity: 1
  },
  '100%': {
    transform: 'translate3d(0, 100%, 0)',
    transformOrigin: '0 0',
    opacity: 0
  }
});
var moveLeftIn = new Keyframe('antMoveLeftIn', {
  '0%': {
    transform: 'translate3d(-100%, 0, 0)',
    transformOrigin: '0 0',
    opacity: 0
  },
  '100%': {
    transform: 'translate3d(0, 0, 0)',
    transformOrigin: '0 0',
    opacity: 1
  }
});
var moveLeftOut = new Keyframe('antMoveLeftOut', {
  '0%': {
    transform: 'translate3d(0, 0, 0)',
    transformOrigin: '0 0',
    opacity: 1
  },
  '100%': {
    transform: 'translate3d(-100%, 0, 0)',
    transformOrigin: '0 0',
    opacity: 0
  }
});
var moveRightIn = new Keyframe('antMoveRightIn', {
  '0%': {
    transform: 'translate3d(100%, 0, 0)',
    transformOrigin: '0 0',
    opacity: 0
  },
  '100%': {
    transform: 'translate3d(0, 0, 0)',
    transformOrigin: '0 0',
    opacity: 1
  }
});
var moveRightOut = new Keyframe('antMoveRightOut', {
  '0%': {
    transform: 'translate3d(0, 0, 0)',
    transformOrigin: '0 0',
    opacity: 1
  },
  '100%': {
    transform: 'translate3d(100%, 0, 0)',
    transformOrigin: '0 0',
    opacity: 0
  }
});
var moveUpIn = new Keyframe('antMoveUpIn', {
  '0%': {
    transform: 'translate3d(0, -100%, 0)',
    transformOrigin: '0 0',
    opacity: 0
  },
  '100%': {
    transform: 'translate3d(0, 0, 0)',
    transformOrigin: '0 0',
    opacity: 1
  }
});
var moveUpOut = new Keyframe('antMoveUpOut', {
  '0%': {
    transform: 'translate3d(0, 0, 0)',
    transformOrigin: '0 0',
    opacity: 1
  },
  '100%': {
    transform: 'translate3d(0, -100%, 0)',
    transformOrigin: '0 0',
    opacity: 0
  }
});
var moveMotion = {
  'move-up': {
    inKeyframes: moveUpIn,
    outKeyframes: moveUpOut
  },
  'move-down': {
    inKeyframes: moveDownIn,
    outKeyframes: moveDownOut
  },
  'move-left': {
    inKeyframes: moveLeftIn,
    outKeyframes: moveLeftOut
  },
  'move-right': {
    inKeyframes: moveRightIn,
    outKeyframes: moveRightOut
  }
};
var initMoveMotion = function initMoveMotion(token, motionName) {
  var _ref;
  var antCls = token.antCls;
  var motionCls = antCls + "-" + motionName;
  var _moveMotion$motionNam = moveMotion[motionName],
    inKeyframes = _moveMotion$motionNam.inKeyframes,
    outKeyframes = _moveMotion$motionNam.outKeyframes;
  return [initMotion(motionCls, inKeyframes, outKeyframes, token.motionDurationMid), (_ref = {}, _defineProperty$1(_ref, "\n        " + motionCls + "-enter,\n        " + motionCls + "-appear\n      ", {
    opacity: 0,
    animationTimingFunction: token.motionEaseOutCirc
  }), _defineProperty$1(_ref, motionCls + "-leave", {
    animationTimingFunction: token.motionEaseInOutCirc
  }), _ref)];
};

var slideUpIn = new Keyframe('antSlideUpIn', {
  '0%': {
    transform: 'scaleY(0.8)',
    transformOrigin: '0% 0%',
    opacity: 0
  },
  '100%': {
    transform: 'scaleY(1)',
    transformOrigin: '0% 0%',
    opacity: 1
  }
});
var slideUpOut = new Keyframe('antSlideUpOut', {
  '0%': {
    transform: 'scaleY(1)',
    transformOrigin: '0% 0%',
    opacity: 1
  },
  '100%': {
    transform: 'scaleY(0.8)',
    transformOrigin: '0% 0%',
    opacity: 0
  }
});
var slideDownIn = new Keyframe('antSlideDownIn', {
  '0%': {
    transform: 'scaleY(0.8)',
    transformOrigin: '100% 100%',
    opacity: 0
  },
  '100%': {
    transform: 'scaleY(1)',
    transformOrigin: '100% 100%',
    opacity: 1
  }
});
var slideDownOut = new Keyframe('antSlideDownOut', {
  '0%': {
    transform: 'scaleY(1)',
    transformOrigin: '100% 100%',
    opacity: 1
  },
  '100%': {
    transform: 'scaleY(0.8)',
    transformOrigin: '100% 100%',
    opacity: 0
  }
});
var slideLeftIn = new Keyframe('antSlideLeftIn', {
  '0%': {
    transform: 'scaleX(0.8)',
    transformOrigin: '0% 0%',
    opacity: 0
  },
  '100%': {
    transform: 'scaleX(1)',
    transformOrigin: '0% 0%',
    opacity: 1
  }
});
var slideLeftOut = new Keyframe('antSlideLeftOut', {
  '0%': {
    transform: 'scaleX(1)',
    transformOrigin: '0% 0%',
    opacity: 1
  },
  '100%': {
    transform: 'scaleX(0.8)',
    transformOrigin: '0% 0%',
    opacity: 0
  }
});
var slideRightIn = new Keyframe('antSlideRightIn', {
  '0%': {
    transform: 'scaleX(0.8)',
    transformOrigin: '100% 0%',
    opacity: 0
  },
  '100%': {
    transform: 'scaleX(1)',
    transformOrigin: '100% 0%',
    opacity: 1
  }
});
var slideRightOut = new Keyframe('antSlideRightOut', {
  '0%': {
    transform: 'scaleX(1)',
    transformOrigin: '100% 0%',
    opacity: 1
  },
  '100%': {
    transform: 'scaleX(0.8)',
    transformOrigin: '100% 0%',
    opacity: 0
  }
});
var slideMotion = {
  'slide-up': {
    inKeyframes: slideUpIn,
    outKeyframes: slideUpOut
  },
  'slide-down': {
    inKeyframes: slideDownIn,
    outKeyframes: slideDownOut
  },
  'slide-left': {
    inKeyframes: slideLeftIn,
    outKeyframes: slideLeftOut
  },
  'slide-right': {
    inKeyframes: slideRightIn,
    outKeyframes: slideRightOut
  }
};
var initSlideMotion = function initSlideMotion(token, motionName) {
  var _ref;
  var antCls = token.antCls;
  var motionCls = antCls + "-" + motionName;
  var _slideMotion$motionNa = slideMotion[motionName],
    inKeyframes = _slideMotion$motionNa.inKeyframes,
    outKeyframes = _slideMotion$motionNa.outKeyframes;
  return [initMotion(motionCls, inKeyframes, outKeyframes, token.motionDurationMid), (_ref = {}, _defineProperty$1(_ref, "\n      " + motionCls + "-enter,\n      " + motionCls + "-appear\n    ", {
    opacity: 0,
    animationTimingFunction: token.motionEaseOutQuint
  }), _defineProperty$1(_ref, motionCls + "-leave", {
    animationTimingFunction: token.motionEaseInQuint
  }), _ref)];
};

var zoomIn = new Keyframe('antZoomIn', {
  '0%': {
    transform: 'scale(0.2)',
    opacity: 0
  },
  '100%': {
    transform: 'scale(1)',
    opacity: 1
  }
});
var zoomOut = new Keyframe('antZoomOut', {
  '0%': {
    transform: 'scale(1)'
  },
  '100%': {
    transform: 'scale(0.2)',
    opacity: 0
  }
});
var zoomBigIn = new Keyframe('antZoomBigIn', {
  '0%': {
    transform: 'scale(0.8)',
    opacity: 0
  },
  '100%': {
    transform: 'scale(1)',
    opacity: 1
  }
});
var zoomBigOut = new Keyframe('antZoomBigOut', {
  '0%': {
    transform: 'scale(1)'
  },
  '100%': {
    transform: 'scale(0.8)',
    opacity: 0
  }
});
var zoomUpIn = new Keyframe('antZoomUpIn', {
  '0%': {
    transform: 'scale(0.8)',
    transformOrigin: '50% 0%',
    opacity: 0
  },
  '100%': {
    transform: 'scale(1)',
    transformOrigin: '50% 0%'
  }
});
var zoomUpOut = new Keyframe('antZoomUpOut', {
  '0%': {
    transform: 'scale(1)',
    transformOrigin: '50% 0%'
  },
  '100%': {
    transform: 'scale(0.8)',
    transformOrigin: '50% 0%',
    opacity: 0
  }
});
var zoomLeftIn = new Keyframe('antZoomLeftIn', {
  '0%': {
    transform: 'scale(0.8)',
    transformOrigin: '0% 50%',
    opacity: 0
  },
  '100%': {
    transform: 'scale(1)',
    transformOrigin: '0% 50%'
  }
});
var zoomLeftOut = new Keyframe('antZoomLeftOut', {
  '0%': {
    transform: 'scale(1)',
    transformOrigin: '0% 50%'
  },
  '100%': {
    transform: 'scale(0.8)',
    transformOrigin: '0% 50%',
    opacity: 0
  }
});
var zoomRightIn = new Keyframe('antZoomRightIn', {
  '0%': {
    transform: 'scale(0.8)',
    transformOrigin: '100% 50%',
    opacity: 0
  },
  '100%': {
    transform: 'scale(1)',
    transformOrigin: '100% 50%'
  }
});
var zoomRightOut = new Keyframe('antZoomRightOut', {
  '0%': {
    transform: 'scale(1)',
    transformOrigin: '100% 50%'
  },
  '100%': {
    transform: 'scale(0.8)',
    transformOrigin: '100% 50%',
    opacity: 0
  }
});
var zoomDownIn = new Keyframe('antZoomDownIn', {
  '0%': {
    transform: 'scale(0.8)',
    transformOrigin: '50% 100%',
    opacity: 0
  },
  '100%': {
    transform: 'scale(1)',
    transformOrigin: '50% 100%'
  }
});
var zoomDownOut = new Keyframe('antZoomDownOut', {
  '0%': {
    transform: 'scale(1)',
    transformOrigin: '50% 100%'
  },
  '100%': {
    transform: 'scale(0.8)',
    transformOrigin: '50% 100%',
    opacity: 0
  }
});
var zoomMotion = {
  zoom: {
    inKeyframes: zoomIn,
    outKeyframes: zoomOut
  },
  'zoom-big': {
    inKeyframes: zoomBigIn,
    outKeyframes: zoomBigOut
  },
  'zoom-big-fast': {
    inKeyframes: zoomBigIn,
    outKeyframes: zoomBigOut
  },
  'zoom-left': {
    inKeyframes: zoomLeftIn,
    outKeyframes: zoomLeftOut
  },
  'zoom-right': {
    inKeyframes: zoomRightIn,
    outKeyframes: zoomRightOut
  },
  'zoom-up': {
    inKeyframes: zoomUpIn,
    outKeyframes: zoomUpOut
  },
  'zoom-down': {
    inKeyframes: zoomDownIn,
    outKeyframes: zoomDownOut
  }
};
var initZoomMotion = function initZoomMotion(token, motionName) {
  var _ref;
  var antCls = token.antCls;
  var motionCls = antCls + "-" + motionName;
  var _zoomMotion$motionNam = zoomMotion[motionName],
    inKeyframes = _zoomMotion$motionNam.inKeyframes,
    outKeyframes = _zoomMotion$motionNam.outKeyframes;
  return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === 'zoom-big-fast' ? token.motionDurationFast : token.motionDurationMid), (_ref = {}, _defineProperty$1(_ref, "\n        " + motionCls + "-enter,\n        " + motionCls + "-appear\n      ", {
    transform: 'scale(0)',
    opacity: 0,
    animationTimingFunction: token.motionEaseOutCirc,
    '&-prepare': {
      transform: 'none'
    }
  }), _defineProperty$1(_ref, motionCls + "-leave", {
    animationTimingFunction: token.motionEaseInOutCirc
  }), _ref)];
};

var genCollapseMotion = function genCollapseMotion(token) {
  var _token$componentCls;
  return _defineProperty$1({}, token.componentCls, (_token$componentCls = {}, _defineProperty$1(_token$componentCls, token.antCls + "-motion-collapse-legacy", {
    overflow: 'hidden',
    '&-active': {
      transition: "height " + token.motionDurationMid + " " + token.motionEaseInOut + ",\n        opacity " + token.motionDurationMid + " " + token.motionEaseInOut + " !important"
    }
  }), _defineProperty$1(_token$componentCls, token.antCls + "-motion-collapse", {
    overflow: 'hidden',
    transition: "height " + token.motionDurationMid + " " + token.motionEaseInOut + ",\n        opacity " + token.motionDurationMid + " " + token.motionEaseInOut + " !important"
  }), _token$componentCls));
};
const genCollapseMotion$1 = genCollapseMotion;

var genItemStyle = function genItemStyle(token) {
  var controlPaddingHorizontal = token.controlPaddingHorizontal;
  return {
    position: 'relative',
    display: 'block',
    minHeight: token.controlHeight,
    padding: (token.controlHeight - token.fontSize * token.lineHeight) / 2 + "px " + controlPaddingHorizontal + "px",
    color: token.colorText,
    fontWeight: 'normal',
    fontSize: token.fontSize,
    lineHeight: token.lineHeight,
    boxSizing: 'border-box'
  };
};
var genSingleStyle$1 = function genSingleStyle(token) {
  var _disabled, _option, _extends2;
  var antCls = token.antCls,
    componentCls = token.componentCls;
  var selectItemCls = componentCls + "-item";
  return [_defineProperty$1({}, componentCls + "-dropdown", _extends$2(_extends$2({}, resetComponent(token)), (_extends2 = {
    position: 'absolute',
    top: -9999,
    zIndex: token.zIndexPopup,
    boxSizing: 'border-box',
    padding: token.paddingXXS,
    overflow: 'hidden',
    fontSize: token.fontSize,
    // Fix select render lag of long text in chrome
    // https://github.com/ant-design/ant-design/issues/11456
    // https://github.com/ant-design/ant-design/issues/11843
    fontVariant: 'initial',
    backgroundColor: token.colorBgElevated,
    borderRadius: token.borderRadiusLG,
    outline: 'none',
    boxShadow: token.boxShadowSecondary
  }, _defineProperty$1(_extends2, "\n            &" + antCls + "-slide-up-enter" + antCls + "-slide-up-enter-active&-placement-bottomLeft,\n            &" + antCls + "-slide-up-appear" + antCls + "-slide-up-appear-active&-placement-bottomLeft\n          ", {
    animationName: slideUpIn
  }), _defineProperty$1(_extends2, "\n            &" + antCls + "-slide-up-enter" + antCls + "-slide-up-enter-active&-placement-topLeft,\n            &" + antCls + "-slide-up-appear" + antCls + "-slide-up-appear-active&-placement-topLeft\n          ", {
    animationName: slideDownIn
  }), _defineProperty$1(_extends2, "&" + antCls + "-slide-up-leave" + antCls + "-slide-up-leave-active&-placement-bottomLeft", {
    animationName: slideUpOut
  }), _defineProperty$1(_extends2, "&" + antCls + "-slide-up-leave" + antCls + "-slide-up-leave-active&-placement-topLeft", {
    animationName: slideDownOut
  }), _defineProperty$1(_extends2, '&-hidden', {
    display: 'none'
  }), _defineProperty$1(_extends2, '&-empty', {
    color: token.colorTextDisabled
  }), _defineProperty$1(_extends2, selectItemCls + "-empty", _extends$2(_extends$2({}, genItemStyle(token)), {
    color: token.colorTextDisabled
  })), _defineProperty$1(_extends2, "" + selectItemCls, _extends$2(_extends$2({}, genItemStyle(token)), {
    cursor: 'pointer',
    transition: "background " + token.motionDurationSlow + " ease",
    borderRadius: token.borderRadiusSM,
    // =========== Group ============
    '&-group': {
      color: token.colorTextDescription,
      fontSize: token.fontSizeSM,
      cursor: 'default'
    },
    // =========== Option ===========
    '&-option': (_option = {
      display: 'flex',
      '&-content': _extends$2({
        flex: 'auto'
      }, textEllipsis),
      '&-state': {
        flex: 'none'
      }
    }, _defineProperty$1(_option, "&-active:not(" + selectItemCls + "-option-disabled)", {
      backgroundColor: token.controlItemBgHover
    }), _defineProperty$1(_option, "&-selected:not(" + selectItemCls + "-option-disabled)", _defineProperty$1({
      color: token.colorText,
      fontWeight: token.fontWeightStrong,
      backgroundColor: token.controlItemBgActive
    }, selectItemCls + "-option-state", {
      color: token.colorPrimary
    })), _defineProperty$1(_option, '&-disabled', (_disabled = {}, _defineProperty$1(_disabled, "&" + selectItemCls + "-option-selected", {
      backgroundColor: token.colorBgContainerDisabled
    }), _defineProperty$1(_disabled, "color", token.colorTextDisabled), _defineProperty$1(_disabled, "cursor", 'not-allowed'), _disabled)), _defineProperty$1(_option, '&-grouped', {
      paddingInlineStart: token.controlPaddingHorizontal * 2
    }), _option)
  })), _defineProperty$1(_extends2, '&-rtl', {
    direction: 'rtl'
  }), _extends2))),
  // Follow code may reuse in other components
  initSlideMotion(token, 'slide-up'), initSlideMotion(token, 'slide-down'), initMoveMotion(token, 'move-up'), initMoveMotion(token, 'move-down')];
};
const genDropdownStyle$1 = genSingleStyle$1;

var FIXED_ITEM_MARGIN = 2;
function getSelectItemStyle(_ref) {
  var controlHeightSM = _ref.controlHeightSM,
    controlHeight = _ref.controlHeight,
    borderWidth = _ref.lineWidth;
  var selectItemDist = (controlHeight - controlHeightSM) / 2 - borderWidth;
  var selectItemMargin = Math.ceil(selectItemDist / 2);
  return [selectItemDist, selectItemMargin];
}
function genSizeStyle$4(token, suffix) {
  var _ref2, _extends2, _ref3, _ref5, _ref6;
  var componentCls = token.componentCls,
    iconCls = token.iconCls;
  var selectOverflowPrefixCls = componentCls + "-selection-overflow";
  var selectItemHeight = token.controlHeightSM;
  var _getSelectItemStyle = getSelectItemStyle(token),
    _getSelectItemStyle2 = _slicedToArray(_getSelectItemStyle, 1),
    selectItemDist = _getSelectItemStyle2[0];
  var suffixCls = suffix ? componentCls + "-" + suffix : '';
  return _defineProperty$1({}, componentCls + "-multiple" + suffixCls, (_ref6 = {
    fontSize: token.fontSize
  }, _defineProperty$1(_ref6, selectOverflowPrefixCls, {
    position: 'relative',
    display: 'flex',
    flex: 'auto',
    flexWrap: 'wrap',
    maxWidth: '100%',
    '&-item': {
      flex: 'none',
      alignSelf: 'center',
      maxWidth: '100%',
      display: 'inline-flex'
    }
  }), _defineProperty$1(_ref6, componentCls + "-selector", (_ref2 = {
    display: 'flex',
    flexWrap: 'wrap',
    alignItems: 'center',
    // Multiple is little different that horizontal is follow the vertical
    padding: selectItemDist - FIXED_ITEM_MARGIN + "px " + FIXED_ITEM_MARGIN * 2 + "px",
    borderRadius: token.borderRadius
  }, _defineProperty$1(_ref2, componentCls + "-show-search&", {
    cursor: 'text'
  }), _defineProperty$1(_ref2, componentCls + "-disabled&", {
    background: token.colorBgContainerDisabled,
    cursor: 'not-allowed'
  }), _defineProperty$1(_ref2, '&:after', {
    display: 'inline-block',
    width: 0,
    margin: FIXED_ITEM_MARGIN + "px 0",
    lineHeight: selectItemHeight + "px",
    content: '"\\a0"'
  }), _ref2)), _defineProperty$1(_ref6, "\n        &" + componentCls + "-show-arrow " + componentCls + "-selector,\n        &" + componentCls + "-allow-clear " + componentCls + "-selector\n      ", {
    paddingInlineEnd: token.fontSizeIcon + token.controlPaddingHorizontal
  }), _defineProperty$1(_ref6, componentCls + "-selection-item", (_ref3 = {
    position: 'relative',
    display: 'flex',
    flex: 'none',
    boxSizing: 'border-box',
    maxWidth: '100%',
    height: selectItemHeight,
    marginTop: FIXED_ITEM_MARGIN,
    marginBottom: FIXED_ITEM_MARGIN,
    lineHeight: selectItemHeight - token.lineWidth * 2 + "px",
    background: token.colorFillSecondary,
    border: token.lineWidth + "px solid " + token.colorSplit,
    borderRadius: token.borderRadiusSM,
    cursor: 'default',
    transition: "font-size " + token.motionDurationSlow + ", line-height " + token.motionDurationSlow + ", height " + token.motionDurationSlow,
    userSelect: 'none',
    marginInlineEnd: FIXED_ITEM_MARGIN * 2,
    paddingInlineStart: token.paddingXS,
    paddingInlineEnd: token.paddingXS / 2
  }, _defineProperty$1(_ref3, componentCls + "-disabled&", {
    color: token.colorTextDisabled,
    borderColor: token.colorBorder,
    cursor: 'not-allowed'
  }), _defineProperty$1(_ref3, '&-content', {
    display: 'inline-block',
    marginInlineEnd: token.paddingXS / 2,
    overflow: 'hidden',
    whiteSpace: 'pre',
    textOverflow: 'ellipsis'
  }), _defineProperty$1(_ref3, '&-remove', _extends$2(_extends$2({}, resetIcon()), (_extends2 = {
    display: 'inline-block',
    color: token.colorIcon,
    fontWeight: 'bold',
    fontSize: 10,
    lineHeight: 'inherit',
    cursor: 'pointer'
  }, _defineProperty$1(_extends2, "> " + iconCls, {
    verticalAlign: '-0.2em'
  }), _defineProperty$1(_extends2, '&:hover', {
    color: token.colorIconHover
  }), _extends2))), _ref3)), _defineProperty$1(_ref6, selectOverflowPrefixCls + "-item + " + selectOverflowPrefixCls + "-item", _defineProperty$1({}, componentCls + "-selection-search", {
    marginInlineStart: 0
  })), _defineProperty$1(_ref6, componentCls + "-selection-search", (_ref5 = {
    display: 'inline-flex',
    position: 'relative',
    maxWidth: '100%',
    marginInlineStart: token.inputPaddingHorizontalBase - selectItemDist
  }, _defineProperty$1(_ref5, "\n          &-input,\n          &-mirror\n        ", {
    height: selectItemHeight,
    fontFamily: token.fontFamily,
    lineHeight: selectItemHeight + "px",
    transition: "all " + token.motionDurationSlow
  }), _defineProperty$1(_ref5, '&-input', {
    width: '100%',
    minWidth: 4.1 // fix search cursor missing
  }), _defineProperty$1(_ref5, '&-mirror', {
    position: 'absolute',
    top: 0,
    insetInlineStart: 0,
    insetInlineEnd: 'auto',
    zIndex: 999,
    whiteSpace: 'pre',
    visibility: 'hidden'
  }), _ref5)), _defineProperty$1(_ref6, componentCls + "-selection-placeholder ", {
    position: 'absolute',
    top: '50%',
    insetInlineStart: token.inputPaddingHorizontalBase,
    insetInlineEnd: token.inputPaddingHorizontalBase,
    transform: 'translateY(-50%)',
    transition: "all " + token.motionDurationSlow
  }), _ref6));
}
function genMultipleStyle(token) {
  var _ref8;
  var componentCls = token.componentCls;
  var smallToken = merge$2(token, {
    controlHeight: token.controlHeightSM,
    controlHeightSM: token.controlHeightXS,
    borderRadius: token.borderRadiusSM,
    borderRadiusSM: token.borderRadiusXS
  });
  var _getSelectItemStyle3 = getSelectItemStyle(token),
    _getSelectItemStyle4 = _slicedToArray(_getSelectItemStyle3, 2),
    smSelectItemMargin = _getSelectItemStyle4[1];
  return [genSizeStyle$4(token),
  // ======================== Small ========================
  // Shared
  genSizeStyle$4(smallToken, 'sm'), // Padding
  _defineProperty$1({}, componentCls + "-multiple" + componentCls + "-sm", (_ref8 = {}, _defineProperty$1(_ref8, componentCls + "-selection-placeholder", {
    insetInlineStart: token.controlPaddingHorizontalSM - token.lineWidth,
    insetInlineEnd: 'auto'
  }), _defineProperty$1(_ref8, componentCls + "-selection-search", {
    marginInlineStart: smSelectItemMargin
  }), _ref8)),
  // ======================== Large ========================
  // Shared
  genSizeStyle$4(merge$2(token, {
    fontSize: token.fontSizeLG,
    controlHeight: token.controlHeightLG,
    controlHeightSM: token.controlHeight,
    borderRadius: token.borderRadiusLG,
    borderRadiusSM: token.borderRadius
  }), 'lg')];
}

function genSizeStyle$3(token, suffix) {
  var _extends2, _ref, _ref3, _ref5;
  var componentCls = token.componentCls,
    inputPaddingHorizontalBase = token.inputPaddingHorizontalBase,
    borderRadius = token.borderRadius;
  var selectHeightWithoutBorder = token.controlHeight - token.lineWidth * 2;
  var selectionItemPadding = Math.ceil(token.fontSize * 1.25);
  var suffixCls = suffix ? componentCls + "-" + suffix : '';
  return _defineProperty$1({}, componentCls + "-single" + suffixCls, (_ref5 = {
    fontSize: token.fontSize
  }, _defineProperty$1(_ref5, componentCls + "-selector", _extends$2(_extends$2({}, resetComponent(token)), (_extends2 = {
    display: 'flex',
    borderRadius: borderRadius
  }, _defineProperty$1(_extends2, componentCls + "-selection-search", {
    position: 'absolute',
    top: 0,
    insetInlineStart: inputPaddingHorizontalBase,
    insetInlineEnd: inputPaddingHorizontalBase,
    bottom: 0,
    '&-input': {
      width: '100%'
    }
  }), _defineProperty$1(_extends2, "\n          " + componentCls + "-selection-item,\n          " + componentCls + "-selection-placeholder\n        ", {
    padding: 0,
    lineHeight: selectHeightWithoutBorder + "px",
    transition: "all " + token.motionDurationSlow,
    // Firefox inline-block position calculation is not same as Chrome & Safari. Patch this:
    '@supports (-moz-appearance: meterbar)': {
      lineHeight: selectHeightWithoutBorder + "px"
    }
  }), _defineProperty$1(_extends2, componentCls + "-selection-item", {
    position: 'relative',
    userSelect: 'none'
  }), _defineProperty$1(_extends2, componentCls + "-selection-placeholder", {
    transition: 'none',
    pointerEvents: 'none'
  }), _defineProperty$1(_extends2, ['&:after', /* For '' value baseline align */componentCls + "-selection-item:after", /* For undefined value baseline align */componentCls + "-selection-placeholder:after"].join(','), {
    display: 'inline-block',
    width: 0,
    visibility: 'hidden',
    content: '"\\a0"'
  }), _extends2))), _defineProperty$1(_ref5, "\n        &" + componentCls + "-show-arrow " + componentCls + "-selection-item,\n        &" + componentCls + "-show-arrow " + componentCls + "-selection-placeholder\n      ", {
    paddingInlineEnd: selectionItemPadding
  }), _defineProperty$1(_ref5, "&" + componentCls + "-open " + componentCls + "-selection-item", {
    color: token.colorTextPlaceholder
  }), _defineProperty$1(_ref5, "&:not(" + componentCls + "-customize-input)", _defineProperty$1({}, componentCls + "-selector", (_ref = {
    width: '100%',
    height: token.controlHeight,
    padding: "0 " + inputPaddingHorizontalBase + "px"
  }, _defineProperty$1(_ref, componentCls + "-selection-search-input", {
    height: selectHeightWithoutBorder
  }), _defineProperty$1(_ref, '&:after', {
    lineHeight: selectHeightWithoutBorder + "px"
  }), _ref))), _defineProperty$1(_ref5, "&" + componentCls + "-customize-input", _defineProperty$1({}, componentCls + "-selector", (_ref3 = {
    '&:after': {
      display: 'none'
    }
  }, _defineProperty$1(_ref3, componentCls + "-selection-search", {
    position: 'static',
    width: '100%'
  }), _defineProperty$1(_ref3, componentCls + "-selection-placeholder", {
    position: 'absolute',
    insetInlineStart: 0,
    insetInlineEnd: 0,
    padding: "0 " + inputPaddingHorizontalBase + "px",
    '&:after': {
      display: 'none'
    }
  }), _ref3))), _ref5));
}
function genSingleStyle(token) {
  var _ref7;
  var componentCls = token.componentCls;
  var inputPaddingHorizontalSM = token.controlPaddingHorizontalSM - token.lineWidth;
  return [genSizeStyle$3(token),
  // ======================== Small ========================
  // Shared
  genSizeStyle$3(merge$2(token, {
    controlHeight: token.controlHeightSM,
    borderRadius: token.borderRadiusSM
  }), 'sm'), // padding
  _defineProperty$1({}, componentCls + "-single" + componentCls + "-sm", _defineProperty$1({}, "&:not(" + componentCls + "-customize-input)", (_ref7 = {}, _defineProperty$1(_ref7, componentCls + "-selection-search", {
    insetInlineStart: inputPaddingHorizontalSM,
    insetInlineEnd: inputPaddingHorizontalSM
  }), _defineProperty$1(_ref7, componentCls + "-selector", {
    padding: "0 " + inputPaddingHorizontalSM + "px"
  }), _defineProperty$1(_ref7, "&" + componentCls + "-show-arrow " + componentCls + "-selection-search", {
    insetInlineEnd: inputPaddingHorizontalSM + token.fontSize * 1.5
  }), _defineProperty$1(_ref7, "\n            &" + componentCls + "-show-arrow " + componentCls + "-selection-item,\n            &" + componentCls + "-show-arrow " + componentCls + "-selection-placeholder\n          ", {
    paddingInlineEnd: token.fontSize * 1.5
  }), _ref7))),
  // ======================== Large ========================
  // Shared
  genSizeStyle$3(merge$2(token, {
    controlHeight: token.controlHeightLG,
    fontSize: token.fontSizeLG,
    borderRadius: token.borderRadiusLG
  }), 'lg')];
}

// handle border collapse
function compactItemBorder(token, options) {
  var childCombinator = options.borderElCls ? '> *' : '';
  var hoverEffects = ['hover', options.focus ? 'focus' : null, 'active'].filter(Boolean).map(function (n) {
    return "&:" + n + " " + childCombinator;
  }).join(',');
  return {
    '&-item:not(&-last-item)': {
      marginInlineEnd: -token.lineWidth
    },
    '&-item': _extends$2(_extends$2(_defineProperty$1({}, hoverEffects, {
      zIndex: 2
    }), options.focusElCls ? _defineProperty$1({}, "&" + options.focusElCls, {
      zIndex: 2
    }) : {}), _defineProperty$1({}, "&[disabled] " + childCombinator, {
      zIndex: 0
    }))
  };
}
// handle border-radius
function compactItemBorderRadius(prefixCls, options) {
  var _ref2;
  var childCombinator = options.borderElCls ? "> " + options.borderElCls : '';
  return _ref2 = {}, _defineProperty$1(_ref2, "&-item:not(&-first-item):not(&-last-item) " + childCombinator, {
    borderRadius: 0
  }), _defineProperty$1(_ref2, '&-item:not(&-last-item)&-first-item', _defineProperty$1({}, "& " + childCombinator + ", &" + prefixCls + "-sm " + childCombinator + ", &" + prefixCls + "-lg " + childCombinator, {
    borderStartEndRadius: 0,
    borderEndEndRadius: 0
  })), _defineProperty$1(_ref2, '&-item:not(&-first-item)&-last-item', _defineProperty$1({}, "& " + childCombinator + ", &" + prefixCls + "-sm " + childCombinator + ", &" + prefixCls + "-lg " + childCombinator, {
    borderStartStartRadius: 0,
    borderEndStartRadius: 0
  })), _ref2;
}
function genCompactItemStyle(token) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    focus: true
  };
  return _defineProperty$1({}, token.componentCls + "-compact", _extends$2(_extends$2({}, compactItemBorder(token, options)), compactItemBorderRadius(token.componentCls, options)));
}

// ============================= Selector =============================
var genSelectorStyle = function genSelectorStyle(token) {
  var _ref, _ref2;
  var componentCls = token.componentCls;
  return _ref2 = {
    position: 'relative',
    backgroundColor: token.colorBgContainer,
    border: token.lineWidth + "px " + token.lineType + " " + token.colorBorder,
    transition: "all " + token.motionDurationMid + " " + token.motionEaseInOut,
    input: {
      cursor: 'pointer'
    }
  }, _defineProperty$1(_ref2, componentCls + "-show-search&", {
    cursor: 'text',
    input: {
      cursor: 'auto',
      color: 'inherit'
    }
  }), _defineProperty$1(_ref2, componentCls + "-disabled&", (_ref = {
    color: token.colorTextDisabled,
    background: token.colorBgContainerDisabled,
    cursor: 'not-allowed'
  }, _defineProperty$1(_ref, componentCls + "-multiple&", {
    background: token.colorBgContainerDisabled
  }), _defineProperty$1(_ref, "input", {
    cursor: 'not-allowed'
  }), _ref)), _ref2;
};
// ============================== Status ==============================
var genStatusStyle$3 = function genStatusStyle(rootSelectCls, token) {
  var _extends2;
  var overwriteDefaultBorder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var componentCls = token.componentCls,
    borderHoverColor = token.borderHoverColor,
    outlineColor = token.outlineColor,
    antCls = token.antCls;
  var overwriteStyle = overwriteDefaultBorder ? _defineProperty$1({}, componentCls + "-selector", {
    borderColor: borderHoverColor
  }) : {};
  return _defineProperty$1({}, rootSelectCls, _defineProperty$1({}, "&:not(" + componentCls + "-disabled):not(" + componentCls + "-customize-input):not(" + antCls + "-pagination-size-changer)", _extends$2(_extends$2({}, overwriteStyle), (_extends2 = {}, _defineProperty$1(_extends2, componentCls + "-focused& " + componentCls + "-selector", {
    borderColor: borderHoverColor,
    boxShadow: "0 0 0 " + token.controlOutlineWidth + "px " + outlineColor,
    borderInlineEndWidth: token.controlLineWidth + "px !important",
    outline: 0
  }), _defineProperty$1(_extends2, "&:hover " + componentCls + "-selector", {
    borderColor: borderHoverColor,
    borderInlineEndWidth: token.controlLineWidth + "px !important"
  }), _extends2))));
};
// ============================== Styles ==============================
// /* Reset search input style */
var getSearchInputWithoutBorderStyle = function getSearchInputWithoutBorderStyle(token) {
  var componentCls = token.componentCls;
  return _defineProperty$1({}, componentCls + "-selection-search-input", {
    margin: 0,
    padding: 0,
    background: 'transparent',
    border: 'none',
    outline: 'none',
    appearance: 'none',
    '&::-webkit-search-cancel-button': {
      display: 'none',
      '-webkit-appearance': 'none'
    }
  });
};
// =============================== Base ===============================
var genBaseStyle$4 = function genBaseStyle(token) {
  var _extends3, _extends4, _ref7;
  var componentCls = token.componentCls,
    inputPaddingHorizontalBase = token.inputPaddingHorizontalBase,
    iconCls = token.iconCls;
  return _ref7 = {}, _defineProperty$1(_ref7, componentCls, _extends$2(_extends$2({}, resetComponent(token)), (_extends4 = {
    position: 'relative',
    display: 'inline-block',
    cursor: 'pointer'
  }, _defineProperty$1(_extends4, "&:not(&-customize-input) " + componentCls + "-selector", _extends$2(_extends$2({}, genSelectorStyle(token)), getSearchInputWithoutBorderStyle(token))), _defineProperty$1(_extends4, componentCls + "-selection-item", _extends$2({
    flex: 1,
    fontWeight: 'normal'
  }, textEllipsis)), _defineProperty$1(_extends4, componentCls + "-selection-placeholder", _extends$2(_extends$2({}, textEllipsis), {
    flex: 1,
    color: token.colorTextPlaceholder,
    pointerEvents: 'none'
  })), _defineProperty$1(_extends4, componentCls + "-arrow", _extends$2(_extends$2({}, resetIcon()), (_extends3 = {
    position: 'absolute',
    top: '50%',
    insetInlineStart: 'auto',
    insetInlineEnd: inputPaddingHorizontalBase,
    height: token.fontSizeIcon,
    marginTop: -token.fontSizeIcon / 2,
    color: token.colorTextQuaternary,
    fontSize: token.fontSizeIcon,
    lineHeight: 1,
    textAlign: 'center',
    pointerEvents: 'none',
    display: 'flex',
    alignItems: 'center'
  }, _defineProperty$1(_extends3, iconCls, _defineProperty$1({
    verticalAlign: 'top',
    transition: "transform " + token.motionDurationSlow,
    '> svg': {
      verticalAlign: 'top'
    }
  }, "&:not(" + componentCls + "-suffix)", {
    pointerEvents: 'auto'
  })), _defineProperty$1(_extends3, componentCls + "-disabled &", {
    cursor: 'not-allowed'
  }), _defineProperty$1(_extends3, '> *:not(:last-child)', {
    marginInlineEnd: 8 // FIXME: magic
  }), _extends3))), _defineProperty$1(_extends4, componentCls + "-clear", {
    position: 'absolute',
    top: '50%',
    insetInlineStart: 'auto',
    insetInlineEnd: inputPaddingHorizontalBase,
    zIndex: 1,
    display: 'inline-block',
    width: token.fontSizeIcon,
    height: token.fontSizeIcon,
    marginTop: -token.fontSizeIcon / 2,
    color: token.colorTextQuaternary,
    fontSize: token.fontSizeIcon,
    fontStyle: 'normal',
    lineHeight: 1,
    textAlign: 'center',
    textTransform: 'none',
    background: token.colorBgContainer,
    cursor: 'pointer',
    opacity: 0,
    transition: "color " + token.motionDurationMid + " ease, opacity " + token.motionDurationSlow + " ease",
    textRendering: 'auto',
    '&:before': {
      display: 'block'
    },
    '&:hover': {
      color: token.colorTextTertiary
    }
  }), _defineProperty$1(_extends4, '&:hover', _defineProperty$1({}, componentCls + "-clear", {
    opacity: 1
  })), _extends4))), _defineProperty$1(_ref7, componentCls + "-has-feedback", _defineProperty$1({}, componentCls + "-clear", {
    insetInlineEnd: inputPaddingHorizontalBase + token.fontSize + token.paddingXXS
  })), _ref7;
};
// ============================== Styles ==============================
var genSelectStyle = function genSelectStyle(token) {
  var _componentCls;
  var componentCls = token.componentCls;
  return [_defineProperty$1({}, componentCls, (_componentCls = {}, _defineProperty$1(_componentCls, "&-borderless " + componentCls + "-selector", {
    backgroundColor: "transparent !important",
    borderColor: "transparent !important",
    boxShadow: "none !important"
  }), _defineProperty$1(_componentCls, '&&-in-form-item', {
    width: '100%'
  }), _componentCls)),
  // =====================================================
  // ==                       LTR                       ==
  // =====================================================
  // Base
  genBaseStyle$4(token),
  // Single
  genSingleStyle(token),
  // Multiple
  genMultipleStyle(token),
  // Dropdown
  genDropdownStyle$1(token), // =====================================================
  // ==                       RTL                       ==
  // =====================================================
  _defineProperty$1({}, componentCls + "-rtl", {
    direction: 'rtl'
  }),
  // =====================================================
  // ==                     Status                      ==
  // =====================================================
  genStatusStyle$3(componentCls, merge$2(token, {
    borderHoverColor: token.colorPrimaryHover,
    outlineColor: token.controlOutline
  })), genStatusStyle$3(componentCls + "-status-error", merge$2(token, {
    borderHoverColor: token.colorErrorHover,
    outlineColor: token.colorErrorOutline
  }), true), genStatusStyle$3(componentCls + "-status-warning", merge$2(token, {
    borderHoverColor: token.colorWarningHover,
    outlineColor: token.colorWarningOutline
  }), true),
  // =====================================================
  // ==             Space Compact                       ==
  // =====================================================
  genCompactItemStyle(token, {
    borderElCls: componentCls + "-selector",
    focusElCls: componentCls + "-focused"
  })];
};
// ============================== Export ==============================
const useSelectStyle = genComponentStyleHook('Select', function (token, _ref10) {
  var rootPrefixCls = _ref10.rootPrefixCls;
  var selectToken = merge$2(token, {
    rootPrefixCls: rootPrefixCls,
    inputPaddingHorizontalBase: token.paddingSM - 1
  });
  return [genSelectStyle(selectToken)];
}, function (token) {
  return {
    zIndexPopup: token.zIndexPopupBase + 50
  };
});

function useEvent(callback) {
  var fnRef = react.exports.useRef();
  fnRef.current = callback;
  var memoFn = react.exports.useCallback(function () {
    var _fnRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}

/**
 * Wrap `React.useLayoutEffect` which will not throw warning message in test env
 */
var useLayoutEffect$1 = canUseDom$1() ? react.exports.useLayoutEffect : react.exports.useEffect;
var useLayoutUpdateEffect = function useLayoutUpdateEffect(callback, deps) {
  var firstMountRef = react.exports.useRef(true);
  useLayoutEffect$1(function () {
    if (!firstMountRef.current) {
      return callback();
    }
  }, deps);
  // We tell react that first mount has passed
  useLayoutEffect$1(function () {
    firstMountRef.current = false;
    return function () {
      firstMountRef.current = true;
    };
  }, []);
};

/**
 * Same as React.useState but `setState` accept `ignoreDestroy` param to not to setState after destroyed.
 * We do not make this auto is to avoid real memory leak.
 * Developer should confirm it's safe to ignore themselves.
 */
function useSafeState(defaultValue) {
  var destroyRef = react.exports.useRef(false);
  var _React$useState = react.exports.useState(defaultValue),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    value = _React$useState2[0],
    setValue = _React$useState2[1];
  react.exports.useEffect(function () {
    destroyRef.current = false;
    return function () {
      destroyRef.current = true;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }
    setValue(updater);
  }
  return [value, safeSetState];
}

/** We only think `undefined` is empty */
function hasValue(value) {
  return value !== undefined;
}
/**
 * Similar to `useState` but will use props value if provided.
 * Note that internal use rc-util `useState` hook.
 */
function useMergedState(defaultStateValue, option) {
  var _ref = option || {},
    defaultValue = _ref.defaultValue,
    value = _ref.value,
    onChange = _ref.onChange,
    postState = _ref.postState;
  // ======================= Init =======================
  var _useState = useSafeState(function () {
      if (hasValue(value)) {
        return value;
      } else if (hasValue(defaultValue)) {
        return typeof defaultValue === 'function' ? defaultValue() : defaultValue;
      } else {
        return typeof defaultStateValue === 'function' ? defaultStateValue() : defaultStateValue;
      }
    }),
    _useState2 = _slicedToArray(_useState, 2),
    innerValue = _useState2[0],
    setInnerValue = _useState2[1];
  var mergedValue = value !== undefined ? value : innerValue;
  var postMergedValue = postState ? postState(mergedValue) : mergedValue;
  // ====================== Change ======================
  var onChangeFn = useEvent(onChange);
  var _useState3 = useSafeState([mergedValue]),
    _useState4 = _slicedToArray(_useState3, 2),
    prevValue = _useState4[0],
    setPrevValue = _useState4[1];
  useLayoutUpdateEffect(function () {
    var prev = prevValue[0];
    if (innerValue !== prev) {
      onChangeFn(innerValue, prev);
    }
  }, [prevValue]);
  // Sync value back to `undefined` when it from control to un-control
  useLayoutUpdateEffect(function () {
    if (!hasValue(value)) {
      setInnerValue(value);
    }
  }, [value]);
  // ====================== Update ======================
  var triggerChange = useEvent(function (updater, ignoreDestroy) {
    setInnerValue(updater, ignoreDestroy);
    setPrevValue([mergedValue], ignoreDestroy);
  });
  return [postMergedValue, triggerChange];
}

function genPurePanel(Component, defaultPrefixCls, getDropdownCls) {
  return function PurePanel(props) {
    var customizePrefixCls = props.prefixCls,
      style = props.style;
    var holderRef = react.exports.useRef(null);
    var _React$useState = react.exports.useState(0),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      popupHeight = _React$useState2[0],
      setPopupHeight = _React$useState2[1];
    var _React$useState3 = react.exports.useState(0),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      popupWidth = _React$useState4[0],
      setPopupWidth = _React$useState4[1];
    var _useMergedState = useMergedState(false, {
        value: props.open
      }),
      _useMergedState2 = _slicedToArray(_useMergedState, 2),
      open = _useMergedState2[0],
      setOpen = _useMergedState2[1];
    var _React$useContext = react.exports.useContext(ConfigContext),
      getPrefixCls = _React$useContext.getPrefixCls;
    var prefixCls = getPrefixCls(defaultPrefixCls || 'select', customizePrefixCls);
    react.exports.useEffect(function () {
      // We do not care about ssr
      setOpen(true);
      if (typeof ResizeObserver !== 'undefined') {
        var resizeObserver = new ResizeObserver(function (entries) {
          var element = entries[0].target;
          setPopupHeight(element.offsetHeight + 8);
          setPopupWidth(element.offsetWidth);
        });
        var interval = setInterval(function () {
          var _a;
          var dropdownCls = getDropdownCls ? "." + getDropdownCls(prefixCls) : "." + prefixCls + "-dropdown";
          var popup = (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(dropdownCls);
          if (popup) {
            clearInterval(interval);
            resizeObserver.observe(popup);
          }
        }, 10);
        return function () {
          clearInterval(interval);
          resizeObserver.disconnect();
        };
      }
    }, []);
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(ConfigProvider, {
        theme: {
          token: {
            motionDurationFast: '0.01s',
            motionDurationMid: '0.01s',
            motionDurationSlow: '0.01s'
          }
        },
        children: /*#__PURE__*/jsx$1("div", {
          ref: holderRef,
          style: {
            paddingBottom: popupHeight,
            position: 'relative',
            width: 'fit-content',
            minWidth: popupWidth
          },
          children: /*#__PURE__*/jsx$1(Component, {
            ...props,
            style: _extends$2(_extends$2({}, style), {
              margin: 0
            }),
            open: open,
            visible: open,
            getPopupContainer: function getPopupContainer() {
              return holderRef.current;
            }
          })
        })
      })
    );
  };
}

var genSpaceCompactStyle = function genSpaceCompactStyle(token) {
  var componentCls = token.componentCls;
  return _defineProperty$1({}, componentCls, {
    display: 'inline-flex',
    '&-block': {
      display: 'flex',
      width: '100%'
    },
    '&-vertical': {
      flexDirection: 'column'
    }
  });
};
// ============================== Export ==============================
const genSpaceCompactStyle$1 = genSpaceCompactStyle;

var genSpaceStyle = function genSpaceStyle(token) {
  var componentCls = token.componentCls;
  return _defineProperty$1({}, componentCls, _defineProperty$1({
    display: 'inline-flex',
    '&-rtl': {
      direction: 'rtl'
    },
    '&-vertical': {
      flexDirection: 'column'
    },
    '&-align': {
      flexDirection: 'column',
      '&-center': {
        alignItems: 'center'
      },
      '&-start': {
        alignItems: 'flex-start'
      },
      '&-end': {
        alignItems: 'flex-end'
      },
      '&-baseline': {
        alignItems: 'flex-baseline'
      }
    }
  }, componentCls + "-space-item", {
    '&:empty': {
      display: 'none'
    }
  }));
};
// ============================== Export ==============================
const useStyle$m = genComponentStyleHook('Space', function (token) {
  return [genSpaceStyle(token), genSpaceCompactStyle$1(token)];
});

var __rest$N = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var SpaceCompactItemContext = /*#__PURE__*/react.exports.createContext(null);
var useCompactItemContext = function useCompactItemContext(prefixCls, direction) {
  var compactItemContext = react.exports.useContext(SpaceCompactItemContext);
  var compactItemClassnames = react.exports.useMemo(function () {
    var _classNames;
    if (!compactItemContext) return '';
    var compactDirection = compactItemContext.compactDirection,
      isFirstItem = compactItemContext.isFirstItem,
      isLastItem = compactItemContext.isLastItem;
    var separator = compactDirection === 'vertical' ? '-vertical-' : '-';
    return classNames$1((_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-compact" + separator + "item", true), _defineProperty$1(_classNames, prefixCls + "-compact" + separator + "first-item", isFirstItem), _defineProperty$1(_classNames, prefixCls + "-compact" + separator + "last-item", isLastItem), _defineProperty$1(_classNames, prefixCls + "-compact" + separator + "item-rtl", direction === 'rtl'), _classNames));
  }, [prefixCls, direction, compactItemContext]);
  return {
    compactSize: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize,
    compactDirection: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection,
    compactItemClassnames: compactItemClassnames
  };
};
var NoCompactStyle = function NoCompactStyle(_ref) {
  var children = _ref.children;
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(SpaceCompactItemContext.Provider, {
      value: null,
      children: children
    })
  );
};
var CompactItem = function CompactItem(_a) {
  var children = _a.children,
    otherProps = __rest$N(_a, ["children"]);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(SpaceCompactItemContext.Provider, {
      value: otherProps,
      children: children
    })
  );
};
var Compact = function Compact(props) {
  var _classNames2;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    directionConfig = _React$useContext.direction;
  var _props$size = props.size,
    size = _props$size === void 0 ? 'middle' : _props$size,
    direction = props.direction,
    block = props.block,
    customizePrefixCls = props.prefixCls,
    className = props.className,
    children = props.children,
    restProps = __rest$N(props, ["size", "direction", "block", "prefixCls", "className", "children"]);
  var prefixCls = getPrefixCls('space-compact', customizePrefixCls);
  var _useStyle = useStyle$m(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var clx = classNames$1(prefixCls, hashId, (_classNames2 = {}, _defineProperty$1(_classNames2, prefixCls + "-rtl", directionConfig === 'rtl'), _defineProperty$1(_classNames2, prefixCls + "-block", block), _defineProperty$1(_classNames2, prefixCls + "-vertical", direction === 'vertical'), _classNames2), className);
  var compactItemContext = react.exports.useContext(SpaceCompactItemContext);
  var childNodes = toArray$5(children);
  var nodes = react.exports.useMemo(function () {
    return childNodes.map(function (child, i) {
      var key = child && child.key || prefixCls + "-item-" + i;
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(CompactItem, {
          compactSize: size,
          compactDirection: direction,
          isFirstItem: i === 0 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isFirstItem)),
          isLastItem: i === childNodes.length - 1 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isLastItem)),
          children: child
        }, key)
      );
    });
  }, [size, childNodes, compactItemContext]);
  // =========================== Render ===========================
  if (childNodes.length === 0) {
    return null;
  }
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    className: clx,
    ...restProps,
    children: nodes
  }));
};
const Compact$1 = Compact;

// TODO: 4.0 - codemod should help to change `filterOption` to support node props.
var __rest$M = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var SECRET_COMBOBOX_MODE_DO_NOT_USE = 'SECRET_COMBOBOX_MODE_DO_NOT_USE';
var InternalSelect = function InternalSelect(_a, ref) {
  var _classNames2;
  var customizePrefixCls = _a.prefixCls,
    _a$bordered = _a.bordered,
    bordered = _a$bordered === void 0 ? true : _a$bordered,
    className = _a.className,
    getPopupContainer = _a.getPopupContainer,
    popupClassName = _a.popupClassName,
    dropdownClassName = _a.dropdownClassName,
    _a$listHeight = _a.listHeight,
    listHeight = _a$listHeight === void 0 ? 256 : _a$listHeight,
    placement = _a.placement,
    _a$listItemHeight = _a.listItemHeight,
    listItemHeight = _a$listItemHeight === void 0 ? 24 : _a$listItemHeight,
    customizeSize = _a.size,
    customDisabled = _a.disabled,
    notFoundContent = _a.notFoundContent,
    customStatus = _a.status,
    showArrow = _a.showArrow,
    props = __rest$M(_a, ["prefixCls", "bordered", "className", "getPopupContainer", "popupClassName", "dropdownClassName", "listHeight", "placement", "listItemHeight", "size", "disabled", "notFoundContent", "status", "showArrow"]);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getContextPopupContainer = _React$useContext.getPopupContainer,
    getPrefixCls = _React$useContext.getPrefixCls,
    renderEmpty = _React$useContext.renderEmpty,
    direction = _React$useContext.direction,
    virtual = _React$useContext.virtual,
    dropdownMatchSelectWidth = _React$useContext.dropdownMatchSelectWidth,
    select = _React$useContext.select;
  var size = react.exports.useContext(SizeContext);
  var prefixCls = getPrefixCls('select', customizePrefixCls);
  var rootPrefixCls = getPrefixCls();
  var _useCompactItemContex = useCompactItemContext(prefixCls, direction),
    compactSize = _useCompactItemContex.compactSize,
    compactItemClassnames = _useCompactItemContex.compactItemClassnames;
  var _useStyle = useSelectStyle(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var mode = react.exports.useMemo(function () {
    var m = props.mode;
    if (m === 'combobox') {
      return undefined;
    }
    if (m === SECRET_COMBOBOX_MODE_DO_NOT_USE) {
      return 'combobox';
    }
    return m;
  }, [props.mode]);
  var isMultiple = mode === 'multiple' || mode === 'tags';
  var mergedShowArrow = showArrow !== undefined ? showArrow : props.loading || !(isMultiple || mode === 'combobox');
  // ===================== Form Status =====================
  var _React$useContext2 = react.exports.useContext(FormItemInputContext),
    contextStatus = _React$useContext2.status,
    hasFeedback = _React$useContext2.hasFeedback,
    isFormItemInput = _React$useContext2.isFormItemInput,
    feedbackIcon = _React$useContext2.feedbackIcon;
  var mergedStatus = getMergedStatus(contextStatus, customStatus);
  // ===================== Empty =====================
  var mergedNotFound;
  if (notFoundContent !== undefined) {
    mergedNotFound = notFoundContent;
  } else if (mode === 'combobox') {
    mergedNotFound = null;
  } else {
    mergedNotFound = (renderEmpty || defaultRenderEmpty$1)('Select');
  }
  // ===================== Icons =====================
  var _getIcons = getIcons(_extends$2(_extends$2({}, props), {
      multiple: isMultiple,
      hasFeedback: hasFeedback,
      feedbackIcon: feedbackIcon,
      showArrow: mergedShowArrow,
      prefixCls: prefixCls
    })),
    suffixIcon = _getIcons.suffixIcon,
    itemIcon = _getIcons.itemIcon,
    removeIcon = _getIcons.removeIcon,
    clearIcon = _getIcons.clearIcon;
  var selectProps = omit$1(props, ['suffixIcon', 'itemIcon']);
  var rcSelectRtlDropdownClassName = classNames$1(popupClassName || dropdownClassName, _defineProperty$1({}, prefixCls + "-dropdown-" + direction, direction === 'rtl'), hashId);
  var mergedSize = compactSize || customizeSize || size;
  // ===================== Disabled =====================
  var disabled = react.exports.useContext(DisabledContext);
  var mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
  var mergedClassName = classNames$1((_classNames2 = {}, _defineProperty$1(_classNames2, prefixCls + "-lg", mergedSize === 'large'), _defineProperty$1(_classNames2, prefixCls + "-sm", mergedSize === 'small'), _defineProperty$1(_classNames2, prefixCls + "-rtl", direction === 'rtl'), _defineProperty$1(_classNames2, prefixCls + "-borderless", !bordered), _defineProperty$1(_classNames2, prefixCls + "-in-form-item", isFormItemInput), _classNames2), getStatusClassNames(prefixCls, mergedStatus, hasFeedback), compactItemClassnames, className, hashId);
  // ===================== Placement =====================
  var getPlacement = function getPlacement() {
    if (placement !== undefined) {
      return placement;
    }
    return direction === 'rtl' ? 'bottomRight' : 'bottomLeft';
  };
  // ====================== Render =======================
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(TypedSelect, {
    ref: ref,
    virtual: virtual,
    dropdownMatchSelectWidth: dropdownMatchSelectWidth,
    showSearch: select === null || select === void 0 ? void 0 : select.showSearch,
    ...selectProps,
    transitionName: getTransitionName(rootPrefixCls, getTransitionDirection(placement), props.transitionName),
    listHeight: listHeight,
    listItemHeight: listItemHeight,
    mode: mode,
    prefixCls: prefixCls,
    placement: getPlacement(),
    direction: direction,
    inputIcon: suffixIcon,
    menuItemSelectedIcon: itemIcon,
    removeIcon: removeIcon,
    clearIcon: clearIcon,
    notFoundContent: mergedNotFound,
    className: mergedClassName,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    dropdownClassName: rcSelectRtlDropdownClassName,
    showArrow: hasFeedback || showArrow,
    disabled: mergedDisabled
  }));
};
var Select$2 = /*#__PURE__*/react.exports.forwardRef(InternalSelect);
// We don't care debug panel
/* istanbul ignore next */
var PurePanel$4 = genPurePanel(Select$2);
Select$2.SECRET_COMBOBOX_MODE_DO_NOT_USE = SECRET_COMBOBOX_MODE_DO_NOT_USE;
Select$2.Option = Option$1;
Select$2.OptGroup = OptGroup;
Select$2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$4;
const Select$3 = Select$2;

function fillRef(ref, node) {
  if (typeof ref === 'function') {
    ref(node);
  } else if (_typeof$1(ref) === 'object' && ref && 'current' in ref) {
    ref.current = node;
  }
}
/**
 * Merge refs into one ref function to support ref passing.
 */
function composeRef() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(function (ref) {
    return ref;
  });
  if (refList.length <= 1) {
    return refList[0];
  }
  return function (node) {
    refs.forEach(function (ref) {
      fillRef(ref, node);
    });
  };
}
function supportRef(nodeOrComponent) {
  var _type$prototype, _nodeOrComponent$prot;
  var type = reactIs.exports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
  // Function component node
  if (typeof type === 'function' && !((_type$prototype = type.prototype) === null || _type$prototype === void 0 ? void 0 : _type$prototype.render)) {
    return false;
  }
  // Class component
  if (typeof nodeOrComponent === 'function' && !((_nodeOrComponent$prot = nodeOrComponent.prototype) === null || _nodeOrComponent$prot === void 0 ? void 0 : _nodeOrComponent$prot.render)) {
    return false;
  }
  return true;
}
/* eslint-enable */

function useForceUpdate() {
  var _React$useReducer = react.exports.useReducer(function (x) {
      return x + 1;
    }, 0),
    _React$useReducer2 = _slicedToArray(_React$useReducer, 2),
    forceUpdate = _React$useReducer2[1];
  return forceUpdate;
}

var responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];
var getResponsiveMap = function getResponsiveMap(token) {
  return {
    xs: "(max-width: " + token.screenXSMax + "px)",
    sm: "(min-width: " + token.screenSM + "px)",
    md: "(min-width: " + token.screenMD + "px)",
    lg: "(min-width: " + token.screenLG + "px)",
    xl: "(min-width: " + token.screenXL + "px)",
    xxl: "(min-width: " + token.screenXXL + "px)"
  };
};
function useResponsiveObserver() {
  var _useToken = useToken(),
    _useToken2 = _slicedToArray(_useToken, 2),
    token = _useToken2[1];
  var responsiveMap = getResponsiveMap(token);
  // To avoid repeat create instance, we add `useMemo` here.
  return React.useMemo(function () {
    var subscribers = new Map();
    var subUid = -1;
    var screens = {};
    return {
      matchHandlers: {},
      dispatch: function dispatch(pointMap) {
        screens = pointMap;
        subscribers.forEach(function (func) {
          return func(screens);
        });
        return subscribers.size >= 1;
      },
      subscribe: function subscribe(func) {
        if (!subscribers.size) this.register();
        subUid += 1;
        subscribers.set(subUid, func);
        func(screens);
        return subUid;
      },
      unsubscribe: function unsubscribe(paramToken) {
        subscribers["delete"](paramToken);
        if (!subscribers.size) this.unregister();
      },
      unregister: function unregister() {
        var _this = this;
        Object.keys(responsiveMap).forEach(function (screen) {
          var matchMediaQuery = responsiveMap[screen];
          var handler = _this.matchHandlers[matchMediaQuery];
          handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);
        });
        subscribers.clear();
      },
      register: function register() {
        var _this2 = this;
        Object.keys(responsiveMap).forEach(function (screen) {
          var matchMediaQuery = responsiveMap[screen];
          var listener = function listener(_ref) {
            var matches = _ref.matches;
            _this2.dispatch(_extends$2(_extends$2({}, screens), _defineProperty$1({}, screen, matches)));
          };
          var mql = window.matchMedia(matchMediaQuery);
          mql.addListener(listener);
          _this2.matchHandlers[matchMediaQuery] = {
            mql: mql,
            listener: listener
          };
          listener(mql);
        });
      },
      responsiveMap: responsiveMap
    };
  }, [token]);
}

function useBreakpoint() {
  var refreshOnChange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var screensRef = react.exports.useRef({});
  var forceUpdate = useForceUpdate();
  var responsiveObserve = useResponsiveObserver();
  react.exports.useEffect(function () {
    var token = responsiveObserve.subscribe(function (supportScreens) {
      screensRef.current = supportScreens;
      if (refreshOnChange) {
        forceUpdate();
      }
    });
    return function () {
      return responsiveObserve.unsubscribe(token);
    };
  }, []);
  return screensRef.current;
}

var autoAdjustOverflow$2 = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset$2 = [0, 0];
var placements$2 = {
  left: {
    points: ['cr', 'cl'],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  },
  right: {
    points: ['cl', 'cr'],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  top: {
    points: ['bc', 'tc'],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  bottom: {
    points: ['tc', 'bc'],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  topLeft: {
    points: ['bl', 'tl'],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  leftTop: {
    points: ['tr', 'tl'],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  rightTop: {
    points: ['tl', 'tr'],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  rightBottom: {
    points: ['bl', 'br'],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  leftBottom: {
    points: ['br', 'bl'],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  }
};

function Popup(props) {
  var showArrow = props.showArrow,
    arrowContent = props.arrowContent,
    children = props.children,
    prefixCls = props.prefixCls,
    id = props.id,
    overlayInnerStyle = props.overlayInnerStyle,
    className = props.className,
    style = props.style;
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("div", {
      className: classNames$1("".concat(prefixCls, "-content"), className),
      style: style,
      children: [showArrow !== false &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("div", {
        className: "".concat(prefixCls, "-arrow"),
        children: arrowContent
      }, "arrow"), /*#__PURE__*/jsx$1("div", {
        className: "".concat(prefixCls, "-inner"),
        id: id,
        role: "tooltip",
        style: overlayInnerStyle,
        children: typeof children === 'function' ? children() : children
      })]
    })
  );
}

var Tooltip$2 = function Tooltip(props, ref) {
  var overlayClassName = props.overlayClassName,
    _props$trigger = props.trigger,
    trigger = _props$trigger === void 0 ? ['hover'] : _props$trigger,
    _props$mouseEnterDela = props.mouseEnterDelay,
    mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela,
    _props$mouseLeaveDela = props.mouseLeaveDelay,
    mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela,
    overlayStyle = props.overlayStyle,
    _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-tooltip' : _props$prefixCls,
    children = props.children,
    onVisibleChange = props.onVisibleChange,
    afterVisibleChange = props.afterVisibleChange,
    transitionName = props.transitionName,
    animation = props.animation,
    motion = props.motion,
    _props$placement = props.placement,
    placement = _props$placement === void 0 ? 'right' : _props$placement,
    _props$align = props.align,
    align = _props$align === void 0 ? {} : _props$align,
    _props$destroyTooltip = props.destroyTooltipOnHide,
    destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip,
    defaultVisible = props.defaultVisible,
    getTooltipContainer = props.getTooltipContainer,
    overlayInnerStyle = props.overlayInnerStyle,
    arrowContent = props.arrowContent,
    overlay = props.overlay,
    id = props.id,
    showArrow = props.showArrow,
    restProps = _objectWithoutProperties(props, ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"]);
  var domRef = react.exports.useRef(null);
  react.exports.useImperativeHandle(ref, function () {
    return domRef.current;
  });
  var extraProps = _objectSpread2$1({}, restProps);
  if ('visible' in props) {
    extraProps.popupVisible = props.visible;
  }
  var getPopupElement = function getPopupElement() {
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(Popup, {
        showArrow: showArrow,
        arrowContent: arrowContent,
        prefixCls: prefixCls,
        id: id,
        overlayInnerStyle: overlayInnerStyle,
        children: overlay
      }, "content")
    );
  };
  var destroyTooltip = false;
  var autoDestroy = false;
  if (typeof destroyTooltipOnHide === 'boolean') {
    destroyTooltip = destroyTooltipOnHide;
  } else if (destroyTooltipOnHide && _typeof$1(destroyTooltipOnHide) === 'object') {
    var keepParent = destroyTooltipOnHide.keepParent;
    destroyTooltip = keepParent === true;
    autoDestroy = keepParent === false;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Trigger, {
      popupClassName: overlayClassName,
      prefixCls: prefixCls,
      popup: getPopupElement,
      action: trigger,
      builtinPlacements: placements$2,
      popupPlacement: placement,
      ref: domRef,
      popupAlign: align,
      getPopupContainer: getTooltipContainer,
      onPopupVisibleChange: onVisibleChange,
      afterPopupVisibleChange: afterVisibleChange,
      popupTransitionName: transitionName,
      popupAnimation: animation,
      popupMotion: motion,
      defaultPopupVisible: defaultVisible,
      destroyPopupOnHide: destroyTooltip,
      autoDestroy: autoDestroy,
      mouseLeaveDelay: mouseLeaveDelay,
      popupStyle: overlayStyle,
      mouseEnterDelay: mouseEnterDelay,
      ...extraProps,
      children: children
    })
  );
};
const Tooltip$3 = /*#__PURE__*/react.exports.forwardRef(Tooltip$2);

var autoAdjustOverflowEnabled = {
  adjustX: 1,
  adjustY: 1
};
var autoAdjustOverflowDisabled = {
  adjustX: 0,
  adjustY: 0
};
var targetOffset$1 = [0, 0];
function getOverflowOptions(autoAdjustOverflow) {
  if (typeof autoAdjustOverflow === 'boolean') {
    return autoAdjustOverflow ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled;
  }
  return _extends$2(_extends$2({}, autoAdjustOverflowDisabled), autoAdjustOverflow);
}
function getPlacements(config) {
  var _config$arrowWidth = config.arrowWidth,
    arrowWidth = _config$arrowWidth === void 0 ? 4 : _config$arrowWidth,
    _config$horizontalArr = config.horizontalArrowShift,
    horizontalArrowShift = _config$horizontalArr === void 0 ? 16 : _config$horizontalArr,
    _config$verticalArrow = config.verticalArrowShift,
    verticalArrowShift = _config$verticalArrow === void 0 ? 8 : _config$verticalArrow,
    autoAdjustOverflow = config.autoAdjustOverflow,
    arrowPointAtCenter = config.arrowPointAtCenter;
  var placementMap = {
    left: {
      points: ['cr', 'cl'],
      offset: [-4, 0]
    },
    right: {
      points: ['cl', 'cr'],
      offset: [4, 0]
    },
    top: {
      points: ['bc', 'tc'],
      offset: [0, -4]
    },
    bottom: {
      points: ['tc', 'bc'],
      offset: [0, 4]
    },
    topLeft: {
      points: ['bl', 'tc'],
      offset: [-(horizontalArrowShift + arrowWidth), -4]
    },
    leftTop: {
      points: ['tr', 'cl'],
      offset: [-4, -(verticalArrowShift + arrowWidth)]
    },
    topRight: {
      points: ['br', 'tc'],
      offset: [horizontalArrowShift + arrowWidth, -4]
    },
    rightTop: {
      points: ['tl', 'cr'],
      offset: [4, -(verticalArrowShift + arrowWidth)]
    },
    bottomRight: {
      points: ['tr', 'bc'],
      offset: [horizontalArrowShift + arrowWidth, 4]
    },
    rightBottom: {
      points: ['bl', 'cr'],
      offset: [4, verticalArrowShift + arrowWidth]
    },
    bottomLeft: {
      points: ['tl', 'bc'],
      offset: [-(horizontalArrowShift + arrowWidth), 4]
    },
    leftBottom: {
      points: ['br', 'cl'],
      offset: [-4, verticalArrowShift + arrowWidth]
    }
  };
  Object.keys(placementMap).forEach(function (key) {
    placementMap[key] = arrowPointAtCenter ? _extends$2(_extends$2({}, placementMap[key]), {
      overflow: getOverflowOptions(autoAdjustOverflow),
      targetOffset: targetOffset$1
    }) : _extends$2(_extends$2({}, placements$2[key]), {
      overflow: getOverflowOptions(autoAdjustOverflow)
    });
    placementMap[key].ignoreShake = true;
  });
  return placementMap;
}

function connectArrowCls(classList) {
  var showArrowCls = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return classList.map(function (cls) {
    return "" + showArrowCls + cls;
  }).join(',');
}
var MAX_VERTICAL_CONTENT_RADIUS = 8;
function getArrowOffset(options) {
  var maxVerticalContentRadius = MAX_VERTICAL_CONTENT_RADIUS;
  var sizePopupArrow = options.sizePopupArrow,
    contentRadius = options.contentRadius,
    borderRadiusOuter = options.borderRadiusOuter,
    limitVerticalRadius = options.limitVerticalRadius;
  var arrowInnerOffset = sizePopupArrow / 2 - Math.ceil(borderRadiusOuter * (Math.sqrt(2) - 1));
  var dropdownArrowOffset = (contentRadius > 12 ? contentRadius + 2 : 12) - arrowInnerOffset;
  var dropdownArrowOffsetVertical = limitVerticalRadius ? maxVerticalContentRadius - arrowInnerOffset : dropdownArrowOffset;
  return {
    dropdownArrowOffset: dropdownArrowOffset,
    dropdownArrowOffsetVertical: dropdownArrowOffsetVertical
  };
}
function getArrowStyle(token, options) {
  var _componentCls;
  var componentCls = token.componentCls,
    sizePopupArrow = token.sizePopupArrow,
    marginXXS = token.marginXXS,
    borderRadiusXS = token.borderRadiusXS,
    borderRadiusOuter = token.borderRadiusOuter,
    boxShadowPopoverArrow = token.boxShadowPopoverArrow;
  var colorBg = options.colorBg,
    showArrowCls = options.showArrowCls,
    _options$contentRadiu = options.contentRadius,
    contentRadius = _options$contentRadiu === void 0 ? token.borderRadiusLG : _options$contentRadiu,
    limitVerticalRadius = options.limitVerticalRadius;
  var _getArrowOffset = getArrowOffset({
      sizePopupArrow: sizePopupArrow,
      contentRadius: contentRadius,
      borderRadiusOuter: borderRadiusOuter,
      limitVerticalRadius: limitVerticalRadius
    }),
    dropdownArrowOffsetVertical = _getArrowOffset.dropdownArrowOffsetVertical,
    dropdownArrowOffset = _getArrowOffset.dropdownArrowOffset;
  var dropdownArrowDistance = sizePopupArrow / 2 + marginXXS;
  return _defineProperty$1({}, componentCls, (_componentCls = {}, _defineProperty$1(_componentCls, componentCls + "-arrow", [_extends$2(_extends$2({
    position: 'absolute',
    zIndex: 1,
    display: 'block'
  }, roundedArrow(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBg, boxShadowPopoverArrow)), {
    '&:before': {
      background: colorBg
    }
  })]), _defineProperty$1(_componentCls, ["&-placement-top " + componentCls + "-arrow", "&-placement-topLeft " + componentCls + "-arrow", "&-placement-topRight " + componentCls + "-arrow"].join(','), {
    bottom: 0,
    transform: 'translateY(100%) rotate(180deg)'
  }), _defineProperty$1(_componentCls, "&-placement-top " + componentCls + "-arrow", {
    left: {
      _skip_check_: true,
      value: '50%'
    },
    transform: 'translateX(-50%) translateY(100%) rotate(180deg)'
  }), _defineProperty$1(_componentCls, "&-placement-topLeft " + componentCls + "-arrow", {
    left: {
      _skip_check_: true,
      value: dropdownArrowOffset
    }
  }), _defineProperty$1(_componentCls, "&-placement-topRight " + componentCls + "-arrow", {
    right: {
      _skip_check_: true,
      value: dropdownArrowOffset
    }
  }), _defineProperty$1(_componentCls, ["&-placement-bottom " + componentCls + "-arrow", "&-placement-bottomLeft " + componentCls + "-arrow", "&-placement-bottomRight " + componentCls + "-arrow"].join(','), {
    top: 0,
    transform: "translateY(-100%)"
  }), _defineProperty$1(_componentCls, "&-placement-bottom " + componentCls + "-arrow", {
    left: {
      _skip_check_: true,
      value: '50%'
    },
    transform: "translateX(-50%) translateY(-100%)"
  }), _defineProperty$1(_componentCls, "&-placement-bottomLeft " + componentCls + "-arrow", {
    left: {
      _skip_check_: true,
      value: dropdownArrowOffset
    }
  }), _defineProperty$1(_componentCls, "&-placement-bottomRight " + componentCls + "-arrow", {
    right: {
      _skip_check_: true,
      value: dropdownArrowOffset
    }
  }), _defineProperty$1(_componentCls, ["&-placement-left " + componentCls + "-arrow", "&-placement-leftTop " + componentCls + "-arrow", "&-placement-leftBottom " + componentCls + "-arrow"].join(','), {
    right: {
      _skip_check_: true,
      value: 0
    },
    transform: 'translateX(100%) rotate(90deg)'
  }), _defineProperty$1(_componentCls, "&-placement-left " + componentCls + "-arrow", {
    top: {
      _skip_check_: true,
      value: '50%'
    },
    transform: 'translateY(-50%) translateX(100%) rotate(90deg)'
  }), _defineProperty$1(_componentCls, "&-placement-leftTop " + componentCls + "-arrow", {
    top: dropdownArrowOffsetVertical
  }), _defineProperty$1(_componentCls, "&-placement-leftBottom " + componentCls + "-arrow", {
    bottom: dropdownArrowOffsetVertical
  }), _defineProperty$1(_componentCls, ["&-placement-right " + componentCls + "-arrow", "&-placement-rightTop " + componentCls + "-arrow", "&-placement-rightBottom " + componentCls + "-arrow"].join(','), {
    left: {
      _skip_check_: true,
      value: 0
    },
    transform: 'translateX(-100%) rotate(-90deg)'
  }), _defineProperty$1(_componentCls, "&-placement-right " + componentCls + "-arrow", {
    top: {
      _skip_check_: true,
      value: '50%'
    },
    transform: 'translateY(-50%) translateX(-100%) rotate(-90deg)'
  }), _defineProperty$1(_componentCls, "&-placement-rightTop " + componentCls + "-arrow", {
    top: dropdownArrowOffsetVertical
  }), _defineProperty$1(_componentCls, "&-placement-rightBottom " + componentCls + "-arrow", {
    bottom: dropdownArrowOffsetVertical
  }), _defineProperty$1(_componentCls, connectArrowCls(["&-placement-topLeft", "&-placement-top", "&-placement-topRight"], showArrowCls), {
    paddingBottom: dropdownArrowDistance
  }), _defineProperty$1(_componentCls, connectArrowCls(["&-placement-bottomLeft", "&-placement-bottom", "&-placement-bottomRight"], showArrowCls), {
    paddingTop: dropdownArrowDistance
  }), _defineProperty$1(_componentCls, connectArrowCls(["&-placement-leftTop", "&-placement-left", "&-placement-leftBottom"], showArrowCls), {
    paddingRight: {
      _skip_check_: true,
      value: dropdownArrowDistance
    }
  }), _defineProperty$1(_componentCls, connectArrowCls(["&-placement-rightTop", "&-placement-right", "&-placement-rightBottom"], showArrowCls), {
    paddingLeft: {
      _skip_check_: true,
      value: dropdownArrowDistance
    }
  }), _componentCls));
}

var generatorTooltipPresetColor = function generatorTooltipPresetColor(token) {
  var componentCls = token.componentCls;
  return PresetColors.reduce(function (previousValue, currentValue) {
    var _previousValue;
    var lightColor = token[currentValue + "-6"];
    previousValue["&" + componentCls + "-" + currentValue] = (_previousValue = {}, _defineProperty$1(_previousValue, componentCls + "-inner", {
      backgroundColor: lightColor
    }), _defineProperty$1(_previousValue, componentCls + "-arrow", {
      '--antd-arrow-background-color': lightColor
    }), _previousValue);
    return previousValue;
  }, {});
};
var genTooltipStyle = function genTooltipStyle(token) {
  var _extends2;
  var componentCls = token.componentCls,
    tooltipMaxWidth = token.tooltipMaxWidth,
    tooltipColor = token.tooltipColor,
    tooltipBg = token.tooltipBg,
    tooltipBorderRadius = token.tooltipBorderRadius,
    zIndexPopup = token.zIndexPopup,
    controlHeight = token.controlHeight,
    boxShadowSecondary = token.boxShadowSecondary,
    paddingSM = token.paddingSM,
    paddingXS = token.paddingXS,
    tooltipRadiusOuter = token.tooltipRadiusOuter;
  return [_defineProperty$1({}, componentCls, _extends$2(_extends$2(_extends$2(_extends$2({}, resetComponent(token)), (_extends2 = {
    position: 'absolute',
    zIndex: zIndexPopup,
    display: 'block',
    '&': [{
      width: 'max-content'
    }, {
      width: 'intrinsic'
    }],
    maxWidth: tooltipMaxWidth,
    visibility: 'visible',
    '&-hidden': {
      display: 'none'
    },
    '--antd-arrow-background-color': tooltipBg
  }, _defineProperty$1(_extends2, componentCls + "-inner", {
    minWidth: controlHeight,
    minHeight: controlHeight,
    padding: paddingSM / 2 + "px " + paddingXS + "px",
    color: tooltipColor,
    textAlign: 'start',
    textDecoration: 'none',
    wordWrap: 'break-word',
    backgroundColor: tooltipBg,
    borderRadius: tooltipBorderRadius,
    boxShadow: boxShadowSecondary
  }), _defineProperty$1(_extends2, ["&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom"].join(','), _defineProperty$1({}, componentCls + "-inner", {
    borderRadius: tooltipBorderRadius > MAX_VERTICAL_CONTENT_RADIUS ? MAX_VERTICAL_CONTENT_RADIUS : tooltipBorderRadius
  })), _defineProperty$1(_extends2, componentCls + "-content", {
    position: 'relative'
  }), _extends2)), generatorTooltipPresetColor(token)), {
    // RTL
    '&-rtl': {
      direction: 'rtl'
    }
  })),
  // Arrow Style
  getArrowStyle(merge$2(token, {
    borderRadiusOuter: tooltipRadiusOuter
  }), {
    colorBg: 'var(--antd-arrow-background-color)',
    showArrowCls: '',
    contentRadius: tooltipBorderRadius,
    limitVerticalRadius: true
  }), // Pure Render
  _defineProperty$1({}, componentCls + "-pure", {
    position: 'relative',
    maxWidth: 'none'
  })];
};
// ============================== Export ==============================
const useStyle$l = (function (prefixCls, injectStyle) {
  var useOriginHook = genComponentStyleHook('Tooltip', function (token) {
    // Popover use Tooltip as internal component. We do not need to handle this.
    if (injectStyle === false) {
      return [];
    }
    var borderRadius = token.borderRadius,
      colorTextLightSolid = token.colorTextLightSolid,
      colorBgDefault = token.colorBgDefault,
      borderRadiusOuter = token.borderRadiusOuter;
    var TooltipToken = merge$2(token, {
      // default variables
      tooltipMaxWidth: 250,
      tooltipColor: colorTextLightSolid,
      tooltipBorderRadius: borderRadius,
      tooltipBg: colorBgDefault,
      tooltipRadiusOuter: borderRadiusOuter > 4 ? 4 : borderRadiusOuter
    });
    return [genTooltipStyle(TooltipToken), initZoomMotion(token, 'zoom-big-fast'), initZoomMotion(token, 'zoom-down')];
  }, function (_ref3) {
    var zIndexPopupBase = _ref3.zIndexPopupBase,
      colorBgSpotlight = _ref3.colorBgSpotlight;
    return {
      zIndexPopup: zIndexPopupBase + 70,
      colorBgDefault: colorBgSpotlight
    };
  });
  return useOriginHook(prefixCls);
});

var PresetColorTypes = ['pink', 'red', 'yellow', 'orange', 'cyan', 'green', 'blue', 'purple', 'geekblue', 'magenta', 'volcano', 'gold', 'lime'];

var PresetColorRegex = new RegExp("^(" + PresetColorTypes.join('|') + ")(-inverse)?$");
function parseColor(prefixCls, color) {
  var className = classNames$1(_defineProperty$1({}, prefixCls + "-" + color, color && PresetColorRegex.test(color)));
  var overlayStyle = {};
  var arrowStyle = {};
  if (color && !PresetColorRegex.test(color)) {
    overlayStyle.background = color;
    // @ts-ignore
    arrowStyle['--antd-arrow-background-color'] = color;
  }
  return {
    className: className,
    overlayStyle: overlayStyle,
    arrowStyle: arrowStyle
  };
}

function PurePanel$3(props) {
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    _props$placement = props.placement,
    placement = _props$placement === void 0 ? 'top' : _props$placement,
    title = props.title,
    color = props.color,
    overlayInnerStyle = props.overlayInnerStyle;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls('tooltip', customizePrefixCls);
  var _useStyle = useStyle$l(prefixCls, true),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  // Color
  var colorInfo = parseColor(prefixCls, color);
  var formattedOverlayInnerStyle = _extends$2(_extends$2({}, overlayInnerStyle), colorInfo.overlayStyle);
  var arrowContentStyle = colorInfo.arrowStyle;
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    className: classNames$1(hashId, prefixCls, prefixCls + "-pure", prefixCls + "-placement-" + placement, className, colorInfo.className),
    style: arrowContentStyle,
    children: /*#__PURE__*/jsx$1(Popup, {
      ...props,
      className: hashId,
      prefixCls: prefixCls,
      overlayInnerStyle: formattedOverlayInnerStyle,
      children: title
    })
  }));
}

var __rest$L = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var splitObject = function splitObject(obj, keys) {
  var picked = {};
  var omitted = _extends$2({}, obj);
  keys.forEach(function (key) {
    if (obj && key in obj) {
      picked[key] = obj[key];
      delete omitted[key];
    }
  });
  return {
    picked: picked,
    omitted: omitted
  };
};
// Fix Tooltip won't hide at disabled button
// mouse events don't trigger at disabled button in Chrome
// https://github.com/react-component/tooltip/issues/18
function getDisabledCompatibleChildren(element, prefixCls) {
  var elementType = element.type;
  if ((elementType.__ANT_BUTTON === true || element.type === 'button') && element.props.disabled || elementType.__ANT_SWITCH === true && (element.props.disabled || element.props.loading) || elementType.__ANT_RADIO === true && element.props.disabled) {
    // Pick some layout related style properties up to span
    // Prevent layout bugs like https://github.com/ant-design/ant-design/issues/5254
    var _splitObject = splitObject(element.props.style, ['position', 'left', 'right', 'top', 'bottom', 'float', 'display', 'zIndex']),
      picked = _splitObject.picked,
      omitted = _splitObject.omitted;
    var spanStyle = _extends$2(_extends$2({
      display: 'inline-block'
    }, picked), {
      cursor: 'not-allowed',
      width: element.props.block ? '100%' : undefined
    });
    var buttonStyle = _extends$2(_extends$2({}, omitted), {
      pointerEvents: 'none'
    });
    var child = cloneElement(element, {
      style: buttonStyle,
      className: null
    });
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        style: spanStyle,
        className: classNames$1(element.props.className, prefixCls + "-disabled-compatible-wrapper"),
        children: child
      })
    );
  }
  return element;
}
var Tooltip = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _a, _b;
  var customizePrefixCls = props.prefixCls,
    openClassName = props.openClassName,
    getTooltipContainer = props.getTooltipContainer,
    overlayClassName = props.overlayClassName,
    color = props.color,
    overlayInnerStyle = props.overlayInnerStyle,
    children = props.children,
    afterOpenChange = props.afterOpenChange,
    afterVisibleChange = props.afterVisibleChange;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getContextPopupContainer = _React$useContext.getPopupContainer,
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var _useMergedState = useMergedState(false, {
      value: (_a = props.open) !== null && _a !== void 0 ? _a : props.visible,
      defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
    }),
    _useMergedState2 = _slicedToArray(_useMergedState, 2),
    open = _useMergedState2[0],
    setOpen = _useMergedState2[1];
  var isNoTitle = function isNoTitle() {
    var title = props.title,
      overlay = props.overlay;
    return !title && !overlay && title !== 0; // overlay for old version compatibility
  };

  var onOpenChange = function onOpenChange(vis) {
    var _a, _b;
    setOpen(isNoTitle() ? false : vis);
    if (!isNoTitle()) {
      (_a = props.onOpenChange) === null || _a === void 0 ? void 0 : _a.call(props, vis);
      (_b = props.onVisibleChange) === null || _b === void 0 ? void 0 : _b.call(props, vis);
    }
  };
  var getTooltipPlacements = function getTooltipPlacements() {
    var builtinPlacements = props.builtinPlacements,
      _props$arrowPointAtCe = props.arrowPointAtCenter,
      arrowPointAtCenter = _props$arrowPointAtCe === void 0 ? false : _props$arrowPointAtCe,
      _props$autoAdjustOver = props.autoAdjustOverflow,
      autoAdjustOverflow = _props$autoAdjustOver === void 0 ? true : _props$autoAdjustOver;
    return builtinPlacements || getPlacements({
      arrowPointAtCenter: arrowPointAtCenter,
      autoAdjustOverflow: autoAdjustOverflow
    });
  };
  // 
  var onPopupAlign = function onPopupAlign(domNode, align) {
    var placements = getTooltipPlacements();
    // 
    var placement = Object.keys(placements).find(function (key) {
      var _a, _b;
      return placements[key].points[0] === ((_a = align.points) === null || _a === void 0 ? void 0 : _a[0]) && placements[key].points[1] === ((_b = align.points) === null || _b === void 0 ? void 0 : _b[1]);
    });
    if (!placement) {
      return;
    }
    // 
    var rect = domNode.getBoundingClientRect();
    var transformOrigin = {
      top: '50%',
      left: '50%'
    };
    if (/top|Bottom/.test(placement)) {
      transformOrigin.top = rect.height - align.offset[1] + "px";
    } else if (/Top|bottom/.test(placement)) {
      transformOrigin.top = -align.offset[1] + "px";
    }
    if (/left|Right/.test(placement)) {
      transformOrigin.left = rect.width - align.offset[0] + "px";
    } else if (/right|Left/.test(placement)) {
      transformOrigin.left = -align.offset[0] + "px";
    }
    domNode.style.transformOrigin = transformOrigin.left + " " + transformOrigin.top;
  };
  var getOverlay = function getOverlay() {
    var title = props.title,
      overlay = props.overlay;
    if (title === 0) {
      return title;
    }
    return overlay || title || '';
  };
  var getPopupContainer = props.getPopupContainer,
    _props$placement = props.placement,
    placement = _props$placement === void 0 ? 'top' : _props$placement,
    _props$mouseEnterDela = props.mouseEnterDelay,
    mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0.1 : _props$mouseEnterDela,
    _props$mouseLeaveDela = props.mouseLeaveDelay,
    mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela,
    overlayStyle = props.overlayStyle,
    otherProps = __rest$L(props, ["getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle"]);
  var prefixCls = getPrefixCls('tooltip', customizePrefixCls);
  var rootPrefixCls = getPrefixCls();
  var injectFromPopover = props['data-popover-inject'];
  var tempOpen = open;
  // Hide tooltip when there is no title
  if (!('open' in props) && !('visible' in props) && isNoTitle()) {
    tempOpen = false;
  }
  var child = getDisabledCompatibleChildren(isValidElement(children) && !isFragment(children) ? children :
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("span", {
    children: children
  }), prefixCls);
  var childProps = child.props;
  var childCls = !childProps.className || typeof childProps.className === 'string' ? classNames$1(childProps.className, _defineProperty$1({}, openClassName || prefixCls + "-open", true)) : childProps.className;
  // Style
  var _useStyle = useStyle$l(prefixCls, !injectFromPopover),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  // Color
  var colorInfo = parseColor(prefixCls, color);
  var formattedOverlayInnerStyle = _extends$2(_extends$2({}, overlayInnerStyle), colorInfo.overlayStyle);
  var arrowContentStyle = colorInfo.arrowStyle;
  var customOverlayClassName = classNames$1(overlayClassName, _defineProperty$1({}, prefixCls + "-rtl", direction === 'rtl'), colorInfo.className, hashId);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(Tooltip$3, {
    ...otherProps,
    placement: placement,
    mouseEnterDelay: mouseEnterDelay,
    mouseLeaveDelay: mouseLeaveDelay,
    prefixCls: prefixCls,
    overlayClassName: customOverlayClassName,
    overlayStyle: _extends$2(_extends$2({}, arrowContentStyle), overlayStyle),
    getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
    ref: ref,
    builtinPlacements: getTooltipPlacements(),
    overlay: getOverlay(),
    visible: tempOpen,
    onVisibleChange: onOpenChange,
    afterVisibleChange: afterOpenChange !== null && afterOpenChange !== void 0 ? afterOpenChange : afterVisibleChange,
    onPopupAlign: onPopupAlign,
    overlayInnerStyle: formattedOverlayInnerStyle,
    arrowContent:
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      className: prefixCls + "-arrow-content"
    }),
    motion: {
      motionName: getTransitionName(rootPrefixCls, 'zoom-big-fast', props.transitionName),
      motionDeadline: 1000
    },
    children: tempOpen ? cloneElement(child, {
      className: childCls
    }) : child
  }));
});
Tooltip._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$3;
const Tooltip$1 = Tooltip;

var _excluded$z = ["children", "locked"];
var MenuContext$2 = /*#__PURE__*/react.exports.createContext(null);
function mergeProps(origin, target) {
  var clone = _objectSpread2$1({}, origin);
  Object.keys(target).forEach(function (key) {
    var value = target[key];
    if (value !== undefined) {
      clone[key] = value;
    }
  });
  return clone;
}
function InheritableContextProvider(_ref) {
  var children = _ref.children,
    locked = _ref.locked,
    restProps = _objectWithoutProperties(_ref, _excluded$z);
  var context = react.exports.useContext(MenuContext$2);
  var inheritableContext = useMemo(function () {
    return mergeProps(context, restProps);
  }, [context, restProps], function (prev, next) {
    return !locked && (prev[0] !== next[0] || !shallowequal(prev[1], next[1]));
  });
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(MenuContext$2.Provider, {
      value: inheritableContext,
      children: children
    })
  );
}

function useActive(eventKey, disabled, onMouseEnter, onMouseLeave) {
  var _React$useContext = react.exports.useContext(MenuContext$2),
      activeKey = _React$useContext.activeKey,
      onActive = _React$useContext.onActive,
      onInactive = _React$useContext.onInactive;

  var ret = {
    active: activeKey === eventKey
  }; // Skip when disabled

  if (!disabled) {
    ret.onMouseEnter = function (domEvent) {
      onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
        key: eventKey,
        domEvent: domEvent
      });
      onActive(eventKey);
    };

    ret.onMouseLeave = function (domEvent) {
      onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
        key: eventKey,
        domEvent: domEvent
      });
      onInactive(eventKey);
    };
  }

  return ret;
}

var _excluded$y = ["item"];
/**
 * `onClick` event return `info.item` which point to react node directly.
 * We should warning this since it will not work on FC.
 */

function warnItemProp(_ref) {
  var item = _ref.item,
      restInfo = _objectWithoutProperties(_ref, _excluded$y);

  Object.defineProperty(restInfo, 'item', {
    get: function get() {
      warningOnce(false, '`info.item` is deprecated since we will move to function component that not provides React Node instance in future.');
      return item;
    }
  });
  return restInfo;
}

function Icon(_ref) {
  var icon = _ref.icon,
    props = _ref.props,
    children = _ref.children;
  var iconNode;
  if (typeof icon === 'function') {
    iconNode = /*#__PURE__*/react.exports.createElement(icon, _objectSpread2$1({}, props));
  } else {
    // Compatible for origin definition
    iconNode = icon;
  }
  return iconNode || children || null;
}

function useDirectionStyle(level) {
  var _React$useContext = react.exports.useContext(MenuContext$2),
      mode = _React$useContext.mode,
      rtl = _React$useContext.rtl,
      inlineIndent = _React$useContext.inlineIndent;

  if (mode !== 'inline') {
    return null;
  }

  var len = level;
  return rtl ? {
    paddingRight: len * inlineIndent
  } : {
    paddingLeft: len * inlineIndent
  };
}

var EmptyList = []; // ========================= Path Register =========================

var PathRegisterContext = /*#__PURE__*/react.exports.createContext(null);
function useMeasure() {
  return react.exports.useContext(PathRegisterContext);
} // ========================= Path Tracker ==========================

var PathTrackerContext = /*#__PURE__*/react.exports.createContext(EmptyList);
function useFullPath(eventKey) {
  var parentKeyPath = react.exports.useContext(PathTrackerContext);
  return react.exports.useMemo(function () {
    return eventKey !== undefined ? [].concat(_toConsumableArray(parentKeyPath), [eventKey]) : parentKeyPath;
  }, [parentKeyPath, eventKey]);
} // =========================== Path User ===========================

var PathUserContext = /*#__PURE__*/react.exports.createContext(null);

var IdContext = /*#__PURE__*/react.exports.createContext(null);
function getMenuId(uuid, eventKey) {
  if (uuid === undefined) {
    return null;
  }

  return "".concat(uuid, "-").concat(eventKey);
}
/**
 * Get `data-menu-id`
 */

function useMenuId(eventKey) {
  var id = react.exports.useContext(IdContext);
  return getMenuId(id, eventKey);
}

var PrivateContext = /*#__PURE__*/react.exports.createContext({});

var _excluded$x = ["title", "attribute", "elementRef"],
  _excluded2$5 = ["style", "className", "eventKey", "warnKey", "disabled", "itemIcon", "children", "role", "onMouseEnter", "onMouseLeave", "onClick", "onKeyDown", "onFocus"],
  _excluded3 = ["active"];
var LegacyMenuItem = /*#__PURE__*/function (_React$Component) {
  _inherits(LegacyMenuItem, _React$Component);
  var _super = _createSuper(LegacyMenuItem);
  function LegacyMenuItem() {
    _classCallCheck(this, LegacyMenuItem);
    return _super.apply(this, arguments);
  }
  _createClass(LegacyMenuItem, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
        title = _this$props.title,
        attribute = _this$props.attribute,
        elementRef = _this$props.elementRef,
        restProps = _objectWithoutProperties(_this$props, _excluded$x);
      var passedProps = omit(restProps, ['eventKey']);
      warningOnce(!attribute, '`attribute` of Menu.Item is deprecated. Please pass attribute directly.');
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(ForwardOverflow.Item, {
          ...attribute,
          title: typeof title === 'string' ? title : undefined,
          ...passedProps,
          ref: elementRef
        })
      );
    }
  }]);
  return LegacyMenuItem;
}(react.exports.Component);
/**
 * Real Menu Item component
 */

var InternalMenuItem = function InternalMenuItem(props) {
  var _classNames;
  var style = props.style,
    className = props.className,
    eventKey = props.eventKey;
    props.warnKey;
    var disabled = props.disabled,
    itemIcon = props.itemIcon,
    children = props.children,
    role = props.role,
    onMouseEnter = props.onMouseEnter,
    onMouseLeave = props.onMouseLeave,
    onClick = props.onClick,
    onKeyDown = props.onKeyDown,
    onFocus = props.onFocus,
    restProps = _objectWithoutProperties(props, _excluded2$5);
  var domDataId = useMenuId(eventKey);
  var _React$useContext = react.exports.useContext(MenuContext$2),
    prefixCls = _React$useContext.prefixCls,
    onItemClick = _React$useContext.onItemClick,
    contextDisabled = _React$useContext.disabled,
    overflowDisabled = _React$useContext.overflowDisabled,
    contextItemIcon = _React$useContext.itemIcon,
    selectedKeys = _React$useContext.selectedKeys,
    onActive = _React$useContext.onActive;
  var _React$useContext2 = react.exports.useContext(PrivateContext),
    _internalRenderMenuItem = _React$useContext2._internalRenderMenuItem;
  var itemCls = "".concat(prefixCls, "-item");
  var legacyMenuItemRef = react.exports.useRef();
  var elementRef = react.exports.useRef();
  var mergedDisabled = contextDisabled || disabled;
  var connectedKeys = useFullPath(eventKey); // ================================ Warn ================================

  var getEventInfo = function getEventInfo(e) {
    return {
      key: eventKey,
      // Note: For legacy code is reversed which not like other antd component
      keyPath: _toConsumableArray(connectedKeys).reverse(),
      item: legacyMenuItemRef.current,
      domEvent: e
    };
  }; // ============================= Icon =============================

  var mergedItemIcon = itemIcon || contextItemIcon; // ============================ Active ============================

  var _useActive = useActive(eventKey, mergedDisabled, onMouseEnter, onMouseLeave),
    active = _useActive.active,
    activeProps = _objectWithoutProperties(_useActive, _excluded3); // ============================ Select ============================

  var selected = selectedKeys.includes(eventKey); // ======================== DirectionStyle ========================

  var directionStyle = useDirectionStyle(connectedKeys.length); // ============================ Events ============================

  var onInternalClick = function onInternalClick(e) {
    if (mergedDisabled) {
      return;
    }
    var info = getEventInfo(e);
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info));
    onItemClick(info);
  };
  var onInternalKeyDown = function onInternalKeyDown(e) {
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e);
    if (e.which === KeyCode$1.ENTER) {
      var info = getEventInfo(e); // Legacy. Key will also trigger click event

      onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info));
      onItemClick(info);
    }
  };
  /**
   * Used for accessibility. Helper will focus element without key board.
   * We should manually trigger an active
   */

  var onInternalFocus = function onInternalFocus(e) {
    onActive(eventKey);
    onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
  }; // ============================ Render ============================

  var optionRoleProps = {};
  if (props.role === 'option') {
    optionRoleProps['aria-selected'] = selected;
  }
  var renderNode =
  /*#__PURE__*/
  /*#__PURE__*/
  jsxs(LegacyMenuItem, {
    ref: legacyMenuItemRef,
    elementRef: elementRef,
    role: role === null ? 'none' : role || 'menuitem',
    tabIndex: disabled ? null : -1,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
    ...restProps,
    ...activeProps,
    ...optionRoleProps,
    component: "li",
    "aria-disabled": disabled,
    style: _objectSpread2$1(_objectSpread2$1({}, directionStyle), style),
    className: classNames$1(itemCls, (_classNames = {}, _defineProperty$1(_classNames, "".concat(itemCls, "-active"), active), _defineProperty$1(_classNames, "".concat(itemCls, "-selected"), selected), _defineProperty$1(_classNames, "".concat(itemCls, "-disabled"), mergedDisabled), _classNames), className),
    onClick: onInternalClick,
    onKeyDown: onInternalKeyDown,
    onFocus: onInternalFocus,
    children: [children, /*#__PURE__*/jsx$1(Icon, {
      props: _objectSpread2$1(_objectSpread2$1({}, props), {}, {
        isSelected: selected
      }),
      icon: mergedItemIcon
    })]
  });
  if (_internalRenderMenuItem) {
    renderNode = _internalRenderMenuItem(renderNode, props, {
      selected: selected
    });
  }
  return renderNode;
};
function MenuItem$1(props) {
  var eventKey = props.eventKey; // ==================== Record KeyPath ====================

  var measure = useMeasure();
  var connectedKeyPath = useFullPath(eventKey); // eslint-disable-next-line consistent-return

  react.exports.useEffect(function () {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return function () {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  if (measure) {
    return null;
  } // ======================== Render ========================

  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(InternalMenuItem, {
      ...props
    })
  );
}

var _excluded$w = ["label", "children", "key", "type"];
function parseChildren(children, keyPath) {
  return toArray$6(children).map(function (child, index) {
    if ( /*#__PURE__*/react.exports.isValidElement(child)) {
      var _eventKey, _child$props;
      var key = child.key;
      var eventKey = (_eventKey = (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.eventKey) !== null && _eventKey !== void 0 ? _eventKey : key;
      var emptyKey = eventKey === null || eventKey === undefined;
      if (emptyKey) {
        eventKey = "tmp_key-".concat([].concat(_toConsumableArray(keyPath), [index]).join('-'));
      }
      var cloneProps = {
        key: eventKey,
        eventKey: eventKey
      };
      return /*#__PURE__*/react.exports.cloneElement(child, cloneProps);
    }
    return child;
  });
}
function convertItemsToNodes$1(list) {
  return (list || []).map(function (opt, index) {
    if (opt && _typeof$1(opt) === 'object') {
      var _ref = opt,
        label = _ref.label,
        children = _ref.children,
        key = _ref.key,
        type = _ref.type,
        restProps = _objectWithoutProperties(_ref, _excluded$w);
      var mergedKey = key !== null && key !== void 0 ? key : "tmp-".concat(index); // MenuItemGroup & SubMenuItem

      if (children || type === 'group') {
        if (type === 'group') {
          // Group
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1(MenuItemGroup, {
              ...restProps,
              title: label,
              children: convertItemsToNodes$1(children)
            }, mergedKey)
          );
        } // Sub Menu

        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(SubMenu$2, {
            ...restProps,
            title: label,
            children: convertItemsToNodes$1(children)
          }, mergedKey)
        );
      } // MenuItem & Divider

      if (type === 'divider') {
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(Divider, {
            ...restProps
          }, mergedKey)
        );
      }
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(MenuItem$1, {
          ...restProps,
          children: label
        }, mergedKey)
      );
    }
    return null;
  }).filter(function (opt) {
    return opt;
  });
}
function parseItems(children, items, keyPath) {
  var childNodes = children;
  if (items) {
    childNodes = convertItemsToNodes$1(items);
  }
  return parseChildren(childNodes, keyPath);
}

/**
 * Cache callback function that always return same ref instead.
 * This is used for context optimization.
 */

function useMemoCallback(func) {
  var funRef = react.exports.useRef(func);
  funRef.current = func;
  var callback = react.exports.useCallback(function () {
    var _funRef$current;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_funRef$current = funRef.current) === null || _funRef$current === void 0 ? void 0 : _funRef$current.call.apply(_funRef$current, [funRef].concat(args));
  }, []);
  return func ? callback : undefined;
}

var _excluded$v = ["className", "children"];
var InternalSubMenuList = function InternalSubMenuList(_ref, ref) {
  var className = _ref.className,
    children = _ref.children,
    restProps = _objectWithoutProperties(_ref, _excluded$v);
  var _React$useContext = react.exports.useContext(MenuContext$2),
    prefixCls = _React$useContext.prefixCls,
    mode = _React$useContext.mode,
    rtl = _React$useContext.rtl;
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("ul", {
      className: classNames$1(prefixCls, rtl && "".concat(prefixCls, "-rtl"), "".concat(prefixCls, "-sub"), "".concat(prefixCls, "-").concat(mode === 'inline' ? 'inline' : 'vertical'), className),
      ...restProps,
      "data-menu-list": true,
      ref: ref,
      children: children
    })
  );
};
var SubMenuList = /*#__PURE__*/react.exports.forwardRef(InternalSubMenuList);
SubMenuList.displayName = 'SubMenuList';

var autoAdjustOverflow$1 = {
  adjustX: 1,
  adjustY: 1
};
var placements$1 = {
  topLeft: {
    points: ['bl', 'tl'],
    overflow: autoAdjustOverflow$1,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: autoAdjustOverflow$1,
    offset: [0, 7]
  },
  leftTop: {
    points: ['tr', 'tl'],
    overflow: autoAdjustOverflow$1,
    offset: [-4, 0]
  },
  rightTop: {
    points: ['tl', 'tr'],
    overflow: autoAdjustOverflow$1,
    offset: [4, 0]
  }
};
var placementsRtl = {
  topLeft: {
    points: ['bl', 'tl'],
    overflow: autoAdjustOverflow$1,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: autoAdjustOverflow$1,
    offset: [0, 7]
  },
  rightTop: {
    points: ['tr', 'tl'],
    overflow: autoAdjustOverflow$1,
    offset: [-4, 0]
  },
  leftTop: {
    points: ['tl', 'tr'],
    overflow: autoAdjustOverflow$1,
    offset: [4, 0]
  }
};

function getMotion$1(mode, motion, defaultMotions) {
  if (motion) {
    return motion;
  }

  if (defaultMotions) {
    return defaultMotions[mode] || defaultMotions.other;
  }

  return undefined;
}

var popupPlacementMap = {
  horizontal: 'bottomLeft',
  vertical: 'rightTop',
  'vertical-left': 'rightTop',
  'vertical-right': 'leftTop'
};
function PopupTrigger(_ref) {
  var prefixCls = _ref.prefixCls,
    visible = _ref.visible,
    children = _ref.children,
    popup = _ref.popup,
    popupClassName = _ref.popupClassName,
    popupOffset = _ref.popupOffset,
    disabled = _ref.disabled,
    mode = _ref.mode,
    onVisibleChange = _ref.onVisibleChange;
  var _React$useContext = react.exports.useContext(MenuContext$2),
    getPopupContainer = _React$useContext.getPopupContainer,
    rtl = _React$useContext.rtl,
    subMenuOpenDelay = _React$useContext.subMenuOpenDelay,
    subMenuCloseDelay = _React$useContext.subMenuCloseDelay,
    builtinPlacements = _React$useContext.builtinPlacements,
    triggerSubMenuAction = _React$useContext.triggerSubMenuAction,
    forceSubMenuRender = _React$useContext.forceSubMenuRender,
    rootClassName = _React$useContext.rootClassName,
    motion = _React$useContext.motion,
    defaultMotions = _React$useContext.defaultMotions;
  var _React$useState = react.exports.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    innerVisible = _React$useState2[0],
    setInnerVisible = _React$useState2[1];
  var placement = rtl ? _objectSpread2$1(_objectSpread2$1({}, placementsRtl), builtinPlacements) : _objectSpread2$1(_objectSpread2$1({}, placements$1), builtinPlacements);
  var popupPlacement = popupPlacementMap[mode];
  var targetMotion = getMotion$1(mode, motion, defaultMotions);
  var mergedMotion = _objectSpread2$1(_objectSpread2$1({}, targetMotion), {}, {
    leavedClassName: "".concat(prefixCls, "-hidden"),
    removeOnLeave: false,
    motionAppear: true
  }); // Delay to change visible

  var visibleRef = react.exports.useRef();
  react.exports.useEffect(function () {
    visibleRef.current = wrapperRaf$1(function () {
      setInnerVisible(visible);
    });
    return function () {
      wrapperRaf$1.cancel(visibleRef.current);
    };
  }, [visible]);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Trigger, {
      prefixCls: prefixCls,
      popupClassName: classNames$1("".concat(prefixCls, "-popup"), _defineProperty$1({}, "".concat(prefixCls, "-rtl"), rtl), popupClassName, rootClassName),
      stretch: mode === 'horizontal' ? 'minWidth' : null,
      getPopupContainer: getPopupContainer,
      builtinPlacements: placement,
      popupPlacement: popupPlacement,
      popupVisible: innerVisible,
      popup: popup,
      popupAlign: popupOffset && {
        offset: popupOffset
      },
      action: disabled ? [] : [triggerSubMenuAction],
      mouseEnterDelay: subMenuOpenDelay,
      mouseLeaveDelay: subMenuCloseDelay,
      onPopupVisibleChange: onVisibleChange,
      forceRender: forceSubMenuRender,
      popupMotion: mergedMotion,
      children: children
    })
  );
}

function InlineSubMenuList(_ref) {
  var id = _ref.id,
    open = _ref.open,
    keyPath = _ref.keyPath,
    children = _ref.children;
  var fixedMode = 'inline';
  var _React$useContext = react.exports.useContext(MenuContext$2),
    prefixCls = _React$useContext.prefixCls,
    forceSubMenuRender = _React$useContext.forceSubMenuRender,
    motion = _React$useContext.motion,
    defaultMotions = _React$useContext.defaultMotions,
    mode = _React$useContext.mode; // Always use latest mode check

  var sameModeRef = react.exports.useRef(false);
  sameModeRef.current = mode === fixedMode; // We record `destroy` mark here since when mode change from `inline` to others.
  // The inline list should remove when motion end.

  var _React$useState = react.exports.useState(!sameModeRef.current),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    destroy = _React$useState2[0],
    setDestroy = _React$useState2[1];
  var mergedOpen = sameModeRef.current ? open : false; // ================================= Effect =================================
  // Reset destroy state when mode change back

  react.exports.useEffect(function () {
    if (sameModeRef.current) {
      setDestroy(false);
    }
  }, [mode]); // ================================= Render =================================

  var mergedMotion = _objectSpread2$1({}, getMotion$1(fixedMode, motion, defaultMotions)); // No need appear since nest inlineCollapse changed

  if (keyPath.length > 1) {
    mergedMotion.motionAppear = false;
  } // Hide inline list when mode changed and motion end

  var originOnVisibleChanged = mergedMotion.onVisibleChanged;
  mergedMotion.onVisibleChanged = function (newVisible) {
    if (!sameModeRef.current && !newVisible) {
      setDestroy(true);
    }
    return originOnVisibleChanged === null || originOnVisibleChanged === void 0 ? void 0 : originOnVisibleChanged(newVisible);
  };
  if (destroy) {
    return null;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(InheritableContextProvider, {
      mode: fixedMode,
      locked: !sameModeRef.current,
      children: /*#__PURE__*/jsx$1(CSSMotion, {
        visible: mergedOpen,
        ...mergedMotion,
        forceRender: forceSubMenuRender,
        removeOnLeave: false,
        leavedClassName: "".concat(prefixCls, "-hidden"),
        children: function (_ref2) {
          var motionClassName = _ref2.className,
            motionStyle = _ref2.style;
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1(SubMenuList, {
              id: id,
              className: motionClassName,
              style: motionStyle,
              children: children
            })
          );
        }
      })
    })
  );
}

var _excluded$u = ["style", "className", "title", "eventKey", "warnKey", "disabled", "internalPopupClose", "children", "itemIcon", "expandIcon", "popupClassName", "popupOffset", "onClick", "onMouseEnter", "onMouseLeave", "onTitleClick", "onTitleMouseEnter", "onTitleMouseLeave"],
  _excluded2$4 = ["active"];
var InternalSubMenu = function InternalSubMenu(props) {
  var _classNames;
  var style = props.style,
    className = props.className,
    title = props.title,
    eventKey = props.eventKey;
    props.warnKey;
    var disabled = props.disabled,
    internalPopupClose = props.internalPopupClose,
    children = props.children,
    itemIcon = props.itemIcon,
    expandIcon = props.expandIcon,
    popupClassName = props.popupClassName,
    popupOffset = props.popupOffset,
    onClick = props.onClick,
    onMouseEnter = props.onMouseEnter,
    onMouseLeave = props.onMouseLeave,
    onTitleClick = props.onTitleClick,
    onTitleMouseEnter = props.onTitleMouseEnter,
    onTitleMouseLeave = props.onTitleMouseLeave,
    restProps = _objectWithoutProperties(props, _excluded$u);
  var domDataId = useMenuId(eventKey);
  var _React$useContext = react.exports.useContext(MenuContext$2),
    prefixCls = _React$useContext.prefixCls,
    mode = _React$useContext.mode,
    openKeys = _React$useContext.openKeys,
    contextDisabled = _React$useContext.disabled,
    overflowDisabled = _React$useContext.overflowDisabled,
    activeKey = _React$useContext.activeKey,
    selectedKeys = _React$useContext.selectedKeys,
    contextItemIcon = _React$useContext.itemIcon,
    contextExpandIcon = _React$useContext.expandIcon,
    onItemClick = _React$useContext.onItemClick,
    onOpenChange = _React$useContext.onOpenChange,
    onActive = _React$useContext.onActive;
  var _React$useContext2 = react.exports.useContext(PrivateContext),
    _internalRenderSubMenuItem = _React$useContext2._internalRenderSubMenuItem;
  var _React$useContext3 = react.exports.useContext(PathUserContext),
    isSubPathKey = _React$useContext3.isSubPathKey;
  var connectedPath = useFullPath();
  var subMenuPrefixCls = "".concat(prefixCls, "-submenu");
  var mergedDisabled = contextDisabled || disabled;
  var elementRef = react.exports.useRef();
  var popupRef = react.exports.useRef(); // ================================ Warn ================================

  var mergedItemIcon = itemIcon || contextItemIcon;
  var mergedExpandIcon = expandIcon || contextExpandIcon; // ================================ Open ================================

  var originOpen = openKeys.includes(eventKey);
  var open = !overflowDisabled && originOpen; // =============================== Select ===============================

  var childrenSelected = isSubPathKey(selectedKeys, eventKey); // =============================== Active ===============================

  var _useActive = useActive(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave),
    active = _useActive.active,
    activeProps = _objectWithoutProperties(_useActive, _excluded2$4); // Fallback of active check to avoid hover on menu title or disabled item

  var _React$useState = react.exports.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    childrenActive = _React$useState2[0],
    setChildrenActive = _React$useState2[1];
  var triggerChildrenActive = function triggerChildrenActive(newActive) {
    if (!mergedDisabled) {
      setChildrenActive(newActive);
    }
  };
  var onInternalMouseEnter = function onInternalMouseEnter(domEvent) {
    triggerChildrenActive(true);
    onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
      key: eventKey,
      domEvent: domEvent
    });
  };
  var onInternalMouseLeave = function onInternalMouseLeave(domEvent) {
    triggerChildrenActive(false);
    onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
      key: eventKey,
      domEvent: domEvent
    });
  };
  var mergedActive = react.exports.useMemo(function () {
    if (active) {
      return active;
    }
    if (mode !== 'inline') {
      return childrenActive || isSubPathKey([activeKey], eventKey);
    }
    return false;
  }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]); // ========================== DirectionStyle ==========================

  var directionStyle = useDirectionStyle(connectedPath.length); // =============================== Events ===============================
  // >>>> Title click

  var onInternalTitleClick = function onInternalTitleClick(e) {
    // Skip if disabled
    if (mergedDisabled) {
      return;
    }
    onTitleClick === null || onTitleClick === void 0 ? void 0 : onTitleClick({
      key: eventKey,
      domEvent: e
    }); // Trigger open by click when mode is `inline`

    if (mode === 'inline') {
      onOpenChange(eventKey, !originOpen);
    }
  }; // >>>> Context for children click

  var onMergedItemClick = useMemoCallback(function (info) {
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info));
    onItemClick(info);
  }); // >>>>> Visible change

  var onPopupVisibleChange = function onPopupVisibleChange(newVisible) {
    if (mode !== 'inline') {
      onOpenChange(eventKey, newVisible);
    }
  };
  /**
   * Used for accessibility. Helper will focus element without key board.
   * We should manually trigger an active
   */

  var onInternalFocus = function onInternalFocus() {
    onActive(eventKey);
  }; // =============================== Render ===============================

  var popupId = domDataId && "".concat(domDataId, "-popup"); // >>>>> Title

  var titleNode =
  /*#__PURE__*/
  /*#__PURE__*/
  jsxs("div", {
    role: "menuitem",
    style: directionStyle,
    className: "".concat(subMenuPrefixCls, "-title"),
    tabIndex: mergedDisabled ? null : -1,
    ref: elementRef,
    title: typeof title === 'string' ? title : null,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
    "aria-expanded": open,
    "aria-haspopup": true,
    "aria-controls": popupId,
    "aria-disabled": mergedDisabled,
    onClick: onInternalTitleClick,
    onFocus: onInternalFocus,
    ...activeProps,
    children: [title, /*#__PURE__*/jsx$1(Icon, {
      icon: mode !== 'horizontal' ? mergedExpandIcon : null,
      props: _objectSpread2$1(_objectSpread2$1({}, props), {}, {
        isOpen: open,
        // [Legacy] Not sure why need this mark
        isSubMenu: true
      }),
      children: /*#__PURE__*/jsx$1("i", {
        className: "".concat(subMenuPrefixCls, "-arrow")
      })
    })]
  }); // Cache mode if it change to `inline` which do not have popup motion

  var triggerModeRef = react.exports.useRef(mode);
  if (mode !== 'inline' && connectedPath.length > 1) {
    triggerModeRef.current = 'vertical';
  } else {
    triggerModeRef.current = mode;
  }
  if (!overflowDisabled) {
    var triggerMode = triggerModeRef.current; // Still wrap with Trigger here since we need avoid react re-mount dom node
    // Which makes motion failed

    titleNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(PopupTrigger, {
      mode: triggerMode,
      prefixCls: subMenuPrefixCls,
      visible: !internalPopupClose && open && mode !== 'inline',
      popupClassName: popupClassName,
      popupOffset: popupOffset,
      popup:
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(InheritableContextProvider, {
        mode: triggerMode === 'horizontal' ? 'vertical' : triggerMode,
        children: /*#__PURE__*/jsx$1(SubMenuList, {
          id: popupId,
          ref: popupRef,
          children: children
        })
      }),
      disabled: mergedDisabled,
      onVisibleChange: onPopupVisibleChange,
      children: titleNode
    });
  } // >>>>> List node

  var listNode =
  /*#__PURE__*/
  /*#__PURE__*/
  jsxs(ForwardOverflow.Item, {
    role: "none",
    ...restProps,
    component: "li",
    style: style,
    className: classNames$1(subMenuPrefixCls, "".concat(subMenuPrefixCls, "-").concat(mode), className, (_classNames = {}, _defineProperty$1(_classNames, "".concat(subMenuPrefixCls, "-open"), open), _defineProperty$1(_classNames, "".concat(subMenuPrefixCls, "-active"), mergedActive), _defineProperty$1(_classNames, "".concat(subMenuPrefixCls, "-selected"), childrenSelected), _defineProperty$1(_classNames, "".concat(subMenuPrefixCls, "-disabled"), mergedDisabled), _classNames)),
    onMouseEnter: onInternalMouseEnter,
    onMouseLeave: onInternalMouseLeave,
    children: [titleNode, !overflowDisabled &&
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(InlineSubMenuList, {
      id: popupId,
      open: open,
      keyPath: connectedPath,
      children: children
    })]
  });
  if (_internalRenderSubMenuItem) {
    listNode = _internalRenderSubMenuItem(listNode, props, {
      selected: childrenSelected,
      active: mergedActive,
      open: open,
      disabled: mergedDisabled
    });
  } // >>>>> Render

  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(InheritableContextProvider, {
      onItemClick: onMergedItemClick,
      mode: mode === 'horizontal' ? 'vertical' : mode,
      itemIcon: mergedItemIcon,
      expandIcon: mergedExpandIcon,
      children: listNode
    })
  );
};
function SubMenu$2(props) {
  var eventKey = props.eventKey,
    children = props.children;
  var connectedKeyPath = useFullPath(eventKey);
  var childList = parseChildren(children, connectedKeyPath); // ==================== Record KeyPath ====================

  var measure = useMeasure(); // eslint-disable-next-line consistent-return

  react.exports.useEffect(function () {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return function () {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  var renderNode; // ======================== Render ========================

  if (measure) {
    renderNode = childList;
  } else {
    renderNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(InternalSubMenu, {
      ...props,
      children: childList
    });
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(PathTrackerContext.Provider, {
      value: connectedKeyPath,
      children: renderNode
    })
  );
}

function focusable(node) {
  var includePositive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (isVisible(node)) {
    var nodeName = node.nodeName.toLowerCase();
    var isFocusableElement =
    // Focusable element
    ['input', 'select', 'textarea', 'button'].includes(nodeName) ||
    // Editable element
    node.isContentEditable ||
    // Anchor with href element
    nodeName === 'a' && !!node.getAttribute('href');
    // Get tabIndex
    var tabIndexAttr = node.getAttribute('tabindex');
    var tabIndexNum = Number(tabIndexAttr);
    // Parse as number if validate
    var tabIndex = null;
    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
      tabIndex = tabIndexNum;
    } else if (isFocusableElement && tabIndex === null) {
      tabIndex = 0;
    }
    // Block focusable if disabled
    if (isFocusableElement && node.disabled) {
      tabIndex = null;
    }
    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
  }
  return false;
}
function getFocusNodeList(node) {
  var includePositive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var res = _toConsumableArray(node.querySelectorAll('*')).filter(function (child) {
    return focusable(child, includePositive);
  });
  if (focusable(node, includePositive)) {
    res.unshift(node);
  }
  return res;
}

var LEFT = KeyCode$1.LEFT,
    RIGHT = KeyCode$1.RIGHT,
    UP = KeyCode$1.UP,
    DOWN = KeyCode$1.DOWN,
    ENTER = KeyCode$1.ENTER,
    ESC$1 = KeyCode$1.ESC,
    HOME = KeyCode$1.HOME,
    END = KeyCode$1.END;
var ArrowKeys = [UP, DOWN, LEFT, RIGHT];

function getOffset$1(mode, isRootLevel, isRtl, which) {
  var _inline, _horizontal, _vertical, _offsets;

  var prev = 'prev';
  var next = 'next';
  var children = 'children';
  var parent = 'parent'; // Inline enter is special that we use unique operation

  if (mode === 'inline' && which === ENTER) {
    return {
      inlineTrigger: true
    };
  }

  var inline = (_inline = {}, _defineProperty$1(_inline, UP, prev), _defineProperty$1(_inline, DOWN, next), _inline);
  var horizontal = (_horizontal = {}, _defineProperty$1(_horizontal, LEFT, isRtl ? next : prev), _defineProperty$1(_horizontal, RIGHT, isRtl ? prev : next), _defineProperty$1(_horizontal, DOWN, children), _defineProperty$1(_horizontal, ENTER, children), _horizontal);
  var vertical = (_vertical = {}, _defineProperty$1(_vertical, UP, prev), _defineProperty$1(_vertical, DOWN, next), _defineProperty$1(_vertical, ENTER, children), _defineProperty$1(_vertical, ESC$1, parent), _defineProperty$1(_vertical, LEFT, isRtl ? children : parent), _defineProperty$1(_vertical, RIGHT, isRtl ? parent : children), _vertical);
  var offsets = {
    inline: inline,
    horizontal: horizontal,
    vertical: vertical,
    inlineSub: inline,
    horizontalSub: vertical,
    verticalSub: vertical
  };
  var type = (_offsets = offsets["".concat(mode).concat(isRootLevel ? '' : 'Sub')]) === null || _offsets === void 0 ? void 0 : _offsets[which];

  switch (type) {
    case prev:
      return {
        offset: -1,
        sibling: true
      };

    case next:
      return {
        offset: 1,
        sibling: true
      };

    case parent:
      return {
        offset: -1,
        sibling: false
      };

    case children:
      return {
        offset: 1,
        sibling: false
      };

    default:
      return null;
  }
}

function findContainerUL(element) {
  var current = element;

  while (current) {
    if (current.getAttribute('data-menu-list')) {
      return current;
    }

    current = current.parentElement;
  } // Normally should not reach this line

  /* istanbul ignore next */


  return null;
}
/**
 * Find focused element within element set provided
 */


function getFocusElement(activeElement, elements) {
  var current = activeElement || document.activeElement;

  while (current) {
    if (elements.has(current)) {
      return current;
    }

    current = current.parentElement;
  }

  return null;
}
/**
 * Get focusable elements from the element set under provided container
 */


function getFocusableElements(container, elements) {
  var list = getFocusNodeList(container, true);
  return list.filter(function (ele) {
    return elements.has(ele);
  });
}

function getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {
  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

  // Key on the menu item will not get validate parent container
  if (!parentQueryContainer) {
    return null;
  } // List current level menu item elements


  var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements); // Find next focus index

  var count = sameLevelFocusableMenuElementList.length;
  var focusIndex = sameLevelFocusableMenuElementList.findIndex(function (ele) {
    return focusMenuElement === ele;
  });

  if (offset < 0) {
    if (focusIndex === -1) {
      focusIndex = count - 1;
    } else {
      focusIndex -= 1;
    }
  } else if (offset > 0) {
    focusIndex += 1;
  }

  focusIndex = (focusIndex + count) % count; // Focus menu item

  return sameLevelFocusableMenuElementList[focusIndex];
}

function useAccessibility$1(mode, activeKey, isRtl, id, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
  var rafRef = react.exports.useRef();
  var activeRef = react.exports.useRef();
  activeRef.current = activeKey;

  var cleanRaf = function cleanRaf() {
    wrapperRaf$1.cancel(rafRef.current);
  };

  react.exports.useEffect(function () {
    return function () {
      cleanRaf();
    };
  }, []);
  return function (e) {
    var which = e.which;

    if ([].concat(ArrowKeys, [ENTER, ESC$1, HOME, END]).includes(which)) {
      // Convert key to elements
      var elements;
      var key2element;
      var element2key; // >>> Wrap as function since we use raf for some case

      var refreshElements = function refreshElements() {
        elements = new Set();
        key2element = new Map();
        element2key = new Map();
        var keys = getKeys();
        keys.forEach(function (key) {
          var element = document.querySelector("[data-menu-id='".concat(getMenuId(id, key), "']"));

          if (element) {
            elements.add(element);
            element2key.set(element, key);
            key2element.set(key, element);
          }
        });
        return elements;
      };

      refreshElements(); // First we should find current focused MenuItem/SubMenu element

      var activeElement = key2element.get(activeKey);
      var focusMenuElement = getFocusElement(activeElement, elements);
      var focusMenuKey = element2key.get(focusMenuElement);
      var offsetObj = getOffset$1(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which); // Some mode do not have fully arrow operation like inline

      if (!offsetObj && which !== HOME && which !== END) {
        return;
      } // Arrow prevent default to avoid page scroll


      if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {
        e.preventDefault();
      }

      var tryFocus = function tryFocus(menuElement) {
        if (menuElement) {
          var focusTargetElement = menuElement; // Focus to link instead of menu item if possible

          var link = menuElement.querySelector('a');

          if (link !== null && link !== void 0 && link.getAttribute('href')) {
            focusTargetElement = link;
          }

          var targetKey = element2key.get(menuElement);
          triggerActiveKey(targetKey);
          /**
           * Do not `useEffect` here since `tryFocus` may trigger async
           * which makes React sync update the `activeKey`
           * that force render before `useRef` set the next activeKey
           */

          cleanRaf();
          rafRef.current = wrapperRaf$1(function () {
            if (activeRef.current === targetKey) {
              focusTargetElement.focus();
            }
          });
        }
      };

      if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
        // ========================== Sibling ==========================
        // Find walkable focus menu element container
        var parentQueryContainer;

        if (!focusMenuElement || mode === 'inline') {
          parentQueryContainer = containerRef.current;
        } else {
          parentQueryContainer = findContainerUL(focusMenuElement);
        } // Get next focus element


        var targetElement;
        var focusableElements = getFocusableElements(parentQueryContainer, elements);

        if (which === HOME) {
          targetElement = focusableElements[0];
        } else if (which === END) {
          targetElement = focusableElements[focusableElements.length - 1];
        } else {
          targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
        } // Focus menu item


        tryFocus(targetElement); // ======================= InlineTrigger =======================
      } else if (offsetObj.inlineTrigger) {
        // Inline trigger no need switch to sub menu item
        triggerAccessibilityOpen(focusMenuKey); // =========================== Level ===========================
      } else if (offsetObj.offset > 0) {
        triggerAccessibilityOpen(focusMenuKey, true);
        cleanRaf();
        rafRef.current = wrapperRaf$1(function () {
          // Async should resync elements
          refreshElements();
          var controlId = focusMenuElement.getAttribute('aria-controls');
          var subQueryContainer = document.getElementById(controlId); // Get sub focusable menu item

          var targetElement = getNextFocusElement(subQueryContainer, elements); // Focus menu item

          tryFocus(targetElement);
        }, 5);
      } else if (offsetObj.offset < 0) {
        var keyPath = getKeyPath(focusMenuKey, true);
        var parentKey = keyPath[keyPath.length - 2];
        var parentMenuElement = key2element.get(parentKey); // Focus menu item

        triggerAccessibilityOpen(parentKey, false);
        tryFocus(parentMenuElement);
      }
    } // Pass origin key down event


    originOnKeyDown === null || originOnKeyDown === void 0 ? void 0 : originOnKeyDown(e);
  };
}

var uniquePrefix = Math.random().toFixed(5).toString().slice(2);
var internalId = 0;
function useUUID(id) {
  var _useMergedState = useMergedState$1(id, {
    value: id
  }),
      _useMergedState2 = _slicedToArray(_useMergedState, 2),
      uuid = _useMergedState2[0],
      setUUID = _useMergedState2[1];

  react.exports.useEffect(function () {
    internalId += 1;
    var newId = "".concat(uniquePrefix, "-").concat(internalId);
    setUUID("rc-menu-uuid-".concat(newId));
  }, []);
  return uuid;
}

function nextSlice(callback) {
  /* istanbul ignore next */
  Promise.resolve().then(callback);
}

var PATH_SPLIT = '__RC_UTIL_PATH_SPLIT__';

var getPathStr = function getPathStr(keyPath) {
  return keyPath.join(PATH_SPLIT);
};

var getPathKeys = function getPathKeys(keyPathStr) {
  return keyPathStr.split(PATH_SPLIT);
};

var OVERFLOW_KEY = 'rc-menu-more';
function useKeyRecords() {
  var _React$useState = react.exports.useState({}),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      internalForceUpdate = _React$useState2[1];

  var key2pathRef = react.exports.useRef(new Map());
  var path2keyRef = react.exports.useRef(new Map());

  var _React$useState3 = react.exports.useState([]),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      overflowKeys = _React$useState4[0],
      setOverflowKeys = _React$useState4[1];

  var updateRef = react.exports.useRef(0);
  var destroyRef = react.exports.useRef(false);

  var forceUpdate = function forceUpdate() {
    if (!destroyRef.current) {
      internalForceUpdate({});
    }
  };

  var registerPath = react.exports.useCallback(function (key, keyPath) {


    var connectedPath = getPathStr(keyPath);
    path2keyRef.current.set(connectedPath, key);
    key2pathRef.current.set(key, connectedPath);
    updateRef.current += 1;
    var id = updateRef.current;
    nextSlice(function () {
      if (id === updateRef.current) {
        forceUpdate();
      }
    });
  }, []);
  var unregisterPath = react.exports.useCallback(function (key, keyPath) {
    var connectedPath = getPathStr(keyPath);
    path2keyRef.current.delete(connectedPath);
    key2pathRef.current.delete(key);
  }, []);
  var refreshOverflowKeys = react.exports.useCallback(function (keys) {
    setOverflowKeys(keys);
  }, []);
  var getKeyPath = react.exports.useCallback(function (eventKey, includeOverflow) {
    var fullPath = key2pathRef.current.get(eventKey) || '';
    var keys = getPathKeys(fullPath);

    if (includeOverflow && overflowKeys.includes(keys[0])) {
      keys.unshift(OVERFLOW_KEY);
    }

    return keys;
  }, [overflowKeys]);
  var isSubPathKey = react.exports.useCallback(function (pathKeys, eventKey) {
    return pathKeys.some(function (pathKey) {
      var pathKeyList = getKeyPath(pathKey, true);
      return pathKeyList.includes(eventKey);
    });
  }, [getKeyPath]);

  var getKeys = function getKeys() {
    var keys = _toConsumableArray(key2pathRef.current.keys());

    if (overflowKeys.length) {
      keys.push(OVERFLOW_KEY);
    }

    return keys;
  };
  /**
   * Find current key related child path keys
   */


  var getSubPathKeys = react.exports.useCallback(function (key) {
    var connectedPath = "".concat(key2pathRef.current.get(key)).concat(PATH_SPLIT);
    var pathKeys = new Set();

    _toConsumableArray(path2keyRef.current.keys()).forEach(function (pathKey) {
      if (pathKey.startsWith(connectedPath)) {
        pathKeys.add(path2keyRef.current.get(pathKey));
      }
    });

    return pathKeys;
  }, []);
  react.exports.useEffect(function () {
    return function () {
      destroyRef.current = true;
    };
  }, []);
  return {
    // Register
    registerPath: registerPath,
    unregisterPath: unregisterPath,
    refreshOverflowKeys: refreshOverflowKeys,
    // Util
    isSubPathKey: isSubPathKey,
    getKeyPath: getKeyPath,
    getKeys: getKeys,
    getSubPathKeys: getSubPathKeys
  };
}

var _excluded$t = ["prefixCls", "rootClassName", "style", "className", "tabIndex", "items", "children", "direction", "id", "mode", "inlineCollapsed", "disabled", "disabledOverflow", "subMenuOpenDelay", "subMenuCloseDelay", "forceSubMenuRender", "defaultOpenKeys", "openKeys", "activeKey", "defaultActiveFirst", "selectable", "multiple", "defaultSelectedKeys", "selectedKeys", "onSelect", "onDeselect", "inlineIndent", "motion", "defaultMotions", "triggerSubMenuAction", "builtinPlacements", "itemIcon", "expandIcon", "overflowedIndicator", "overflowedIndicatorPopupClassName", "getPopupContainer", "onClick", "onOpenChange", "onKeyDown", "openAnimation", "openTransitionName", "_internalRenderMenuItem", "_internalRenderSubMenuItem"];
var EMPTY_LIST$4 = [];
var Menu$3 = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _childList$, _classNames;
  var _ref = props,
    _ref$prefixCls = _ref.prefixCls,
    prefixCls = _ref$prefixCls === void 0 ? 'rc-menu' : _ref$prefixCls,
    rootClassName = _ref.rootClassName,
    style = _ref.style,
    className = _ref.className,
    _ref$tabIndex = _ref.tabIndex,
    tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex,
    items = _ref.items,
    children = _ref.children,
    direction = _ref.direction,
    id = _ref.id,
    _ref$mode = _ref.mode,
    mode = _ref$mode === void 0 ? 'vertical' : _ref$mode,
    inlineCollapsed = _ref.inlineCollapsed,
    disabled = _ref.disabled,
    disabledOverflow = _ref.disabledOverflow,
    _ref$subMenuOpenDelay = _ref.subMenuOpenDelay,
    subMenuOpenDelay = _ref$subMenuOpenDelay === void 0 ? 0.1 : _ref$subMenuOpenDelay,
    _ref$subMenuCloseDela = _ref.subMenuCloseDelay,
    subMenuCloseDelay = _ref$subMenuCloseDela === void 0 ? 0.1 : _ref$subMenuCloseDela,
    forceSubMenuRender = _ref.forceSubMenuRender,
    defaultOpenKeys = _ref.defaultOpenKeys,
    openKeys = _ref.openKeys,
    activeKey = _ref.activeKey,
    defaultActiveFirst = _ref.defaultActiveFirst,
    _ref$selectable = _ref.selectable,
    selectable = _ref$selectable === void 0 ? true : _ref$selectable,
    _ref$multiple = _ref.multiple,
    multiple = _ref$multiple === void 0 ? false : _ref$multiple,
    defaultSelectedKeys = _ref.defaultSelectedKeys,
    selectedKeys = _ref.selectedKeys,
    onSelect = _ref.onSelect,
    onDeselect = _ref.onDeselect,
    _ref$inlineIndent = _ref.inlineIndent,
    inlineIndent = _ref$inlineIndent === void 0 ? 24 : _ref$inlineIndent,
    motion = _ref.motion,
    defaultMotions = _ref.defaultMotions,
    _ref$triggerSubMenuAc = _ref.triggerSubMenuAction,
    triggerSubMenuAction = _ref$triggerSubMenuAc === void 0 ? 'hover' : _ref$triggerSubMenuAc,
    builtinPlacements = _ref.builtinPlacements,
    itemIcon = _ref.itemIcon,
    expandIcon = _ref.expandIcon,
    _ref$overflowedIndica = _ref.overflowedIndicator,
    overflowedIndicator = _ref$overflowedIndica === void 0 ? '...' : _ref$overflowedIndica,
    overflowedIndicatorPopupClassName = _ref.overflowedIndicatorPopupClassName,
    getPopupContainer = _ref.getPopupContainer,
    onClick = _ref.onClick,
    onOpenChange = _ref.onOpenChange,
    onKeyDown = _ref.onKeyDown;
    _ref.openAnimation;
    _ref.openTransitionName;
    var _internalRenderMenuItem = _ref._internalRenderMenuItem,
    _internalRenderSubMenuItem = _ref._internalRenderSubMenuItem,
    restProps = _objectWithoutProperties(_ref, _excluded$t);
  var childList = react.exports.useMemo(function () {
    return parseItems(children, items, EMPTY_LIST$4);
  }, [children, items]);
  var _React$useState = react.exports.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    mounted = _React$useState2[0],
    setMounted = _React$useState2[1];
  var containerRef = react.exports.useRef();
  var uuid = useUUID(id);
  var isRtl = direction === 'rtl'; // ========================= Warn =========================

  var _useMergedState = useMergedState$1(defaultOpenKeys, {
      value: openKeys,
      postState: function postState(keys) {
        return keys || EMPTY_LIST$4;
      }
    }),
    _useMergedState2 = _slicedToArray(_useMergedState, 2),
    mergedOpenKeys = _useMergedState2[0],
    setMergedOpenKeys = _useMergedState2[1];
  var triggerOpenKeys = function triggerOpenKeys(keys) {
    setMergedOpenKeys(keys);
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(keys);
  }; // >>>>> Cache & Reset open keys when inlineCollapsed changed

  var _React$useState3 = react.exports.useState(mergedOpenKeys),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    inlineCacheOpenKeys = _React$useState4[0],
    setInlineCacheOpenKeys = _React$useState4[1];
  var mountRef = react.exports.useRef(false); // ========================= Mode =========================

  var _React$useMemo = react.exports.useMemo(function () {
      if ((mode === 'inline' || mode === 'vertical') && inlineCollapsed) {
        return ['vertical', inlineCollapsed];
      }
      return [mode, false];
    }, [mode, inlineCollapsed]),
    _React$useMemo2 = _slicedToArray(_React$useMemo, 2),
    mergedMode = _React$useMemo2[0],
    mergedInlineCollapsed = _React$useMemo2[1];
  var isInlineMode = mergedMode === 'inline';
  var _React$useState5 = react.exports.useState(mergedMode),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    internalMode = _React$useState6[0],
    setInternalMode = _React$useState6[1];
  var _React$useState7 = react.exports.useState(mergedInlineCollapsed),
    _React$useState8 = _slicedToArray(_React$useState7, 2),
    internalInlineCollapsed = _React$useState8[0],
    setInternalInlineCollapsed = _React$useState8[1];
  react.exports.useEffect(function () {
    setInternalMode(mergedMode);
    setInternalInlineCollapsed(mergedInlineCollapsed);
    if (!mountRef.current) {
      return;
    } // Synchronously update MergedOpenKeys

    if (isInlineMode) {
      setMergedOpenKeys(inlineCacheOpenKeys);
    } else {
      // Trigger open event in case its in control
      triggerOpenKeys(EMPTY_LIST$4);
    }
  }, [mergedMode, mergedInlineCollapsed]); // ====================== Responsive ======================

  var _React$useState9 = react.exports.useState(0),
    _React$useState10 = _slicedToArray(_React$useState9, 2),
    lastVisibleIndex = _React$useState10[0],
    setLastVisibleIndex = _React$useState10[1];
  var allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== 'horizontal' || disabledOverflow; // Cache

  react.exports.useEffect(function () {
    if (isInlineMode) {
      setInlineCacheOpenKeys(mergedOpenKeys);
    }
  }, [mergedOpenKeys]);
  react.exports.useEffect(function () {
    mountRef.current = true;
    return function () {
      mountRef.current = false;
    };
  }, []); // ========================= Path =========================

  var _useKeyRecords = useKeyRecords(),
    registerPath = _useKeyRecords.registerPath,
    unregisterPath = _useKeyRecords.unregisterPath,
    refreshOverflowKeys = _useKeyRecords.refreshOverflowKeys,
    isSubPathKey = _useKeyRecords.isSubPathKey,
    getKeyPath = _useKeyRecords.getKeyPath,
    getKeys = _useKeyRecords.getKeys,
    getSubPathKeys = _useKeyRecords.getSubPathKeys;
  var registerPathContext = react.exports.useMemo(function () {
    return {
      registerPath: registerPath,
      unregisterPath: unregisterPath
    };
  }, [registerPath, unregisterPath]);
  var pathUserContext = react.exports.useMemo(function () {
    return {
      isSubPathKey: isSubPathKey
    };
  }, [isSubPathKey]);
  react.exports.useEffect(function () {
    refreshOverflowKeys(allVisible ? EMPTY_LIST$4 : childList.slice(lastVisibleIndex + 1).map(function (child) {
      return child.key;
    }));
  }, [lastVisibleIndex, allVisible]); // ======================== Active ========================

  var _useMergedState3 = useMergedState$1(activeKey || defaultActiveFirst && ((_childList$ = childList[0]) === null || _childList$ === void 0 ? void 0 : _childList$.key), {
      value: activeKey
    }),
    _useMergedState4 = _slicedToArray(_useMergedState3, 2),
    mergedActiveKey = _useMergedState4[0],
    setMergedActiveKey = _useMergedState4[1];
  var onActive = useMemoCallback(function (key) {
    setMergedActiveKey(key);
  });
  var onInactive = useMemoCallback(function () {
    setMergedActiveKey(undefined);
  });
  react.exports.useImperativeHandle(ref, function () {
    return {
      list: containerRef.current,
      focus: function focus(options) {
        var _childList$find;
        var shouldFocusKey = mergedActiveKey !== null && mergedActiveKey !== void 0 ? mergedActiveKey : (_childList$find = childList.find(function (node) {
          return !node.props.disabled;
        })) === null || _childList$find === void 0 ? void 0 : _childList$find.key;
        if (shouldFocusKey) {
          var _containerRef$current, _containerRef$current2, _containerRef$current3;
          (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.querySelector("li[data-menu-id='".concat(getMenuId(uuid, shouldFocusKey), "']"))) === null || _containerRef$current2 === void 0 ? void 0 : (_containerRef$current3 = _containerRef$current2.focus) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.call(_containerRef$current2, options);
        }
      }
    };
  }); // ======================== Select ========================
  // >>>>> Select keys

  var _useMergedState5 = useMergedState$1(defaultSelectedKeys || [], {
      value: selectedKeys,
      // Legacy convert key to array
      postState: function postState(keys) {
        if (Array.isArray(keys)) {
          return keys;
        }
        if (keys === null || keys === undefined) {
          return EMPTY_LIST$4;
        }
        return [keys];
      }
    }),
    _useMergedState6 = _slicedToArray(_useMergedState5, 2),
    mergedSelectKeys = _useMergedState6[0],
    setMergedSelectKeys = _useMergedState6[1]; // >>>>> Trigger select

  var triggerSelection = function triggerSelection(info) {
    if (selectable) {
      // Insert or Remove
      var targetKey = info.key;
      var exist = mergedSelectKeys.includes(targetKey);
      var newSelectKeys;
      if (multiple) {
        if (exist) {
          newSelectKeys = mergedSelectKeys.filter(function (key) {
            return key !== targetKey;
          });
        } else {
          newSelectKeys = [].concat(_toConsumableArray(mergedSelectKeys), [targetKey]);
        }
      } else {
        newSelectKeys = [targetKey];
      }
      setMergedSelectKeys(newSelectKeys); // Trigger event

      var selectInfo = _objectSpread2$1(_objectSpread2$1({}, info), {}, {
        selectedKeys: newSelectKeys
      });
      if (exist) {
        onDeselect === null || onDeselect === void 0 ? void 0 : onDeselect(selectInfo);
      } else {
        onSelect === null || onSelect === void 0 ? void 0 : onSelect(selectInfo);
      }
    } // Whatever selectable, always close it

    if (!multiple && mergedOpenKeys.length && internalMode !== 'inline') {
      triggerOpenKeys(EMPTY_LIST$4);
    }
  }; // ========================= Open =========================

  /**
   * Click for item. SubMenu do not have selection status
   */

  var onInternalClick = useMemoCallback(function (info) {
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info));
    triggerSelection(info);
  });
  var onInternalOpenChange = useMemoCallback(function (key, open) {
    var newOpenKeys = mergedOpenKeys.filter(function (k) {
      return k !== key;
    });
    if (open) {
      newOpenKeys.push(key);
    } else if (internalMode !== 'inline') {
      // We need find all related popup to close
      var subPathKeys = getSubPathKeys(key);
      newOpenKeys = newOpenKeys.filter(function (k) {
        return !subPathKeys.has(k);
      });
    }
    if (!shallowequal(mergedOpenKeys, newOpenKeys)) {
      triggerOpenKeys(newOpenKeys);
    }
  });
  var getInternalPopupContainer = useMemoCallback(getPopupContainer); // ==================== Accessibility =====================

  var triggerAccessibilityOpen = function triggerAccessibilityOpen(key, open) {
    var nextOpen = open !== null && open !== void 0 ? open : !mergedOpenKeys.includes(key);
    onInternalOpenChange(key, nextOpen);
  };
  var onInternalKeyDown = useAccessibility$1(internalMode, mergedActiveKey, isRtl, uuid, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown); // ======================== Effect ========================

  react.exports.useEffect(function () {
    setMounted(true);
  }, []); // ======================= Context ========================

  var privateContext = react.exports.useMemo(function () {
    return {
      _internalRenderMenuItem: _internalRenderMenuItem,
      _internalRenderSubMenuItem: _internalRenderSubMenuItem
    };
  }, [_internalRenderMenuItem, _internalRenderSubMenuItem]); // ======================== Render ========================
  // >>>>> Children

  var wrappedChildList = internalMode !== 'horizontal' || disabledOverflow ? childList :
  // Need wrap for overflow dropdown that do not response for open
  childList.map(function (child, index) {
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      // Always wrap provider to avoid sub node re-mount
      jsx$1(InheritableContextProvider, {
        overflowDisabled: index > lastVisibleIndex,
        children: child
      }, child.key)
    );
  }); // >>>>> Container

  var container =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(ForwardOverflow, {
    id: id,
    ref: containerRef,
    prefixCls: "".concat(prefixCls, "-overflow"),
    component: "ul",
    itemComponent: MenuItem$1,
    className: classNames$1(prefixCls, "".concat(prefixCls, "-root"), "".concat(prefixCls, "-").concat(internalMode), className, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-inline-collapsed"), internalInlineCollapsed), _defineProperty$1(_classNames, "".concat(prefixCls, "-rtl"), isRtl), _classNames), rootClassName),
    dir: direction,
    style: style,
    role: "menu",
    tabIndex: tabIndex,
    data: wrappedChildList,
    renderRawItem: function renderRawItem(node) {
      return node;
    },
    renderRawRest: function renderRawRest(omitItems) {
      // We use origin list since wrapped list use context to prevent open
      var len = omitItems.length;
      var originOmitItems = len ? childList.slice(-len) : null;
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(SubMenu$2, {
          eventKey: OVERFLOW_KEY,
          title: overflowedIndicator,
          disabled: allVisible,
          internalPopupClose: len === 0,
          popupClassName: overflowedIndicatorPopupClassName,
          children: originOmitItems
        })
      );
    },
    maxCount: internalMode !== 'horizontal' || disabledOverflow ? ForwardOverflow.INVALIDATE : ForwardOverflow.RESPONSIVE,
    ssr: "full",
    "data-menu-list": true,
    onVisibleChange: function onVisibleChange(newLastIndex) {
      setLastVisibleIndex(newLastIndex);
    },
    onKeyDown: onInternalKeyDown,
    ...restProps
  }); // >>>>> Render

  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(PrivateContext.Provider, {
      value: privateContext,
      children: /*#__PURE__*/jsx$1(IdContext.Provider, {
        value: uuid,
        children: /*#__PURE__*/jsxs(InheritableContextProvider, {
          prefixCls: prefixCls,
          rootClassName: rootClassName,
          mode: internalMode,
          openKeys: mergedOpenKeys,
          rtl: isRtl,
          disabled: disabled,
          motion: mounted ? motion : null,
          defaultMotions: mounted ? defaultMotions : null,
          activeKey: mergedActiveKey,
          onActive: onActive,
          onInactive: onInactive,
          selectedKeys: mergedSelectKeys,
          inlineIndent: inlineIndent,
          subMenuOpenDelay: subMenuOpenDelay,
          subMenuCloseDelay: subMenuCloseDelay,
          forceSubMenuRender: forceSubMenuRender,
          builtinPlacements: builtinPlacements,
          triggerSubMenuAction: triggerSubMenuAction,
          getPopupContainer: getInternalPopupContainer,
          itemIcon: itemIcon,
          expandIcon: expandIcon,
          onItemClick: onInternalClick,
          onOpenChange: onInternalOpenChange,
          children: [/*#__PURE__*/jsx$1(PathUserContext.Provider, {
            value: pathUserContext,
            children: container
          }), /*#__PURE__*/jsx$1("div", {
            style: {
              display: 'none'
            },
            "aria-hidden": true,
            children: /*#__PURE__*/jsx$1(PathRegisterContext.Provider, {
              value: registerPathContext,
              children: childList
            })
          })]
        })
      })
    })
  );
});

var _excluded$s = ["className", "title", "eventKey", "children"],
  _excluded2$3 = ["children"];
var InternalMenuItemGroup = function InternalMenuItemGroup(_ref) {
  var className = _ref.className,
    title = _ref.title;
    _ref.eventKey;
    var children = _ref.children,
    restProps = _objectWithoutProperties(_ref, _excluded$s);
  var _React$useContext = react.exports.useContext(MenuContext$2),
    prefixCls = _React$useContext.prefixCls;
  var groupPrefixCls = "".concat(prefixCls, "-item-group");
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("li", {
      ...restProps,
      onClick: function onClick(e) {
        return e.stopPropagation();
      },
      className: classNames$1(groupPrefixCls, className),
      children: [/*#__PURE__*/jsx$1("div", {
        className: "".concat(groupPrefixCls, "-title"),
        title: typeof title === 'string' ? title : undefined,
        children: title
      }), /*#__PURE__*/jsx$1("ul", {
        className: "".concat(groupPrefixCls, "-list"),
        children: children
      })]
    })
  );
};
function MenuItemGroup(_ref2) {
  var children = _ref2.children,
    props = _objectWithoutProperties(_ref2, _excluded2$3);
  var connectedKeyPath = useFullPath(props.eventKey);
  var childList = parseChildren(children, connectedKeyPath);
  var measure = useMeasure();
  if (measure) {
    return childList;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(InternalMenuItemGroup, {
      ...omit(props, ['warnKey']),
      children: childList
    })
  );
}

function Divider(_ref) {
  var className = _ref.className,
    style = _ref.style;
  var _React$useContext = react.exports.useContext(MenuContext$2),
    prefixCls = _React$useContext.prefixCls;
  var measure = useMeasure();
  if (measure) {
    return null;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("li", {
      className: classNames$1("".concat(prefixCls, "-item-divider"), className),
      style: style
    })
  );
}

var ExportMenu = Menu$3;
ExportMenu.Item = MenuItem$1;
ExportMenu.SubMenu = SubMenu$2;
ExportMenu.ItemGroup = MenuItemGroup;
ExportMenu.Divider = Divider;

// This icon file is generated automatically.
var EllipsisOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "ellipsis", "theme": "outlined" };
const EllipsisOutlinedSvg = EllipsisOutlined$2;

var EllipsisOutlined = function EllipsisOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: EllipsisOutlinedSvg
      })
    })
  );
};
EllipsisOutlined.displayName = 'EllipsisOutlined';
const EllipsisOutlined$1 = /*#__PURE__*/react.exports.forwardRef(EllipsisOutlined);

var getHorizontalStyle = function getHorizontalStyle(token) {
  var _ref;
  var componentCls = token.componentCls,
    motionDurationSlow = token.motionDurationSlow,
    menuHorizontalHeight = token.menuHorizontalHeight,
    colorSplit = token.colorSplit,
    lineWidth = token.lineWidth,
    lineType = token.lineType,
    menuItemPaddingInline = token.menuItemPaddingInline;
  return _defineProperty$1({}, componentCls + "-horizontal", (_ref = {
    lineHeight: menuHorizontalHeight + "px",
    border: 0,
    borderBottom: lineWidth + "px " + lineType + " " + colorSplit,
    boxShadow: 'none',
    '&::after': {
      display: 'block',
      clear: 'both',
      height: 0,
      content: '"\\20"'
    }
  }, _defineProperty$1(_ref, componentCls + "-item, " + componentCls + "-submenu", {
    position: 'relative',
    display: 'inline-block',
    verticalAlign: 'bottom',
    paddingInline: menuItemPaddingInline
  }), _defineProperty$1(_ref, "> " + componentCls + "-item:hover,\n        > " + componentCls + "-item-active,\n        > " + componentCls + "-submenu " + componentCls + "-submenu-title:hover", {
    backgroundColor: 'transparent'
  }), _defineProperty$1(_ref, componentCls + "-item, " + componentCls + "-submenu-title", {
    transition: ["border-color " + motionDurationSlow, "background " + motionDurationSlow].join(',')
  }), _defineProperty$1(_ref, componentCls + "-submenu-arrow", {
    display: 'none'
  }), _ref));
};
const getHorizontalStyle$1 = getHorizontalStyle;

var getRTLStyle = function getRTLStyle(_ref) {
  var _ref3;
  var componentCls = _ref.componentCls,
    menuArrowOffset = _ref.menuArrowOffset;
  return _ref3 = {}, _defineProperty$1(_ref3, componentCls + "-rtl", {
    direction: 'rtl'
  }), _defineProperty$1(_ref3, componentCls + "-submenu-rtl", {
    transformOrigin: '100% 0'
  }), _defineProperty$1(_ref3, componentCls + "-rtl" + componentCls + "-vertical,\n    " + componentCls + "-submenu-rtl " + componentCls + "-vertical", _defineProperty$1({}, componentCls + "-submenu-arrow", {
    '&::before': {
      transform: "rotate(-45deg) translateY(-" + menuArrowOffset + ")"
    },
    '&::after': {
      transform: "rotate(45deg) translateY(" + menuArrowOffset + ")"
    }
  })), _ref3;
};
const getRTLStyle$1 = getRTLStyle;

var accessibilityFocus = function accessibilityFocus(token) {
  return _extends$2({}, genFocusOutline(token));
};
var getThemeStyle = function getThemeStyle(token, themeSuffix) {
  var _ref3, _ref5, _ref6, _ref9, _ref12, _ref13;
  var componentCls = token.componentCls,
    colorItemText = token.colorItemText,
    colorItemTextSelected = token.colorItemTextSelected,
    colorItemTextSelectedHorizontal = token.colorItemTextSelectedHorizontal,
    colorGroupTitle = token.colorGroupTitle,
    colorItemBg = token.colorItemBg,
    colorSubItemBg = token.colorSubItemBg,
    colorItemBgSelectedHorizontal = token.colorItemBgSelectedHorizontal,
    colorItemBgSelected = token.colorItemBgSelected,
    colorActiveBarHeight = token.colorActiveBarHeight,
    colorActiveBarWidth = token.colorActiveBarWidth,
    colorActiveBarBorderSize = token.colorActiveBarBorderSize,
    motionDurationSlow = token.motionDurationSlow,
    motionEaseInOut = token.motionEaseInOut,
    motionEaseOut = token.motionEaseOut,
    menuItemPaddingInline = token.menuItemPaddingInline,
    motionDurationMid = token.motionDurationMid,
    colorItemTextHover = token.colorItemTextHover,
    lineType = token.lineType,
    colorSplit = token.colorSplit,
    colorItemTextDisabled = token.colorItemTextDisabled,
    colorDangerItemText = token.colorDangerItemText,
    colorDangerItemTextHover = token.colorDangerItemTextHover,
    colorDangerItemTextSelected = token.colorDangerItemTextSelected,
    colorDangerItemBgActive = token.colorDangerItemBgActive,
    colorDangerItemBgSelected = token.colorDangerItemBgSelected,
    colorItemBgHover = token.colorItemBgHover,
    menuSubMenuBg = token.menuSubMenuBg;
  return _defineProperty$1({}, componentCls + "-" + themeSuffix, (_ref13 = {
    color: colorItemText,
    background: colorItemBg
  }, _defineProperty$1(_ref13, "&" + componentCls + "-root:focus-visible", _extends$2({}, accessibilityFocus(token))), _defineProperty$1(_ref13, componentCls + "-item-group-title", {
    color: colorGroupTitle
  }), _defineProperty$1(_ref13, componentCls + "-submenu-selected", _defineProperty$1({}, "> " + componentCls + "-submenu-title", {
    color: colorItemTextSelected
  })), _defineProperty$1(_ref13, componentCls + "-item-disabled, " + componentCls + "-submenu-disabled", {
    color: colorItemTextDisabled + " !important"
  }), _defineProperty$1(_ref13, componentCls + "-item:hover, " + componentCls + "-submenu-title:hover", _defineProperty$1({}, "&:not(" + componentCls + "-item-selected):not(" + componentCls + "-submenu-selected)", {
    color: colorItemTextHover
  })), _defineProperty$1(_ref13, "&:not(" + componentCls + "-horizontal)", (_ref3 = {}, _defineProperty$1(_ref3, componentCls + "-item:not(" + componentCls + "-item-selected)", {
    '&:hover': {
      backgroundColor: colorItemBgHover
    },
    '&:active': {
      backgroundColor: colorItemBgSelected
    }
  }), _defineProperty$1(_ref3, componentCls + "-submenu-title", {
    '&:hover': {
      backgroundColor: colorItemBgHover
    },
    '&:active': {
      backgroundColor: colorItemBgSelected
    }
  }), _ref3)), _defineProperty$1(_ref13, componentCls + "-item-danger", (_ref5 = {
    color: colorDangerItemText
  }, _defineProperty$1(_ref5, "&" + componentCls + "-item:hover", _defineProperty$1({}, "&:not(" + componentCls + "-item-selected):not(" + componentCls + "-submenu-selected)", {
    color: colorDangerItemTextHover
  })), _defineProperty$1(_ref5, "&" + componentCls + "-item:active", {
    background: colorDangerItemBgActive
  }), _ref5)), _defineProperty$1(_ref13, componentCls + "-item a", {
    '&, &:hover': {
      color: 'inherit'
    }
  }), _defineProperty$1(_ref13, componentCls + "-item-selected", (_ref6 = {
    color: colorItemTextSelected
  }, _defineProperty$1(_ref6, "&" + componentCls + "-item-danger", {
    color: colorDangerItemTextSelected
  }), _defineProperty$1(_ref6, "a, a:hover", {
    color: 'inherit'
  }), _ref6)), _defineProperty$1(_ref13, "&:not(" + componentCls + "-horizontal) " + componentCls + "-item-selected", _defineProperty$1({
    backgroundColor: colorItemBgSelected
  }, "&" + componentCls + "-item-danger", {
    backgroundColor: colorDangerItemBgSelected
  })), _defineProperty$1(_ref13, componentCls + "-item, " + componentCls + "-submenu-title", _defineProperty$1({}, "&:not(" + componentCls + "-item-disabled):focus-visible", _extends$2({}, accessibilityFocus(token)))), _defineProperty$1(_ref13, "&" + componentCls + "-submenu > " + componentCls, {
    backgroundColor: menuSubMenuBg
  }), _defineProperty$1(_ref13, "&" + componentCls + "-popup > " + componentCls, {
    backgroundColor: colorItemBg
  }), _defineProperty$1(_ref13, "&" + componentCls + "-horizontal", _extends$2(_extends$2({}, themeSuffix === 'dark' ? {
    borderBottom: 0
  } : {}), _defineProperty$1({}, "> " + componentCls + "-item, > " + componentCls + "-submenu", (_ref9 = {
    top: colorActiveBarBorderSize,
    marginTop: -colorActiveBarBorderSize,
    marginBottom: 0,
    borderRadius: token.radiusItem,
    '&::after': {
      position: 'absolute',
      insetInline: menuItemPaddingInline,
      bottom: 0,
      borderBottom: colorActiveBarHeight + "px solid transparent",
      transition: "border-color " + motionDurationSlow + " " + motionEaseInOut,
      content: '""'
    }
  }, _defineProperty$1(_ref9, "&:hover, &-active, &-open", {
    '&::after': {
      borderWidth: colorActiveBarHeight + "px",
      borderBottomColor: colorItemTextSelectedHorizontal
    }
  }), _defineProperty$1(_ref9, "&-selected", {
    color: colorItemTextSelectedHorizontal,
    backgroundColor: colorItemBgSelectedHorizontal,
    '&::after': {
      borderWidth: colorActiveBarHeight + "px",
      borderBottomColor: colorItemTextSelectedHorizontal
    }
  }), _ref9)))), _defineProperty$1(_ref13, "&" + componentCls + "-root", _defineProperty$1({}, "&" + componentCls + "-inline, &" + componentCls + "-vertical", {
    borderInlineEnd: colorActiveBarBorderSize + "px " + lineType + " " + colorSplit
  })), _defineProperty$1(_ref13, "&" + componentCls + "-inline", (_ref12 = {}, _defineProperty$1(_ref12, componentCls + "-sub" + componentCls + "-inline", {
    background: colorSubItemBg
  }), _defineProperty$1(_ref12, componentCls + "-item, " + componentCls + "-submenu-title", colorActiveBarBorderSize && colorActiveBarWidth ? {
    width: "calc(100% + " + colorActiveBarBorderSize + "px)"
  } : {}), _defineProperty$1(_ref12, componentCls + "-item", _defineProperty$1({
    position: 'relative',
    '&::after': {
      position: 'absolute',
      insetBlock: 0,
      insetInlineEnd: 0,
      borderInlineEnd: colorActiveBarWidth + "px solid " + colorItemTextSelected,
      transform: 'scaleY(0.0001)',
      opacity: 0,
      transition: ["transform " + motionDurationMid + " " + motionEaseOut, "opacity " + motionDurationMid + " " + motionEaseOut].join(','),
      content: '""'
    }
  }, "&" + componentCls + "-item-danger", {
    '&::after': {
      borderInlineEndColor: colorDangerItemTextSelected
    }
  })), _defineProperty$1(_ref12, componentCls + "-selected, " + componentCls + "-item-selected", {
    '&::after': {
      transform: 'scaleY(1)',
      opacity: 1,
      transition: ["transform " + motionDurationMid + " " + motionEaseInOut, "opacity " + motionDurationMid + " " + motionEaseInOut].join(',')
    }
  }), _ref12)), _ref13));
};
const getThemeStyle$1 = getThemeStyle;

var getVerticalInlineStyle = function getVerticalInlineStyle(token) {
  var _ref;
  var componentCls = token.componentCls,
    menuItemHeight = token.menuItemHeight,
    itemMarginInline = token.itemMarginInline,
    padding = token.padding,
    menuArrowSize = token.menuArrowSize,
    marginXS = token.marginXS,
    marginXXS = token.marginXXS;
  var paddingWithArrow = padding + menuArrowSize + marginXS;
  return _ref = {}, _defineProperty$1(_ref, componentCls + "-item", {
    position: 'relative'
  }), _defineProperty$1(_ref, componentCls + "-item, " + componentCls + "-submenu-title", {
    height: menuItemHeight,
    lineHeight: menuItemHeight + "px",
    paddingInline: padding,
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    marginInline: itemMarginInline,
    marginBlock: marginXXS,
    width: "calc(100% - " + itemMarginInline * 2 + "px)"
  }), _defineProperty$1(_ref, componentCls + "-submenu", {
    paddingBottom: 0.02
  }), _defineProperty$1(_ref, "> " + componentCls + "-item,\n            > " + componentCls + "-submenu > " + componentCls + "-submenu-title", {
    height: menuItemHeight,
    lineHeight: menuItemHeight + "px"
  }), _defineProperty$1(_ref, componentCls + "-item-group-list " + componentCls + "-submenu-title,\n            " + componentCls + "-submenu-title", {
    paddingInlineEnd: paddingWithArrow
  }), _ref;
};
var getVerticalStyle = function getVerticalStyle(token) {
  var _ref3, _ref5, _ref7, _ref8, _ref12, _tooltip, _ref13;
  var componentCls = token.componentCls,
    iconCls = token.iconCls,
    menuItemHeight = token.menuItemHeight,
    colorTextLightSolid = token.colorTextLightSolid,
    dropdownWidth = token.dropdownWidth,
    controlHeightLG = token.controlHeightLG,
    motionDurationMid = token.motionDurationMid,
    motionEaseOut = token.motionEaseOut,
    paddingXL = token.paddingXL,
    fontSizeSM = token.fontSizeSM,
    fontSizeLG = token.fontSizeLG,
    motionDurationSlow = token.motionDurationSlow,
    paddingXS = token.paddingXS,
    boxShadowSecondary = token.boxShadowSecondary;
  var inlineItemStyle = {
    height: menuItemHeight,
    lineHeight: menuItemHeight + "px",
    listStylePosition: 'inside',
    listStyleType: 'disc'
  };
  return [(_ref3 = {}, _defineProperty$1(_ref3, componentCls, _defineProperty$1({}, "&-inline, &-vertical", _extends$2(_defineProperty$1({}, "&" + componentCls + "-root", {
    boxShadow: 'none'
  }), getVerticalInlineStyle(token)))), _defineProperty$1(_ref3, componentCls + "-submenu-popup", _defineProperty$1({}, componentCls + "-vertical", _extends$2(_extends$2({}, getVerticalInlineStyle(token)), {
    boxShadow: boxShadowSecondary
  }))), _ref3), // Vertical only
  _defineProperty$1({}, componentCls + "-submenu-popup " + componentCls + "-vertical" + componentCls + "-sub", {
    minWidth: dropdownWidth,
    maxHeight: "calc(100vh - " + controlHeightLG * 2.5 + "px)",
    padding: '0',
    overflow: 'hidden',
    borderInlineEnd: 0,
    // https://github.com/ant-design/ant-design/issues/22244
    // https://github.com/ant-design/ant-design/issues/26812
    "&:not([class*='-active'])": {
      overflowX: 'hidden',
      overflowY: 'auto'
    }
  }), // Inline Only
  _defineProperty$1({}, componentCls + "-inline", (_ref8 = {
    width: '100%'
  }, _defineProperty$1(_ref8, "&" + componentCls + "-root", _defineProperty$1({}, componentCls + "-item, " + componentCls + "-submenu-title", (_ref5 = {
    display: 'flex',
    alignItems: 'center',
    transition: ["border-color " + motionDurationSlow, "background " + motionDurationSlow, "padding " + motionDurationMid + " " + motionEaseOut]
  }, _defineProperty$1(_ref5, "> " + componentCls + "-title-content", {
    flex: 'auto',
    minWidth: 0,
    overflow: 'hidden',
    textOverflow: 'ellipsis'
  }), _defineProperty$1(_ref5, '> *', {
    flex: 'none'
  }), _ref5))), _defineProperty$1(_ref8, componentCls + "-sub" + componentCls + "-inline", (_ref7 = {
    padding: 0,
    border: 0,
    borderRadius: 0,
    boxShadow: 'none'
  }, _defineProperty$1(_ref7, "& > " + componentCls + "-submenu > " + componentCls + "-submenu-title", inlineItemStyle), _defineProperty$1(_ref7, "& " + componentCls + "-item-group-title", {
    paddingInlineStart: paddingXL
  }), _ref7)), _defineProperty$1(_ref8, componentCls + "-item", inlineItemStyle), _ref8)), // Inline Collapse Only
  _defineProperty$1({}, componentCls + "-inline-collapsed", (_ref13 = {
    width: menuItemHeight * 2
  }, _defineProperty$1(_ref13, "&" + componentCls + "-root", _defineProperty$1({}, componentCls + "-item, " + componentCls + "-submenu " + componentCls + "-submenu-title", _defineProperty$1({}, "> " + componentCls + "-inline-collapsed-noicon", {
    fontSize: fontSizeLG,
    textAlign: 'center'
  }))), _defineProperty$1(_ref13, "> " + componentCls + "-item,\n          > " + componentCls + "-item-group > " + componentCls + "-item-group-list > " + componentCls + "-item,\n          > " + componentCls + "-item-group > " + componentCls + "-item-group-list > " + componentCls + "-submenu > " + componentCls + "-submenu-title,\n          > " + componentCls + "-submenu > " + componentCls + "-submenu-title", (_ref12 = {
    insetInlineStart: 0,
    paddingInline: "calc(50% - " + fontSizeSM + "px)",
    textOverflow: 'clip'
  }, _defineProperty$1(_ref12, componentCls + "-submenu-arrow", {
    opacity: 0
  }), _defineProperty$1(_ref12, componentCls + "-item-icon, " + iconCls, {
    margin: 0,
    fontSize: fontSizeLG,
    lineHeight: menuItemHeight + "px",
    '+ span': {
      display: 'inline-block',
      opacity: 0
    }
  }), _ref12)), _defineProperty$1(_ref13, componentCls + "-item-icon, " + iconCls, {
    display: 'inline-block'
  }), _defineProperty$1(_ref13, '&-tooltip', (_tooltip = {
    pointerEvents: 'none'
  }, _defineProperty$1(_tooltip, componentCls + "-item-icon, " + iconCls, {
    display: 'none'
  }), _defineProperty$1(_tooltip, 'a, a:hover', {
    color: colorTextLightSolid
  }), _tooltip)), _defineProperty$1(_ref13, componentCls + "-item-group-title", _extends$2(_extends$2({}, textEllipsis), {
    paddingInline: paddingXS
  })), _ref13))];
};
const getVerticalStyle$1 = getVerticalStyle;

var genMenuItemStyle = function genMenuItemStyle(token) {
  var _ref2, _ref4;
  var componentCls = token.componentCls,
    fontSize = token.fontSize,
    motionDurationSlow = token.motionDurationSlow,
    motionDurationMid = token.motionDurationMid,
    motionEaseInOut = token.motionEaseInOut,
    motionEaseOut = token.motionEaseOut,
    iconCls = token.iconCls,
    controlHeightSM = token.controlHeightSM;
  return _ref4 = {}, _defineProperty$1(_ref4, componentCls + "-item, " + componentCls + "-submenu-title", (_ref2 = {
    position: 'relative',
    display: 'block',
    margin: 0,
    whiteSpace: 'nowrap',
    cursor: 'pointer',
    transition: ["border-color " + motionDurationSlow, "background " + motionDurationSlow, "padding " + motionDurationSlow + " " + motionEaseInOut].join(',')
  }, _defineProperty$1(_ref2, componentCls + "-item-icon, " + iconCls, {
    minWidth: fontSize,
    fontSize: fontSize,
    transition: ["font-size " + motionDurationMid + " " + motionEaseOut, "margin " + motionDurationSlow + " " + motionEaseInOut, "color " + motionDurationSlow].join(','),
    '+ span': {
      marginInlineStart: controlHeightSM - fontSize,
      opacity: 1,
      transition: ["opacity " + motionDurationSlow + " " + motionEaseInOut, "margin " + motionDurationSlow, "color " + motionDurationSlow].join(',')
    }
  }), _defineProperty$1(_ref2, componentCls + "-item-icon", _extends$2({}, resetIcon())), _defineProperty$1(_ref2, "&" + componentCls + "-item-only-child", _defineProperty$1({}, "> " + iconCls + ", > " + componentCls + "-item-icon", {
    marginInlineEnd: 0
  })), _ref2)), _defineProperty$1(_ref4, componentCls + "-item-disabled, " + componentCls + "-submenu-disabled", _defineProperty$1({
    background: 'none !important',
    cursor: 'not-allowed',
    '&::after': {
      borderColor: 'transparent !important'
    },
    a: {
      color: 'inherit !important'
    }
  }, "> " + componentCls + "-submenu-title", {
    color: 'inherit !important',
    cursor: 'not-allowed'
  })), _ref4;
};
var genSubMenuArrowStyle = function genSubMenuArrowStyle(token) {
  var _ref5;
  var componentCls = token.componentCls,
    motionDurationSlow = token.motionDurationSlow,
    motionEaseInOut = token.motionEaseInOut,
    borderRadius = token.borderRadius,
    menuArrowSize = token.menuArrowSize,
    menuArrowOffset = token.menuArrowOffset;
  return _defineProperty$1({}, componentCls + "-submenu", (_ref5 = {}, _defineProperty$1(_ref5, "&-expand-icon, &-arrow", {
    position: 'absolute',
    top: '50%',
    insetInlineEnd: token.margin,
    width: menuArrowSize,
    color: 'currentcolor',
    transform: 'translateY(-50%)',
    transition: "transform " + motionDurationSlow + " " + motionEaseInOut
  }), _defineProperty$1(_ref5, '&-arrow', {
    // 
    '&::before, &::after': {
      position: 'absolute',
      width: menuArrowSize * 0.6,
      height: menuArrowSize * 0.15,
      backgroundColor: 'currentcolor',
      borderRadius: borderRadius,
      transition: ["background " + motionDurationSlow + " " + motionEaseInOut, "transform " + motionDurationSlow + " " + motionEaseInOut, "top " + motionDurationSlow + " " + motionEaseInOut, "color " + motionDurationSlow + " " + motionEaseInOut].join(','),
      content: '""'
    },
    '&::before': {
      transform: "rotate(45deg) translateY(-" + menuArrowOffset + ")"
    },
    '&::after': {
      transform: "rotate(-45deg) translateY(" + menuArrowOffset + ")"
    }
  }), _ref5));
};
// =============================== Base ===============================
var getBaseStyle = function getBaseStyle(token) {
  var _extends3, _extends4, _extends5, _extends6;
  var antCls = token.antCls,
    componentCls = token.componentCls,
    fontSize = token.fontSize,
    motionDurationSlow = token.motionDurationSlow,
    motionDurationMid = token.motionDurationMid,
    motionEaseInOut = token.motionEaseInOut,
    lineHeight = token.lineHeight,
    paddingXS = token.paddingXS,
    padding = token.padding,
    colorSplit = token.colorSplit,
    lineWidth = token.lineWidth,
    zIndexPopup = token.zIndexPopup,
    borderRadiusLG = token.borderRadiusLG,
    radiusSubMenuItem = token.radiusSubMenuItem,
    menuArrowSize = token.menuArrowSize,
    menuArrowOffset = token.menuArrowOffset,
    lineType = token.lineType,
    menuPanelMaskInset = token.menuPanelMaskInset;
  return [// Misc
  _defineProperty$1({
    '': _defineProperty$1({}, "" + componentCls, _extends$2(_extends$2({}, clearFix()), _defineProperty$1({}, "&-hidden", {
      display: 'none'
    })))
  }, componentCls + "-submenu-hidden", {
    display: 'none'
  }), _defineProperty$1({}, componentCls, _extends$2(_extends$2(_extends$2(_extends$2(_extends$2(_extends$2(_extends$2({}, resetComponent(token)), clearFix()), (_extends3 = {
    marginBottom: 0,
    paddingInlineStart: 0,
    // Override default ul/ol
    fontSize: fontSize,
    lineHeight: 0,
    listStyle: 'none',
    outline: 'none',
    transition: ["background " + motionDurationSlow, // Magic cubic here but smooth transition
    "width " + motionDurationSlow + " cubic-bezier(0.2, 0, 0, 1) 0s"].join(',')
  }, _defineProperty$1(_extends3, "ul, ol", {
    margin: 0,
    padding: 0,
    listStyle: 'none'
  }), _defineProperty$1(_extends3, "&-overflow", _defineProperty$1({
    display: 'flex'
  }, componentCls + "-item", {
    flex: 'none'
  })), _defineProperty$1(_extends3, componentCls + "-item, " + componentCls + "-submenu, " + componentCls + "-submenu-title", {
    borderRadius: token.radiusItem
  }), _defineProperty$1(_extends3, componentCls + "-item-group-title", {
    padding: paddingXS + "px " + padding + "px",
    fontSize: fontSize,
    lineHeight: lineHeight,
    transition: "all " + motionDurationSlow
  }), _defineProperty$1(_extends3, "&-horizontal " + componentCls + "-submenu", {
    transition: ["border-color " + motionDurationSlow + " " + motionEaseInOut, "background " + motionDurationSlow + " " + motionEaseInOut].join(',')
  }), _defineProperty$1(_extends3, componentCls + "-submenu, " + componentCls + "-submenu-inline", {
    transition: ["border-color " + motionDurationSlow + " " + motionEaseInOut, "background " + motionDurationSlow + " " + motionEaseInOut, "padding " + motionDurationMid + " " + motionEaseInOut].join(',')
  }), _defineProperty$1(_extends3, componentCls + "-submenu " + componentCls + "-sub", {
    cursor: 'initial',
    transition: ["background " + motionDurationSlow + " " + motionEaseInOut, "padding " + motionDurationSlow + " " + motionEaseInOut]
  }), _defineProperty$1(_extends3, componentCls + "-title-content", {
    transition: "color " + motionDurationSlow
  }), _defineProperty$1(_extends3, componentCls + "-item a", {
    '&::before': {
      position: 'absolute',
      inset: 0,
      backgroundColor: 'transparent',
      content: '""'
    }
  }), _defineProperty$1(_extends3, componentCls + "-item-divider", {
    overflow: 'hidden',
    lineHeight: 0,
    borderColor: colorSplit,
    borderStyle: lineType,
    borderTopWidth: lineWidth,
    marginBlock: lineWidth,
    padding: 0,
    '&-dashed': {
      borderStyle: 'dashed'
    }
  }), _extends3)), genMenuItemStyle(token)), (_extends5 = {}, _defineProperty$1(_extends5, componentCls + "-item-group", _defineProperty$1({}, componentCls + "-item-group-list", _defineProperty$1({
    margin: 0,
    padding: 0
  }, componentCls + "-item, " + componentCls + "-submenu-title", {
    paddingInline: fontSize * 2 + "px " + padding + "px"
  }))), _defineProperty$1(_extends5, '&-submenu', _defineProperty$1({
    '&-popup': {
      position: 'absolute',
      zIndex: zIndexPopup,
      background: 'transparent',
      borderRadius: borderRadiusLG,
      boxShadow: 'none',
      transformOrigin: '0 0',
      // https://github.com/ant-design/ant-design/issues/13955
      '&::before': {
        position: 'absolute',
        inset: menuPanelMaskInset + "px 0 0",
        zIndex: -1,
        width: '100%',
        height: '100%',
        opacity: 0,
        content: '""'
      }
    },
    // https://github.com/ant-design/ant-design/issues/13955
    '&-placement-rightTop::before': {
      top: 0,
      insetInlineStart: menuPanelMaskInset
    }
  }, "> " + componentCls, _extends$2(_extends$2(_extends$2({
    borderRadius: borderRadiusLG
  }, genMenuItemStyle(token)), genSubMenuArrowStyle(token)), (_extends4 = {}, _defineProperty$1(_extends4, componentCls + "-item, " + componentCls + "-submenu > " + componentCls + "-submenu-title", {
    borderRadius: radiusSubMenuItem
  }), _defineProperty$1(_extends4, componentCls + "-submenu-title::after", {
    transition: "transform " + motionDurationSlow + " " + motionEaseInOut
  }), _extends4)))), _extends5)), genSubMenuArrowStyle(token)), (_extends6 = {}, _defineProperty$1(_extends6, "&-inline-collapsed " + componentCls + "-submenu-arrow,\n        &-inline " + componentCls + "-submenu-arrow", {
    // 
    '&::before': {
      transform: "rotate(-45deg) translateX(" + menuArrowOffset + ")"
    },
    '&::after': {
      transform: "rotate(45deg) translateX(-" + menuArrowOffset + ")"
    }
  }), _defineProperty$1(_extends6, componentCls + "-submenu-open" + componentCls + "-submenu-inline > " + componentCls + "-submenu-title > " + componentCls + "-submenu-arrow", {
    // 
    transform: "translateY(-" + menuArrowSize * 0.2 + "px)",
    '&::after': {
      transform: "rotate(-45deg) translateX(-" + menuArrowOffset + ")"
    },
    '&::before': {
      transform: "rotate(45deg) translateX(" + menuArrowOffset + ")"
    }
  }), _extends6))), // Integration with header element so menu items have the same height
  _defineProperty$1({}, antCls + "-layout-header", _defineProperty$1({}, componentCls, {
    lineHeight: 'inherit'
  }))];
};
// ============================== Export ==============================
const useStyle$k = (function (prefixCls, injectStyle) {
  var useOriginHook = genComponentStyleHook('Menu', function (token, _ref14) {
    var overrideComponentToken = _ref14.overrideComponentToken;
    // Dropdown will handle menu style self. We do not need to handle this.
    if (injectStyle === false) {
      return [];
    }
    var colorBgElevated = token.colorBgElevated,
      colorPrimary = token.colorPrimary,
      colorError = token.colorError,
      colorErrorHover = token.colorErrorHover,
      colorTextLightSolid = token.colorTextLightSolid,
      colorTextSecondary = token.colorTextSecondary;
    var controlHeightLG = token.controlHeightLG,
      fontSize = token.fontSize;
    var menuArrowSize = fontSize / 7 * 5;
    // Menu Token
    var menuToken = merge$2(token, {
      menuItemHeight: controlHeightLG,
      menuItemPaddingInline: token.margin,
      menuArrowSize: menuArrowSize,
      menuHorizontalHeight: controlHeightLG * 1.15,
      menuArrowOffset: menuArrowSize * 0.25 + "px",
      menuPanelMaskInset: -7,
      menuSubMenuBg: colorBgElevated
    });
    var menuDarkToken = merge$2(menuToken, {
      colorItemText: new TinyColor(colorTextLightSolid).setAlpha(0.65).toRgbString(),
      colorItemTextHover: colorTextLightSolid,
      colorGroupTitle: colorTextSecondary,
      colorItemTextSelected: colorTextLightSolid,
      colorItemBg: '#001529',
      colorSubItemBg: '#000c17',
      colorItemBgActive: 'transparent',
      colorItemBgSelected: colorPrimary,
      colorActiveBarWidth: 0,
      colorActiveBarHeight: 0,
      colorActiveBarBorderSize: 0,
      // Disabled
      colorItemTextDisabled: new TinyColor(colorTextLightSolid).setAlpha(0.25).toRgbString(),
      // Danger
      colorDangerItemText: colorError,
      colorDangerItemTextHover: colorErrorHover,
      colorDangerItemTextSelected: colorTextLightSolid,
      colorDangerItemBgActive: colorError,
      colorDangerItemBgSelected: colorError,
      menuSubMenuBg: '#001529'
    }, _extends$2({}, overrideComponentToken));
    return [
    // Basic
    getBaseStyle(menuToken),
    // Horizontal
    getHorizontalStyle$1(menuToken),
    // Vertical
    getVerticalStyle$1(menuToken),
    // Theme
    getThemeStyle$1(menuToken, 'light'), getThemeStyle$1(menuDarkToken, 'dark'),
    // RTL
    getRTLStyle$1(menuToken),
    // Motion
    genCollapseMotion$1(menuToken), initSlideMotion(menuToken, 'slide-up'), initSlideMotion(menuToken, 'slide-down'), initZoomMotion(menuToken, 'zoom-big')];
  }, function (token) {
    var colorPrimary = token.colorPrimary,
      colorError = token.colorError,
      colorTextDisabled = token.colorTextDisabled,
      colorErrorBg = token.colorErrorBg,
      colorText = token.colorText,
      colorTextDescription = token.colorTextDescription,
      colorBgContainer = token.colorBgContainer,
      colorFillAlter = token.colorFillAlter,
      colorFillContent = token.colorFillContent,
      lineWidth = token.lineWidth,
      lineWidthBold = token.lineWidthBold,
      controlItemBgActive = token.controlItemBgActive,
      colorBgTextHover = token.colorBgTextHover;
    return {
      dropdownWidth: 160,
      zIndexPopup: token.zIndexPopupBase + 50,
      radiusItem: token.borderRadiusLG,
      radiusSubMenuItem: token.borderRadiusSM,
      colorItemText: colorText,
      colorItemTextHover: colorText,
      colorItemTextHoverHorizontal: colorPrimary,
      colorGroupTitle: colorTextDescription,
      colorItemTextSelected: colorPrimary,
      colorItemTextSelectedHorizontal: colorPrimary,
      colorItemBg: colorBgContainer,
      colorItemBgHover: colorBgTextHover,
      colorItemBgActive: colorFillContent,
      colorSubItemBg: colorFillAlter,
      colorItemBgSelected: controlItemBgActive,
      colorItemBgSelectedHorizontal: 'transparent',
      colorActiveBarWidth: 0,
      colorActiveBarHeight: lineWidthBold,
      colorActiveBarBorderSize: lineWidth,
      // Disabled
      colorItemTextDisabled: colorTextDisabled,
      // Danger
      colorDangerItemText: colorError,
      colorDangerItemTextHover: colorError,
      colorDangerItemTextSelected: colorError,
      colorDangerItemBgActive: colorErrorBg,
      colorDangerItemBgSelected: colorErrorBg,
      itemMarginInline: token.marginXXS
    };
  });
  return useOriginHook(prefixCls);
});

var __rest$K = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var OverrideContext = /*#__PURE__*/react.exports.createContext(null);
/** @internal Only used for Dropdown component. Do not use this in your production. */
var OverrideProvider = function OverrideProvider(props) {
  var children = props.children,
    restProps = __rest$K(props, ["children"]);
  var override = react.exports.useContext(OverrideContext);
  var context = react.exports.useMemo(function () {
    return _extends$2(_extends$2({}, override), restProps);
  }, [override, restProps.prefixCls,
  // restProps.expandIcon, Not mark as deps since this is a ReactNode
  restProps.mode, restProps.selectable
  // restProps.validator, Not mark as deps since this is a function
  ]);

  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(OverrideContext.Provider, {
      value: context,
      children: children
    })
  );
};

var __rest$J = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var MenuDivider = function MenuDivider(props) {
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    dashed = props.dashed,
    restProps = __rest$J(props, ["prefixCls", "className", "dashed"]);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls('menu', customizePrefixCls);
  var classString = classNames$1(_defineProperty$1({}, prefixCls + "-item-divider-dashed", !!dashed), className);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Divider, {
      className: classString,
      ...restProps
    })
  );
};
const MenuDivider$1 = MenuDivider;

// This icon file is generated automatically.
var LeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, "name": "left", "theme": "outlined" };
const LeftOutlinedSvg = LeftOutlined$2;

var LeftOutlined = function LeftOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: LeftOutlinedSvg
      })
    })
  );
};
LeftOutlined.displayName = 'LeftOutlined';
const LeftOutlined$1 = /*#__PURE__*/react.exports.forwardRef(LeftOutlined);

// This icon file is generated automatically.
var RightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, "name": "right", "theme": "outlined" };
const RightOutlinedSvg = RightOutlined$2;

var RightOutlined = function RightOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: RightOutlinedSvg
      })
    })
  );
};
RightOutlined.displayName = 'RightOutlined';
const RightOutlined$1 = /*#__PURE__*/react.exports.forwardRef(RightOutlined);

globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var SiderContext = /*#__PURE__*/react.exports.createContext({});

var MenuContext = /*#__PURE__*/react.exports.createContext({
  prefixCls: '',
  firstLevel: true,
  inlineCollapsed: false
});
const MenuContext$1 = MenuContext;

var MenuItem = function MenuItem(props) {
  var className = props.className,
    children = props.children,
    icon = props.icon,
    title = props.title,
    danger = props.danger;
  var _React$useContext = react.exports.useContext(MenuContext$1),
    prefixCls = _React$useContext.prefixCls,
    firstLevel = _React$useContext.firstLevel,
    direction = _React$useContext.direction,
    disableMenuItemTitleTooltip = _React$useContext.disableMenuItemTitleTooltip,
    isInlineCollapsed = _React$useContext.inlineCollapsed;
  var renderItemChildren = function renderItemChildren(inlineCollapsed) {
    var wrapNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      className: prefixCls + "-title-content",
      children: children
    });
    // inline-collapsed.md demo  span , icon  span
    // ref: https://github.com/ant-design/ant-design/pull/23456
    if (!icon || isValidElement(children) && children.type === 'span') {
      if (children && inlineCollapsed && firstLevel && typeof children === 'string') {
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("div", {
            className: prefixCls + "-inline-collapsed-noicon",
            children: children.charAt(0)
          })
        );
      }
    }
    return wrapNode;
  };
  var renderItem = function renderItem(_ref) {
    var _classNames;
    var siderCollapsed = _ref.siderCollapsed;
    var _a;
    var tooltipTitle = title;
    if (typeof title === 'undefined') {
      tooltipTitle = firstLevel ? children : '';
    } else if (title === false) {
      tooltipTitle = '';
    }
    var tooltipProps = {
      title: tooltipTitle
    };
    if (!siderCollapsed && !isInlineCollapsed) {
      tooltipProps.title = null;
      // Reset `open` to fix control mode tooltip display not correct
      // ref: https://github.com/ant-design/ant-design/issues/16742
      tooltipProps.open = false;
    }
    var childrenLength = toArray$5(children).length;
    var returnNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs(MenuItem$1, {
      ...omit$1(props, ['title', 'icon', 'danger']),
      className: classNames$1((_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-item-danger", danger), _defineProperty$1(_classNames, prefixCls + "-item-only-child", (icon ? childrenLength + 1 : childrenLength) === 1), _classNames), className),
      title: typeof title === 'string' ? title : undefined,
      children: [cloneElement(icon, {
        className: classNames$1(isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : '', prefixCls + "-item-icon")
      }), renderItemChildren(isInlineCollapsed)]
    });
    if (!disableMenuItemTitleTooltip) {
      returnNode =
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(Tooltip$1, {
        ...tooltipProps,
        placement: direction === 'rtl' ? 'left' : 'right',
        overlayClassName: prefixCls + "-inline-collapsed-tooltip",
        children: returnNode
      });
    }
    return returnNode;
  };
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(SiderContext.Consumer, {
      children: renderItem
    })
  );
};
const Item$3 = MenuItem;

var SubMenu = function SubMenu(props) {
  var _a;
  var popupClassName = props.popupClassName,
    icon = props.icon,
    title = props.title,
    customTheme = props.theme;
  var context = react.exports.useContext(MenuContext$1);
  var prefixCls = context.prefixCls,
    inlineCollapsed = context.inlineCollapsed,
    contextTheme = context.theme,
    mode = context.mode;
  var parentPath = useFullPath();
  var titleNode;
  if (!icon) {
    titleNode = inlineCollapsed && !parentPath.length && title && typeof title === 'string' ?
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      className: prefixCls + "-inline-collapsed-noicon",
      children: title.charAt(0)
    }) :
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      className: prefixCls + "-title-content",
      children: title
    });
  } else {
    // inline-collapsed.md demo  span , icon  span
    // ref: https://github.com/ant-design/ant-design/pull/23456
    var titleIsSpan = isValidElement(title) && title.type === 'span';
    titleNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs(Fragment, {
      children: [cloneElement(icon, {
        className: classNames$1(isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : '', prefixCls + "-item-icon")
      }), titleIsSpan ? title :
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        className: prefixCls + "-title-content",
        children: title
      })]
    });
  }
  var contextValue = react.exports.useMemo(function () {
    return _extends$2(_extends$2({}, context), {
      firstLevel: false
    });
  }, [context]);
  var popupOffset = mode === 'horizontal' ? [0, 8] : [10, 0];
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(MenuContext$1.Provider, {
      value: contextValue,
      children: /*#__PURE__*/jsx$1(SubMenu$2, {
        popupOffset: popupOffset,
        ...omit$1(props, ['icon']),
        title: titleNode,
        popupClassName: classNames$1(prefixCls, popupClassName, prefixCls + "-" + (customTheme || contextTheme))
      })
    })
  );
};
const SubMenu$1 = SubMenu;

var __rest$I = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function convertItemsToNodes(list) {
  return (list || []).map(function (opt, index) {
    if (opt && _typeof$1(opt) === 'object') {
      var _a = opt,
        label = _a.label,
        children = _a.children,
        key = _a.key,
        type = _a.type,
        restProps = __rest$I(_a, ["label", "children", "key", "type"]);
      var mergedKey = key !== null && key !== void 0 ? key : "tmp-" + index;
      // MenuItemGroup & SubMenuItem
      if (children || type === 'group') {
        if (type === 'group') {
          // Group
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1(MenuItemGroup, {
              ...restProps,
              title: label,
              children: convertItemsToNodes(children)
            }, mergedKey)
          );
        }
        // Sub Menu
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(SubMenu$1, {
            ...restProps,
            title: label,
            children: convertItemsToNodes(children)
          }, mergedKey)
        );
      }
      // MenuItem & Divider
      if (type === 'divider') {
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(MenuDivider$1, {
            ...restProps
          }, mergedKey)
        );
      }
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(Item$3, {
          ...restProps,
          children: label
        }, mergedKey)
      );
    }
    return null;
  }).filter(function (opt) {
    return opt;
  });
}
// FIXME: Move logic here in v5
/**
 * We simply convert `items` to ReactNode for reuse origin component logic. But we need move all the
 * logic from component into this hooks when in v5
 */
function useItems(items) {
  return react.exports.useMemo(function () {
    if (!items) {
      return items;
    }
    return convertItemsToNodes(items);
  }, [items]);
}

var __rest$H = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var InternalMenu = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _a;
  var override = react.exports.useContext(OverrideContext);
  var overrideObj = override || {};
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    getPopupContainer = _React$useContext.getPopupContainer,
    direction = _React$useContext.direction;
  var rootPrefixCls = getPrefixCls();
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    _props$theme = props.theme,
    theme = _props$theme === void 0 ? 'light' : _props$theme,
    expandIcon = props.expandIcon,
    _internalDisableMenuItemTitleTooltip = props._internalDisableMenuItemTitleTooltip,
    inlineCollapsed = props.inlineCollapsed,
    siderCollapsed = props.siderCollapsed,
    items = props.items,
    children = props.children,
    rootClassName = props.rootClassName,
    mode = props.mode,
    selectable = props.selectable,
    onClick = props.onClick,
    restProps = __rest$H(props, ["prefixCls", "className", "theme", "expandIcon", "_internalDisableMenuItemTitleTooltip", "inlineCollapsed", "siderCollapsed", "items", "children", "rootClassName", "mode", "selectable", "onClick"]);
  var passedProps = omit$1(restProps, ['collapsedWidth']);
  // ========================= Items ===========================
  var mergedChildren = useItems(items) || children;
  (_a = overrideObj.validator) === null || _a === void 0 ? void 0 : _a.call(overrideObj, {
    mode: mode
  });
  // ========================== Click ==========================
  // Tell dropdown that item clicked
  var onItemClick = useEvent(function () {
    var _a;
    onClick === null || onClick === void 0 ? void 0 : onClick.apply(void 0, arguments);
    (_a = overrideObj.onClick) === null || _a === void 0 ? void 0 : _a.call(overrideObj);
  });
  // ========================== Mode ===========================
  var mergedMode = overrideObj.mode || mode;
  // ======================= Selectable ========================
  var mergedSelectable = selectable !== null && selectable !== void 0 ? selectable : overrideObj.selectable;
  // ======================== Collapsed ========================
  // Inline Collapsed
  var mergedInlineCollapsed = react.exports.useMemo(function () {
    if (siderCollapsed !== undefined) {
      return siderCollapsed;
    }
    return inlineCollapsed;
  }, [inlineCollapsed, siderCollapsed]);
  var defaultMotions = {
    horizontal: {
      motionName: rootPrefixCls + "-slide-up"
    },
    inline: initCollapseMotion$1(rootPrefixCls),
    other: {
      motionName: rootPrefixCls + "-zoom-big"
    }
  };
  var prefixCls = getPrefixCls('menu', customizePrefixCls || overrideObj.prefixCls);
  var _useStyle = useStyle$k(prefixCls, !override),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var menuClassName = classNames$1(prefixCls + "-" + theme, className);
  // ====================== Expand Icon ========================
  var mergedExpandIcon;
  if (typeof expandIcon === 'function') {
    mergedExpandIcon = expandIcon;
  } else {
    mergedExpandIcon = cloneElement(expandIcon || overrideObj.expandIcon, {
      className: prefixCls + "-submenu-expand-icon"
    });
  }
  // ======================== Context ==========================
  var contextValue = react.exports.useMemo(function () {
    return {
      prefixCls: prefixCls,
      inlineCollapsed: mergedInlineCollapsed || false,
      direction: direction,
      firstLevel: true,
      theme: theme,
      mode: mergedMode,
      disableMenuItemTitleTooltip: _internalDisableMenuItemTitleTooltip
    };
  }, [prefixCls, mergedInlineCollapsed, direction, _internalDisableMenuItemTitleTooltip, theme]);
  // ========================= Render ==========================
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(OverrideContext.Provider, {
    value: null,
    children: /*#__PURE__*/jsx$1(MenuContext$1.Provider, {
      value: contextValue,
      children: /*#__PURE__*/jsx$1(ExportMenu, {
        getPopupContainer: getPopupContainer,
        overflowedIndicator:
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(EllipsisOutlined$1, {}),
        overflowedIndicatorPopupClassName: prefixCls + "-" + theme,
        mode: mergedMode,
        selectable: mergedSelectable,
        onClick: onItemClick,
        ...passedProps,
        inlineCollapsed: mergedInlineCollapsed,
        className: menuClassName,
        prefixCls: prefixCls,
        direction: direction,
        defaultMotions: defaultMotions,
        expandIcon: mergedExpandIcon,
        ref: ref,
        rootClassName: classNames$1(rootClassName, hashId),
        children: mergedChildren
      })
    })
  }));
});
const InternalMenu$1 = InternalMenu;

var Menu$1 = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var menuRef = react.exports.useRef(null);
  var context = react.exports.useContext(SiderContext);
  react.exports.useImperativeHandle(ref, function () {
    return {
      menu: menuRef.current,
      focus: function focus(options) {
        var _a;
        (_a = menuRef.current) === null || _a === void 0 ? void 0 : _a.focus(options);
      }
    };
  });
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(InternalMenu$1, {
      ref: menuRef,
      ...props,
      ...context
    })
  );
});
Menu$1.Item = Item$3;
Menu$1.SubMenu = SubMenu$1;
Menu$1.Divider = MenuDivider$1;
Menu$1.ItemGroup = MenuItemGroup;
const Menu$2 = Menu$1;

var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset = [0, 0];
var placements = {
  topLeft: {
    points: ['bl', 'tl'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  topCenter: {
    points: ['bc', 'tc'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  bottomCenter: {
    points: ['tc', 'bc'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  }
};

var ESC = KeyCode$1.ESC,
    TAB = KeyCode$1.TAB;
function useAccessibility(_ref) {
  var visible = _ref.visible,
      setTriggerVisible = _ref.setTriggerVisible,
      triggerRef = _ref.triggerRef,
      onVisibleChange = _ref.onVisibleChange,
      autoFocus = _ref.autoFocus;
  var focusMenuRef = react.exports.useRef(false);

  var handleCloseMenuAndReturnFocus = function handleCloseMenuAndReturnFocus() {
    if (visible && triggerRef.current) {
      var _triggerRef$current, _triggerRef$current$t, _triggerRef$current$t2, _triggerRef$current$t3;

      (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : (_triggerRef$current$t = _triggerRef$current.triggerRef) === null || _triggerRef$current$t === void 0 ? void 0 : (_triggerRef$current$t2 = _triggerRef$current$t.current) === null || _triggerRef$current$t2 === void 0 ? void 0 : (_triggerRef$current$t3 = _triggerRef$current$t2.focus) === null || _triggerRef$current$t3 === void 0 ? void 0 : _triggerRef$current$t3.call(_triggerRef$current$t2);
      setTriggerVisible(false);

      if (typeof onVisibleChange === 'function') {
        onVisibleChange(false);
      }
    }
  };

  var focusMenu = function focusMenu() {
    var _triggerRef$current2, _triggerRef$current2$, _triggerRef$current2$2, _triggerRef$current2$3;

    var elements = getFocusNodeList((_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : (_triggerRef$current2$ = _triggerRef$current2.popupRef) === null || _triggerRef$current2$ === void 0 ? void 0 : (_triggerRef$current2$2 = _triggerRef$current2$.current) === null || _triggerRef$current2$2 === void 0 ? void 0 : (_triggerRef$current2$3 = _triggerRef$current2$2.getElement) === null || _triggerRef$current2$3 === void 0 ? void 0 : _triggerRef$current2$3.call(_triggerRef$current2$2));
    var firstElement = elements[0];

    if (firstElement === null || firstElement === void 0 ? void 0 : firstElement.focus) {
      firstElement.focus();
      focusMenuRef.current = true;
      return true;
    }

    return false;
  };

  var handleKeyDown = function handleKeyDown(event) {
    switch (event.keyCode) {
      case ESC:
        handleCloseMenuAndReturnFocus();
        break;

      case TAB:
        {
          var focusResult = false;

          if (!focusMenuRef.current) {
            focusResult = focusMenu();
          }

          if (focusResult) {
            event.preventDefault();
          } else {
            handleCloseMenuAndReturnFocus();
          }

          break;
        }
    }
  };

  react.exports.useEffect(function () {
    if (visible) {
      window.addEventListener('keydown', handleKeyDown);

      if (autoFocus) {
        // FIXME: hack with raf
        wrapperRaf$1(focusMenu, 3);
      }

      return function () {
        window.removeEventListener('keydown', handleKeyDown);
        focusMenuRef.current = false;
      };
    }

    return function () {
      focusMenuRef.current = false;
    };
  }, [visible]); // eslint-disable-line react-hooks/exhaustive-deps
}

var _excluded$r = ["arrow", "prefixCls", "transitionName", "animation", "align", "placement", "placements", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "visible", "trigger", "autoFocus"];
function Dropdown$2(props, ref) {
  var _props$arrow = props.arrow,
    arrow = _props$arrow === void 0 ? false : _props$arrow,
    _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-dropdown' : _props$prefixCls,
    transitionName = props.transitionName,
    animation = props.animation,
    align = props.align,
    _props$placement = props.placement,
    placement = _props$placement === void 0 ? 'bottomLeft' : _props$placement,
    _props$placements = props.placements,
    placements$1 = _props$placements === void 0 ? placements : _props$placements,
    getPopupContainer = props.getPopupContainer,
    showAction = props.showAction,
    hideAction = props.hideAction,
    overlayClassName = props.overlayClassName,
    overlayStyle = props.overlayStyle,
    visible = props.visible,
    _props$trigger = props.trigger,
    trigger = _props$trigger === void 0 ? ['hover'] : _props$trigger,
    autoFocus = props.autoFocus,
    otherProps = _objectWithoutProperties(props, _excluded$r);
  var _React$useState = react.exports.useState(),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    triggerVisible = _React$useState2[0],
    setTriggerVisible = _React$useState2[1];
  var mergedVisible = 'visible' in props ? visible : triggerVisible;
  var triggerRef = react.exports.useRef(null);
  react.exports.useImperativeHandle(ref, function () {
    return triggerRef.current;
  });
  useAccessibility({
    visible: mergedVisible,
    setTriggerVisible: setTriggerVisible,
    triggerRef: triggerRef,
    onVisibleChange: props.onVisibleChange,
    autoFocus: autoFocus
  });
  var getOverlayElement = function getOverlayElement() {
    var overlay = props.overlay;
    var overlayElement;
    if (typeof overlay === 'function') {
      overlayElement = overlay();
    } else {
      overlayElement = overlay;
    }
    return overlayElement;
  };
  var onClick = function onClick(e) {
    var onOverlayClick = props.onOverlayClick;
    setTriggerVisible(false);
    if (onOverlayClick) {
      onOverlayClick(e);
    }
  };
  var onVisibleChange = function onVisibleChange(newVisible) {
    var onVisibleChangeProp = props.onVisibleChange;
    setTriggerVisible(newVisible);
    if (typeof onVisibleChangeProp === 'function') {
      onVisibleChangeProp(newVisible);
    }
  };
  var getMenuElement = function getMenuElement() {
    var overlayElement = getOverlayElement();
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsxs(Fragment, {
        children: [arrow &&
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("div", {
          className: "".concat(prefixCls, "-arrow")
        }), overlayElement]
      })
    );
  };
  var getMenuElementOrLambda = function getMenuElementOrLambda() {
    var overlay = props.overlay;
    if (typeof overlay === 'function') {
      return getMenuElement;
    }
    return getMenuElement();
  };
  var getMinOverlayWidthMatchTrigger = function getMinOverlayWidthMatchTrigger() {
    var minOverlayWidthMatchTrigger = props.minOverlayWidthMatchTrigger,
      alignPoint = props.alignPoint;
    if ('minOverlayWidthMatchTrigger' in props) {
      return minOverlayWidthMatchTrigger;
    }
    return !alignPoint;
  };
  var getOpenClassName = function getOpenClassName() {
    var openClassName = props.openClassName;
    if (openClassName !== undefined) {
      return openClassName;
    }
    return "".concat(prefixCls, "-open");
  };
  var renderChildren = function renderChildren() {
    var children = props.children;
    var childrenProps = children.props ? children.props : {};
    var childClassName = classNames$1(childrenProps.className, getOpenClassName());
    return mergedVisible && children ? /*#__PURE__*/react.exports.cloneElement(children, {
      className: childClassName
    }) : children;
  };
  var triggerHideAction = hideAction;
  if (!triggerHideAction && trigger.indexOf('contextMenu') !== -1) {
    triggerHideAction = ['click'];
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Trigger, {
      ..._objectSpread2$1(_objectSpread2$1({
        builtinPlacements: placements$1
      }, otherProps), {}, {
        prefixCls: prefixCls,
        ref: triggerRef,
        popupClassName: classNames$1(overlayClassName, _defineProperty$1({}, "".concat(prefixCls, "-show-arrow"), arrow)),
        popupStyle: overlayStyle,
        action: trigger,
        showAction: showAction,
        hideAction: triggerHideAction || [],
        popupPlacement: placement,
        popupAlign: align,
        popupTransitionName: transitionName,
        popupAnimation: animation,
        popupVisible: mergedVisible,
        stretch: getMinOverlayWidthMatchTrigger() ? 'minWidth' : '',
        popup: getMenuElementOrLambda(),
        onPopupVisibleChange: onVisibleChange,
        onPopupClick: onClick,
        getPopupContainer: getPopupContainer
      }),
      children: renderChildren()
    })
  );
}
const Dropdown$3 = /*#__PURE__*/react.exports.forwardRef(Dropdown$2);

var id = 0;
var ids = {};
// Support call raf with delay specified frame
function wrapperRaf(callback) {
  var delayFrames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var myId = id++;
  var restFrames = delayFrames;
  function internalCallback() {
    restFrames -= 1;
    if (restFrames <= 0) {
      callback();
      delete ids[myId];
    } else {
      ids[myId] = raf$2(internalCallback);
    }
  }
  ids[myId] = raf$2(internalCallback);
  return myId;
}
wrapperRaf.cancel = function cancel(pid) {
  if (pid === undefined) return;
  raf$2.cancel(ids[pid]);
  delete ids[pid];
};
wrapperRaf.ids = ids; // export this for test usage

var genWaveStyle = function genWaveStyle(token) {
  var _ref;
  var waveEffect = new Keyframe('waveEffect', {
    '100%': {
      boxShadow: "0 0 0 6px var(--antd-wave-shadow-color)"
    }
  });
  var fadeEffect = new Keyframe('fadeEffect', {
    '100%': {
      opacity: 0
    }
  });
  return [(_ref = {}, _defineProperty$1(_ref, token.clickAnimatingWithoutExtraNodeTrue + ",\n      " + token.clickAnimatingTrue, {
    '--antd-wave-shadow-color': token.colorPrimary,
    '--scroll-bar': 0,
    position: 'relative'
  }), _defineProperty$1(_ref, token.clickAnimatingWithoutExtraNodeTrueAfter + ",\n      & " + token.clickAnimatingNode, {
    position: 'absolute',
    top: 0,
    insetInlineStart: 0,
    insetInlineEnd: 0,
    bottom: 0,
    display: 'block',
    borderRadius: 'inherit',
    boxShadow: "0 0 0 0 var(--antd-wave-shadow-color)",
    opacity: 0.2,
    animation: {
      _skip_check_: true,
      value: fadeEffect.getName(token.hashId) + " 2s " + token.motionEaseOutCirc + ", " + waveEffect.getName(token.hashId) + " 0.4s " + token.motionEaseOutCirc
    },
    animationFillMode: 'forwards',
    content: '""',
    pointerEvents: 'none'
  }), _ref), {}, waveEffect, fadeEffect];
};
const useStyle$j = (function () {
  var _useToken = useToken(),
    _useToken2 = _slicedToArray(_useToken, 3),
    theme = _useToken2[0],
    token = _useToken2[1],
    hashId = _useToken2[2];
  var _useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _useContext.getPrefixCls;
  var rootPrefixCls = getPrefixCls();
  var clickAnimatingTrue = "[" + rootPrefixCls + "-click-animating='true']";
  var clickAnimatingWithoutExtraNodeTrue = "[" + rootPrefixCls + "-click-animating-without-extra-node='true']";
  var clickAnimatingNode = "." + rootPrefixCls + "-click-animating-node";
  var waveToken = _extends$2(_extends$2({}, token), {
    hashId: hashId,
    clickAnimatingNode: clickAnimatingNode,
    clickAnimatingTrue: clickAnimatingTrue,
    clickAnimatingWithoutExtraNodeTrue: clickAnimatingWithoutExtraNodeTrue,
    clickAnimatingWithoutExtraNodeTrueAfter: clickAnimatingWithoutExtraNodeTrue + "::after"
  });
  return [useStyleRegister({
    theme: theme,
    token: token,
    hashId: hashId,
    path: ['wave']
  }, function () {
    return [genWaveStyle(waveToken)];
  }), hashId];
});

var styleForPseudo;
// Where el is the DOM element you'd like to test for visibility
function isHidden(element) {
  return !element || element.offsetParent === null || element.hidden;
}
function getValidateContainer(nodeRoot) {
  if (nodeRoot instanceof Document) {
    return nodeRoot.body;
  }
  return Array.from(nodeRoot.childNodes).find(function (ele) {
    return (ele === null || ele === void 0 ? void 0 : ele.nodeType) === Node.ELEMENT_NODE;
  });
}
function isNotGrey(color) {
  // eslint-disable-next-line no-useless-escape
  var match = (color || '').match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  if (match && match[1] && match[2] && match[3]) {
    return !(match[1] === match[2] && match[2] === match[3]);
  }
  return true;
}
function isValidWaveColor(color) {
  return color && color !== '#fff' && color !== '#ffffff' && color !== 'rgb(255, 255, 255)' && color !== 'rgba(255, 255, 255, 1)' && isNotGrey(color) && !/rgba\((?:\d*, ){3}0\)/.test(color) &&
  // any transparent rgba color
  color !== 'transparent';
}
function getTargetWaveColor(node) {
  var computedStyle = getComputedStyle(node);
  var borderTopColor = computedStyle.getPropertyValue('border-top-color');
  var borderColor = computedStyle.getPropertyValue('border-color');
  var backgroundColor = computedStyle.getPropertyValue('background-color');
  if (isValidWaveColor(borderTopColor)) {
    return borderTopColor;
  }
  if (isValidWaveColor(borderColor)) {
    return borderColor;
  }
  return backgroundColor;
}
var InternalWave = /*#__PURE__*/function (_React$Component) {
  _inherits(InternalWave, _React$Component);
  var _super = _createSuper(InternalWave);
  function InternalWave() {
    var _this;
    _classCallCheck(this, InternalWave);
    _this = _super.apply(this, arguments);
    _this.containerRef = /*#__PURE__*/react.exports.createRef();
    _this.animationStart = false;
    _this.destroyed = false;
    _this.onClick = function (node, waveColor) {
      var _a, _b;
      var _this$props = _this.props,
        insertExtraNode = _this$props.insertExtraNode,
        disabled = _this$props.disabled;
      if (disabled || !node || isHidden(node) || node.className.includes('-leave')) {
        return;
      }
      _this.extraNode = document.createElement('div');
      var _assertThisInitialize = _assertThisInitialized(_this),
        extraNode = _assertThisInitialize.extraNode;
      var getPrefixCls = _this.context.getPrefixCls;
      extraNode.className = getPrefixCls('') + "-click-animating-node";
      var attributeName = _this.getAttributeName();
      node.setAttribute(attributeName, 'true');
      // Not white or transparent or grey
      if (isValidWaveColor(waveColor)) {
        extraNode.style.borderColor = waveColor;
        var nodeRoot = ((_a = node.getRootNode) === null || _a === void 0 ? void 0 : _a.call(node)) || node.ownerDocument;
        var nodeBody = (_b = getValidateContainer(nodeRoot)) !== null && _b !== void 0 ? _b : nodeRoot;
        styleForPseudo = updateCSS$1("\n      [" + getPrefixCls('') + "-click-animating-without-extra-node='true']::after, ." + getPrefixCls('') + "-click-animating-node {\n        --antd-wave-shadow-color: " + waveColor + ";\n      }", 'antd-wave', {
          csp: _this.csp,
          attachTo: nodeBody
        });
      }
      if (insertExtraNode) {
        node.appendChild(extraNode);
      }
      ['transition', 'animation'].forEach(function (name) {
        node.addEventListener(name + "start", _this.onTransitionStart);
        node.addEventListener(name + "end", _this.onTransitionEnd);
      });
    };
    _this.onTransitionStart = function (e) {
      if (_this.destroyed) {
        return;
      }
      var node = _this.containerRef.current;
      if (!e || e.target !== node || _this.animationStart) {
        return;
      }
      _this.resetEffect(node);
    };
    _this.onTransitionEnd = function (e) {
      if (!e || e.animationName !== 'fadeEffect') {
        return;
      }
      _this.resetEffect(e.target);
    };
    _this.bindAnimationEvent = function (node) {
      if (!node || !node.getAttribute || node.getAttribute('disabled') || node.className.includes('disabled')) {
        return;
      }
      var onClick = function onClick(e) {
        // Fix radio button click twice
        if (e.target.tagName === 'INPUT' || isHidden(e.target)) {
          return;
        }
        _this.resetEffect(node);
        // Get wave color from target
        var waveColor = getTargetWaveColor(node);
        _this.clickWaveTimeoutId = window.setTimeout(function () {
          return _this.onClick(node, waveColor);
        }, 0);
        wrapperRaf.cancel(_this.animationStartId);
        _this.animationStart = true;
        // Render to trigger transition event cost 3 frames. Let's delay 10 frames to reset this.
        _this.animationStartId = wrapperRaf(function () {
          _this.animationStart = false;
        }, 10);
      };
      node.addEventListener('click', onClick, true);
      return {
        cancel: function cancel() {
          node.removeEventListener('click', onClick, true);
        }
      };
    };
    _this.renderWave = function (_ref) {
      var csp = _ref.csp;
      var children = _this.props.children;
      _this.csp = csp;
      if (! /*#__PURE__*/react.exports.isValidElement(children)) return children;
      var ref = _this.containerRef;
      if (supportRef(children)) {
        ref = composeRef(children.ref, _this.containerRef);
      }
      return cloneElement(children, {
        ref: ref
      });
    };
    return _this;
  }
  _createClass(InternalWave, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.destroyed = false;
      var node = this.containerRef.current;
      if (!node || node.nodeType !== 1) {
        return;
      }
      this.instance = this.bindAnimationEvent(node);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.instance) {
        this.instance.cancel();
      }
      if (this.clickWaveTimeoutId) {
        clearTimeout(this.clickWaveTimeoutId);
      }
      this.destroyed = true;
    }
  }, {
    key: "getAttributeName",
    value: function getAttributeName() {
      var getPrefixCls = this.context.getPrefixCls;
      var insertExtraNode = this.props.insertExtraNode;
      return insertExtraNode ? getPrefixCls('') + "-click-animating" : getPrefixCls('') + "-click-animating-without-extra-node";
    }
  }, {
    key: "resetEffect",
    value: function resetEffect(node) {
      var _this2 = this;
      if (!node || node === this.extraNode || !(node instanceof Element)) {
        return;
      }
      var insertExtraNode = this.props.insertExtraNode;
      var attributeName = this.getAttributeName();
      node.setAttribute(attributeName, 'false'); // edge has bug on `removeAttribute` #14466
      if (styleForPseudo) {
        styleForPseudo.innerHTML = '';
      }
      if (insertExtraNode && this.extraNode && node.contains(this.extraNode)) {
        node.removeChild(this.extraNode);
      }
      ['transition', 'animation'].forEach(function (name) {
        node.removeEventListener(name + "start", _this2.onTransitionStart);
        node.removeEventListener(name + "end", _this2.onTransitionEnd);
      });
    }
  }, {
    key: "render",
    value: function render() {
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(ConfigConsumer, {
          children: this.renderWave
        })
      );
    }
  }]);
  return InternalWave;
}(react.exports.Component);
InternalWave.contextType = ConfigContext;
var Wave = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  useStyle$j();
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(InternalWave, {
      ref: ref,
      ...props
    })
  );
});
const Wave$1 = Wave;

var __rest$G = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var GroupSizeContext = /*#__PURE__*/react.exports.createContext(undefined);
var ButtonGroup = function ButtonGroup(props) {
  var _classNames;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var customizePrefixCls = props.prefixCls,
    size = props.size,
    className = props.className,
    others = __rest$G(props, ["prefixCls", "size", "className"]);
  var prefixCls = getPrefixCls('btn-group', customizePrefixCls);
  // Here we only need hashId
  var _useToken = useToken(),
    _useToken2 = _slicedToArray(_useToken, 3),
    hashId = _useToken2[2];
  // large => lg
  // small => sm
  var sizeCls = '';
  switch (size) {
    case 'large':
      sizeCls = 'lg';
      break;
    case 'small':
      sizeCls = 'sm';
      break;
  }
  var classes = classNames$1(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-" + sizeCls, sizeCls), _defineProperty$1(_classNames, prefixCls + "-rtl", direction === 'rtl'), _classNames), className, hashId);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(GroupSizeContext.Provider, {
      value: size,
      children: /*#__PURE__*/jsx$1("div", {
        ...others,
        className: classes
      })
    })
  );
};
const Group$5 = ButtonGroup;

var getCollapsedWidth = function getCollapsedWidth() {
  return {
    width: 0,
    opacity: 0,
    transform: 'scale(0)'
  };
};
var getRealWidth = function getRealWidth(node) {
  return {
    width: node.scrollWidth,
    opacity: 1,
    transform: 'scale(1)'
  };
};
var LoadingIcon = function LoadingIcon(_ref) {
  var prefixCls = _ref.prefixCls,
    loading = _ref.loading,
    existIcon = _ref.existIcon;
  var visible = !!loading;
  if (existIcon) {
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        className: prefixCls + "-loading-icon",
        children: /*#__PURE__*/jsx$1(LoadingOutlined$1, {})
      })
    );
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(CSSMotion, {
      visible: visible,
      motionName: prefixCls + "-loading-icon-motion",
      removeOnLeave: true,
      onAppearStart: getCollapsedWidth,
      onAppearActive: getRealWidth,
      onEnterStart: getCollapsedWidth,
      onEnterActive: getRealWidth,
      onLeaveStart: getRealWidth,
      onLeaveActive: getCollapsedWidth,
      children: function (_ref2, ref) {
        var className = _ref2.className,
          style = _ref2.style;
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("span", {
            className: prefixCls + "-loading-icon",
            style: style,
            ref: ref,
            children: /*#__PURE__*/jsx$1(LoadingOutlined$1, {
              className: className
            })
          })
        );
      }
    })
  );
};
const LoadingIcon$1 = LoadingIcon;

var genButtonBorderStyle = function genButtonBorderStyle(buttonTypeCls, borderColor) {
  return _defineProperty$1({}, "> span, > " + buttonTypeCls, {
    '&:not(:last-child)': _defineProperty$1({}, "&, & > " + buttonTypeCls, {
      '&:not(:disabled)': {
        borderInlineEndColor: borderColor
      }
    }),
    '&:not(:first-child)': _defineProperty$1({}, "&, & > " + buttonTypeCls, {
      '&:not(:disabled)': {
        borderInlineStartColor: borderColor
      }
    })
  });
};
var genGroupStyle$1 = function genGroupStyle(token) {
  var _componentCls, _ref2;
  var componentCls = token.componentCls,
    fontSize = token.fontSize,
    lineWidth = token.lineWidth,
    colorPrimaryHover = token.colorPrimaryHover,
    colorErrorHover = token.colorErrorHover;
  return _defineProperty$1({}, componentCls + "-group", [(_ref2 = {
    position: 'relative',
    display: 'inline-flex'
  }, _defineProperty$1(_ref2, "> span, > " + componentCls, {
    '&:not(:last-child)': _defineProperty$1({}, "&, & > " + componentCls, {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0
    }),
    '&:not(:first-child)': _defineProperty$1({
      marginInlineStart: -lineWidth
    }, "&, & > " + componentCls, {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0
    })
  }), _defineProperty$1(_ref2, componentCls, (_componentCls = {
    position: 'relative',
    zIndex: 1
  }, _defineProperty$1(_componentCls, "&:hover,\n          &:focus,\n          &:active", {
    zIndex: 2
  }), _defineProperty$1(_componentCls, '&[disabled]', {
    zIndex: 0
  }), _componentCls)), _defineProperty$1(_ref2, componentCls + "-icon-only", {
    fontSize: fontSize
  }), _ref2),
  // Border Color
  genButtonBorderStyle(componentCls + "-primary", colorPrimaryHover), genButtonBorderStyle(componentCls + "-danger", colorErrorHover)]);
};
const genGroupStyle$2 = genGroupStyle$1;

function compactItemVerticalBorder(token) {
  return {
    // border collapse
    '&-item:not(&-last-item)': {
      marginBottom: -token.lineWidth
    },
    '&-item': {
      '&:hover,&:focus,&:active': {
        zIndex: 2
      },
      '&[disabled]': {
        zIndex: 0
      }
    }
  };
}
function compactItemBorderVerticalRadius(prefixCls) {
  return {
    '&-item:not(&-first-item):not(&-last-item)': {
      borderRadius: 0
    },
    '&-item&-first-item:not(&-last-item)': _defineProperty$1({}, "&, &" + prefixCls + "-sm, &" + prefixCls + "-lg", {
      borderEndEndRadius: 0,
      borderEndStartRadius: 0
    }),
    '&-item&-last-item:not(&-first-item)': _defineProperty$1({}, "&, &" + prefixCls + "-sm, &" + prefixCls + "-lg", {
      borderStartStartRadius: 0,
      borderStartEndRadius: 0
    })
  };
}
function genCompactItemVerticalStyle(token) {
  return _defineProperty$1({}, token.componentCls + "-compact-vertical", _extends$2(_extends$2({}, compactItemVerticalBorder(token)), compactItemBorderVerticalRadius(token.componentCls)));
}

// ============================== Shared ==============================
var genSharedButtonStyle = function genSharedButtonStyle(token) {
  var _componentCls;
  var componentCls = token.componentCls,
    iconCls = token.iconCls;
  return _defineProperty$1({}, componentCls, (_componentCls = {
    outline: 'none',
    position: 'relative',
    display: 'inline-block',
    fontWeight: 400,
    whiteSpace: 'nowrap',
    textAlign: 'center',
    backgroundImage: 'none',
    backgroundColor: 'transparent',
    border: token.lineWidth + "px " + token.lineType + " transparent",
    cursor: 'pointer',
    transition: "all " + token.motionDurationMid + " " + token.motionEaseInOut,
    userSelect: 'none',
    touchAction: 'manipulation',
    lineHeight: token.lineHeight,
    color: token.colorText,
    '> span': {
      display: 'inline-block'
    }
  }, _defineProperty$1(_componentCls, "> " + iconCls + " + span, > span + " + iconCls, {
    marginInlineStart: token.marginXS
  }), _defineProperty$1(_componentCls, '&:not(:disabled)', _extends$2({}, genFocusStyle(token))), _defineProperty$1(_componentCls, '&-icon-only&-compact-item', {
    flex: 'none'
  }), _defineProperty$1(_componentCls, "&-compact-item" + componentCls + "-primary", {
    '&:not([disabled]) + &:not([disabled])': {
      position: 'relative',
      '&:before': {
        position: 'absolute',
        top: -token.lineWidth,
        insetInlineStart: -token.lineWidth,
        display: 'inline-block',
        width: token.lineWidth,
        height: "calc(100% + " + token.lineWidth * 2 + "px)",
        backgroundColor: token.colorPrimaryHover,
        content: '""'
      }
    }
  }), _defineProperty$1(_componentCls, '&-compact-vertical-item', _defineProperty$1({}, "&" + componentCls + "-primary", {
    '&:not([disabled]) + &:not([disabled])': {
      position: 'relative',
      '&:before': {
        position: 'absolute',
        top: -token.lineWidth,
        insetInlineStart: -token.lineWidth,
        display: 'inline-block',
        width: "calc(100% + " + token.lineWidth * 2 + "px)",
        height: token.lineWidth,
        backgroundColor: token.colorPrimaryHover,
        content: '""'
      }
    }
  })), _componentCls));
};
var genHoverActiveButtonStyle = function genHoverActiveButtonStyle(hoverStyle, activeStyle) {
  return {
    '&:not(:disabled)': {
      '&:hover': hoverStyle,
      '&:active': activeStyle
    }
  };
};
// ============================== Shape ===============================
var genCircleButtonStyle = function genCircleButtonStyle(token) {
  return {
    minWidth: token.controlHeight,
    paddingInlineStart: 0,
    paddingInlineEnd: 0,
    borderRadius: '50%'
  };
};
var genRoundButtonStyle = function genRoundButtonStyle(token) {
  return {
    borderRadius: token.controlHeight,
    paddingInlineStart: token.controlHeight / 2,
    paddingInlineEnd: token.controlHeight / 2,
    width: 'auto'
  };
};
// =============================== Type ===============================
var genDisabledStyle$1 = function genDisabledStyle(token) {
  return {
    cursor: 'not-allowed',
    borderColor: token.colorBorder,
    color: token.colorTextDisabled,
    backgroundColor: token.colorBgContainerDisabled,
    boxShadow: 'none'
  };
};
var genGhostButtonStyle = function genGhostButtonStyle(btnCls, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) {
  return _defineProperty$1({}, "&" + btnCls + "-background-ghost", _extends$2(_extends$2({
    color: textColor || undefined,
    backgroundColor: 'transparent',
    borderColor: borderColor || undefined,
    boxShadow: 'none'
  }, genHoverActiveButtonStyle(_extends$2({
    backgroundColor: 'transparent'
  }, hoverStyle), _extends$2({
    backgroundColor: 'transparent'
  }, activeStyle))), {
    '&:disabled': {
      cursor: 'not-allowed',
      color: textColorDisabled || undefined,
      borderColor: borderColorDisabled || undefined
    }
  }));
};
var genSolidDisabledButtonStyle = function genSolidDisabledButtonStyle(token) {
  return {
    '&:disabled': _extends$2({}, genDisabledStyle$1(token))
  };
};
var genSolidButtonStyle = function genSolidButtonStyle(token) {
  return _extends$2({}, genSolidDisabledButtonStyle(token));
};
var genPureDisabledButtonStyle = function genPureDisabledButtonStyle(token) {
  return {
    '&:disabled': {
      cursor: 'not-allowed',
      color: token.colorTextDisabled
    }
  };
};
// Type: Default
var genDefaultButtonStyle = function genDefaultButtonStyle(token) {
  return _extends$2(_extends$2(_extends$2(_extends$2(_extends$2({}, genSolidButtonStyle(token)), {
    backgroundColor: token.colorBgContainer,
    borderColor: token.colorBorder,
    boxShadow: "0 " + token.controlOutlineWidth + "px 0 " + token.controlTmpOutline
  }), genHoverActiveButtonStyle({
    color: token.colorPrimaryHover,
    borderColor: token.colorPrimaryHover
  }, {
    color: token.colorPrimaryActive,
    borderColor: token.colorPrimaryActive
  })), genGhostButtonStyle(token.componentCls, token.colorBgContainer, token.colorBgContainer, token.colorTextDisabled, token.colorBorder)), _defineProperty$1({}, "&" + token.componentCls + "-dangerous", _extends$2(_extends$2(_extends$2({
    color: token.colorError,
    borderColor: token.colorError
  }, genHoverActiveButtonStyle({
    color: token.colorErrorHover,
    borderColor: token.colorErrorBorderHover
  }, {
    color: token.colorErrorActive,
    borderColor: token.colorErrorActive
  })), genGhostButtonStyle(token.componentCls, token.colorError, token.colorError, token.colorTextDisabled, token.colorBorder)), genSolidDisabledButtonStyle(token))));
};
// Type: Primary
var genPrimaryButtonStyle = function genPrimaryButtonStyle(token) {
  return _extends$2(_extends$2(_extends$2(_extends$2(_extends$2({}, genSolidButtonStyle(token)), {
    color: token.colorTextLightSolid,
    backgroundColor: token.colorPrimary,
    boxShadow: "0 " + token.controlOutlineWidth + "px 0 " + token.controlOutline
  }), genHoverActiveButtonStyle({
    color: token.colorTextLightSolid,
    backgroundColor: token.colorPrimaryHover
  }, {
    color: token.colorTextLightSolid,
    backgroundColor: token.colorPrimaryActive
  })), genGhostButtonStyle(token.componentCls, token.colorPrimary, token.colorPrimary, token.colorTextDisabled, token.colorBorder, {
    color: token.colorPrimaryHover,
    borderColor: token.colorPrimaryHover
  }, {
    color: token.colorPrimaryActive,
    borderColor: token.colorPrimaryActive
  })), _defineProperty$1({}, "&" + token.componentCls + "-dangerous", _extends$2(_extends$2(_extends$2({
    backgroundColor: token.colorError,
    boxShadow: "0 " + token.controlOutlineWidth + "px 0 " + token.colorErrorOutline
  }, genHoverActiveButtonStyle({
    backgroundColor: token.colorErrorHover
  }, {
    backgroundColor: token.colorErrorActive
  })), genGhostButtonStyle(token.componentCls, token.colorError, token.colorError, token.colorTextDisabled, token.colorBorder, {
    color: token.colorErrorHover,
    borderColor: token.colorErrorHover
  }, {
    color: token.colorErrorActive,
    borderColor: token.colorErrorActive
  })), genSolidDisabledButtonStyle(token))));
};
// Type: Dashed
var genDashedButtonStyle = function genDashedButtonStyle(token) {
  return _extends$2(_extends$2({}, genDefaultButtonStyle(token)), {
    borderStyle: 'dashed'
  });
};
// Type: Link
var genLinkButtonStyle = function genLinkButtonStyle(token) {
  return _extends$2(_extends$2(_extends$2({
    color: token.colorLink
  }, genHoverActiveButtonStyle({
    color: token.colorLinkHover
  }, {
    color: token.colorLinkActive
  })), genPureDisabledButtonStyle(token)), _defineProperty$1({}, "&" + token.componentCls + "-dangerous", _extends$2(_extends$2({
    color: token.colorError
  }, genHoverActiveButtonStyle({
    color: token.colorErrorHover
  }, {
    color: token.colorErrorActive
  })), genPureDisabledButtonStyle(token))));
};
// Type: Text
var genTextButtonStyle = function genTextButtonStyle(token) {
  return _extends$2(_extends$2(_extends$2({}, genHoverActiveButtonStyle({
    color: token.colorText,
    backgroundColor: token.colorBgTextHover
  }, {
    color: token.colorText,
    backgroundColor: token.colorBgTextActive
  })), genPureDisabledButtonStyle(token)), _defineProperty$1({}, "&" + token.componentCls + "-dangerous", _extends$2(_extends$2({
    color: token.colorError
  }, genPureDisabledButtonStyle(token)), genHoverActiveButtonStyle({
    color: token.colorErrorHover,
    backgroundColor: token.colorErrorBg
  }, {
    color: token.colorErrorHover,
    backgroundColor: token.colorErrorBg
  }))));
};
// Href and Disabled
var genDisabledButtonStyle = function genDisabledButtonStyle(token) {
  return _extends$2(_extends$2({}, genDisabledStyle$1(token)), _defineProperty$1({}, "&" + token.componentCls + ":hover", _extends$2({}, genDisabledStyle$1(token))));
};
var genTypeButtonStyle = function genTypeButtonStyle(token) {
  var _ref3;
  var componentCls = token.componentCls;
  return _ref3 = {}, _defineProperty$1(_ref3, componentCls + "-default", genDefaultButtonStyle(token)), _defineProperty$1(_ref3, componentCls + "-primary", genPrimaryButtonStyle(token)), _defineProperty$1(_ref3, componentCls + "-dashed", genDashedButtonStyle(token)), _defineProperty$1(_ref3, componentCls + "-link", genLinkButtonStyle(token)), _defineProperty$1(_ref3, componentCls + "-text", genTextButtonStyle(token)), _defineProperty$1(_ref3, componentCls + "-disabled", genDisabledButtonStyle(token)), _ref3;
};
// =============================== Size ===============================
var genSizeButtonStyle = function genSizeButtonStyle(token) {
  var _ref4;
  var sizePrefixCls = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var componentCls = token.componentCls,
    iconCls = token.iconCls;
  var paddingVertical = Math.max(0, (token.controlHeight - token.fontSize * token.lineHeight) / 2 - token.lineWidth);
  var paddingHorizontal = token.buttonPaddingHorizontal - token.lineWidth;
  var iconOnlyCls = componentCls + "-icon-only";
  return [// Size
  _defineProperty$1({}, "" + componentCls + sizePrefixCls, (_ref4 = {
    fontSize: token.fontSize,
    height: token.controlHeight,
    padding: paddingVertical + "px " + paddingHorizontal + "px",
    borderRadius: token.borderRadius
  }, _defineProperty$1(_ref4, "&" + iconOnlyCls, {
    width: token.controlHeight,
    paddingInlineStart: 0,
    paddingInlineEnd: 0,
    '> span': {
      transform: 'scale(1.143)' // 14px -> 16px
    }
  }), _defineProperty$1(_ref4, "&" + componentCls + "-loading", {
    opacity: token.opacityLoading,
    cursor: 'default'
  }), _defineProperty$1(_ref4, componentCls + "-loading-icon", {
    transition: "width " + token.motionDurationSlow + " " + token.motionEaseInOut + ", opacity " + token.motionDurationSlow + " " + token.motionEaseInOut
  }), _defineProperty$1(_ref4, "&:not(" + iconOnlyCls + ") " + componentCls + "-loading-icon > " + iconCls, {
    marginInlineEnd: token.marginXS
  }), _ref4)), // Shape - patch prefixCls again to override solid border radius style
  _defineProperty$1({}, "" + componentCls + componentCls + "-circle" + sizePrefixCls, genCircleButtonStyle(token)), _defineProperty$1({}, "" + componentCls + componentCls + "-round" + sizePrefixCls, genRoundButtonStyle(token))];
};
var genSizeBaseButtonStyle = function genSizeBaseButtonStyle(token) {
  return genSizeButtonStyle(token);
};
var genSizeSmallButtonStyle = function genSizeSmallButtonStyle(token) {
  var smallToken = merge$2(token, {
    controlHeight: token.controlHeightSM,
    padding: token.paddingXS,
    buttonPaddingHorizontal: 8,
    borderRadius: token.borderRadiusSM
  });
  return genSizeButtonStyle(smallToken, token.componentCls + "-sm");
};
var genSizeLargeButtonStyle = function genSizeLargeButtonStyle(token) {
  var largeToken = merge$2(token, {
    controlHeight: token.controlHeightLG,
    fontSize: token.fontSizeLG,
    borderRadius: token.borderRadiusLG
  });
  return genSizeButtonStyle(largeToken, token.componentCls + "-lg");
};
var genBlockButtonStyle = function genBlockButtonStyle(token) {
  var componentCls = token.componentCls;
  return _defineProperty$1({}, componentCls, _defineProperty$1({}, "&" + componentCls + "-block", {
    width: '100%'
  }));
};
// ============================== Export ==============================
const useStyle$i = genComponentStyleHook('Button', function (token) {
  var controlTmpOutline = token.controlTmpOutline,
    paddingContentHorizontal = token.paddingContentHorizontal;
  var buttonToken = merge$2(token, {
    colorOutlineDefault: controlTmpOutline,
    buttonPaddingHorizontal: paddingContentHorizontal
  });
  return [
  // Shared
  genSharedButtonStyle(buttonToken),
  // Size
  genSizeSmallButtonStyle(buttonToken), genSizeBaseButtonStyle(buttonToken), genSizeLargeButtonStyle(buttonToken),
  // Block
  genBlockButtonStyle(buttonToken),
  // Group (type, ghost, danger, disabled, loading)
  genTypeButtonStyle(buttonToken),
  // Button Group
  genGroupStyle$2(buttonToken),
  // Space Compact
  genCompactItemStyle(token, {
    focus: false
  }), genCompactItemVerticalStyle(token)];
});

var __rest$F = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
var isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
function isString$1(str) {
  return typeof str === 'string';
}
function isUnBorderedButtonType(type) {
  return type === 'text' || type === 'link';
}
// Insert one space between two chinese characters automatically.
function insertSpace(child, needInserted) {
  // Check the child if is undefined or null.
  if (child === null || child === undefined) {
    return;
  }
  var SPACE = needInserted ? ' ' : '';
  // strictNullChecks oops.
  if (typeof child !== 'string' && typeof child !== 'number' && isString$1(child.type) && isTwoCNChar(child.props.children)) {
    return cloneElement(child, {
      children: child.props.children.split('').join(SPACE)
    });
  }
  if (typeof child === 'string') {
    return isTwoCNChar(child) ?
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      children: child.split('').join(SPACE)
    }) :
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      children: child
    });
  }
  if (isFragment(child)) {
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        children: child
      })
    );
  }
  return child;
}
function spaceChildren(children, needInserted) {
  var isPrevChildPure = false;
  var childList = [];
  react.exports.Children.forEach(children, function (child) {
    var type = _typeof$1(child);
    var isCurrentChildPure = type === 'string' || type === 'number';
    if (isPrevChildPure && isCurrentChildPure) {
      var lastIndex = childList.length - 1;
      var lastChild = childList[lastIndex];
      childList[lastIndex] = "" + lastChild + child;
    } else {
      childList.push(child);
    }
    isPrevChildPure = isCurrentChildPure;
  });
  // Pass to React.Children.map to auto fill key
  return react.exports.Children.map(childList, function (child) {
    return insertSpace(child, needInserted);
  });
}
function convertLegacyProps(type) {
  if (type === 'danger') {
    return {
      danger: true
    };
  }
  return {
    type: type
  };
}
var InternalButton = function InternalButton(props, ref) {
  var _classNames;
  var _props$loading = props.loading,
    loading = _props$loading === void 0 ? false : _props$loading,
    customizePrefixCls = props.prefixCls,
    _props$type = props.type,
    type = _props$type === void 0 ? 'default' : _props$type,
    danger = props.danger,
    _props$shape = props.shape,
    shape = _props$shape === void 0 ? 'default' : _props$shape,
    customizeSize = props.size,
    customDisabled = props.disabled,
    className = props.className,
    children = props.children,
    icon = props.icon,
    _props$ghost = props.ghost,
    ghost = _props$ghost === void 0 ? false : _props$ghost,
    _props$block = props.block,
    block = _props$block === void 0 ? false : _props$block,
    _props$htmlType = props.htmlType,
    htmlType = _props$htmlType === void 0 ? 'button' : _props$htmlType,
    rest = __rest$F(props, ["loading", "prefixCls", "type", "danger", "shape", "size", "disabled", "className", "children", "icon", "ghost", "block", "htmlType"]);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    autoInsertSpaceInButton = _React$useContext.autoInsertSpaceInButton,
    direction = _React$useContext.direction;
  var prefixCls = getPrefixCls('btn', customizePrefixCls);
  // Style
  var _useStyle = useStyle$i(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var size = react.exports.useContext(SizeContext);
  // ===================== Disabled =====================
  var disabled = react.exports.useContext(DisabledContext);
  var mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
  var groupSize = react.exports.useContext(GroupSizeContext);
  var _React$useState = react.exports.useState(!!loading),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    innerLoading = _React$useState2[0],
    setLoading = _React$useState2[1];
  var _React$useState3 = react.exports.useState(false),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    hasTwoCNChar = _React$useState4[0],
    setHasTwoCNChar = _React$useState4[1];
  var buttonRef = ref || /*#__PURE__*/react.exports.createRef();
  var isNeedInserted = function isNeedInserted() {
    return react.exports.Children.count(children) === 1 && !icon && !isUnBorderedButtonType(type);
  };
  var fixTwoCNChar = function fixTwoCNChar() {
    // Fix for HOC usage like <FormatMessage />
    if (!buttonRef || !buttonRef.current || autoInsertSpaceInButton === false) {
      return;
    }
    var buttonText = buttonRef.current.textContent;
    if (isNeedInserted() && isTwoCNChar(buttonText)) {
      if (!hasTwoCNChar) {
        setHasTwoCNChar(true);
      }
    } else if (hasTwoCNChar) {
      setHasTwoCNChar(false);
    }
  };
  // =============== Update Loading ===============
  var loadingOrDelay = typeof loading === 'boolean' ? loading : (loading === null || loading === void 0 ? void 0 : loading.delay) || true;
  react.exports.useEffect(function () {
    var delayTimer = null;
    if (typeof loadingOrDelay === 'number') {
      delayTimer = window.setTimeout(function () {
        delayTimer = null;
        setLoading(loadingOrDelay);
      }, loadingOrDelay);
    } else {
      setLoading(loadingOrDelay);
    }
    return function () {
      if (delayTimer) {
        // in order to not perform a React state update on an unmounted component
        // and clear timer after 'loadingOrDelay' updated.
        window.clearTimeout(delayTimer);
        delayTimer = null;
      }
    };
  }, [loadingOrDelay]);
  react.exports.useEffect(fixTwoCNChar, [buttonRef]);
  var handleClick = function handleClick(e) {
    var onClick = props.onClick;
    // https://github.com/ant-design/ant-design/issues/30207
    if (innerLoading || mergedDisabled) {
      e.preventDefault();
      return;
    }
    onClick === null || onClick === void 0 ? void 0 : onClick(e);
  };
  var autoInsertSpace = autoInsertSpaceInButton !== false;
  var _useCompactItemContex = useCompactItemContext(prefixCls, direction),
    compactSize = _useCompactItemContex.compactSize,
    compactItemClassnames = _useCompactItemContex.compactItemClassnames;
  var sizeClassNameMap = {
    large: 'lg',
    small: 'sm',
    middle: undefined
  };
  var sizeFullname = compactSize || groupSize || customizeSize || size;
  var sizeCls = sizeFullname ? sizeClassNameMap[sizeFullname] || '' : '';
  var iconType = innerLoading ? 'loading' : icon;
  var linkButtonRestProps = omit$1(rest, ['navigate']);
  var hrefAndDisabled = linkButtonRestProps.href !== undefined && mergedDisabled;
  var classes = classNames$1(prefixCls, hashId, (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-" + shape, shape !== 'default' && shape), _defineProperty$1(_classNames, prefixCls + "-" + type, type), _defineProperty$1(_classNames, prefixCls + "-" + sizeCls, sizeCls), _defineProperty$1(_classNames, prefixCls + "-icon-only", !children && children !== 0 && !!iconType), _defineProperty$1(_classNames, prefixCls + "-background-ghost", ghost && !isUnBorderedButtonType(type)), _defineProperty$1(_classNames, prefixCls + "-loading", innerLoading), _defineProperty$1(_classNames, prefixCls + "-two-chinese-chars", hasTwoCNChar && autoInsertSpace && !innerLoading), _defineProperty$1(_classNames, prefixCls + "-block", block), _defineProperty$1(_classNames, prefixCls + "-dangerous", !!danger), _defineProperty$1(_classNames, prefixCls + "-rtl", direction === 'rtl'), _defineProperty$1(_classNames, prefixCls + "-disabled", hrefAndDisabled), _classNames), compactItemClassnames, className);
  var iconNode = icon && !innerLoading ? icon :
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(LoadingIcon$1, {
    existIcon: !!icon,
    prefixCls: prefixCls,
    loading: !!innerLoading
  });
  var kids = children || children === 0 ? spaceChildren(children, isNeedInserted() && autoInsertSpace) : null;
  if (linkButtonRestProps.href !== undefined) {
    return wrapSSR(
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("a", {
      ...linkButtonRestProps,
      className: classes,
      onClick: handleClick,
      ref: buttonRef,
      children: [iconNode, kids]
    }));
  }
  var buttonNode =
  /*#__PURE__*/
  /*#__PURE__*/
  jsxs("button", {
    ...rest,
    type: htmlType,
    className: classes,
    onClick: handleClick,
    disabled: mergedDisabled,
    ref: buttonRef,
    children: [iconNode, kids]
  });
  if (!isUnBorderedButtonType(type)) {
    buttonNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Wave$1, {
      disabled: !!innerLoading,
      children: buttonNode
    });
  }
  return wrapSSR(buttonNode);
};
var Button$1 = /*#__PURE__*/react.exports.forwardRef(InternalButton);
Button$1.Group = Group$5;
Button$1.__ANT_BUTTON = true;
const Button$2 = Button$1;

var isStyleNameSupport$1 = function isStyleNameSupport(styleName) {
  if (canUseDom$1() && window.document.documentElement) {
    var styleNameList = Array.isArray(styleName) ? styleName : [styleName];
    var documentElement = window.document.documentElement;
    return styleNameList.some(function (name) {
      return name in documentElement.style;
    });
  }
  return false;
};
var isStyleValueSupport$1 = function isStyleValueSupport(styleName, value) {
  if (!isStyleNameSupport$1(styleName)) {
    return false;
  }
  var ele = document.createElement('div');
  var origin = ele.style[styleName];
  ele.style[styleName] = value;
  return ele.style[styleName] !== origin;
};
function isStyleSupport$1(styleName, styleValue) {
  if (!Array.isArray(styleName) && styleValue !== undefined) {
    return isStyleValueSupport$1(styleName, styleValue);
  }
  return isStyleNameSupport$1(styleName);
}

var canUseDocElement = function canUseDocElement() {
  return canUseDom$1() && window.document.documentElement;
};
var flexGapSupported;
var detectFlexGapSupported = function detectFlexGapSupported() {
  if (!canUseDocElement()) {
    return false;
  }
  if (flexGapSupported !== undefined) {
    return flexGapSupported;
  }
  // create flex container with row-gap set
  var flex = document.createElement('div');
  flex.style.display = 'flex';
  flex.style.flexDirection = 'column';
  flex.style.rowGap = '1px';
  // create two, elements inside it
  flex.appendChild(document.createElement('div'));
  flex.appendChild(document.createElement('div'));
  // append to the DOM (needed to obtain scrollHeight)
  document.body.appendChild(flex);
  flexGapSupported = flex.scrollHeight === 1; // flex container should be 1px high from the row-gap
  document.body.removeChild(flex);
  return flexGapSupported;
};

const useFlexGapSupport = (function () {
  var _React$useState = react.exports.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    flexible = _React$useState2[0],
    setFlexible = _React$useState2[1];
  react.exports.useEffect(function () {
    setFlexible(detectFlexGapSupported());
  }, []);
  return flexible;
});

function Item$2(_ref) {
  var className = _ref.className,
    direction = _ref.direction,
    index = _ref.index,
    marginDirection = _ref.marginDirection,
    children = _ref.children,
    split = _ref.split,
    wrap = _ref.wrap;
  var _React$useContext = react.exports.useContext(SpaceContext),
    horizontalSize = _React$useContext.horizontalSize,
    verticalSize = _React$useContext.verticalSize,
    latestIndex = _React$useContext.latestIndex,
    supportFlexGap = _React$useContext.supportFlexGap;
  var style = {};
  if (!supportFlexGap) {
    if (direction === 'vertical') {
      if (index < latestIndex) {
        style = {
          marginBottom: horizontalSize / (split ? 2 : 1)
        };
      }
    } else {
      style = _extends$2(_extends$2({}, index < latestIndex && _defineProperty$1({}, marginDirection, horizontalSize / (split ? 2 : 1))), wrap && {
        paddingBottom: verticalSize
      });
    }
  }
  if (children === null || children === undefined) {
    return null;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs(Fragment, {
      children: [/*#__PURE__*/jsx$1("div", {
        className: className,
        style: style,
        children: children
      }), index < latestIndex && split &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        className: className + "-split",
        style: style,
        children: split
      })]
    })
  );
}

var __rest$E = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var SpaceContext = /*#__PURE__*/react.exports.createContext({
  latestIndex: 0,
  horizontalSize: 0,
  verticalSize: 0,
  supportFlexGap: false
});
var spaceSize = {
  small: 8,
  middle: 16,
  large: 24
};
function getNumberSize(size) {
  return typeof size === 'string' ? spaceSize[size] : size || 0;
}
var Space = function Space(props) {
  var _classNames;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    space = _React$useContext.space,
    directionConfig = _React$useContext.direction;
  var _props$size = props.size,
    size = _props$size === void 0 ? (space === null || space === void 0 ? void 0 : space.size) || 'small' : _props$size,
    align = props.align,
    className = props.className,
    children = props.children,
    _props$direction = props.direction,
    direction = _props$direction === void 0 ? 'horizontal' : _props$direction,
    customizePrefixCls = props.prefixCls,
    split = props.split,
    style = props.style,
    _props$wrap = props.wrap,
    wrap = _props$wrap === void 0 ? false : _props$wrap,
    otherProps = __rest$E(props, ["size", "align", "className", "children", "direction", "prefixCls", "split", "style", "wrap"]);
  var supportFlexGap = useFlexGapSupport();
  var _React$useMemo = react.exports.useMemo(function () {
      return (Array.isArray(size) ? size : [size, size]).map(function (item) {
        return getNumberSize(item);
      });
    }, [size]),
    _React$useMemo2 = _slicedToArray(_React$useMemo, 2),
    horizontalSize = _React$useMemo2[0],
    verticalSize = _React$useMemo2[1];
  var childNodes = toArray$5(children, {
    keepEmpty: true
  });
  var mergedAlign = align === undefined && direction === 'horizontal' ? 'center' : align;
  var prefixCls = getPrefixCls('space', customizePrefixCls);
  var _useStyle = useStyle$m(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var cn = classNames$1(prefixCls, hashId, prefixCls + "-" + direction, (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-rtl", directionConfig === 'rtl'), _defineProperty$1(_classNames, prefixCls + "-align-" + mergedAlign, mergedAlign), _classNames), className);
  var itemClassName = prefixCls + "-item";
  var marginDirection = directionConfig === 'rtl' ? 'marginLeft' : 'marginRight';
  // Calculate latest one
  var latestIndex = 0;
  var nodes = childNodes.map(function (child, i) {
    if (child !== null && child !== undefined) {
      latestIndex = i;
    }
    var key = child && child.key || itemClassName + "-" + i;
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(Item$2, {
        className: itemClassName,
        direction: direction,
        index: i,
        marginDirection: marginDirection,
        split: split,
        wrap: wrap,
        children: child
      }, key)
    );
  });
  var spaceContext = react.exports.useMemo(function () {
    return {
      horizontalSize: horizontalSize,
      verticalSize: verticalSize,
      latestIndex: latestIndex,
      supportFlexGap: supportFlexGap
    };
  }, [horizontalSize, verticalSize, latestIndex, supportFlexGap]);
  // =========================== Render ===========================
  if (childNodes.length === 0) {
    return null;
  }
  var gapStyle = {};
  if (wrap) {
    gapStyle.flexWrap = 'wrap';
    // Patch for gap not support
    if (!supportFlexGap) {
      gapStyle.marginBottom = -verticalSize;
    }
  }
  if (supportFlexGap) {
    gapStyle.columnGap = horizontalSize;
    gapStyle.rowGap = verticalSize;
  }
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    className: cn,
    style: _extends$2(_extends$2({}, gapStyle), style),
    ...otherProps,
    children: /*#__PURE__*/jsx$1(SpaceContext.Provider, {
      value: spaceContext,
      children: nodes
    })
  }));
};
var CompoundedSpace = Space;
CompoundedSpace.Compact = Compact$1;
const Space$1 = CompoundedSpace;

var genButtonStyle = function genButtonStyle(token) {
  var _ref;
  var componentCls = token.componentCls,
    antCls = token.antCls,
    paddingXS = token.paddingXS,
    opacityLoading = token.opacityLoading;
  return _defineProperty$1({}, componentCls + "-button", _defineProperty$1({
    whiteSpace: 'nowrap'
  }, "&" + antCls + "-btn-group > " + antCls + "-btn", (_ref = {}, _defineProperty$1(_ref, "&-loading, &-loading + " + antCls + "-btn", {
    cursor: 'default',
    pointerEvents: 'none',
    opacity: opacityLoading
  }), _defineProperty$1(_ref, "&:last-child:not(:first-child):not(" + antCls + "-btn-icon-only)", {
    paddingInline: paddingXS
  }), _ref)));
};
const genButtonStyle$1 = genButtonStyle;

var genStatusStyle$1 = function genStatusStyle(token) {
  var componentCls = token.componentCls,
    menuCls = token.menuCls,
    colorError = token.colorError,
    colorTextLightSolid = token.colorTextLightSolid;
  var itemCls = menuCls + "-item";
  return _defineProperty$1({}, componentCls + ", " + componentCls + "-menu-submenu", _defineProperty$1({}, menuCls + " " + itemCls, _defineProperty$1({}, "&" + itemCls + "-danger", {
    color: colorError,
    '&:hover': {
      color: colorTextLightSolid,
      backgroundColor: colorError
    }
  })));
};
const genStatusStyle$2 = genStatusStyle$1;

// =============================== Base ===============================
var genBaseStyle$3 = function genBaseStyle(token) {
  var _ref, _extends2, _extends5, _ref7;
  var componentCls = token.componentCls,
    menuCls = token.menuCls,
    zIndexPopup = token.zIndexPopup,
    dropdownArrowDistance = token.dropdownArrowDistance,
    dropdownArrowOffset = token.dropdownArrowOffset,
    sizePopupArrow = token.sizePopupArrow,
    antCls = token.antCls,
    iconCls = token.iconCls,
    motionDurationMid = token.motionDurationMid,
    dropdownPaddingVertical = token.dropdownPaddingVertical,
    fontSize = token.fontSize,
    dropdownEdgeChildPadding = token.dropdownEdgeChildPadding,
    borderRadius = token.borderRadius,
    colorTextDisabled = token.colorTextDisabled,
    fontSizeIcon = token.fontSizeIcon,
    controlPaddingHorizontal = token.controlPaddingHorizontal,
    colorBgElevated = token.colorBgElevated,
    boxShadowPopoverArrow = token.boxShadowPopoverArrow;
  return [_defineProperty$1({}, componentCls, _extends$2(_extends$2({}, resetComponent(token)), (_extends2 = {
    position: 'absolute',
    top: -9999,
    left: {
      _skip_check_: true,
      value: -9999
    },
    zIndex: zIndexPopup,
    display: 'block',
    // A placeholder out of dropdown visible range to avoid close when user moving
    '&::before': {
      position: 'absolute',
      insetBlock: -dropdownArrowDistance + sizePopupArrow / 2,
      // insetInlineStart: -7, // FIXME: Seems not work for hidden element
      zIndex: -9999,
      opacity: 0.0001,
      content: '""'
    }
  }, _defineProperty$1(_extends2, componentCls + "-wrap", (_ref = {
    position: 'relative'
  }, _defineProperty$1(_ref, antCls + "-btn > " + iconCls + "-down", {
    fontSize: fontSizeIcon
  }), _defineProperty$1(_ref, iconCls + "-down::before", {
    transition: "transform " + motionDurationMid
  }), _ref)), _defineProperty$1(_extends2, componentCls + "-wrap-open", _defineProperty$1({}, iconCls + "-down::before", {
    transform: "rotate(180deg)"
  })), _defineProperty$1(_extends2, "\n        &-hidden,\n        &-menu-hidden,\n        &-menu-submenu-hidden\n      ", {
    display: 'none'
  }), _defineProperty$1(_extends2, "\n        &-show-arrow&-placement-topLeft,\n        &-show-arrow&-placement-top,\n        &-show-arrow&-placement-topRight\n      ", {
    paddingBottom: dropdownArrowDistance
  }), _defineProperty$1(_extends2, "\n        &-show-arrow&-placement-bottomLeft,\n        &-show-arrow&-placement-bottom,\n        &-show-arrow&-placement-bottomRight\n      ", {
    paddingTop: dropdownArrowDistance
  }), _defineProperty$1(_extends2, componentCls + "-arrow", _extends$2({
    position: 'absolute',
    zIndex: 1,
    display: 'block'
  }, roundedArrow(sizePopupArrow, token.borderRadiusXS, token.borderRadiusOuter, colorBgElevated, boxShadowPopoverArrow))), _defineProperty$1(_extends2, "\n        &-placement-top > " + componentCls + "-arrow,\n        &-placement-topLeft > " + componentCls + "-arrow,\n        &-placement-topRight > " + componentCls + "-arrow\n      ", {
    bottom: dropdownArrowDistance,
    transform: 'translateY(100%) rotate(180deg)'
  }), _defineProperty$1(_extends2, "&-placement-top > " + componentCls + "-arrow", {
    left: {
      _skip_check_: true,
      value: '50%'
    },
    transform: 'translateX(-50%) translateY(100%) rotate(180deg)'
  }), _defineProperty$1(_extends2, "&-placement-topLeft > " + componentCls + "-arrow", {
    left: {
      _skip_check_: true,
      value: dropdownArrowOffset
    }
  }), _defineProperty$1(_extends2, "&-placement-topRight > " + componentCls + "-arrow", {
    right: {
      _skip_check_: true,
      value: dropdownArrowOffset
    }
  }), _defineProperty$1(_extends2, "\n          &-placement-bottom > " + componentCls + "-arrow,\n          &-placement-bottomLeft > " + componentCls + "-arrow,\n          &-placement-bottomRight > " + componentCls + "-arrow\n        ", {
    top: dropdownArrowDistance,
    transform: "translateY(-100%)"
  }), _defineProperty$1(_extends2, "&-placement-bottom > " + componentCls + "-arrow", {
    left: {
      _skip_check_: true,
      value: '50%'
    },
    transform: "translateY(-100%) translateX(-50%)"
  }), _defineProperty$1(_extends2, "&-placement-bottomLeft > " + componentCls + "-arrow", {
    left: {
      _skip_check_: true,
      value: dropdownArrowOffset
    }
  }), _defineProperty$1(_extends2, "&-placement-bottomRight > " + componentCls + "-arrow", {
    right: {
      _skip_check_: true,
      value: dropdownArrowOffset
    }
  }), _defineProperty$1(_extends2, "&" + antCls + "-slide-down-enter" + antCls + "-slide-down-enter-active&-placement-bottomLeft,\n          &" + antCls + "-slide-down-appear" + antCls + "-slide-down-appear-active&-placement-bottomLeft\n          &" + antCls + "-slide-down-enter" + antCls + "-slide-down-enter-active&-placement-bottom,\n          &" + antCls + "-slide-down-appear" + antCls + "-slide-down-appear-active&-placement-bottom,\n          &" + antCls + "-slide-down-enter" + antCls + "-slide-down-enter-active&-placement-bottomRight,\n          &" + antCls + "-slide-down-appear" + antCls + "-slide-down-appear-active&-placement-bottomRight", {
    animationName: slideUpIn
  }), _defineProperty$1(_extends2, "&" + antCls + "-slide-up-enter" + antCls + "-slide-up-enter-active&-placement-topLeft,\n          &" + antCls + "-slide-up-appear" + antCls + "-slide-up-appear-active&-placement-topLeft,\n          &" + antCls + "-slide-up-enter" + antCls + "-slide-up-enter-active&-placement-top,\n          &" + antCls + "-slide-up-appear" + antCls + "-slide-up-appear-active&-placement-top,\n          &" + antCls + "-slide-up-enter" + antCls + "-slide-up-enter-active&-placement-topRight,\n          &" + antCls + "-slide-up-appear" + antCls + "-slide-up-appear-active&-placement-topRight", {
    animationName: slideDownIn
  }), _defineProperty$1(_extends2, "&" + antCls + "-slide-down-leave" + antCls + "-slide-down-leave-active&-placement-bottomLeft,\n          &" + antCls + "-slide-down-leave" + antCls + "-slide-down-leave-active&-placement-bottom,\n          &" + antCls + "-slide-down-leave" + antCls + "-slide-down-leave-active&-placement-bottomRight", {
    animationName: slideUpOut
  }), _defineProperty$1(_extends2, "&" + antCls + "-slide-up-leave" + antCls + "-slide-up-leave-active&-placement-topLeft,\n          &" + antCls + "-slide-up-leave" + antCls + "-slide-up-leave-active&-placement-top,\n          &" + antCls + "-slide-up-leave" + antCls + "-slide-up-leave-active&-placement-topRight", {
    animationName: slideDownOut
  }), _extends2))), (_ref7 = {}, _defineProperty$1(_ref7, componentCls + " " + menuCls, {
    position: 'relative',
    margin: 0
  }), _defineProperty$1(_ref7, menuCls + "-submenu-popup", {
    position: 'absolute',
    zIndex: zIndexPopup,
    background: 'transparent',
    boxShadow: 'none',
    transformOrigin: '0 0',
    'ul,li': {
      listStyle: 'none'
    },
    ul: {
      marginInline: '0.3em'
    }
  }), _defineProperty$1(_ref7, componentCls + ", " + componentCls + "-menu-submenu", _defineProperty$1({}, menuCls, _extends$2(_extends$2({
    padding: dropdownEdgeChildPadding,
    listStyleType: 'none',
    backgroundColor: colorBgElevated,
    backgroundClip: 'padding-box',
    borderRadius: token.borderRadiusLG,
    outline: 'none',
    boxShadow: token.boxShadowSecondary
  }, genFocusStyle(token)), (_extends5 = {}, _defineProperty$1(_extends5, menuCls + "-item-group-title", {
    padding: dropdownPaddingVertical + "px " + controlPaddingHorizontal + "px",
    color: token.colorTextDescription,
    transition: "all " + motionDurationMid
  }), _defineProperty$1(_extends5, menuCls + "-item", {
    position: 'relative',
    display: 'flex',
    alignItems: 'center',
    borderRadius: token.borderRadiusSM
  }), _defineProperty$1(_extends5, menuCls + "-item-icon", {
    minWidth: fontSize,
    marginInlineEnd: token.marginXS,
    fontSize: token.fontSizeSM
  }), _defineProperty$1(_extends5, menuCls + "-title-content", {
    flex: 'auto',
    '> a': {
      color: 'inherit',
      transition: "all " + motionDurationMid,
      '&:hover': {
        color: 'inherit'
      },
      '&::after': {
        position: 'absolute',
        inset: 0,
        content: '""'
      }
    }
  }), _defineProperty$1(_extends5, menuCls + "-item, " + menuCls + "-submenu-title", _extends$2(_extends$2(_defineProperty$1({
    clear: 'both',
    margin: 0,
    padding: dropdownPaddingVertical + "px " + controlPaddingHorizontal + "px",
    color: token.colorText,
    fontWeight: 'normal',
    fontSize: fontSize,
    lineHeight: token.lineHeight,
    cursor: 'pointer',
    transition: "all " + motionDurationMid,
    '&:first-child': !dropdownEdgeChildPadding ? {
      borderRadius: borderRadius + "px " + borderRadius + "px 0 0"
    } : [],
    '&:last-child': !dropdownEdgeChildPadding ? {
      borderRadius: "0 0 " + borderRadius + "px " + borderRadius + "px"
    } : []
  }, "&:hover, &-active", {
    backgroundColor: token.controlItemBgHover
  }), genFocusStyle(token)), _defineProperty$1({
    '&-selected': {
      color: token.colorPrimary,
      backgroundColor: token.controlItemBgActive,
      '&:hover, &-active': {
        backgroundColor: token.controlItemBgActiveHover
      }
    },
    '&-disabled': {
      color: colorTextDisabled,
      cursor: 'not-allowed',
      '&:hover': {
        color: colorTextDisabled,
        backgroundColor: colorBgElevated,
        cursor: 'not-allowed'
      },
      a: {
        pointerEvents: 'none'
      }
    },
    '&-divider': {
      height: 1,
      margin: token.marginXXS + "px 0",
      overflow: 'hidden',
      lineHeight: 0,
      backgroundColor: token.colorSplit
    }
  }, componentCls + "-menu-submenu-expand-icon", _defineProperty$1({
    position: 'absolute',
    insetInlineEnd: token.paddingXS
  }, componentCls + "-menu-submenu-arrow-icon", {
    marginInlineEnd: '0 !important',
    color: token.colorTextDescription,
    fontSize: fontSizeIcon,
    fontStyle: 'normal'
  })))), _defineProperty$1(_extends5, menuCls + "-item-group-list", {
    margin: "0 " + token.marginXS + "px",
    padding: 0,
    listStyle: 'none'
  }), _defineProperty$1(_extends5, menuCls + "-submenu-title", {
    paddingInlineEnd: controlPaddingHorizontal + token.fontSizeSM
  }), _defineProperty$1(_extends5, menuCls + "-submenu-vertical", {
    position: 'relative'
  }), _defineProperty$1(_extends5, menuCls + "-submenu" + menuCls + "-submenu-disabled " + componentCls + "-menu-submenu-title", _defineProperty$1({}, "&, " + componentCls + "-menu-submenu-arrow-icon", {
    color: colorTextDisabled,
    backgroundColor: colorBgElevated,
    cursor: 'not-allowed'
  })), _defineProperty$1(_extends5, menuCls + "-submenu-selected " + componentCls + "-menu-submenu-title", {
    color: token.colorPrimary
  }), _extends5)))), _ref7),
  // Follow code may reuse in other components
  [initSlideMotion(token, 'slide-up'), initSlideMotion(token, 'slide-down'), initMoveMotion(token, 'move-up'), initMoveMotion(token, 'move-down'), initZoomMotion(token, 'zoom-big')]];
};
// ============================== Export ==============================
const useStyle$h = genComponentStyleHook('Dropdown', function (token, _ref8) {
  var rootPrefixCls = _ref8.rootPrefixCls;
  var marginXXS = token.marginXXS,
    sizePopupArrow = token.sizePopupArrow,
    controlHeight = token.controlHeight,
    fontSize = token.fontSize,
    lineHeight = token.lineHeight,
    paddingXXS = token.paddingXXS,
    componentCls = token.componentCls,
    borderRadiusOuter = token.borderRadiusOuter,
    borderRadiusLG = token.borderRadiusLG;
  var dropdownPaddingVertical = (controlHeight - fontSize * lineHeight) / 2;
  var _getArrowOffset = getArrowOffset({
      sizePopupArrow: sizePopupArrow,
      contentRadius: borderRadiusLG,
      borderRadiusOuter: borderRadiusOuter
    }),
    dropdownArrowOffset = _getArrowOffset.dropdownArrowOffset;
  var dropdownToken = merge$2(token, {
    menuCls: componentCls + "-menu",
    rootPrefixCls: rootPrefixCls,
    dropdownArrowDistance: sizePopupArrow / 2 + marginXXS,
    dropdownArrowOffset: dropdownArrowOffset,
    dropdownPaddingVertical: dropdownPaddingVertical,
    dropdownEdgeChildPadding: paddingXXS
  });
  return [genBaseStyle$3(dropdownToken), genButtonStyle$1(dropdownToken), genStatusStyle$2(dropdownToken)];
}, function (token) {
  return {
    zIndexPopup: token.zIndexPopupBase + 50
  };
});

var __rest$D = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var DropdownButton = function DropdownButton(props) {
  var _React$useContext = react.exports.useContext(ConfigContext),
    getContextPopupContainer = _React$useContext.getPopupContainer,
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var customizePrefixCls = props.prefixCls,
    _props$type = props.type,
    type = _props$type === void 0 ? 'default' : _props$type,
    danger = props.danger,
    disabled = props.disabled,
    loading = props.loading,
    onClick = props.onClick,
    htmlType = props.htmlType,
    children = props.children,
    className = props.className,
    menu = props.menu,
    arrow = props.arrow,
    autoFocus = props.autoFocus,
    overlay = props.overlay,
    trigger = props.trigger,
    align = props.align,
    open = props.open,
    onOpenChange = props.onOpenChange,
    placement = props.placement,
    getPopupContainer = props.getPopupContainer,
    href = props.href,
    _props$icon = props.icon,
    icon = _props$icon === void 0 ?
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(EllipsisOutlined$1, {}) : _props$icon,
    title = props.title,
    _props$buttonsRender = props.buttonsRender,
    buttonsRender = _props$buttonsRender === void 0 ? function (buttons) {
      return buttons;
    } : _props$buttonsRender,
    mouseEnterDelay = props.mouseEnterDelay,
    mouseLeaveDelay = props.mouseLeaveDelay,
    overlayClassName = props.overlayClassName,
    overlayStyle = props.overlayStyle,
    destroyPopupOnHide = props.destroyPopupOnHide,
    dropdownRender = props.dropdownRender,
    restProps = __rest$D(props, ["prefixCls", "type", "danger", "disabled", "loading", "onClick", "htmlType", "children", "className", "menu", "arrow", "autoFocus", "overlay", "trigger", "align", "open", "onOpenChange", "placement", "getPopupContainer", "href", "icon", "title", "buttonsRender", "mouseEnterDelay", "mouseLeaveDelay", "overlayClassName", "overlayStyle", "destroyPopupOnHide", "dropdownRender"]);
  var prefixCls = getPrefixCls('dropdown', customizePrefixCls);
  var buttonPrefixCls = prefixCls + "-button";
  var _useStyle = useStyle$h(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var dropdownProps = {
    menu: menu,
    arrow: arrow,
    autoFocus: autoFocus,
    align: align,
    disabled: disabled,
    trigger: disabled ? [] : trigger,
    onOpenChange: onOpenChange,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    mouseEnterDelay: mouseEnterDelay,
    mouseLeaveDelay: mouseLeaveDelay,
    overlayClassName: overlayClassName,
    overlayStyle: overlayStyle,
    destroyPopupOnHide: destroyPopupOnHide,
    dropdownRender: dropdownRender
  };
  var _useCompactItemContex = useCompactItemContext(prefixCls, direction),
    compactSize = _useCompactItemContex.compactSize,
    compactItemClassnames = _useCompactItemContex.compactItemClassnames;
  var classes = classNames$1(buttonPrefixCls, compactItemClassnames, className, hashId);
  if ('overlay' in props) {
    dropdownProps.overlay = overlay;
  }
  if ('open' in props) {
    dropdownProps.open = open;
  }
  if ('placement' in props) {
    dropdownProps.placement = placement;
  } else {
    dropdownProps.placement = direction === 'rtl' ? 'bottomLeft' : 'bottomRight';
  }
  var leftButton =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(Button$2, {
    type: type,
    danger: danger,
    disabled: disabled,
    loading: loading,
    onClick: onClick,
    htmlType: htmlType,
    href: href,
    title: title,
    children: children
  });
  var rightButton =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(Button$2, {
    type: type,
    danger: danger,
    icon: icon
  });
  var _buttonsRender = buttonsRender([leftButton, rightButton]),
    _buttonsRender2 = _slicedToArray(_buttonsRender, 2),
    leftButtonToRender = _buttonsRender2[0],
    rightButtonToRender = _buttonsRender2[1];
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsxs(Space$1.Compact, {
    className: classes,
    size: compactSize,
    block: true,
    ...restProps,
    children: [leftButtonToRender, /*#__PURE__*/jsx$1(Dropdown$1, {
      ...dropdownProps,
      children: rightButtonToRender
    })]
  }));
};
DropdownButton.__ANT_BUTTON = true;
const DropdownButton$1 = DropdownButton;

var Dropdown = function Dropdown(props) {
  var _React$useContext = react.exports.useContext(ConfigContext),
    getContextPopupContainer = _React$useContext.getPopupContainer,
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var getTransitionName = function getTransitionName() {
    var rootPrefixCls = getPrefixCls();
    var _props$placement = props.placement,
      placement = _props$placement === void 0 ? '' : _props$placement,
      transitionName = props.transitionName;
    if (transitionName !== undefined) {
      return transitionName;
    }
    if (placement.includes('top')) {
      return rootPrefixCls + "-slide-down";
    }
    return rootPrefixCls + "-slide-up";
  };
  var getPlacement = function getPlacement() {
    var placement = props.placement;
    if (!placement) {
      return direction === 'rtl' ? 'bottomRight' : 'bottomLeft';
    }
    if (placement.includes('Center')) {
      var newPlacement = placement.slice(0, placement.indexOf('Center'));
      return newPlacement;
    }
    return placement;
  };
  var menu = props.menu,
    arrow = props.arrow,
    customizePrefixCls = props.prefixCls,
    children = props.children,
    trigger = props.trigger,
    disabled = props.disabled,
    dropdownRender = props.dropdownRender,
    getPopupContainer = props.getPopupContainer,
    overlayClassName = props.overlayClassName,
    open = props.open,
    onOpenChange = props.onOpenChange,
    visible = props.visible,
    onVisibleChange = props.onVisibleChange,
    _props$mouseEnterDela = props.mouseEnterDelay,
    mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0.15 : _props$mouseEnterDela,
    _props$mouseLeaveDela = props.mouseLeaveDelay,
    mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela;
  var prefixCls = getPrefixCls('dropdown', customizePrefixCls);
  var _useStyle = useStyle$h(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var child = react.exports.Children.only(children);
  var dropdownTrigger = cloneElement(child, {
    className: classNames$1(prefixCls + "-trigger", _defineProperty$1({}, prefixCls + "-rtl", direction === 'rtl'), child.props.className),
    disabled: disabled
  });
  var triggerActions = disabled ? [] : trigger;
  var alignPoint;
  if (triggerActions && triggerActions.includes('contextMenu')) {
    alignPoint = true;
  }
  // =========================== Open ============================
  var _useMergedState = useMergedState(false, {
      value: open !== null && open !== void 0 ? open : visible
    }),
    _useMergedState2 = _slicedToArray(_useMergedState, 2),
    mergedOpen = _useMergedState2[0],
    setOpen = _useMergedState2[1];
  var onInnerOpenChange = useEvent(function (nextOpen) {
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(nextOpen);
    onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(nextOpen);
    setOpen(nextOpen);
  });
  // =========================== Overlay ============================
  var overlayClassNameCustomized = classNames$1(overlayClassName, hashId, _defineProperty$1({}, prefixCls + "-rtl", direction === 'rtl'));
  var builtinPlacements = getPlacements({
    arrowPointAtCenter: _typeof$1(arrow) === 'object' && arrow.pointAtCenter,
    autoAdjustOverflow: true
  });
  var onMenuClick = react.exports.useCallback(function () {
    setOpen(false);
  }, []);
  var renderOverlay = function renderOverlay() {
    // rc-dropdown already can process the function of overlay, but we have check logic here.
    // So we need render the element to check and pass back to rc-dropdown.
    var overlay = props.overlay;
    var overlayNode;
    if (menu === null || menu === void 0 ? void 0 : menu.items) {
      overlayNode =
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(Menu$2, {
        ...menu
      });
    } else if (typeof overlay === 'function') {
      overlayNode = overlay();
    } else {
      overlayNode = overlay;
    }
    if (dropdownRender) {
      overlayNode = dropdownRender(overlayNode);
    }
    overlayNode = react.exports.Children.only(typeof overlayNode === 'string' ?
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      children: overlayNode
    }) : overlayNode);
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(OverrideProvider, {
        prefixCls: prefixCls + "-menu",
        expandIcon:
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("span", {
          className: prefixCls + "-menu-submenu-arrow",
          children: /*#__PURE__*/jsx$1(RightOutlined$1, {
            className: prefixCls + "-menu-submenu-arrow-icon"
          })
        }),
        mode: "vertical",
        selectable: false,
        onClick: onMenuClick,
        validator: function validator(_ref5) {
          _ref5.mode;
        },
        children: /*#__PURE__*/jsx$1(NoCompactStyle, {
          children: overlayNode
        })
      })
    );
  };
  // ============================ Render ============================
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(Dropdown$3, {
    alignPoint: alignPoint,
    ...props,
    mouseEnterDelay: mouseEnterDelay,
    mouseLeaveDelay: mouseLeaveDelay,
    visible: mergedOpen,
    builtinPlacements: builtinPlacements,
    arrow: !!arrow,
    overlayClassName: overlayClassNameCustomized,
    prefixCls: prefixCls,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    transitionName: getTransitionName(),
    trigger: triggerActions,
    overlay: renderOverlay,
    placement: getPlacement(),
    onVisibleChange: onInnerOpenChange,
    children: dropdownTrigger
  }));
};
Dropdown.Button = DropdownButton$1;
// We don't care debug panel
var PurePanel$2 = genPurePanel(Dropdown, 'dropdown', function (prefixCls) {
  return prefixCls;
});
/* istanbul ignore next */
var WrapPurePanel = function WrapPurePanel(props) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(PurePanel$2, {
      ...props,
      children: /*#__PURE__*/jsx$1("span", {})
    })
  );
};
Dropdown._InternalPanelDoNotUseOrYouWillBeFired = WrapPurePanel;
const Dropdown$1 = Dropdown;

var RadioGroupContext = /*#__PURE__*/react.exports.createContext(null);
var RadioGroupContextProvider = RadioGroupContext.Provider;
var RadioOptionTypeContext = /*#__PURE__*/react.exports.createContext(null);
var RadioOptionTypeContextProvider = RadioOptionTypeContext.Provider;

var Checkbox$3 = /*#__PURE__*/function (_Component) {
  _inherits(Checkbox, _Component);
  var _super = _createSuper(Checkbox);
  function Checkbox(props) {
    var _this;
    _classCallCheck(this, Checkbox);
    _this = _super.call(this, props);
    _this.handleChange = function (e) {
      var _this$props = _this.props,
        disabled = _this$props.disabled,
        onChange = _this$props.onChange;
      if (disabled) {
        return;
      }
      if (!('checked' in _this.props)) {
        _this.setState({
          checked: e.target.checked
        });
      }
      if (onChange) {
        onChange({
          target: _objectSpread2$1(_objectSpread2$1({}, _this.props), {}, {
            checked: e.target.checked
          }),
          stopPropagation: function stopPropagation() {
            e.stopPropagation();
          },
          preventDefault: function preventDefault() {
            e.preventDefault();
          },
          nativeEvent: e.nativeEvent
        });
      }
    };
    _this.saveInput = function (node) {
      _this.input = node;
    };
    var checked = 'checked' in props ? props.checked : props.defaultChecked;
    _this.state = {
      checked: checked
    };
    return _this;
  }
  _createClass(Checkbox, [{
    key: "focus",
    value: function focus() {
      this.input.focus();
    }
  }, {
    key: "blur",
    value: function blur() {
      this.input.blur();
    }
  }, {
    key: "render",
    value: function render() {
      var _classNames;
      var _this$props2 = this.props,
        prefixCls = _this$props2.prefixCls,
        className = _this$props2.className,
        style = _this$props2.style,
        name = _this$props2.name,
        id = _this$props2.id,
        type = _this$props2.type,
        disabled = _this$props2.disabled,
        readOnly = _this$props2.readOnly,
        tabIndex = _this$props2.tabIndex,
        onClick = _this$props2.onClick,
        onFocus = _this$props2.onFocus,
        onBlur = _this$props2.onBlur,
        onKeyDown = _this$props2.onKeyDown,
        onKeyPress = _this$props2.onKeyPress,
        onKeyUp = _this$props2.onKeyUp,
        autoFocus = _this$props2.autoFocus,
        value = _this$props2.value,
        required = _this$props2.required,
        others = _objectWithoutProperties(_this$props2, ["prefixCls", "className", "style", "name", "id", "type", "disabled", "readOnly", "tabIndex", "onClick", "onFocus", "onBlur", "onKeyDown", "onKeyPress", "onKeyUp", "autoFocus", "value", "required"]);
      var globalProps = Object.keys(others).reduce(function (prev, key) {
        if (key.substr(0, 5) === 'aria-' || key.substr(0, 5) === 'data-' || key === 'role') {
          // eslint-disable-next-line no-param-reassign
          prev[key] = others[key];
        }
        return prev;
      }, {});
      var checked = this.state.checked;
      var classString = classNames$1(prefixCls, className, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-checked"), checked), _defineProperty$1(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsxs("span", {
          className: classString,
          style: style,
          children: [/*#__PURE__*/jsx$1("input", {
            name: name,
            id: id,
            type: type,
            required: required,
            readOnly: readOnly,
            disabled: disabled,
            tabIndex: tabIndex,
            className: "".concat(prefixCls, "-input"),
            checked: !!checked,
            onClick: onClick,
            onFocus: onFocus,
            onBlur: onBlur,
            onKeyUp: onKeyUp,
            onKeyDown: onKeyDown,
            onKeyPress: onKeyPress,
            onChange: this.handleChange,
            autoFocus: autoFocus,
            ref: this.saveInput,
            value: value,
            ...globalProps
          }), /*#__PURE__*/jsx$1("span", {
            className: "".concat(prefixCls, "-inner")
          })]
        })
      );
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      if ('checked' in props) {
        return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
          checked: props.checked
        });
      }
      return null;
    }
  }]);
  return Checkbox;
}(react.exports.Component);
Checkbox$3.defaultProps = {
  prefixCls: 'rc-checkbox',
  className: '',
  style: {},
  type: 'checkbox',
  defaultChecked: false,
  onFocus: function onFocus() {},
  onBlur: function onBlur() {},
  onChange: function onChange() {},
  onKeyDown: function onKeyDown() {},
  onKeyPress: function onKeyPress() {},
  onKeyUp: function onKeyUp() {}
};

// ============================== Styles ==============================
var antRadioEffect = new Keyframe('antRadioEffect', {
  '0%': {
    transform: 'scale(1)',
    opacity: 0.5
  },
  '100%': {
    transform: 'scale(1.6)',
    opacity: 0
  }
});
// styles from RadioGroup only
var getGroupRadioStyle = function getGroupRadioStyle(token) {
  var _extends2;
  var componentCls = token.componentCls,
    antCls = token.antCls;
  var groupPrefixCls = componentCls + "-group";
  return _defineProperty$1({}, groupPrefixCls, _extends$2(_extends$2({}, resetComponent(token)), (_extends2 = {
    display: 'inline-block',
    fontSize: 0,
    // RTL
    '&&-rtl': {
      direction: 'rtl'
    }
  }, _defineProperty$1(_extends2, antCls + "-badge " + antCls + "-badge-count", {
    zIndex: 1
  }), _defineProperty$1(_extends2, "> " + antCls + "-badge:not(:first-child) > " + antCls + "-button-wrapper", {
    borderInlineStart: 'none'
  }), _extends2)));
};
// Styles from radio-wrapper
var getRadioBasicStyle = function getRadioBasicStyle(token) {
  var _ref4, _extends3;
  var componentCls = token.componentCls,
    radioWrapperMarginRight = token.radioWrapperMarginRight,
    radioCheckedColor = token.radioCheckedColor,
    radioSize = token.radioSize,
    motionDurationSlow = token.motionDurationSlow,
    motionDurationMid = token.motionDurationMid,
    motionEaseInOut = token.motionEaseInOut,
    motionEaseInOutCirc = token.motionEaseInOutCirc,
    radioButtonBg = token.radioButtonBg,
    colorBorder = token.colorBorder,
    lineWidth = token.lineWidth,
    radioDotSize = token.radioDotSize,
    colorBgContainerDisabled = token.colorBgContainerDisabled,
    colorTextDisabled = token.colorTextDisabled,
    paddingXS = token.paddingXS,
    radioDotDisabledColor = token.radioDotDisabledColor,
    lineType = token.lineType,
    radioDotDisabledSize = token.radioDotDisabledSize,
    wireframe = token.wireframe,
    colorWhite = token.colorWhite;
  var radioInnerPrefixCls = componentCls + "-inner";
  return _defineProperty$1({}, componentCls + "-wrapper", _extends$2(_extends$2({}, resetComponent(token)), (_extends3 = {
    position: 'relative',
    display: 'inline-flex',
    alignItems: 'baseline',
    marginInlineStart: 0,
    marginInlineEnd: radioWrapperMarginRight,
    cursor: 'pointer',
    // RTL
    '&&-rtl': {
      direction: 'rtl'
    },
    '&-disabled': {
      cursor: 'not-allowed'
    },
    '&::after': {
      display: 'inline-block',
      width: 0,
      overflow: 'hidden',
      content: '"\\a0"'
    }
  }, _defineProperty$1(_extends3, componentCls + "-checked::after", {
    position: 'absolute',
    insetBlockStart: 0,
    insetInlineStart: 0,
    width: '100%',
    height: '100%',
    border: lineWidth + "px " + lineType + " " + radioCheckedColor,
    borderRadius: '50%',
    visibility: 'hidden',
    animationName: antRadioEffect,
    animationDuration: motionDurationSlow,
    animationTimingFunction: motionEaseInOut,
    animationFillMode: 'both',
    content: '""'
  }), _defineProperty$1(_extends3, componentCls, _extends$2(_extends$2({}, resetComponent(token)), {
    position: 'relative',
    display: 'inline-block',
    outline: 'none',
    cursor: 'pointer',
    alignSelf: 'center'
  })), _defineProperty$1(_extends3, componentCls + "-wrapper:hover &,\n        &:hover " + radioInnerPrefixCls, {
    borderColor: radioCheckedColor
  }), _defineProperty$1(_extends3, componentCls + "-input:focus-visible + " + radioInnerPrefixCls, _extends$2({}, genFocusOutline(token))), _defineProperty$1(_extends3, componentCls + ":hover::after, " + componentCls + "-wrapper:hover &::after", {
    visibility: 'visible'
  }), _defineProperty$1(_extends3, componentCls + "-inner", {
    '&::after': {
      boxSizing: 'border-box',
      position: 'absolute',
      insetBlockStart: '50%',
      insetInlineStart: '50%',
      display: 'block',
      width: radioSize,
      height: radioSize,
      marginBlockStart: radioSize / -2,
      marginInlineStart: radioSize / -2,
      backgroundColor: wireframe ? radioCheckedColor : colorWhite,
      borderBlockStart: 0,
      borderInlineStart: 0,
      borderRadius: radioSize,
      transform: 'scale(0)',
      opacity: 0,
      transition: "all " + motionDurationSlow + " " + motionEaseInOutCirc,
      content: '""'
    },
    boxSizing: 'border-box',
    position: 'relative',
    insetBlockStart: 0,
    insetInlineStart: 0,
    display: 'block',
    width: radioSize,
    height: radioSize,
    backgroundColor: radioButtonBg,
    borderColor: colorBorder,
    borderStyle: 'solid',
    borderWidth: lineWidth,
    borderRadius: '50%',
    transition: "all " + motionDurationMid
  }), _defineProperty$1(_extends3, componentCls + "-input", {
    position: 'absolute',
    insetBlockStart: 0,
    insetInlineEnd: 0,
    insetBlockEnd: 0,
    insetInlineStart: 0,
    zIndex: 1,
    cursor: 'pointer',
    opacity: 0
  }), _defineProperty$1(_extends3, componentCls + "-checked", _defineProperty$1({}, radioInnerPrefixCls, {
    borderColor: radioCheckedColor,
    backgroundColor: wireframe ? radioButtonBg : radioCheckedColor,
    '&::after': {
      transform: "scale(" + radioDotSize / radioSize + ")",
      opacity: 1,
      transition: "all " + motionDurationSlow + " " + motionEaseInOutCirc
    }
  })), _defineProperty$1(_extends3, componentCls + "-disabled", (_ref4 = {
    cursor: 'not-allowed'
  }, _defineProperty$1(_ref4, radioInnerPrefixCls, {
    backgroundColor: colorBgContainerDisabled,
    borderColor: colorBorder,
    cursor: 'not-allowed',
    '&::after': {
      backgroundColor: radioDotDisabledColor
    }
  }), _defineProperty$1(_ref4, '&-input', {
    cursor: 'not-allowed'
  }), _defineProperty$1(_ref4, componentCls + "-disabled + span", {
    color: colorTextDisabled,
    cursor: 'not-allowed'
  }), _defineProperty$1(_ref4, "&" + componentCls + "-checked", _defineProperty$1({}, radioInnerPrefixCls, {
    '&::after': {
      transform: "scale(" + radioDotDisabledSize / radioSize + ")"
    }
  })), _ref4)), _defineProperty$1(_extends3, "span" + componentCls + " + *", {
    paddingInlineStart: paddingXS,
    paddingInlineEnd: paddingXS
  }), _extends3)));
};
// Styles from radio-button
var getRadioButtonStyle = function getRadioButtonStyle(token) {
  var _ref6;
  var radioButtonColor = token.radioButtonColor,
    controlHeight = token.controlHeight,
    componentCls = token.componentCls,
    lineWidth = token.lineWidth,
    lineType = token.lineType,
    colorBorder = token.colorBorder,
    motionDurationSlow = token.motionDurationSlow,
    motionDurationMid = token.motionDurationMid,
    radioButtonPaddingHorizontal = token.radioButtonPaddingHorizontal,
    fontSize = token.fontSize,
    radioButtonBg = token.radioButtonBg,
    fontSizeLG = token.fontSizeLG,
    controlHeightLG = token.controlHeightLG,
    controlHeightSM = token.controlHeightSM,
    paddingXS = token.paddingXS,
    borderRadius = token.borderRadius,
    borderRadiusSM = token.borderRadiusSM,
    borderRadiusLG = token.borderRadiusLG,
    radioCheckedColor = token.radioCheckedColor,
    radioButtonCheckedBg = token.radioButtonCheckedBg,
    radioButtonHoverColor = token.radioButtonHoverColor,
    radioButtonActiveColor = token.radioButtonActiveColor,
    radioSolidCheckedColor = token.radioSolidCheckedColor,
    colorTextDisabled = token.colorTextDisabled,
    colorBgContainerDisabled = token.colorBgContainerDisabled,
    radioDisabledButtonCheckedColor = token.radioDisabledButtonCheckedColor,
    radioDisabledButtonCheckedBg = token.radioDisabledButtonCheckedBg;
  return _defineProperty$1({}, componentCls + "-button-wrapper", (_ref6 = {
    position: 'relative',
    display: 'inline-block',
    height: controlHeight,
    margin: 0,
    paddingInline: radioButtonPaddingHorizontal,
    paddingBlock: 0,
    color: radioButtonColor,
    fontSize: fontSize,
    lineHeight: controlHeight - lineWidth * 2 + "px",
    background: radioButtonBg,
    border: lineWidth + "px " + lineType + " " + colorBorder,
    // strange align fix for chrome but works
    // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif
    borderBlockStartWidth: lineWidth + 0.02,
    borderInlineStartWidth: 0,
    borderInlineEndWidth: lineWidth,
    cursor: 'pointer',
    transition: ["color " + motionDurationMid, "background " + motionDurationMid, "border-color " + motionDurationMid, "box-shadow " + motionDurationMid].join(','),
    a: {
      color: radioButtonColor
    }
  }, _defineProperty$1(_ref6, "> " + componentCls + "-button", {
    position: 'absolute',
    insetBlockStart: 0,
    insetInlineStart: 0,
    zIndex: -1,
    width: '100%',
    height: '100%'
  }), _defineProperty$1(_ref6, '&:not(:first-child)', {
    '&::before': {
      position: 'absolute',
      insetBlockStart: -lineWidth,
      insetInlineStart: -lineWidth,
      display: 'block',
      boxSizing: 'content-box',
      width: 1,
      height: '100%',
      paddingBlock: lineWidth,
      paddingInline: 0,
      backgroundColor: colorBorder,
      transition: "background-color " + motionDurationSlow,
      content: '""'
    }
  }), _defineProperty$1(_ref6, '&:first-child', {
    borderInlineStart: lineWidth + "px " + lineType + " " + colorBorder,
    borderStartStartRadius: borderRadius,
    borderEndStartRadius: borderRadius
  }), _defineProperty$1(_ref6, '&:last-child', {
    borderStartEndRadius: borderRadius,
    borderEndEndRadius: borderRadius
  }), _defineProperty$1(_ref6, '&:first-child:last-child', {
    borderRadius: borderRadius
  }), _defineProperty$1(_ref6, componentCls + "-group-large &", {
    height: controlHeightLG,
    fontSize: fontSizeLG,
    lineHeight: controlHeightLG - lineWidth * 2 + "px",
    '&:first-child': {
      borderStartStartRadius: borderRadiusLG,
      borderEndStartRadius: borderRadiusLG
    },
    '&:last-child': {
      borderStartEndRadius: borderRadiusLG,
      borderEndEndRadius: borderRadiusLG
    }
  }), _defineProperty$1(_ref6, componentCls + "-group-small &", {
    height: controlHeightSM,
    paddingInline: paddingXS - lineWidth,
    paddingBlock: 0,
    lineHeight: controlHeightSM - lineWidth * 2 + "px",
    '&:first-child': {
      borderStartStartRadius: borderRadiusSM,
      borderEndStartRadius: borderRadiusSM
    },
    '&:last-child': {
      borderStartEndRadius: borderRadiusSM,
      borderEndEndRadius: borderRadiusSM
    }
  }), _defineProperty$1(_ref6, '&:hover', {
    position: 'relative',
    color: radioCheckedColor
  }), _defineProperty$1(_ref6, '&:has(:focus-visible)', _extends$2({}, genFocusOutline(token))), _defineProperty$1(_ref6, componentCls + "-inner, input[type='checkbox'], input[type='radio']", {
    width: 0,
    height: 0,
    opacity: 0,
    pointerEvents: 'none'
  }), _defineProperty$1(_ref6, '&-checked:not(&-disabled)', {
    zIndex: 1,
    color: radioCheckedColor,
    background: radioButtonCheckedBg,
    borderColor: radioCheckedColor,
    '&::before': {
      backgroundColor: radioCheckedColor
    },
    '&:first-child': {
      borderColor: radioCheckedColor
    },
    '&:hover': {
      color: radioButtonHoverColor,
      borderColor: radioButtonHoverColor,
      '&::before': {
        backgroundColor: radioButtonHoverColor
      }
    },
    '&:active': {
      color: radioButtonActiveColor,
      borderColor: radioButtonActiveColor,
      '&::before': {
        backgroundColor: radioButtonActiveColor
      }
    }
  }), _defineProperty$1(_ref6, componentCls + "-group-solid &-checked:not(&-disabled)", {
    color: radioSolidCheckedColor,
    background: radioCheckedColor,
    borderColor: radioCheckedColor,
    '&:hover': {
      color: radioSolidCheckedColor,
      background: radioButtonHoverColor,
      borderColor: radioButtonHoverColor
    },
    '&:active': {
      color: radioSolidCheckedColor,
      background: radioButtonActiveColor,
      borderColor: radioButtonActiveColor
    }
  }), _defineProperty$1(_ref6, '&-disabled', {
    color: colorTextDisabled,
    backgroundColor: colorBgContainerDisabled,
    borderColor: colorBorder,
    cursor: 'not-allowed',
    '&:first-child, &:hover': {
      color: colorTextDisabled,
      backgroundColor: colorBgContainerDisabled,
      borderColor: colorBorder
    }
  }), _defineProperty$1(_ref6, '&-disabled&-checked', {
    color: radioDisabledButtonCheckedColor,
    backgroundColor: radioDisabledButtonCheckedBg,
    borderColor: colorBorder,
    boxShadow: 'none'
  }), _ref6));
};
// ============================== Export ==============================
const useStyle$g = genComponentStyleHook('Radio', function (token) {
  var padding = token.padding,
    lineWidth = token.lineWidth,
    controlItemBgActiveDisabled = token.controlItemBgActiveDisabled,
    colorTextDisabled = token.colorTextDisabled,
    colorBgContainer = token.colorBgContainer,
    fontSizeLG = token.fontSizeLG,
    controlOutline = token.controlOutline,
    colorPrimaryHover = token.colorPrimaryHover,
    colorPrimaryActive = token.colorPrimaryActive,
    colorText = token.colorText,
    colorPrimary = token.colorPrimary,
    marginXS = token.marginXS,
    controlOutlineWidth = token.controlOutlineWidth,
    colorTextLightSolid = token.colorTextLightSolid,
    wireframe = token.wireframe;
  // Radio
  var radioFocusShadow = "0 0 0 " + controlOutlineWidth + "px " + controlOutline;
  var radioButtonFocusShadow = radioFocusShadow;
  var radioSize = fontSizeLG;
  var dotPadding = 4; // Fixed value
  var radioDotDisabledSize = radioSize - dotPadding * 2;
  var radioDotSize = wireframe ? radioDotDisabledSize : radioSize - (dotPadding + lineWidth) * 2;
  var radioCheckedColor = colorPrimary;
  // Radio buttons
  var radioButtonColor = colorText;
  var radioButtonHoverColor = colorPrimaryHover;
  var radioButtonActiveColor = colorPrimaryActive;
  var radioButtonPaddingHorizontal = padding - lineWidth;
  var radioDisabledButtonCheckedColor = colorTextDisabled;
  var radioWrapperMarginRight = marginXS;
  var radioToken = merge$2(token, {
    radioFocusShadow: radioFocusShadow,
    radioButtonFocusShadow: radioButtonFocusShadow,
    radioSize: radioSize,
    radioDotSize: radioDotSize,
    radioDotDisabledSize: radioDotDisabledSize,
    radioCheckedColor: radioCheckedColor,
    radioDotDisabledColor: colorTextDisabled,
    radioSolidCheckedColor: colorTextLightSolid,
    radioButtonBg: colorBgContainer,
    radioButtonCheckedBg: colorBgContainer,
    radioButtonColor: radioButtonColor,
    radioButtonHoverColor: radioButtonHoverColor,
    radioButtonActiveColor: radioButtonActiveColor,
    radioButtonPaddingHorizontal: radioButtonPaddingHorizontal,
    radioDisabledButtonCheckedBg: controlItemBgActiveDisabled,
    radioDisabledButtonCheckedColor: radioDisabledButtonCheckedColor,
    radioWrapperMarginRight: radioWrapperMarginRight
  });
  return [getGroupRadioStyle(radioToken), getRadioBasicStyle(radioToken), getRadioButtonStyle(radioToken)];
});

var __rest$C = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var InternalRadio = function InternalRadio(props, ref) {
  var _classNames;
  var groupContext = react.exports.useContext(RadioGroupContext);
  var radioOptionTypeContext = react.exports.useContext(RadioOptionTypeContext);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var innerRef = react.exports.useRef();
  var mergedRef = composeRef(ref, innerRef);
  var _React$useContext2 = react.exports.useContext(FormItemInputContext),
    isFormItemInput = _React$useContext2.isFormItemInput;
  var onChange = function onChange(e) {
    var _a, _b;
    (_a = props.onChange) === null || _a === void 0 ? void 0 : _a.call(props, e);
    (_b = groupContext === null || groupContext === void 0 ? void 0 : groupContext.onChange) === null || _b === void 0 ? void 0 : _b.call(groupContext, e);
  };
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    children = props.children,
    style = props.style,
    customDisabled = props.disabled,
    restProps = __rest$C(props, ["prefixCls", "className", "children", "style", "disabled"]);
  var radioPrefixCls = getPrefixCls('radio', customizePrefixCls);
  var prefixCls = ((groupContext === null || groupContext === void 0 ? void 0 : groupContext.optionType) || radioOptionTypeContext) === 'button' ? radioPrefixCls + "-button" : radioPrefixCls;
  // Style
  var _useStyle = useStyle$g(radioPrefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var radioProps = _extends$2({}, restProps);
  // ===================== Disabled =====================
  var disabled = react.exports.useContext(DisabledContext);
  radioProps.disabled = customDisabled || disabled;
  if (groupContext) {
    radioProps.name = groupContext.name;
    radioProps.onChange = onChange;
    radioProps.checked = props.value === groupContext.value;
    radioProps.disabled = radioProps.disabled || groupContext.disabled;
  }
  var wrapperClassString = classNames$1(prefixCls + "-wrapper", (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-wrapper-checked", radioProps.checked), _defineProperty$1(_classNames, prefixCls + "-wrapper-disabled", radioProps.disabled), _defineProperty$1(_classNames, prefixCls + "-wrapper-rtl", direction === 'rtl'), _defineProperty$1(_classNames, prefixCls + "-wrapper-in-form-item", isFormItemInput), _classNames), className, hashId);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  // eslint-disable-next-line jsx-a11y/label-has-associated-control
  jsxs("label", {
    className: wrapperClassString,
    style: style,
    onMouseEnter: props.onMouseEnter,
    onMouseLeave: props.onMouseLeave,
    children: [/*#__PURE__*/jsx$1(Checkbox$3, {
      ...radioProps,
      type: "radio",
      prefixCls: prefixCls,
      ref: mergedRef
    }), children !== undefined ?
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      children: children
    }) : null]
  }));
};
var Radio$2 = /*#__PURE__*/react.exports.forwardRef(InternalRadio);
const InternalRadio$1 = Radio$2;

var RadioGroup = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _classNames;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var size = react.exports.useContext(SizeContext);
  var _useMergedState = useMergedState(props.defaultValue, {
      value: props.value
    }),
    _useMergedState2 = _slicedToArray(_useMergedState, 2),
    value = _useMergedState2[0],
    setValue = _useMergedState2[1];
  var onRadioChange = function onRadioChange(ev) {
    var lastValue = value;
    var val = ev.target.value;
    if (!('value' in props)) {
      setValue(val);
    }
    var onChange = props.onChange;
    if (onChange && val !== lastValue) {
      onChange(ev);
    }
  };
  var customizePrefixCls = props.prefixCls,
    _props$className = props.className,
    className = _props$className === void 0 ? '' : _props$className,
    options = props.options,
    _props$buttonStyle = props.buttonStyle,
    buttonStyle = _props$buttonStyle === void 0 ? 'outline' : _props$buttonStyle,
    disabled = props.disabled,
    children = props.children,
    customizeSize = props.size,
    style = props.style,
    id = props.id,
    onMouseEnter = props.onMouseEnter,
    onMouseLeave = props.onMouseLeave,
    onFocus = props.onFocus,
    onBlur = props.onBlur;
  var prefixCls = getPrefixCls('radio', customizePrefixCls);
  var groupPrefixCls = prefixCls + "-group";
  // Style
  var _useStyle = useStyle$g(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var childrenToRender = children;
  //  options, 
  if (options && options.length > 0) {
    childrenToRender = options.map(function (option) {
      if (typeof option === 'string' || typeof option === 'number') {
        //  string
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(InternalRadio$1, {
            prefixCls: prefixCls,
            disabled: disabled,
            value: option,
            checked: value === option,
            children: option
          }, option.toString())
        );
      }
      //  { label: string value: string }
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(InternalRadio$1, {
          prefixCls: prefixCls,
          disabled: option.disabled || disabled,
          value: option.value,
          checked: value === option.value,
          style: option.style,
          children: option.label
        }, "radio-group-value-options-" + option.value)
      );
    });
  }
  var mergedSize = customizeSize || size;
  var classString = classNames$1(groupPrefixCls, groupPrefixCls + "-" + buttonStyle, (_classNames = {}, _defineProperty$1(_classNames, groupPrefixCls + "-" + mergedSize, mergedSize), _defineProperty$1(_classNames, groupPrefixCls + "-rtl", direction === 'rtl'), _classNames), className, hashId);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    ...getDataOrAriaProps(props),
    className: classString,
    style: style,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    onFocus: onFocus,
    onBlur: onBlur,
    id: id,
    ref: ref,
    children: /*#__PURE__*/jsx$1(RadioGroupContextProvider, {
      value: {
        onChange: onRadioChange,
        value: value,
        disabled: props.disabled,
        name: props.name,
        optionType: props.optionType
      },
      children: childrenToRender
    })
  }));
});
const Group$4 = /*#__PURE__*/react.exports.memo(RadioGroup);

var __rest$B = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var RadioButton = function RadioButton(props, ref) {
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls;
  var customizePrefixCls = props.prefixCls,
    radioProps = __rest$B(props, ["prefixCls"]);
  var prefixCls = getPrefixCls('radio', customizePrefixCls);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(RadioOptionTypeContextProvider, {
      value: "button",
      children: /*#__PURE__*/jsx$1(InternalRadio$1, {
        prefixCls: prefixCls,
        ...radioProps,
        type: "radio",
        ref: ref
      })
    })
  );
};
const Button = /*#__PURE__*/react.exports.forwardRef(RadioButton);

var Radio = InternalRadio$1;
Radio.Button = Button;
Radio.Group = Group$4;
Radio.__ANT_RADIO = true;
const Radio$1 = Radio;

var genPlaceholderStyle = function genPlaceholderStyle(color) {
  return {
    // Firefox
    '&::-moz-placeholder': {
      opacity: 1
    },
    '&::placeholder': {
      color: color,
      userSelect: 'none' // https://github.com/ant-design/ant-design/pull/32639
    },

    '&:placeholder-shown': {
      textOverflow: 'ellipsis'
    }
  };
};
var genHoverStyle = function genHoverStyle(token) {
  return {
    borderColor: token.inputBorderHoverColor,
    borderInlineEndWidth: token.lineWidth
  };
};
var genActiveStyle = function genActiveStyle(token) {
  return {
    borderColor: token.inputBorderHoverColor,
    boxShadow: "0 0 0 " + token.controlOutlineWidth + "px " + token.controlOutline,
    borderInlineEndWidth: token.lineWidth,
    outline: 0
  };
};
var genDisabledStyle = function genDisabledStyle(token) {
  return {
    color: token.colorTextDisabled,
    backgroundColor: token.colorBgContainerDisabled,
    borderColor: token.colorBorder,
    boxShadow: 'none',
    cursor: 'not-allowed',
    opacity: 1,
    '&:hover': _extends$2({}, genHoverStyle(merge$2(token, {
      inputBorderHoverColor: token.colorBorder
    })))
  };
};
var genInputLargeStyle = function genInputLargeStyle(token) {
  var inputPaddingVerticalLG = token.inputPaddingVerticalLG,
    fontSizeLG = token.fontSizeLG,
    lineHeightLG = token.lineHeightLG,
    borderRadiusLG = token.borderRadiusLG,
    inputPaddingHorizontalLG = token.inputPaddingHorizontalLG;
  return {
    padding: inputPaddingVerticalLG + "px " + inputPaddingHorizontalLG + "px",
    fontSize: fontSizeLG,
    lineHeight: lineHeightLG,
    borderRadius: borderRadiusLG
  };
};
var genInputSmallStyle = function genInputSmallStyle(token) {
  return {
    padding: token.inputPaddingVerticalSM + "px " + (token.controlPaddingHorizontalSM - 1) + "px",
    borderRadius: token.borderRadiusSM
  };
};
var genStatusStyle = function genStatusStyle(token) {
  var componentCls = token.componentCls,
    colorError = token.colorError,
    colorWarning = token.colorWarning,
    colorErrorOutline = token.colorErrorOutline,
    colorWarningOutline = token.colorWarningOutline,
    colorErrorBorderHover = token.colorErrorBorderHover,
    colorWarningBorderHover = token.colorWarningBorderHover;
  return {
    '&-status-error:not(&-disabled):not(&-borderless)&': _defineProperty$1({
      borderColor: colorError,
      '&:hover': {
        borderColor: colorErrorBorderHover
      },
      '&:focus, &-focused': _extends$2({}, genActiveStyle(merge$2(token, {
        inputBorderActiveColor: colorError,
        inputBorderHoverColor: colorError,
        controlOutline: colorErrorOutline
      })))
    }, componentCls + "-prefix", {
      color: colorError
    }),
    '&-status-warning:not(&-disabled):not(&-borderless)&': _defineProperty$1({
      borderColor: colorWarning,
      '&:hover': {
        borderColor: colorWarningBorderHover
      },
      '&:focus, &-focused': _extends$2({}, genActiveStyle(merge$2(token, {
        inputBorderActiveColor: colorWarning,
        inputBorderHoverColor: colorWarning,
        controlOutline: colorWarningOutline
      })))
    }, componentCls + "-prefix", {
      color: colorWarning
    })
  };
};
var genBasicInputStyle = function genBasicInputStyle(token) {
  return _extends$2(_extends$2({
    position: 'relative',
    display: 'inline-block',
    width: '100%',
    minWidth: 0,
    padding: token.inputPaddingVertical + "px " + token.inputPaddingHorizontal + "px",
    color: token.colorText,
    fontSize: token.fontSize,
    lineHeight: token.lineHeight,
    backgroundColor: token.colorBgContainer,
    backgroundImage: 'none',
    borderWidth: token.lineWidth,
    borderStyle: token.lineType,
    borderColor: token.colorBorder,
    borderRadius: token.borderRadius,
    transition: "all " + token.motionDurationMid
  }, genPlaceholderStyle(token.colorTextPlaceholder)), {
    '&:hover': _extends$2({}, genHoverStyle(token)),
    '&:focus, &-focused': _extends$2({}, genActiveStyle(token)),
    '&-disabled, &[disabled]': _extends$2({}, genDisabledStyle(token)),
    '&-borderless': {
      '&, &:hover, &:focus, &-focused, &-disabled, &[disabled]': {
        backgroundColor: 'transparent',
        border: 'none',
        boxShadow: 'none'
      }
    },
    // Reset height for `textarea`s
    'textarea&': {
      maxWidth: '100%',
      height: 'auto',
      minHeight: token.controlHeight,
      lineHeight: token.lineHeight,
      verticalAlign: 'bottom',
      transition: "all " + token.motionDurationSlow + ", height 0s",
      resize: 'vertical'
    },
    // Size
    '&-lg': _extends$2({}, genInputLargeStyle(token)),
    '&-sm': _extends$2({}, genInputSmallStyle(token)),
    // RTL
    '&-rtl': {
      direction: 'rtl'
    },
    '&-textarea-rtl': {
      direction: 'rtl'
    }
  });
};
var genInputGroupStyle = function genInputGroupStyle(token) {
  var _ref2, _addon, _ref4, _ref6, _ref10, _extends2, _ref12;
  var componentCls = token.componentCls,
    antCls = token.antCls;
  return _ref12 = {
    position: 'relative',
    display: 'table',
    width: '100%',
    borderCollapse: 'separate',
    borderSpacing: 0
  }, _defineProperty$1(_ref12, "&[class*='col-']", {
    paddingInlineEnd: token.paddingXS,
    '&:last-child': {
      paddingInlineEnd: 0
    }
  }), _defineProperty$1(_ref12, "&-lg " + componentCls + ", &-lg > " + componentCls + "-group-addon", _extends$2({}, genInputLargeStyle(token))), _defineProperty$1(_ref12, "&-sm " + componentCls + ", &-sm > " + componentCls + "-group-addon", _extends$2({}, genInputSmallStyle(token))), _defineProperty$1(_ref12, "&-lg " + antCls + "-select-single " + antCls + "-select-selector", {
    height: token.controlHeightLG
  }), _defineProperty$1(_ref12, "&-sm " + antCls + "-select-single " + antCls + "-select-selector", {
    height: token.controlHeightSM
  }), _defineProperty$1(_ref12, "> " + componentCls, {
    display: 'table-cell',
    '&:not(:first-child):not(:last-child)': {
      borderRadius: 0
    }
  }), _defineProperty$1(_ref12, componentCls + "-group", (_ref4 = {}, _defineProperty$1(_ref4, "&-addon, &-wrap", {
    display: 'table-cell',
    width: 1,
    whiteSpace: 'nowrap',
    verticalAlign: 'middle',
    '&:not(:first-child):not(:last-child)': {
      borderRadius: 0
    }
  }), _defineProperty$1(_ref4, '&-wrap > *', {
    display: 'block !important'
  }), _defineProperty$1(_ref4, '&-addon', (_addon = {
    position: 'relative',
    padding: "0 " + token.inputPaddingHorizontal + "px",
    color: token.colorText,
    fontWeight: 'normal',
    fontSize: token.fontSize,
    textAlign: 'center',
    backgroundColor: token.colorFillAlter,
    border: token.lineWidth + "px " + token.lineType + " " + token.colorBorder,
    borderRadius: token.borderRadius,
    transition: "all " + token.motionDurationSlow
  }, _defineProperty$1(_addon, antCls + "-select", (_ref2 = {
    margin: "-" + (token.inputPaddingVertical + 1) + "px -" + token.inputPaddingHorizontal + "px"
  }, _defineProperty$1(_ref2, "&" + antCls + "-select-single:not(" + antCls + "-select-customize-input)", _defineProperty$1({}, antCls + "-select-selector", {
    backgroundColor: 'inherit',
    border: token.lineWidth + "px " + token.lineType + " transparent",
    boxShadow: 'none'
  })), _defineProperty$1(_ref2, '&-open, &-focused', _defineProperty$1({}, antCls + "-select-selector", {
    color: token.colorPrimary
  })), _ref2)), _defineProperty$1(_addon, antCls + "-cascader-picker", _defineProperty$1({
    margin: "-9px -" + token.inputPaddingHorizontal + "px",
    backgroundColor: 'transparent'
  }, antCls + "-cascader-input", {
    textAlign: 'start',
    border: 0,
    boxShadow: 'none'
  })), _addon)), _defineProperty$1(_ref4, '&-addon:first-child', {
    borderInlineEnd: 0
  }), _defineProperty$1(_ref4, '&-addon:last-child', {
    borderInlineStart: 0
  }), _ref4)), _defineProperty$1(_ref12, "" + componentCls, {
    "float": 'inline-start',
    width: '100%',
    marginBottom: 0,
    textAlign: 'inherit',
    '&:focus': {
      zIndex: 1,
      borderInlineEndWidth: 1
    },
    '&:hover': _defineProperty$1({
      zIndex: 1,
      borderInlineEndWidth: 1
    }, componentCls + "-search-with-button &", {
      zIndex: 0
    })
  }), _defineProperty$1(_ref12, "> " + componentCls + ":first-child, " + componentCls + "-group-addon:first-child", _defineProperty$1({
    borderStartEndRadius: 0,
    borderEndEndRadius: 0
  }, antCls + "-select " + antCls + "-select-selector", {
    borderStartEndRadius: 0,
    borderEndEndRadius: 0
  })), _defineProperty$1(_ref12, "> " + componentCls + "-affix-wrapper", (_ref6 = {}, _defineProperty$1(_ref6, "&:not(:first-child) " + componentCls, {
    borderStartStartRadius: 0,
    borderEndStartRadius: 0
  }), _defineProperty$1(_ref6, "&:not(:last-child) " + componentCls, {
    borderStartEndRadius: 0,
    borderEndEndRadius: 0
  }), _ref6)), _defineProperty$1(_ref12, "> " + componentCls + ":last-child, " + componentCls + "-group-addon:last-child", _defineProperty$1({
    borderStartStartRadius: 0,
    borderEndStartRadius: 0
  }, antCls + "-select " + antCls + "-select-selector", {
    borderStartStartRadius: 0,
    borderEndStartRadius: 0
  })), _defineProperty$1(_ref12, componentCls + "-affix-wrapper", _defineProperty$1({
    '&:not(:last-child)': _defineProperty$1({
      borderStartEndRadius: 0,
      borderEndEndRadius: 0
    }, componentCls + "-search &", {
      borderStartStartRadius: token.borderRadius,
      borderEndStartRadius: token.borderRadius
    })
  }, "&:not(:first-child), " + componentCls + "-search &:not(:first-child)", {
    borderStartStartRadius: 0,
    borderEndStartRadius: 0
  })), _defineProperty$1(_ref12, '&&-compact', _extends$2(_extends$2({
    display: 'block'
  }, clearFix()), (_extends2 = {}, _defineProperty$1(_extends2, componentCls + "-group-addon, " + componentCls + "-group-wrap, > " + componentCls, {
    '&:not(:first-child):not(:last-child)': {
      borderInlineEndWidth: token.lineWidth,
      '&:hover': {
        zIndex: 1
      },
      '&:focus': {
        zIndex: 1
      }
    }
  }), _defineProperty$1(_extends2, '& > *', {
    display: 'inline-block',
    "float": 'none',
    verticalAlign: 'top',
    borderRadius: 0
  }), _defineProperty$1(_extends2, "& > " + componentCls + "-affix-wrapper", {
    display: 'inline-flex'
  }), _defineProperty$1(_extends2, "& > " + antCls + "-picker-range", {
    display: 'inline-flex'
  }), _defineProperty$1(_extends2, '& > *:not(:last-child)', {
    marginInlineEnd: -token.lineWidth,
    borderInlineEndWidth: token.lineWidth
  }), _defineProperty$1(_extends2, "" + componentCls, {
    "float": 'none'
  }), _defineProperty$1(_extends2, "& > " + antCls + "-select > " + antCls + "-select-selector,\n      & > " + antCls + "-select-auto-complete " + componentCls + ",\n      & > " + antCls + "-cascader-picker " + componentCls + ",\n      & > " + componentCls + "-group-wrapper " + componentCls, {
    borderInlineEndWidth: token.lineWidth,
    borderRadius: 0,
    '&:hover': {
      zIndex: 1
    },
    '&:focus': {
      zIndex: 1
    }
  }), _defineProperty$1(_extends2, "& > " + antCls + "-select-focused", {
    zIndex: 1
  }), _defineProperty$1(_extends2, "& > " + antCls + "-select > " + antCls + "-select-arrow", {
    zIndex: 1 // https://github.com/ant-design/ant-design/issues/20371
  }), _defineProperty$1(_extends2, "& > *:first-child,\n      & > " + antCls + "-select:first-child > " + antCls + "-select-selector,\n      & > " + antCls + "-select-auto-complete:first-child " + componentCls + ",\n      & > " + antCls + "-cascader-picker:first-child " + componentCls, {
    borderStartStartRadius: token.borderRadius,
    borderEndStartRadius: token.borderRadius
  }), _defineProperty$1(_extends2, "& > *:last-child,\n      & > " + antCls + "-select:last-child > " + antCls + "-select-selector,\n      & > " + antCls + "-cascader-picker:last-child " + componentCls + ",\n      & > " + antCls + "-cascader-picker-focused:last-child " + componentCls, {
    borderInlineEndWidth: token.lineWidth,
    borderStartEndRadius: token.borderRadius,
    borderEndEndRadius: token.borderRadius
  }), _defineProperty$1(_extends2, "& > " + antCls + "-select-auto-complete " + componentCls, {
    verticalAlign: 'top'
  }), _defineProperty$1(_extends2, componentCls + "-group-wrapper + " + componentCls + "-group-wrapper", _defineProperty$1({
    marginInlineStart: -token.lineWidth
  }, componentCls + "-affix-wrapper", {
    borderRadius: 0
  })), _defineProperty$1(_extends2, componentCls + "-group-wrapper:not(:last-child)", _defineProperty$1({}, "&" + componentCls + "-search > " + componentCls + "-group", (_ref10 = {}, _defineProperty$1(_ref10, "& > " + componentCls + "-group-addon > " + componentCls + "-search-button", {
    borderRadius: 0
  }), _defineProperty$1(_ref10, "& > " + componentCls, {
    borderStartStartRadius: token.borderRadius,
    borderStartEndRadius: 0,
    borderEndEndRadius: 0,
    borderEndStartRadius: token.borderRadius
  }), _ref10))), _extends2))), _ref12;
};
var genInputStyle = function genInputStyle(token) {
  var _typeColor;
  var componentCls = token.componentCls,
    controlHeightSM = token.controlHeightSM,
    lineWidth = token.lineWidth;
  var FIXED_CHROME_COLOR_HEIGHT = 16;
  var colorSmallPadding = (controlHeightSM - lineWidth * 2 - FIXED_CHROME_COLOR_HEIGHT) / 2;
  return _defineProperty$1({}, "" + componentCls, _extends$2(_extends$2(_extends$2(_extends$2({}, resetComponent(token)), genBasicInputStyle(token)), genStatusStyle(token)), {
    '&[type="color"]': (_typeColor = {
      height: token.controlHeight
    }, _defineProperty$1(_typeColor, "&" + componentCls + "-lg", {
      height: token.controlHeightLG
    }), _defineProperty$1(_typeColor, "&" + componentCls + "-sm", {
      height: controlHeightSM,
      paddingTop: colorSmallPadding,
      paddingBottom: colorSmallPadding
    }), _typeColor)
  }));
};
var genAllowClearStyle = function genAllowClearStyle(token) {
  var _ref14;
  var componentCls = token.componentCls;
  return _ref14 = {}, _defineProperty$1(_ref14, componentCls + "-clear-icon", {
    margin: 0,
    color: token.colorTextQuaternary,
    fontSize: token.fontSizeIcon,
    verticalAlign: -1,
    // https://github.com/ant-design/ant-design/pull/18151
    // https://codesandbox.io/s/wizardly-sun-u10br
    cursor: 'pointer',
    transition: "color " + token.motionDurationSlow,
    '&:hover': {
      color: token.colorTextTertiary
    },
    '&:active': {
      color: token.colorText
    },
    '&-hidden': {
      visibility: 'hidden'
    },
    '&-has-suffix': {
      margin: "0 " + token.inputAffixPadding + "px"
    }
  }), _defineProperty$1(_ref14, '&-textarea-with-clear-btn', _defineProperty$1({
    padding: '0 !important',
    border: '0 !important'
  }, componentCls + "-clear-icon", {
    position: 'absolute',
    insetBlockStart: token.paddingXS,
    insetInlineEnd: token.paddingXS,
    zIndex: 1
  })), _ref14;
};
var genAffixStyle = function genAffixStyle(token) {
  var _extends4;
  var componentCls = token.componentCls,
    inputAffixPadding = token.inputAffixPadding,
    colorTextDescription = token.colorTextDescription,
    motionDurationSlow = token.motionDurationSlow,
    colorIcon = token.colorIcon,
    colorIconHover = token.colorIconHover,
    iconCls = token.iconCls;
  return _defineProperty$1({}, componentCls + "-affix-wrapper", _extends$2(_extends$2(_extends$2(_extends$2(_extends$2({}, genBasicInputStyle(token)), (_extends4 = {
    display: 'inline-flex',
    '&:not(&-disabled):hover': _extends$2(_extends$2({}, genHoverStyle(token)), _defineProperty$1({
      zIndex: 1
    }, componentCls + "-search-with-button &", {
      zIndex: 0
    })),
    '&-focused, &:focus': {
      zIndex: 1
    },
    '&-disabled': _defineProperty$1({}, componentCls + "[disabled]", {
      background: 'transparent'
    })
  }, _defineProperty$1(_extends4, "> input" + componentCls, {
    padding: 0,
    fontSize: 'inherit',
    border: 'none',
    borderRadius: 0,
    outline: 'none',
    '&:focus': {
      boxShadow: 'none !important'
    }
  }), _defineProperty$1(_extends4, '&::before', {
    width: 0,
    visibility: 'hidden',
    content: '"\\a0"'
  }), _defineProperty$1(_extends4, "" + componentCls, {
    '&-prefix, &-suffix': {
      display: 'flex',
      flex: 'none',
      alignItems: 'center',
      '> *:not(:last-child)': {
        marginInlineEnd: token.paddingXS
      }
    },
    '&-show-count-suffix': {
      color: colorTextDescription
    },
    '&-show-count-has-suffix': {
      marginInlineEnd: token.paddingXXS
    },
    '&-prefix': {
      marginInlineEnd: inputAffixPadding
    },
    '&-suffix': {
      marginInlineStart: inputAffixPadding
    }
  }), _extends4)), genAllowClearStyle(token)), _defineProperty$1({}, "" + iconCls + componentCls + "-password-icon", {
    color: colorIcon,
    cursor: 'pointer',
    transition: "all " + motionDurationSlow,
    '&:hover': {
      color: colorIconHover
    }
  })), genStatusStyle(token)));
};
var genGroupStyle = function genGroupStyle(token) {
  var componentCls = token.componentCls,
    colorError = token.colorError,
    colorSuccess = token.colorSuccess,
    borderRadiusLG = token.borderRadiusLG,
    borderRadiusSM = token.borderRadiusSM;
  return _defineProperty$1({}, componentCls + "-group", _extends$2(_extends$2(_extends$2({}, resetComponent(token)), genInputGroupStyle(token)), {
    '&-rtl': {
      direction: 'rtl'
    },
    '&-wrapper': {
      display: 'inline-block',
      width: '100%',
      textAlign: 'start',
      verticalAlign: 'top',
      '&-rtl': {
        direction: 'rtl'
      },
      // Size
      '&-lg': _defineProperty$1({}, componentCls + "-group-addon", {
        borderRadius: borderRadiusLG
      }),
      '&-sm': _defineProperty$1({}, componentCls + "-group-addon", {
        borderRadius: borderRadiusSM
      }),
      // Status
      '&-status-error': _defineProperty$1({}, componentCls + "-group-addon", {
        color: colorError,
        borderColor: colorError
      }),
      '&-status-warning': _defineProperty$1({}, componentCls + "-group-addon:last-child", {
        color: colorSuccess,
        borderColor: colorSuccess
      })
    }
  }));
};
var genSearchInputStyle = function genSearchInputStyle(token) {
  var _ref18, _ref23, _searchPrefixCls;
  var componentCls = token.componentCls,
    antCls = token.antCls;
  var searchPrefixCls = componentCls + "-search";
  return _defineProperty$1({}, searchPrefixCls, (_searchPrefixCls = {}, _defineProperty$1(_searchPrefixCls, "" + componentCls, {
    '&:hover, &:focus': _defineProperty$1({
      borderColor: token.colorPrimaryHover
    }, "+ " + componentCls + "-group-addon " + searchPrefixCls + "-button:not(" + antCls + "-btn-primary)", {
      borderInlineStartColor: token.colorPrimaryHover
    })
  }), _defineProperty$1(_searchPrefixCls, componentCls + "-affix-wrapper", {
    borderRadius: 0
  }), _defineProperty$1(_searchPrefixCls, componentCls + "-lg", {
    lineHeight: token.lineHeightLG - 0.0002
  }), _defineProperty$1(_searchPrefixCls, "> " + componentCls + "-group", _defineProperty$1({}, "> " + componentCls + "-group-addon:last-child", (_ref18 = {
    insetInlineStart: -1,
    padding: 0,
    border: 0
  }, _defineProperty$1(_ref18, searchPrefixCls + "-button", {
    paddingTop: 0,
    paddingBottom: 0,
    borderStartStartRadius: 0,
    borderStartEndRadius: token.borderRadius,
    borderEndEndRadius: token.borderRadius,
    borderEndStartRadius: 0
  }), _defineProperty$1(_ref18, searchPrefixCls + "-button:not(" + antCls + "-btn-primary)", _defineProperty$1({
    color: token.colorTextDescription,
    '&:hover': {
      color: token.colorPrimaryHover
    },
    '&:active': {
      color: token.colorPrimaryActive
    }
  }, "&" + antCls + "-btn-loading::before", {
    insetInlineStart: 0,
    insetInlineEnd: 0,
    insetBlockStart: 0,
    insetBlockEnd: 0
  })), _ref18))), _defineProperty$1(_searchPrefixCls, searchPrefixCls + "-button", {
    height: token.controlHeight,
    '&:hover, &:focus': {
      zIndex: 1
    }
  }), _defineProperty$1(_searchPrefixCls, "&-large " + searchPrefixCls + "-button", {
    height: token.controlHeightLG
  }), _defineProperty$1(_searchPrefixCls, "&-small " + searchPrefixCls + "-button", {
    height: token.controlHeightSM
  }), _defineProperty$1(_searchPrefixCls, '&-rtl', {
    direction: 'rtl'
  }), _defineProperty$1(_searchPrefixCls, "&" + componentCls + "-compact-item", (_ref23 = {}, _defineProperty$1(_ref23, "&:not(" + componentCls + "-compact-last-item)", _defineProperty$1({}, componentCls + "-group-addon", _defineProperty$1({}, componentCls + "-search-button", {
    marginInlineEnd: -token.lineWidth,
    borderRadius: 0
  }))), _defineProperty$1(_ref23, "&:not(" + componentCls + "-compact-first-item)", _defineProperty$1({}, componentCls + "," + componentCls + "-affix-wrapper", {
    borderRadius: 0
  })), _defineProperty$1(_ref23, "> " + componentCls + "-group-addon " + componentCls + "-search-button,\n        > " + componentCls + ",\n        " + componentCls + "-affix-wrapper", {
    '&:hover,&:focus,&:active': {
      zIndex: 2
    }
  }), _defineProperty$1(_ref23, "> " + componentCls + "-affix-wrapper-focused", {
    zIndex: 2
  }), _ref23)), _searchPrefixCls));
};
function initInputToken(token) {
  // @ts-ignore
  return merge$2(token, {
    inputAffixPadding: token.paddingXXS,
    inputPaddingVertical: Math.max(Math.round((token.controlHeight - token.fontSize * token.lineHeight) / 2 * 10) / 10 - token.lineWidth, 3),
    inputPaddingVerticalLG: Math.ceil((token.controlHeightLG - token.fontSizeLG * token.lineHeightLG) / 2 * 10) / 10 - token.lineWidth,
    inputPaddingVerticalSM: Math.max(Math.round((token.controlHeightSM - token.fontSize * token.lineHeight) / 2 * 10) / 10 - token.lineWidth, 0),
    inputPaddingHorizontal: token.paddingSM - token.lineWidth,
    inputPaddingHorizontalSM: token.paddingXS - token.lineWidth,
    inputPaddingHorizontalLG: token.controlPaddingHorizontal - token.lineWidth,
    inputBorderHoverColor: token.colorPrimaryHover,
    inputBorderActiveColor: token.colorPrimaryHover
  });
}
var genTextAreaStyle = function genTextAreaStyle(token) {
  var _showCount, _textareaPrefixCls;
  var componentCls = token.componentCls,
    inputPaddingHorizontal = token.inputPaddingHorizontal,
    paddingLG = token.paddingLG;
  var textareaPrefixCls = componentCls + "-textarea";
  return _defineProperty$1({}, textareaPrefixCls, (_textareaPrefixCls = {
    position: 'relative'
  }, _defineProperty$1(_textareaPrefixCls, textareaPrefixCls + "-suffix", {
    position: 'absolute',
    top: 0,
    insetInlineEnd: inputPaddingHorizontal,
    bottom: 0,
    zIndex: 1,
    display: 'inline-flex',
    alignItems: 'center',
    margin: 'auto'
  }), _defineProperty$1(_textareaPrefixCls, "&-status-error,\n        &-status-warning,\n        &-status-success,\n        &-status-validating", _defineProperty$1({}, "&" + textareaPrefixCls + "-has-feedback", _defineProperty$1({}, "" + componentCls, {
    paddingInlineEnd: paddingLG
  }))), _defineProperty$1(_textareaPrefixCls, '&-show-count', (_showCount = {}, _defineProperty$1(_showCount, "> " + componentCls, {
    height: '100%'
  }), _defineProperty$1(_showCount, '&::after', {
    color: token.colorTextDescription,
    whiteSpace: 'nowrap',
    content: 'attr(data-count)',
    pointerEvents: 'none',
    "float": 'right'
  }), _showCount)), _defineProperty$1(_textareaPrefixCls, '&-rtl', {
    '&::after': {
      "float": 'left'
    }
  }), _textareaPrefixCls));
};
// ============================== Export ==============================
const useStyle$f = genComponentStyleHook('Input', function (token) {
  var inputToken = initInputToken(token);
  return [genInputStyle(inputToken), genTextAreaStyle(inputToken), genAffixStyle(inputToken), genGroupStyle(inputToken), genSearchInputStyle(inputToken),
  // =====================================================
  // ==             Space Compact                       ==
  // =====================================================
  genCompactItemStyle(inputToken)];
});

var Element$1 = function Element(props) {
  var _classNames, _classNames2;
  var prefixCls = props.prefixCls,
    className = props.className,
    style = props.style,
    size = props.size,
    shape = props.shape;
  var sizeCls = classNames$1((_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-lg", size === 'large'), _defineProperty$1(_classNames, prefixCls + "-sm", size === 'small'), _classNames));
  var shapeCls = classNames$1((_classNames2 = {}, _defineProperty$1(_classNames2, prefixCls + "-circle", shape === 'circle'), _defineProperty$1(_classNames2, prefixCls + "-square", shape === 'square'), _defineProperty$1(_classNames2, prefixCls + "-round", shape === 'round'), _classNames2));
  var sizeStyle = react.exports.useMemo(function () {
    return typeof size === 'number' ? {
      width: size,
      height: size,
      lineHeight: size + "px"
    } : {};
  }, [size]);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      className: classNames$1(prefixCls, sizeCls, shapeCls, className),
      style: _extends$2(_extends$2({}, sizeStyle), style)
    })
  );
};
const Element$2 = Element$1;

var skeletonClsLoading = new Keyframe("ant-skeleton-loading", {
  '0%': {
    transform: 'translateX(-37.5%)'
  },
  '100%': {
    transform: 'translateX(37.5%)'
  }
});
var genSkeletonElementCommonSize = function genSkeletonElementCommonSize(size) {
  return {
    height: size,
    lineHeight: size + "px"
  };
};
var genSkeletonElementAvatarSize = function genSkeletonElementAvatarSize(size) {
  return _extends$2({
    width: size
  }, genSkeletonElementCommonSize(size));
};
var genSkeletonColor = function genSkeletonColor(token) {
  return {
    position: 'relative',
    // fix https://github.com/ant-design/ant-design/issues/36444
    // https://monshin.github.io/202109/css/safari-border-radius-overflow-hidden/
    /* stylelint-disable-next-line property-no-vendor-prefix,value-no-vendor-prefix */
    zIndex: 0,
    overflow: 'hidden',
    background: 'transparent',
    '&::after': {
      position: 'absolute',
      top: 0,
      insetInlineEnd: '-150%',
      bottom: 0,
      insetInlineStart: '-150%',
      background: token.skeletonLoadingBackground,
      animationName: skeletonClsLoading,
      animationDuration: token.skeletonLoadingMotionDuration,
      animationTimingFunction: 'ease',
      animationIterationCount: 'infinite',
      content: '""'
    }
  };
};
var genSkeletonElementInputSize = function genSkeletonElementInputSize(size) {
  return _extends$2({
    width: size * 5,
    minWidth: size * 5
  }, genSkeletonElementCommonSize(size));
};
var genSkeletonElementAvatar = function genSkeletonElementAvatar(token) {
  var _ref;
  var skeletonAvatarCls = token.skeletonAvatarCls,
    color = token.color,
    controlHeight = token.controlHeight,
    controlHeightLG = token.controlHeightLG,
    controlHeightSM = token.controlHeightSM;
  return _ref = {}, _defineProperty$1(_ref, "" + skeletonAvatarCls, _extends$2({
    display: 'inline-block',
    verticalAlign: 'top',
    background: color
  }, genSkeletonElementAvatarSize(controlHeight))), _defineProperty$1(_ref, "" + skeletonAvatarCls + skeletonAvatarCls + "-circle", {
    borderRadius: '50%'
  }), _defineProperty$1(_ref, "" + skeletonAvatarCls + skeletonAvatarCls + "-lg", _extends$2({}, genSkeletonElementAvatarSize(controlHeightLG))), _defineProperty$1(_ref, "" + skeletonAvatarCls + skeletonAvatarCls + "-sm", _extends$2({}, genSkeletonElementAvatarSize(controlHeightSM))), _ref;
};
var genSkeletonElementInput = function genSkeletonElementInput(token) {
  var _ref2;
  var controlHeight = token.controlHeight,
    borderRadiusSM = token.borderRadiusSM,
    skeletonInputCls = token.skeletonInputCls,
    controlHeightLG = token.controlHeightLG,
    controlHeightSM = token.controlHeightSM,
    color = token.color;
  return _ref2 = {}, _defineProperty$1(_ref2, "" + skeletonInputCls, _extends$2({
    display: 'inline-block',
    verticalAlign: 'top',
    background: color,
    borderRadius: borderRadiusSM
  }, genSkeletonElementInputSize(controlHeight))), _defineProperty$1(_ref2, skeletonInputCls + "-lg", _extends$2({}, genSkeletonElementInputSize(controlHeightLG))), _defineProperty$1(_ref2, skeletonInputCls + "-sm", _extends$2({}, genSkeletonElementInputSize(controlHeightSM))), _ref2;
};
var genSkeletonElementImageSize = function genSkeletonElementImageSize(size) {
  return _extends$2({
    width: size
  }, genSkeletonElementCommonSize(size));
};
var genSkeletonElementImage = function genSkeletonElementImage(token) {
  var _extends2, _ref3;
  var skeletonImageCls = token.skeletonImageCls,
    imageSizeBase = token.imageSizeBase,
    color = token.color,
    borderRadiusSM = token.borderRadiusSM;
  return _ref3 = {}, _defineProperty$1(_ref3, "" + skeletonImageCls, _extends$2(_extends$2({
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    verticalAlign: 'top',
    background: color,
    borderRadius: borderRadiusSM
  }, genSkeletonElementImageSize(imageSizeBase * 2)), (_extends2 = {}, _defineProperty$1(_extends2, skeletonImageCls + "-path", {
    fill: '#bfbfbf'
  }), _defineProperty$1(_extends2, skeletonImageCls + "-svg", _extends$2(_extends$2({}, genSkeletonElementImageSize(imageSizeBase)), {
    maxWidth: imageSizeBase * 4,
    maxHeight: imageSizeBase * 4
  })), _defineProperty$1(_extends2, skeletonImageCls + "-svg" + skeletonImageCls + "-svg-circle", {
    borderRadius: '50%'
  }), _extends2))), _defineProperty$1(_ref3, "" + skeletonImageCls + skeletonImageCls + "-circle", {
    borderRadius: '50%'
  }), _ref3;
};
var genSkeletonElementButtonShape = function genSkeletonElementButtonShape(token, size, buttonCls) {
  var _ref4;
  var skeletonButtonCls = token.skeletonButtonCls;
  return _ref4 = {}, _defineProperty$1(_ref4, "" + buttonCls + skeletonButtonCls + "-circle", {
    width: size,
    minWidth: size,
    borderRadius: '50%'
  }), _defineProperty$1(_ref4, "" + buttonCls + skeletonButtonCls + "-round", {
    borderRadius: size
  }), _ref4;
};
var genSkeletonElementButtonSize = function genSkeletonElementButtonSize(size) {
  return _extends$2({
    width: size * 2,
    minWidth: size * 2
  }, genSkeletonElementCommonSize(size));
};
var genSkeletonElementButton = function genSkeletonElementButton(token) {
  var borderRadiusSM = token.borderRadiusSM,
    skeletonButtonCls = token.skeletonButtonCls,
    controlHeight = token.controlHeight,
    controlHeightLG = token.controlHeightLG,
    controlHeightSM = token.controlHeightSM,
    color = token.color;
  return _extends$2(_extends$2(_extends$2(_extends$2(_extends$2(_defineProperty$1({}, "" + skeletonButtonCls, _extends$2({
    display: 'inline-block',
    verticalAlign: 'top',
    background: color,
    borderRadius: borderRadiusSM,
    width: controlHeight * 2,
    minWidth: controlHeight * 2
  }, genSkeletonElementButtonSize(controlHeight))), genSkeletonElementButtonShape(token, controlHeight, skeletonButtonCls)), _defineProperty$1({}, skeletonButtonCls + "-lg", _extends$2({}, genSkeletonElementButtonSize(controlHeightLG)))), genSkeletonElementButtonShape(token, controlHeightLG, skeletonButtonCls + "-lg")), _defineProperty$1({}, skeletonButtonCls + "-sm", _extends$2({}, genSkeletonElementButtonSize(controlHeightSM)))), genSkeletonElementButtonShape(token, controlHeightSM, skeletonButtonCls + "-sm"));
};
// =============================== Base ===============================
var genBaseStyle$2 = function genBaseStyle(token) {
  var _ref5, _ref7, _ref9, _ref12, _ref14;
  var componentCls = token.componentCls,
    skeletonAvatarCls = token.skeletonAvatarCls,
    skeletonTitleCls = token.skeletonTitleCls,
    skeletonParagraphCls = token.skeletonParagraphCls,
    skeletonButtonCls = token.skeletonButtonCls,
    skeletonInputCls = token.skeletonInputCls,
    skeletonImageCls = token.skeletonImageCls,
    controlHeight = token.controlHeight,
    controlHeightLG = token.controlHeightLG,
    controlHeightSM = token.controlHeightSM,
    color = token.color,
    padding = token.padding,
    marginSM = token.marginSM,
    borderRadius = token.borderRadius,
    skeletonTitleHeight = token.skeletonTitleHeight,
    skeletonBlockRadius = token.skeletonBlockRadius,
    skeletonParagraphLineHeight = token.skeletonParagraphLineHeight,
    controlHeightXS = token.controlHeightXS,
    skeletonParagraphMarginTop = token.skeletonParagraphMarginTop;
  return _ref14 = {}, _defineProperty$1(_ref14, "" + componentCls, (_ref9 = {
    display: 'table',
    width: '100%'
  }, _defineProperty$1(_ref9, componentCls + "-header", (_ref5 = {
    display: 'table-cell',
    paddingInlineEnd: padding,
    verticalAlign: 'top'
  }, _defineProperty$1(_ref5, "" + skeletonAvatarCls, _extends$2({
    display: 'inline-block',
    verticalAlign: 'top',
    background: color
  }, genSkeletonElementAvatarSize(controlHeight))), _defineProperty$1(_ref5, skeletonAvatarCls + "-circle", {
    borderRadius: '50%'
  }), _defineProperty$1(_ref5, skeletonAvatarCls + "-lg", _extends$2({}, genSkeletonElementAvatarSize(controlHeightLG))), _defineProperty$1(_ref5, skeletonAvatarCls + "-sm", _extends$2({}, genSkeletonElementAvatarSize(controlHeightSM))), _ref5)), _defineProperty$1(_ref9, componentCls + "-content", (_ref7 = {
    display: 'table-cell',
    width: '100%',
    verticalAlign: 'top'
  }, _defineProperty$1(_ref7, "" + skeletonTitleCls, _defineProperty$1({
    width: '100%',
    height: skeletonTitleHeight,
    background: color,
    borderRadius: skeletonBlockRadius
  }, "+ " + skeletonParagraphCls, {
    marginBlockStart: controlHeightSM
  })), _defineProperty$1(_ref7, "" + skeletonParagraphCls, {
    padding: 0,
    '> li': {
      width: '100%',
      height: skeletonParagraphLineHeight,
      listStyle: 'none',
      background: color,
      borderRadius: skeletonBlockRadius,
      '+ li': {
        marginBlockStart: controlHeightXS
      }
    }
  }), _defineProperty$1(_ref7, skeletonParagraphCls + "> li:last-child:not(:first-child):not(:nth-child(2))", {
    width: '61%'
  }), _ref7)), _defineProperty$1(_ref9, "&-round " + componentCls + "-content", _defineProperty$1({}, skeletonTitleCls + ", " + skeletonParagraphCls + " > li", {
    borderRadius: borderRadius
  })), _ref9)), _defineProperty$1(_ref14, componentCls + "-with-avatar " + componentCls + "-content", _defineProperty$1({}, "" + skeletonTitleCls, _defineProperty$1({
    marginBlockStart: marginSM
  }, "+ " + skeletonParagraphCls, {
    marginBlockStart: skeletonParagraphMarginTop
  }))), _defineProperty$1(_ref14, "" + componentCls + componentCls + "-element", _extends$2(_extends$2(_extends$2(_extends$2({
    display: 'inline-block',
    width: 'auto'
  }, genSkeletonElementButton(token)), genSkeletonElementAvatar(token)), genSkeletonElementInput(token)), genSkeletonElementImage(token))), _defineProperty$1(_ref14, "" + componentCls + componentCls + "-block", (_ref12 = {
    width: '100%'
  }, _defineProperty$1(_ref12, "" + skeletonButtonCls, {
    width: '100%'
  }), _defineProperty$1(_ref12, "" + skeletonInputCls, {
    width: '100%'
  }), _ref12)), _defineProperty$1(_ref14, "" + componentCls + componentCls + "-active", _defineProperty$1({}, "\n        " + skeletonTitleCls + ",\n        " + skeletonParagraphCls + " > li,\n        " + skeletonAvatarCls + ",\n        " + skeletonButtonCls + ",\n        " + skeletonInputCls + ",\n        " + skeletonImageCls + "\n      ", _extends$2({}, genSkeletonColor(token)))), _ref14;
};
// ============================== Export ==============================
const useStyle$e = genComponentStyleHook('Skeleton', function (token) {
  var componentCls = token.componentCls;
  var skeletonToken = merge$2(token, {
    skeletonAvatarCls: componentCls + "-avatar",
    skeletonTitleCls: componentCls + "-title",
    skeletonParagraphCls: componentCls + "-paragraph",
    skeletonButtonCls: componentCls + "-button",
    skeletonInputCls: componentCls + "-input",
    skeletonImageCls: componentCls + "-image",
    imageSizeBase: token.controlHeight * 1.5,
    skeletonTitleHeight: token.controlHeight / 2,
    skeletonBlockRadius: token.borderRadiusSM,
    skeletonParagraphLineHeight: token.controlHeight / 2,
    skeletonParagraphMarginTop: token.marginLG + token.marginXXS,
    borderRadius: 100,
    skeletonLoadingBackground: "linear-gradient(90deg, " + token.color + " 25%, " + token.colorGradientEnd + " 37%, " + token.color + " 63%)",
    skeletonLoadingMotionDuration: '1.4s'
  });
  return [genBaseStyle$2(skeletonToken)];
}, function (token) {
  var colorFillContent = token.colorFillContent,
    colorFill = token.colorFill;
  return {
    color: colorFillContent,
    colorGradientEnd: colorFill
  };
});

var SkeletonAvatar = function SkeletonAvatar(props) {
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    active = props.active,
    _props$shape = props.shape,
    shape = _props$shape === void 0 ? 'circle' : _props$shape,
    _props$size = props.size,
    size = _props$size === void 0 ? 'default' : _props$size;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls('skeleton', customizePrefixCls);
  var _useStyle = useStyle$e(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var otherProps = omit$1(props, ['prefixCls', 'className']);
  var cls = classNames$1(prefixCls, prefixCls + "-element", _defineProperty$1({}, prefixCls + "-active", active), className, hashId);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    className: cls,
    children: /*#__PURE__*/jsx$1(Element$2, {
      prefixCls: prefixCls + "-avatar",
      shape: shape,
      size: size,
      ...otherProps
    })
  }));
};
const SkeletonAvatar$1 = SkeletonAvatar;

var SkeletonButton = function SkeletonButton(props) {
  var _classNames;
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    active = props.active,
    _props$block = props.block,
    block = _props$block === void 0 ? false : _props$block,
    _props$size = props.size,
    size = _props$size === void 0 ? 'default' : _props$size;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls('skeleton', customizePrefixCls);
  var _useStyle = useStyle$e(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var otherProps = omit$1(props, ['prefixCls']);
  var cls = classNames$1(prefixCls, prefixCls + "-element", (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-active", active), _defineProperty$1(_classNames, prefixCls + "-block", block), _classNames), className, hashId);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    className: cls,
    children: /*#__PURE__*/jsx$1(Element$2, {
      prefixCls: prefixCls + "-button",
      size: size,
      ...otherProps
    })
  }));
};
const SkeletonButton$1 = SkeletonButton;

// This icon file is generated automatically.
var DotChartOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M888 792H200V168c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v688c0 4.4 3.6 8 8 8h752c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM288 604a64 64 0 10128 0 64 64 0 10-128 0zm118-224a48 48 0 1096 0 48 48 0 10-96 0zm158 228a96 96 0 10192 0 96 96 0 10-192 0zm148-314a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "dot-chart", "theme": "outlined" };
const DotChartOutlinedSvg = DotChartOutlined$2;

var DotChartOutlined = function DotChartOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: DotChartOutlinedSvg
      })
    })
  );
};
DotChartOutlined.displayName = 'DotChartOutlined';
const DotChartOutlined$1 = /*#__PURE__*/react.exports.forwardRef(DotChartOutlined);

var SkeletonNode = function SkeletonNode(props) {
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    style = props.style,
    active = props.active,
    children = props.children;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls('skeleton', customizePrefixCls);
  var _useStyle = useStyle$e(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var cls = classNames$1(prefixCls, prefixCls + "-element", _defineProperty$1({}, prefixCls + "-active", active), hashId, className);
  var content = children !== null && children !== void 0 ? children :
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(DotChartOutlined$1, {});
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    className: cls,
    children: /*#__PURE__*/jsx$1("div", {
      className: classNames$1(prefixCls + "-image", className),
      style: style,
      children: content
    })
  }));
};
const SkeletonNode$1 = SkeletonNode;

var path = 'M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z';
var SkeletonImage = function SkeletonImage(props) {
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    style = props.style,
    active = props.active;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls('skeleton', customizePrefixCls);
  var _useStyle = useStyle$e(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var cls = classNames$1(prefixCls, prefixCls + "-element", _defineProperty$1({}, prefixCls + "-active", active), className, hashId);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    className: cls,
    children: /*#__PURE__*/jsx$1("div", {
      className: classNames$1(prefixCls + "-image", className),
      style: style,
      children: /*#__PURE__*/jsx$1("svg", {
        viewBox: "0 0 1098 1024",
        xmlns: "http://www.w3.org/2000/svg",
        className: prefixCls + "-image-svg",
        children: /*#__PURE__*/jsx$1("path", {
          d: path,
          className: prefixCls + "-image-path"
        })
      })
    })
  }));
};
const SkeletonImage$1 = SkeletonImage;

var SkeletonInput = function SkeletonInput(props) {
  var _classNames;
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    active = props.active,
    block = props.block,
    _props$size = props.size,
    size = _props$size === void 0 ? 'default' : _props$size;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls('skeleton', customizePrefixCls);
  var _useStyle = useStyle$e(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var otherProps = omit$1(props, ['prefixCls']);
  var cls = classNames$1(prefixCls, prefixCls + "-element", (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-active", active), _defineProperty$1(_classNames, prefixCls + "-block", block), _classNames), className, hashId);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    className: cls,
    children: /*#__PURE__*/jsx$1(Element$2, {
      prefixCls: prefixCls + "-input",
      size: size,
      ...otherProps
    })
  }));
};
const SkeletonInput$1 = SkeletonInput;

var Paragraph$2 = function Paragraph(props) {
  var getWidth = function getWidth(index) {
    var width = props.width,
      _props$rows = props.rows,
      rows = _props$rows === void 0 ? 2 : _props$rows;
    if (Array.isArray(width)) {
      return width[index];
    }
    // last paragraph
    if (rows - 1 === index) {
      return width;
    }
    return undefined;
  };
  var prefixCls = props.prefixCls,
    className = props.className,
    style = props.style,
    rows = props.rows;
  var rowList = _toConsumableArray(Array(rows)).map(function (_, index) {
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      // eslint-disable-next-line react/no-array-index-key
      jsx$1("li", {
        style: {
          width: getWidth(index)
        }
      }, index)
    );
  });
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("ul", {
      className: classNames$1(prefixCls, className),
      style: style,
      children: rowList
    })
  );
};
const Paragraph$3 = Paragraph$2;

var Title$2 = function Title(_ref) {
  var prefixCls = _ref.prefixCls,
    className = _ref.className,
    width = _ref.width,
    style = _ref.style;
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("h3", {
      className: classNames$1(prefixCls, className),
      style: _extends$2({
        width: width
      }, style)
    })
  );
};
const Title$3 = Title$2;

function getComponentProps(prop) {
  if (prop && _typeof$1(prop) === 'object') {
    return prop;
  }
  return {};
}
function getAvatarBasicProps(hasTitle, hasParagraph) {
  if (hasTitle && !hasParagraph) {
    // Square avatar
    return {
      size: 'large',
      shape: 'square'
    };
  }
  return {
    size: 'large',
    shape: 'circle'
  };
}
function getTitleBasicProps(hasAvatar, hasParagraph) {
  if (!hasAvatar && hasParagraph) {
    return {
      width: '38%'
    };
  }
  if (hasAvatar && hasParagraph) {
    return {
      width: '50%'
    };
  }
  return {};
}
function getParagraphBasicProps(hasAvatar, hasTitle) {
  var basicProps = {};
  // Width
  if (!hasAvatar || !hasTitle) {
    basicProps.width = '61%';
  }
  // Rows
  if (!hasAvatar && hasTitle) {
    basicProps.rows = 3;
  } else {
    basicProps.rows = 2;
  }
  return basicProps;
}
var Skeleton = function Skeleton(props) {
  var customizePrefixCls = props.prefixCls,
    loading = props.loading,
    className = props.className,
    style = props.style,
    children = props.children,
    _props$avatar = props.avatar,
    avatar = _props$avatar === void 0 ? false : _props$avatar,
    _props$title = props.title,
    title = _props$title === void 0 ? true : _props$title,
    _props$paragraph = props.paragraph,
    paragraph = _props$paragraph === void 0 ? true : _props$paragraph,
    active = props.active,
    round = props.round;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var prefixCls = getPrefixCls('skeleton', customizePrefixCls);
  var _useStyle = useStyle$e(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  if (loading || !('loading' in props)) {
    var _classNames;
    var hasAvatar = !!avatar;
    var hasTitle = !!title;
    var hasParagraph = !!paragraph;
    // Avatar
    var avatarNode;
    if (hasAvatar) {
      var avatarProps = _extends$2(_extends$2({
        prefixCls: prefixCls + "-avatar"
      }, getAvatarBasicProps(hasTitle, hasParagraph)), getComponentProps(avatar));
      // We direct use SkeletonElement as avatar in skeleton internal.
      avatarNode =
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("div", {
        className: prefixCls + "-header",
        children: /*#__PURE__*/jsx$1(Element$2, {
          ...avatarProps
        })
      });
    }
    var contentNode;
    if (hasTitle || hasParagraph) {
      // Title
      var $title;
      if (hasTitle) {
        var titleProps = _extends$2(_extends$2({
          prefixCls: prefixCls + "-title"
        }, getTitleBasicProps(hasAvatar, hasParagraph)), getComponentProps(title));
        $title =
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(Title$3, {
          ...titleProps
        });
      }
      // Paragraph
      var paragraphNode;
      if (hasParagraph) {
        var paragraphProps = _extends$2(_extends$2({
          prefixCls: prefixCls + "-paragraph"
        }, getParagraphBasicProps(hasAvatar, hasTitle)), getComponentProps(paragraph));
        paragraphNode =
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(Paragraph$3, {
          ...paragraphProps
        });
      }
      contentNode =
      /*#__PURE__*/
      /*#__PURE__*/
      jsxs("div", {
        className: prefixCls + "-content",
        children: [$title, paragraphNode]
      });
    }
    var cls = classNames$1(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-with-avatar", hasAvatar), _defineProperty$1(_classNames, prefixCls + "-active", active), _defineProperty$1(_classNames, prefixCls + "-rtl", direction === 'rtl'), _defineProperty$1(_classNames, prefixCls + "-round", round), _classNames), className, hashId);
    return wrapSSR(
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("div", {
      className: cls,
      style: style,
      children: [avatarNode, contentNode]
    }));
  }
  return typeof children !== 'undefined' ? children : null;
};
Skeleton.Button = SkeletonButton$1;
Skeleton.Avatar = SkeletonAvatar$1;
Skeleton.Input = SkeletonInput$1;
Skeleton.Image = SkeletonImage$1;
Skeleton.Node = SkeletonNode$1;
const Skeleton$1 = Skeleton;

// This icon file is generated automatically.
var PlusOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "defs", "attrs": {}, "children": [{ "tag": "style", "attrs": {} }] }, { "tag": "path", "attrs": { "d": "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { "tag": "path", "attrs": { "d": "M176 474h672q8 0 8 8v60q0 8-8 8H176q-8 0-8-8v-60q0-8 8-8z" } }] }, "name": "plus", "theme": "outlined" };
const PlusOutlinedSvg = PlusOutlined$2;

var PlusOutlined = function PlusOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: PlusOutlinedSvg
      })
    })
  );
};
PlusOutlined.displayName = 'PlusOutlined';
const PlusOutlined$1 = /*#__PURE__*/react.exports.forwardRef(PlusOutlined);

const TabContext = /*#__PURE__*/react.exports.createContext(null);

var TabPane$2 = /*#__PURE__*/react.exports.forwardRef(function (_ref, ref) {
  var prefixCls = _ref.prefixCls,
    className = _ref.className,
    style = _ref.style,
    id = _ref.id,
    active = _ref.active,
    tabKey = _ref.tabKey,
    children = _ref.children;
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      id: id && "".concat(id, "-panel-").concat(tabKey),
      role: "tabpanel",
      tabIndex: active ? 0 : -1,
      "aria-labelledby": id && "".concat(id, "-tab-").concat(tabKey),
      "aria-hidden": !active,
      style: style,
      className: classNames$1(prefixCls, active && "".concat(prefixCls, "-active"), className),
      ref: ref,
      children: children
    })
  );
});

var _excluded$q = ["key", "forceRender", "style", "className"];
function TabPanelList(_ref) {
  var id = _ref.id,
    activeKey = _ref.activeKey,
    animated = _ref.animated,
    tabPosition = _ref.tabPosition,
    destroyInactiveTabPane = _ref.destroyInactiveTabPane;
  var _React$useContext = react.exports.useContext(TabContext),
    prefixCls = _React$useContext.prefixCls,
    tabs = _React$useContext.tabs;
  var tabPaneAnimated = animated.tabPane;
  var tabPanePrefixCls = "".concat(prefixCls, "-tabpane");
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      className: classNames$1("".concat(prefixCls, "-content-holder")),
      children: /*#__PURE__*/jsx$1("div", {
        className: classNames$1("".concat(prefixCls, "-content"), "".concat(prefixCls, "-content-").concat(tabPosition), _defineProperty$1({}, "".concat(prefixCls, "-content-animated"), tabPaneAnimated)),
        children: tabs.map(function (_ref2) {
          var key = _ref2.key,
            forceRender = _ref2.forceRender,
            paneStyle = _ref2.style,
            paneClassName = _ref2.className,
            restTabProps = _objectWithoutProperties(_ref2, _excluded$q);
          var active = key === activeKey;
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1(CSSMotion, {
              visible: active,
              forceRender: forceRender,
              removeOnLeave: !!destroyInactiveTabPane,
              leavedClassName: "".concat(tabPanePrefixCls, "-hidden"),
              ...animated.tabPaneMotion,
              children: function (_ref3, ref) {
                var motionStyle = _ref3.style,
                  motionClassName = _ref3.className;
                return (
                  /*#__PURE__*/
                  /*#__PURE__*/
                  jsx$1(TabPane$2, {
                    ...restTabProps,
                    prefixCls: tabPanePrefixCls,
                    id: id,
                    tabKey: key,
                    animated: tabPaneAnimated,
                    active: active,
                    style: _objectSpread2$1(_objectSpread2$1({}, paneStyle), motionStyle),
                    className: classNames$1(paneClassName, motionClassName),
                    ref: ref
                  })
                );
              }
            }, key)
          );
        })
      })
    })
  );
}

var DEFAULT_SIZE$2 = {
  width: 0,
  height: 0,
  left: 0,
  top: 0
};
function useOffsets(tabs, tabSizes, holderScrollWidth) {
  return react.exports.useMemo(function () {
    var _tabs$;

    var map = new Map();
    var lastOffset = tabSizes.get((_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key) || DEFAULT_SIZE$2;
    var rightOffset = lastOffset.left + lastOffset.width;

    for (var i = 0; i < tabs.length; i += 1) {
      var key = tabs[i].key;
      var data = tabSizes.get(key); // Reuse last one when not exist yet

      if (!data) {
        var _tabs;

        data = tabSizes.get((_tabs = tabs[i - 1]) === null || _tabs === void 0 ? void 0 : _tabs.key) || DEFAULT_SIZE$2;
      }

      var entity = map.get(key) || _objectSpread2$1({}, data); // Right


      entity.right = rightOffset - entity.left - entity.width; // Update entity

      map.set(key, entity);
    }

    return map;
  }, [tabs.map(function (tab) {
    return tab.key;
  }).join('_'), tabSizes, holderScrollWidth]);
}

function useRaf(callback) {
  var rafRef = react.exports.useRef();
  var removedRef = react.exports.useRef(false);

  function trigger() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (!removedRef.current) {
      wrapperRaf$1.cancel(rafRef.current);
      rafRef.current = wrapperRaf$1(function () {
        callback.apply(void 0, args);
      });
    }
  }

  react.exports.useEffect(function () {
    //be compatible with react 18 StrictMode in dev
    removedRef.current = false;
    return function () {
      removedRef.current = true;
      wrapperRaf$1.cancel(rafRef.current);
    };
  }, []);
  return trigger;
}
function useRafState(defaultState) {
  var batchRef = react.exports.useRef([]);

  var _useState = react.exports.useState({}),
      _useState2 = _slicedToArray(_useState, 2),
      forceUpdate = _useState2[1];

  var state = react.exports.useRef(typeof defaultState === 'function' ? defaultState() : defaultState);
  var flushUpdate = useRaf(function () {
    var current = state.current;
    batchRef.current.forEach(function (callback) {
      current = callback(current);
    });
    batchRef.current = [];
    state.current = current;
    forceUpdate({});
  });

  function updater(callback) {
    batchRef.current.push(callback);
    flushUpdate();
  }

  return [state.current, updater];
}

function useSyncState$1(defaultState, onChange) {
  var stateRef = react.exports.useRef(defaultState);

  var _React$useState = react.exports.useState({}),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      forceUpdate = _React$useState2[1];

  function setState(updater) {
    var newValue = typeof updater === 'function' ? updater(stateRef.current) : updater;

    if (newValue !== stateRef.current) {
      onChange(newValue, stateRef.current);
    }

    stateRef.current = newValue;
    forceUpdate({});
  }

  return [stateRef.current, setState];
}

var MIN_SWIPE_DISTANCE = 0.1;
var STOP_SWIPE_DISTANCE = 0.01;
var REFRESH_INTERVAL = 20;
var SPEED_OFF_MULTIPLE = Math.pow(0.995, REFRESH_INTERVAL); // ================================= Hook =================================

function useTouchMove(ref, onOffset) {
  var _useState = react.exports.useState(),
      _useState2 = _slicedToArray(_useState, 2),
      touchPosition = _useState2[0],
      setTouchPosition = _useState2[1];

  var _useState3 = react.exports.useState(0),
      _useState4 = _slicedToArray(_useState3, 2),
      lastTimestamp = _useState4[0],
      setLastTimestamp = _useState4[1];

  var _useState5 = react.exports.useState(0),
      _useState6 = _slicedToArray(_useState5, 2),
      lastTimeDiff = _useState6[0],
      setLastTimeDiff = _useState6[1];

  var _useState7 = react.exports.useState(),
      _useState8 = _slicedToArray(_useState7, 2),
      lastOffset = _useState8[0],
      setLastOffset = _useState8[1];

  var motionRef = react.exports.useRef(); // ========================= Events =========================
  // >>> Touch events

  function onTouchStart(e) {
    var _e$touches$ = e.touches[0],
        screenX = _e$touches$.screenX,
        screenY = _e$touches$.screenY;
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    window.clearInterval(motionRef.current);
  }

  function onTouchMove(e) {
    if (!touchPosition) return;
    e.preventDefault();
    var _e$touches$2 = e.touches[0],
        screenX = _e$touches$2.screenX,
        screenY = _e$touches$2.screenY;
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    var offsetX = screenX - touchPosition.x;
    var offsetY = screenY - touchPosition.y;
    onOffset(offsetX, offsetY);
    var now = Date.now();
    setLastTimestamp(now);
    setLastTimeDiff(now - lastTimestamp);
    setLastOffset({
      x: offsetX,
      y: offsetY
    });
  }

  function onTouchEnd() {
    if (!touchPosition) return;
    setTouchPosition(null);
    setLastOffset(null); // Swipe if needed

    if (lastOffset) {
      var distanceX = lastOffset.x / lastTimeDiff;
      var distanceY = lastOffset.y / lastTimeDiff;
      var absX = Math.abs(distanceX);
      var absY = Math.abs(distanceY); // Skip swipe if low distance

      if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE) return;
      var currentX = distanceX;
      var currentY = distanceY;
      motionRef.current = window.setInterval(function () {
        if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
          window.clearInterval(motionRef.current);
          return;
        }

        currentX *= SPEED_OFF_MULTIPLE;
        currentY *= SPEED_OFF_MULTIPLE;
        onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
      }, REFRESH_INTERVAL);
    }
  } // >>> Wheel event


  var lastWheelDirectionRef = react.exports.useRef();

  function onWheel(e) {
    var deltaX = e.deltaX,
        deltaY = e.deltaY; // Convert both to x & y since wheel only happened on PC

    var mixed = 0;
    var absX = Math.abs(deltaX);
    var absY = Math.abs(deltaY);

    if (absX === absY) {
      mixed = lastWheelDirectionRef.current === 'x' ? deltaX : deltaY;
    } else if (absX > absY) {
      mixed = deltaX;
      lastWheelDirectionRef.current = 'x';
    } else {
      mixed = deltaY;
      lastWheelDirectionRef.current = 'y';
    }

    if (onOffset(-mixed, -mixed)) {
      e.preventDefault();
    }
  } // ========================= Effect =========================


  var touchEventsRef = react.exports.useRef(null);
  touchEventsRef.current = {
    onTouchStart: onTouchStart,
    onTouchMove: onTouchMove,
    onTouchEnd: onTouchEnd,
    onWheel: onWheel
  };
  react.exports.useEffect(function () {
    function onProxyTouchStart(e) {
      touchEventsRef.current.onTouchStart(e);
    }

    function onProxyTouchMove(e) {
      touchEventsRef.current.onTouchMove(e);
    }

    function onProxyTouchEnd(e) {
      touchEventsRef.current.onTouchEnd(e);
    }

    function onProxyWheel(e) {
      touchEventsRef.current.onWheel(e);
    }

    document.addEventListener('touchmove', onProxyTouchMove, {
      passive: false
    });
    document.addEventListener('touchend', onProxyTouchEnd, {
      passive: false
    }); // No need to clean up since element removed

    ref.current.addEventListener('touchstart', onProxyTouchStart, {
      passive: false
    });
    ref.current.addEventListener('wheel', onProxyWheel);
    return function () {
      document.removeEventListener('touchmove', onProxyTouchMove);
      document.removeEventListener('touchend', onProxyTouchEnd);
    };
  }, []);
}

var DEFAULT_SIZE$1 = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
};
function useVisibleRange(tabOffsets, visibleTabContentValue, transform, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, _ref) {
  var tabs = _ref.tabs,
      tabPosition = _ref.tabPosition,
      rtl = _ref.rtl;
  var charUnit;
  var position;
  var transformSize;

  if (['top', 'bottom'].includes(tabPosition)) {
    charUnit = 'width';
    position = rtl ? 'right' : 'left';
    transformSize = Math.abs(transform);
  } else {
    charUnit = 'height';
    position = 'top';
    transformSize = -transform;
  }

  return react.exports.useMemo(function () {
    if (!tabs.length) {
      return [0, 0];
    }

    var len = tabs.length;
    var endIndex = len;

    for (var i = 0; i < len; i += 1) {
      var offset = tabOffsets.get(tabs[i].key) || DEFAULT_SIZE$1;

      if (offset[position] + offset[charUnit] > transformSize + visibleTabContentValue) {
        endIndex = i - 1;
        break;
      }
    }

    var startIndex = 0;

    for (var _i = len - 1; _i >= 0; _i -= 1) {
      var _offset = tabOffsets.get(tabs[_i].key) || DEFAULT_SIZE$1;

      if (_offset[position] < transformSize) {
        startIndex = _i + 1;
        break;
      }
    }

    return [startIndex, endIndex];
  }, [tabOffsets, visibleTabContentValue, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, transformSize, tabPosition, tabs.map(function (tab) {
    return tab.key;
  }).join('_'), rtl]);
}

/**
 * We trade Map as deps which may change with same value but different ref object.
 * We should make it as hash for deps
 * */
function stringify(obj) {
  var tgt;

  if (obj instanceof Map) {
    tgt = {};
    obj.forEach(function (v, k) {
      tgt[k] = v;
    });
  } else {
    tgt = obj;
  }

  return JSON.stringify(tgt);
}

function AddButton(_ref, ref) {
  var prefixCls = _ref.prefixCls,
    editable = _ref.editable,
    locale = _ref.locale,
    style = _ref.style;
  if (!editable || editable.showAdd === false) {
    return null;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("button", {
      ref: ref,
      type: "button",
      className: "".concat(prefixCls, "-nav-add"),
      style: style,
      "aria-label": (locale === null || locale === void 0 ? void 0 : locale.addAriaLabel) || 'Add tab',
      onClick: function onClick(event) {
        editable.onEdit('add', {
          event: event
        });
      },
      children: editable.addIcon || '+'
    })
  );
}
const AddButton$1 = /*#__PURE__*/react.exports.forwardRef(AddButton);

var ExtraContent = /*#__PURE__*/react.exports.forwardRef(function (_ref, ref) {
  var position = _ref.position,
    prefixCls = _ref.prefixCls,
    extra = _ref.extra;
  if (!extra) return null;
  var content; // Parse extra

  var assertExtra = {};
  if (_typeof$1(extra) === 'object' && ! /*#__PURE__*/react.exports.isValidElement(extra)) {
    assertExtra = extra;
  } else {
    assertExtra.right = extra;
  }
  if (position === 'right') {
    content = assertExtra.right;
  }
  if (position === 'left') {
    content = assertExtra.left;
  }
  return content ?
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    className: "".concat(prefixCls, "-extra-content"),
    ref: ref,
    children: content
  }) : null;
});

function OperationNode(_ref, ref) {
  var prefixCls = _ref.prefixCls,
    id = _ref.id,
    tabs = _ref.tabs,
    locale = _ref.locale,
    mobile = _ref.mobile,
    _ref$moreIcon = _ref.moreIcon,
    moreIcon = _ref$moreIcon === void 0 ? 'More' : _ref$moreIcon,
    moreTransitionName = _ref.moreTransitionName,
    style = _ref.style,
    className = _ref.className,
    editable = _ref.editable,
    tabBarGutter = _ref.tabBarGutter,
    rtl = _ref.rtl,
    removeAriaLabel = _ref.removeAriaLabel,
    onTabClick = _ref.onTabClick,
    getPopupContainer = _ref.getPopupContainer,
    popupClassName = _ref.popupClassName;

  // ======================== Dropdown ========================
  var _useState = react.exports.useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    open = _useState2[0],
    setOpen = _useState2[1];
  var _useState3 = react.exports.useState(null),
    _useState4 = _slicedToArray(_useState3, 2),
    selectedKey = _useState4[0],
    setSelectedKey = _useState4[1];
  var popupId = "".concat(id, "-more-popup");
  var dropdownPrefix = "".concat(prefixCls, "-dropdown");
  var selectedItemId = selectedKey !== null ? "".concat(popupId, "-").concat(selectedKey) : null;
  var dropdownAriaLabel = locale === null || locale === void 0 ? void 0 : locale.dropdownAriaLabel;
  function onRemoveTab(event, key) {
    event.preventDefault();
    event.stopPropagation();
    editable.onEdit('remove', {
      key: key,
      event: event
    });
  }
  var menu =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(ExportMenu, {
    onClick: function onClick(_ref2) {
      var key = _ref2.key,
        domEvent = _ref2.domEvent;
      onTabClick(key, domEvent);
      setOpen(false);
    },
    prefixCls: "".concat(dropdownPrefix, "-menu"),
    id: popupId,
    tabIndex: -1,
    role: "listbox",
    "aria-activedescendant": selectedItemId,
    selectedKeys: [selectedKey],
    "aria-label": dropdownAriaLabel !== undefined ? dropdownAriaLabel : 'expanded dropdown',
    children: tabs.map(function (tab) {
      var removable = editable && tab.closable !== false && !tab.disabled;
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsxs(MenuItem$1, {
          id: "".concat(popupId, "-").concat(tab.key),
          role: "option",
          "aria-controls": id && "".concat(id, "-panel-").concat(tab.key),
          disabled: tab.disabled,
          children: [/*#__PURE__*/jsx$1("span", {
            children: tab.label
          }), removable &&
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("button", {
            type: "button",
            "aria-label": removeAriaLabel || 'remove',
            tabIndex: 0,
            className: "".concat(dropdownPrefix, "-menu-item-remove"),
            onClick: function onClick(e) {
              e.stopPropagation();
              onRemoveTab(e, tab.key);
            },
            children: tab.closeIcon || editable.removeIcon || ''
          })]
        }, tab.key)
      );
    })
  });
  function selectOffset(offset) {
    var enabledTabs = tabs.filter(function (tab) {
      return !tab.disabled;
    });
    var selectedIndex = enabledTabs.findIndex(function (tab) {
      return tab.key === selectedKey;
    }) || 0;
    var len = enabledTabs.length;
    for (var i = 0; i < len; i += 1) {
      selectedIndex = (selectedIndex + offset + len) % len;
      var tab = enabledTabs[selectedIndex];
      if (!tab.disabled) {
        setSelectedKey(tab.key);
        return;
      }
    }
  }
  function onKeyDown(e) {
    var which = e.which;
    if (!open) {
      if ([KeyCode$1.DOWN, KeyCode$1.SPACE, KeyCode$1.ENTER].includes(which)) {
        setOpen(true);
        e.preventDefault();
      }
      return;
    }
    switch (which) {
      case KeyCode$1.UP:
        selectOffset(-1);
        e.preventDefault();
        break;
      case KeyCode$1.DOWN:
        selectOffset(1);
        e.preventDefault();
        break;
      case KeyCode$1.ESC:
        setOpen(false);
        break;
      case KeyCode$1.SPACE:
      case KeyCode$1.ENTER:
        if (selectedKey !== null) onTabClick(selectedKey, e);
        break;
    }
  } // ========================= Effect =========================

  react.exports.useEffect(function () {
    // We use query element here to avoid React strict warning
    var ele = document.getElementById(selectedItemId);
    if (ele && ele.scrollIntoView) {
      ele.scrollIntoView(false);
    }
  }, [selectedKey]);
  react.exports.useEffect(function () {
    if (!open) {
      setSelectedKey(null);
    }
  }, [open]); // ========================= Render =========================

  var moreStyle = _defineProperty$1({}, rtl ? 'marginRight' : 'marginLeft', tabBarGutter);
  if (!tabs.length) {
    moreStyle.visibility = 'hidden';
    moreStyle.order = 1;
  }
  var overlayClassName = classNames$1(_defineProperty$1({}, "".concat(dropdownPrefix, "-rtl"), rtl));
  var moreNode = mobile ? null :
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(Dropdown$3, {
    prefixCls: dropdownPrefix,
    overlay: menu,
    trigger: ['hover'],
    visible: tabs.length ? open : false,
    transitionName: moreTransitionName,
    onVisibleChange: setOpen,
    overlayClassName: classNames$1(overlayClassName, popupClassName),
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    getPopupContainer: getPopupContainer,
    children: /*#__PURE__*/jsx$1("button", {
      type: "button",
      className: "".concat(prefixCls, "-nav-more"),
      style: moreStyle,
      tabIndex: -1,
      "aria-hidden": "true",
      "aria-haspopup": "listbox",
      "aria-controls": popupId,
      id: "".concat(id, "-more"),
      "aria-expanded": open,
      onKeyDown: onKeyDown,
      children: moreIcon
    })
  });
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("div", {
      className: classNames$1("".concat(prefixCls, "-nav-operations"), className),
      style: style,
      ref: ref,
      children: [moreNode, /*#__PURE__*/jsx$1(AddButton$1, {
        prefixCls: prefixCls,
        locale: locale,
        editable: editable
      })]
    })
  );
}
const OperationNode$1 = /*#__PURE__*/react.exports.memo( /*#__PURE__*/react.exports.forwardRef(OperationNode), function (_, next) {
  return (
    // https://github.com/ant-design/ant-design/issues/32544
    // We'd better remove syntactic sugar in `rc-menu` since this has perf issue
    next.tabMoving
  );
});

function TabNode(_ref) {
  var _classNames;
  var prefixCls = _ref.prefixCls,
    id = _ref.id,
    active = _ref.active,
    _ref$tab = _ref.tab,
    key = _ref$tab.key,
    label = _ref$tab.label,
    disabled = _ref$tab.disabled,
    closeIcon = _ref$tab.closeIcon,
    closable = _ref.closable,
    renderWrapper = _ref.renderWrapper,
    removeAriaLabel = _ref.removeAriaLabel,
    editable = _ref.editable,
    onClick = _ref.onClick,
    onFocus = _ref.onFocus,
    style = _ref.style;
  var tabPrefix = "".concat(prefixCls, "-tab");
  var removable = editable && closable !== false && !disabled;
  function onInternalClick(e) {
    if (disabled) {
      return;
    }
    onClick(e);
  }
  function onRemoveTab(event) {
    event.preventDefault();
    event.stopPropagation();
    editable.onEdit('remove', {
      key: key,
      event: event
    });
  }
  var node =
  /*#__PURE__*/
  /*#__PURE__*/
  jsxs("div", {
    "data-node-key": key,
    className: classNames$1(tabPrefix, (_classNames = {}, _defineProperty$1(_classNames, "".concat(tabPrefix, "-with-remove"), removable), _defineProperty$1(_classNames, "".concat(tabPrefix, "-active"), active), _defineProperty$1(_classNames, "".concat(tabPrefix, "-disabled"), disabled), _classNames)),
    style: style,
    onClick: onInternalClick,
    children: [/*#__PURE__*/jsx$1("div", {
      role: "tab",
      "aria-selected": active,
      id: id && "".concat(id, "-tab-").concat(key),
      className: "".concat(tabPrefix, "-btn"),
      "aria-controls": id && "".concat(id, "-panel-").concat(key),
      "aria-disabled": disabled,
      tabIndex: disabled ? null : 0,
      onClick: function onClick(e) {
        e.stopPropagation();
        onInternalClick(e);
      },
      onKeyDown: function onKeyDown(e) {
        if ([KeyCode$1.SPACE, KeyCode$1.ENTER].includes(e.which)) {
          e.preventDefault();
          onInternalClick(e);
        }
      },
      onFocus: onFocus,
      children: label
    }), removable &&
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("button", {
      type: "button",
      "aria-label": removeAriaLabel || 'remove',
      tabIndex: 0,
      className: "".concat(tabPrefix, "-remove"),
      onClick: function onClick(e) {
        e.stopPropagation();
        onRemoveTab(e);
      },
      children: closeIcon || editable.removeIcon || ''
    })]
  }, key);
  return renderWrapper ? renderWrapper(node) : node;
}

var getSize = function getSize(refObj) {
  var _ref = refObj.current || {},
    _ref$offsetWidth = _ref.offsetWidth,
    offsetWidth = _ref$offsetWidth === void 0 ? 0 : _ref$offsetWidth,
    _ref$offsetHeight = _ref.offsetHeight,
    offsetHeight = _ref$offsetHeight === void 0 ? 0 : _ref$offsetHeight;
  return [offsetWidth, offsetHeight];
};
/**
 * Convert `SizeInfo` to unit value. Such as [123, 456] with `top` position get `123`
 */

var getUnitValue = function getUnitValue(size, tabPositionTopOrBottom) {
  return size[tabPositionTopOrBottom ? 0 : 1];
};
function TabNavList(props, ref) {
  var _classNames;
  var _React$useContext = react.exports.useContext(TabContext),
    prefixCls = _React$useContext.prefixCls,
    tabs = _React$useContext.tabs;
  var className = props.className,
    style = props.style,
    id = props.id,
    animated = props.animated,
    activeKey = props.activeKey,
    rtl = props.rtl,
    extra = props.extra,
    editable = props.editable,
    locale = props.locale,
    tabPosition = props.tabPosition,
    tabBarGutter = props.tabBarGutter,
    children = props.children,
    onTabClick = props.onTabClick,
    onTabScroll = props.onTabScroll;
  var containerRef = react.exports.useRef();
  var extraLeftRef = react.exports.useRef();
  var extraRightRef = react.exports.useRef();
  var tabsWrapperRef = react.exports.useRef();
  var tabListRef = react.exports.useRef();
  var operationsRef = react.exports.useRef();
  var innerAddButtonRef = react.exports.useRef(); // const [getBtnRef, removeBtnRef] = useRefs<HTMLDivElement>();

  var tabPositionTopOrBottom = tabPosition === 'top' || tabPosition === 'bottom';
  var _useSyncState = useSyncState$1(0, function (next, prev) {
      if (tabPositionTopOrBottom && onTabScroll) {
        onTabScroll({
          direction: next > prev ? 'left' : 'right'
        });
      }
    }),
    _useSyncState2 = _slicedToArray(_useSyncState, 2),
    transformLeft = _useSyncState2[0],
    setTransformLeft = _useSyncState2[1];
  var _useSyncState3 = useSyncState$1(0, function (next, prev) {
      if (!tabPositionTopOrBottom && onTabScroll) {
        onTabScroll({
          direction: next > prev ? 'top' : 'bottom'
        });
      }
    }),
    _useSyncState4 = _slicedToArray(_useSyncState3, 2),
    transformTop = _useSyncState4[0],
    setTransformTop = _useSyncState4[1];
  var _useState = react.exports.useState([0, 0]),
    _useState2 = _slicedToArray(_useState, 2),
    containerExcludeExtraSize = _useState2[0],
    setContainerExcludeExtraSize = _useState2[1];
  var _useState3 = react.exports.useState([0, 0]),
    _useState4 = _slicedToArray(_useState3, 2),
    tabContentSize = _useState4[0],
    setTabContentSize = _useState4[1];
  var _useState5 = react.exports.useState([0, 0]),
    _useState6 = _slicedToArray(_useState5, 2),
    addSize = _useState6[0],
    setAddSize = _useState6[1];
  var _useState7 = react.exports.useState([0, 0]),
    _useState8 = _slicedToArray(_useState7, 2),
    operationSize = _useState8[0],
    setOperationSize = _useState8[1];
  var _useRafState = useRafState(new Map()),
    _useRafState2 = _slicedToArray(_useRafState, 2),
    tabSizes = _useRafState2[0],
    setTabSizes = _useRafState2[1];
  var tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0]); // ========================== Unit =========================

  var containerExcludeExtraSizeValue = getUnitValue(containerExcludeExtraSize, tabPositionTopOrBottom);
  var tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom);
  var addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom);
  var operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom);
  var needScroll = containerExcludeExtraSizeValue < tabContentSizeValue + addSizeValue;
  var visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue; // ========================== Util =========================

  var operationsHiddenClassName = "".concat(prefixCls, "-nav-operations-hidden");
  var transformMin = 0;
  var transformMax = 0;
  if (!tabPositionTopOrBottom) {
    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
    transformMax = 0;
  } else if (rtl) {
    transformMin = 0;
    transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue);
  } else {
    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
    transformMax = 0;
  }
  function alignInRange(value) {
    if (value < transformMin) {
      return transformMin;
    }
    if (value > transformMax) {
      return transformMax;
    }
    return value;
  } // ========================= Mobile ========================

  var touchMovingRef = react.exports.useRef();
  var _useState9 = react.exports.useState(),
    _useState10 = _slicedToArray(_useState9, 2),
    lockAnimation = _useState10[0],
    setLockAnimation = _useState10[1];
  function doLockAnimation() {
    setLockAnimation(Date.now());
  }
  function clearTouchMoving() {
    window.clearTimeout(touchMovingRef.current);
  }
  useTouchMove(tabsWrapperRef, function (offsetX, offsetY) {
    function doMove(setState, offset) {
      setState(function (value) {
        var newValue = alignInRange(value + offset);
        return newValue;
      });
    } // Skip scroll if place is enough

    if (containerExcludeExtraSizeValue >= tabContentSizeValue) {
      return false;
    }
    if (tabPositionTopOrBottom) {
      doMove(setTransformLeft, offsetX);
    } else {
      doMove(setTransformTop, offsetY);
    }
    clearTouchMoving();
    doLockAnimation();
    return true;
  });
  react.exports.useEffect(function () {
    clearTouchMoving();
    if (lockAnimation) {
      touchMovingRef.current = window.setTimeout(function () {
        setLockAnimation(0);
      }, 100);
    }
    return clearTouchMoving;
  }, [lockAnimation]); // ===================== Visible Range =====================
  // Render tab node & collect tab offset

  var _useVisibleRange = useVisibleRange(tabOffsets,
    // Container
    visibleTabContentValue,
    // Transform
    tabPositionTopOrBottom ? transformLeft : transformTop,
    // Tabs
    tabContentSizeValue,
    // Add
    addSizeValue,
    // Operation
    operationSizeValue, _objectSpread2$1(_objectSpread2$1({}, props), {}, {
      tabs: tabs
    })),
    _useVisibleRange2 = _slicedToArray(_useVisibleRange, 2),
    visibleStart = _useVisibleRange2[0],
    visibleEnd = _useVisibleRange2[1]; // ========================= Scroll ========================

  var scrollToTab = function scrollToTab() {
    var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : activeKey;
    var tabOffset = tabOffsets.get(key) || {
      width: 0,
      height: 0,
      left: 0,
      right: 0,
      top: 0
    };
    if (tabPositionTopOrBottom) {
      // ============ Align with top & bottom ============
      var newTransform = transformLeft; // RTL

      if (rtl) {
        if (tabOffset.right < transformLeft) {
          newTransform = tabOffset.right;
        } else if (tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue) {
          newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue;
        }
      } // LTR
      else if (tabOffset.left < -transformLeft) {
        newTransform = -tabOffset.left;
      } else if (tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue) {
        newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue);
      }
      setTransformTop(0);
      setTransformLeft(alignInRange(newTransform));
    } else {
      // ============ Align with left & right ============
      var _newTransform = transformTop;
      if (tabOffset.top < -transformTop) {
        _newTransform = -tabOffset.top;
      } else if (tabOffset.top + tabOffset.height > -transformTop + visibleTabContentValue) {
        _newTransform = -(tabOffset.top + tabOffset.height - visibleTabContentValue);
      }
      setTransformLeft(0);
      setTransformTop(alignInRange(_newTransform));
    }
  }; // ========================== Tab ==========================

  var tabNodeStyle = {};
  if (tabPosition === 'top' || tabPosition === 'bottom') {
    tabNodeStyle[rtl ? 'marginRight' : 'marginLeft'] = tabBarGutter;
  } else {
    tabNodeStyle.marginTop = tabBarGutter;
  }
  var tabNodes = tabs.map(function (tab, i) {
    var key = tab.key;
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(TabNode, {
        id: id,
        prefixCls: prefixCls,
        tab: tab,
        style: i === 0 ? undefined : tabNodeStyle,
        closable: tab.closable,
        editable: editable,
        active: key === activeKey,
        renderWrapper: children,
        removeAriaLabel: locale === null || locale === void 0 ? void 0 : locale.removeAriaLabel,
        onClick: function onClick(e) {
          onTabClick(key, e);
        },
        onFocus: function onFocus() {
          scrollToTab(key);
          doLockAnimation();
          if (!tabsWrapperRef.current) {
            return;
          } // Focus element will make scrollLeft change which we should reset back

          if (!rtl) {
            tabsWrapperRef.current.scrollLeft = 0;
          }
          tabsWrapperRef.current.scrollTop = 0;
        }
      }, key)
    );
  }); // Update buttons records

  var updateTabSizes = function updateTabSizes() {
    return setTabSizes(function () {
      var newSizes = new Map();
      tabs.forEach(function (_ref2) {
        var key = _ref2.key;
        var btnNode = tabListRef.current.querySelector("[data-node-key=\"".concat(key, "\"]"));
        if (btnNode) {
          newSizes.set(key, {
            width: btnNode.offsetWidth,
            height: btnNode.offsetHeight,
            left: btnNode.offsetLeft,
            top: btnNode.offsetTop
          });
        }
      });
      return newSizes;
    });
  };
  react.exports.useEffect(function () {
    updateTabSizes();
  }, [tabs.map(function (tab) {
    return tab.key;
  }).join('_')]);
  var onListHolderResize = useRaf(function () {
    // Update wrapper records
    var containerSize = getSize(containerRef);
    var extraLeftSize = getSize(extraLeftRef);
    var extraRightSize = getSize(extraRightRef);
    setContainerExcludeExtraSize([containerSize[0] - extraLeftSize[0] - extraRightSize[0], containerSize[1] - extraLeftSize[1] - extraRightSize[1]]);
    var newAddSize = getSize(innerAddButtonRef);
    setAddSize(newAddSize);
    var newOperationSize = getSize(operationsRef);
    setOperationSize(newOperationSize); // Which includes add button size

    var tabContentFullSize = getSize(tabListRef);
    setTabContentSize([tabContentFullSize[0] - newAddSize[0], tabContentFullSize[1] - newAddSize[1]]); // Update buttons records

    updateTabSizes();
  }); // ======================== Dropdown =======================

  var startHiddenTabs = tabs.slice(0, visibleStart);
  var endHiddenTabs = tabs.slice(visibleEnd + 1);
  var hiddenTabs = [].concat(_toConsumableArray(startHiddenTabs), _toConsumableArray(endHiddenTabs)); // =================== Link & Operations ===================

  var _useState11 = react.exports.useState(),
    _useState12 = _slicedToArray(_useState11, 2),
    inkStyle = _useState12[0],
    setInkStyle = _useState12[1];
  var activeTabOffset = tabOffsets.get(activeKey); // Delay set ink style to avoid remove tab blink

  var inkBarRafRef = react.exports.useRef();
  function cleanInkBarRaf() {
    wrapperRaf$1.cancel(inkBarRafRef.current);
  }
  react.exports.useEffect(function () {
    var newInkStyle = {};
    if (activeTabOffset) {
      if (tabPositionTopOrBottom) {
        if (rtl) {
          newInkStyle.right = activeTabOffset.right;
        } else {
          newInkStyle.left = activeTabOffset.left;
        }
        newInkStyle.width = activeTabOffset.width;
      } else {
        newInkStyle.top = activeTabOffset.top;
        newInkStyle.height = activeTabOffset.height;
      }
    }
    cleanInkBarRaf();
    inkBarRafRef.current = wrapperRaf$1(function () {
      setInkStyle(newInkStyle);
    });
    return cleanInkBarRaf;
  }, [activeTabOffset, tabPositionTopOrBottom, rtl]); // ========================= Effect ========================

  react.exports.useEffect(function () {
    scrollToTab(); // eslint-disable-next-line
  }, [activeKey, stringify(activeTabOffset), stringify(tabOffsets), tabPositionTopOrBottom]); // Should recalculate when rtl changed

  react.exports.useEffect(function () {
    onListHolderResize(); // eslint-disable-next-line
  }, [rtl]); // ========================= Render ========================

  var hasDropdown = !!hiddenTabs.length;
  var wrapPrefix = "".concat(prefixCls, "-nav-wrap");
  var pingLeft;
  var pingRight;
  var pingTop;
  var pingBottom;
  if (tabPositionTopOrBottom) {
    if (rtl) {
      pingRight = transformLeft > 0;
      pingLeft = transformLeft + containerExcludeExtraSizeValue < tabContentSizeValue;
    } else {
      pingLeft = transformLeft < 0;
      pingRight = -transformLeft + containerExcludeExtraSizeValue < tabContentSizeValue;
    }
  } else {
    pingTop = transformTop < 0;
    pingBottom = -transformTop + containerExcludeExtraSizeValue < tabContentSizeValue;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(ResizeObserver$1, {
      onResize: onListHolderResize,
      children: /*#__PURE__*/jsxs("div", {
        ref: useComposeRef(ref, containerRef),
        role: "tablist",
        className: classNames$1("".concat(prefixCls, "-nav"), className),
        style: style,
        onKeyDown: function onKeyDown() {
          // No need animation when use keyboard
          doLockAnimation();
        },
        children: [/*#__PURE__*/jsx$1(ExtraContent, {
          ref: extraLeftRef,
          position: "left",
          extra: extra,
          prefixCls: prefixCls
        }), /*#__PURE__*/jsx$1("div", {
          className: classNames$1(wrapPrefix, (_classNames = {}, _defineProperty$1(_classNames, "".concat(wrapPrefix, "-ping-left"), pingLeft), _defineProperty$1(_classNames, "".concat(wrapPrefix, "-ping-right"), pingRight), _defineProperty$1(_classNames, "".concat(wrapPrefix, "-ping-top"), pingTop), _defineProperty$1(_classNames, "".concat(wrapPrefix, "-ping-bottom"), pingBottom), _classNames)),
          ref: tabsWrapperRef,
          children: /*#__PURE__*/jsx$1(ResizeObserver$1, {
            onResize: onListHolderResize,
            children: /*#__PURE__*/jsxs("div", {
              ref: tabListRef,
              className: "".concat(prefixCls, "-nav-list"),
              style: {
                transform: "translate(".concat(transformLeft, "px, ").concat(transformTop, "px)"),
                transition: lockAnimation ? 'none' : undefined
              },
              children: [tabNodes, /*#__PURE__*/jsx$1(AddButton$1, {
                ref: innerAddButtonRef,
                prefixCls: prefixCls,
                locale: locale,
                editable: editable,
                style: _objectSpread2$1(_objectSpread2$1({}, tabNodes.length === 0 ? undefined : tabNodeStyle), {}, {
                  visibility: hasDropdown ? 'hidden' : null
                })
              }), /*#__PURE__*/jsx$1("div", {
                className: classNames$1("".concat(prefixCls, "-ink-bar"), _defineProperty$1({}, "".concat(prefixCls, "-ink-bar-animated"), animated.inkBar)),
                style: inkStyle
              })]
            })
          })
        }), /*#__PURE__*/jsx$1(OperationNode$1, {
          ...props,
          removeAriaLabel: locale === null || locale === void 0 ? void 0 : locale.removeAriaLabel,
          ref: operationsRef,
          prefixCls: prefixCls,
          tabs: hiddenTabs,
          className: !hasDropdown && operationsHiddenClassName,
          tabMoving: !!lockAnimation
        }), /*#__PURE__*/jsx$1(ExtraContent, {
          ref: extraRightRef,
          position: "right",
          extra: extra,
          prefixCls: prefixCls
        })]
      })
    })
  );
  /* eslint-enable */
}

const TabNavList$1 = /*#__PURE__*/react.exports.forwardRef(TabNavList);

var _excluded$p = ["renderTabBar"],
  _excluded2$2 = ["label", "key"];
function TabNavListWrapper(_ref) {
  var renderTabBar = _ref.renderTabBar,
    restProps = _objectWithoutProperties(_ref, _excluded$p);
  var _React$useContext = react.exports.useContext(TabContext),
    tabs = _React$useContext.tabs;
  if (renderTabBar) {
    var tabNavBarProps = _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
      // Legacy support. We do not use this actually
      panes: tabs.map(function (_ref2) {
        var label = _ref2.label,
          key = _ref2.key,
          restTabProps = _objectWithoutProperties(_ref2, _excluded2$2);
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(TabPane$2, {
            tab: label,
            tabKey: key,
            ...restTabProps
          }, key)
        );
      })
    });
    return renderTabBar(tabNavBarProps, TabNavList$1);
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(TabNavList$1, {
      ...restProps
    })
  );
}

function useAnimateConfig$1() {
  var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    inkBar: true,
    tabPane: false
  };
  var mergedAnimated;

  if (animated === false) {
    mergedAnimated = {
      inkBar: false,
      tabPane: false
    };
  } else if (animated === true) {
    mergedAnimated = {
      inkBar: true,
      tabPane: false
    };
  } else {
    mergedAnimated = _objectSpread2$1({
      inkBar: true
    }, _typeof$1(animated) === 'object' ? animated : {});
  } // Enable tabPane animation if provide motion


  if (mergedAnimated.tabPaneMotion && mergedAnimated.tabPane === undefined) {
    mergedAnimated.tabPane = true;
  }

  if (!mergedAnimated.tabPaneMotion && mergedAnimated.tabPane) {

    mergedAnimated.tabPane = false;
  }

  return mergedAnimated;
}

var _excluded$o = ["id", "prefixCls", "className", "items", "direction", "activeKey", "defaultActiveKey", "editable", "animated", "tabPosition", "tabBarGutter", "tabBarStyle", "tabBarExtraContent", "locale", "moreIcon", "moreTransitionName", "destroyInactiveTabPane", "renderTabBar", "onChange", "onTabClick", "onTabScroll", "getPopupContainer", "popupClassName"];
var uuid$4 = 0;
function Tabs$1(_ref, ref) {
  var _classNames;
  var id = _ref.id,
    _ref$prefixCls = _ref.prefixCls,
    prefixCls = _ref$prefixCls === void 0 ? 'rc-tabs' : _ref$prefixCls,
    className = _ref.className,
    items = _ref.items,
    direction = _ref.direction,
    activeKey = _ref.activeKey,
    defaultActiveKey = _ref.defaultActiveKey,
    editable = _ref.editable,
    animated = _ref.animated,
    _ref$tabPosition = _ref.tabPosition,
    tabPosition = _ref$tabPosition === void 0 ? 'top' : _ref$tabPosition,
    tabBarGutter = _ref.tabBarGutter,
    tabBarStyle = _ref.tabBarStyle,
    tabBarExtraContent = _ref.tabBarExtraContent,
    locale = _ref.locale,
    moreIcon = _ref.moreIcon,
    moreTransitionName = _ref.moreTransitionName,
    destroyInactiveTabPane = _ref.destroyInactiveTabPane,
    renderTabBar = _ref.renderTabBar,
    onChange = _ref.onChange,
    onTabClick = _ref.onTabClick,
    onTabScroll = _ref.onTabScroll,
    getPopupContainer = _ref.getPopupContainer,
    popupClassName = _ref.popupClassName,
    restProps = _objectWithoutProperties(_ref, _excluded$o);
  var tabs = react.exports.useMemo(function () {
    return (items || []).filter(function (item) {
      return item && _typeof$1(item) === 'object' && 'key' in item;
    });
  }, [items]);
  var rtl = direction === 'rtl';
  var mergedAnimated = useAnimateConfig$1(animated); // ======================== Mobile ========================

  var _useState = react.exports.useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    mobile = _useState2[0],
    setMobile = _useState2[1];
  react.exports.useEffect(function () {
    // Only update on the client side
    setMobile(isMobile());
  }, []); // ====================== Active Key ======================

  var _useMergedState = useMergedState$1(function () {
      var _tabs$;
      return (_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key;
    }, {
      value: activeKey,
      defaultValue: defaultActiveKey
    }),
    _useMergedState2 = _slicedToArray(_useMergedState, 2),
    mergedActiveKey = _useMergedState2[0],
    setMergedActiveKey = _useMergedState2[1];
  var _useState3 = react.exports.useState(function () {
      return tabs.findIndex(function (tab) {
        return tab.key === mergedActiveKey;
      });
    }),
    _useState4 = _slicedToArray(_useState3, 2),
    activeIndex = _useState4[0],
    setActiveIndex = _useState4[1]; // Reset active key if not exist anymore

  react.exports.useEffect(function () {
    var newActiveIndex = tabs.findIndex(function (tab) {
      return tab.key === mergedActiveKey;
    });
    if (newActiveIndex === -1) {
      var _tabs$newActiveIndex;
      newActiveIndex = Math.max(0, Math.min(activeIndex, tabs.length - 1));
      setMergedActiveKey((_tabs$newActiveIndex = tabs[newActiveIndex]) === null || _tabs$newActiveIndex === void 0 ? void 0 : _tabs$newActiveIndex.key);
    }
    setActiveIndex(newActiveIndex);
  }, [tabs.map(function (tab) {
    return tab.key;
  }).join('_'), mergedActiveKey, activeIndex]); // ===================== Accessibility ====================

  var _useMergedState3 = useMergedState$1(null, {
      value: id
    }),
    _useMergedState4 = _slicedToArray(_useMergedState3, 2),
    mergedId = _useMergedState4[0],
    setMergedId = _useMergedState4[1]; // Async generate id to avoid ssr mapping failed

  react.exports.useEffect(function () {
    if (!id) {
      setMergedId("rc-tabs-".concat(uuid$4));
      uuid$4 += 1;
    }
  }, []); // ======================== Events ========================

  function onInternalTabClick(key, e) {
    onTabClick === null || onTabClick === void 0 ? void 0 : onTabClick(key, e);
    var isActiveChanged = key !== mergedActiveKey;
    setMergedActiveKey(key);
    if (isActiveChanged) {
      onChange === null || onChange === void 0 ? void 0 : onChange(key);
    }
  } // ======================== Render ========================

  var sharedProps = {
    id: mergedId,
    activeKey: mergedActiveKey,
    animated: mergedAnimated,
    tabPosition: tabPosition,
    rtl: rtl,
    mobile: mobile
  };
  var tabNavBar;
  var tabNavBarProps = _objectSpread2$1(_objectSpread2$1({}, sharedProps), {}, {
    editable: editable,
    locale: locale,
    moreIcon: moreIcon,
    moreTransitionName: moreTransitionName,
    tabBarGutter: tabBarGutter,
    onTabClick: onInternalTabClick,
    onTabScroll: onTabScroll,
    extra: tabBarExtraContent,
    style: tabBarStyle,
    panes: null,
    getPopupContainer: getPopupContainer,
    popupClassName: popupClassName
  });
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(TabContext.Provider, {
      value: {
        tabs: tabs,
        prefixCls: prefixCls
      },
      children: /*#__PURE__*/jsxs("div", {
        ref: ref,
        id: id,
        className: classNames$1(prefixCls, "".concat(prefixCls, "-").concat(tabPosition), (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-mobile"), mobile), _defineProperty$1(_classNames, "".concat(prefixCls, "-editable"), editable), _defineProperty$1(_classNames, "".concat(prefixCls, "-rtl"), rtl), _classNames), className),
        ...restProps,
        children: [tabNavBar, /*#__PURE__*/jsx$1(TabNavListWrapper, {
          ...tabNavBarProps,
          renderTabBar: renderTabBar
        }), /*#__PURE__*/jsx$1(TabPanelList, {
          destroyInactiveTabPane: destroyInactiveTabPane,
          ...sharedProps,
          animated: mergedAnimated
        })]
      })
    })
  );
}
var ForwardTabs = /*#__PURE__*/react.exports.forwardRef(Tabs$1);

var motion = {
  motionAppear: false,
  motionEnter: true,
  motionLeave: true
};
function useAnimateConfig(prefixCls) {
  var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    inkBar: true,
    tabPane: false
  };
  var mergedAnimated;
  if (animated === false) {
    mergedAnimated = {
      inkBar: false,
      tabPane: false
    };
  } else if (animated === true) {
    mergedAnimated = {
      inkBar: true,
      tabPane: true
    };
  } else {
    mergedAnimated = _extends$2({
      inkBar: true
    }, _typeof$1(animated) === 'object' ? animated : {});
  }
  if (mergedAnimated.tabPane) {
    mergedAnimated.tabPaneMotion = _extends$2(_extends$2({}, motion), {
      motionName: getTransitionName(prefixCls, 'switch')
    });
  }
  return mergedAnimated;
}

var __rest$A = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function filter(items) {
  return items.filter(function (item) {
    return item;
  });
}
function useLegacyItems(items, children) {
  if (items) {
    return items;
  }
  var childrenItems = toArray$5(children).map(function (node) {
    if ( /*#__PURE__*/react.exports.isValidElement(node)) {
      var key = node.key,
        props = node.props;
      var _a = props || {},
        tab = _a.tab,
        restProps = __rest$A(_a, ["tab"]);
      var item = _extends$2(_extends$2({
        key: String(key)
      }, restProps), {
        label: tab
      });
      return item;
    }
    return null;
  });
  return filter(childrenItems);
}

var TabPane = function TabPane() {
  return null;
};
const TabPane$1 = TabPane;

var genMotionStyle = function genMotionStyle(token) {
  var componentCls = token.componentCls,
    motionDurationSlow = token.motionDurationSlow;
  return [_defineProperty$1({}, componentCls, _defineProperty$1({}, componentCls + "-switch", {
    '&-appear, &-enter': {
      transition: 'none',
      '&-start': {
        opacity: 0
      },
      '&-active': {
        opacity: 1,
        transition: "opacity " + motionDurationSlow
      }
    },
    '&-leave': {
      position: 'absolute',
      transition: 'none',
      inset: 0,
      '&-start': {
        opacity: 1
      },
      '&-active': {
        opacity: 0,
        transition: "opacity " + motionDurationSlow
      }
    }
  })),
  // Follow code may reuse in other components
  [initSlideMotion(token, 'slide-up'), initSlideMotion(token, 'slide-down')]];
};
const genMotionStyle$1 = genMotionStyle;

var genCardStyle$1 = function genCardStyle(token) {
  var _ref, _ref4, _ref6, _ref10, _ref12, _ref14;
  var componentCls = token.componentCls,
    tabsCardHorizontalPadding = token.tabsCardHorizontalPadding,
    tabsCardHeadBackground = token.tabsCardHeadBackground,
    tabsCardGutter = token.tabsCardGutter,
    colorSplit = token.colorSplit;
  return _defineProperty$1({}, componentCls + "-card", (_ref14 = {}, _defineProperty$1(_ref14, "> " + componentCls + "-nav, > div > " + componentCls + "-nav", (_ref = {}, _defineProperty$1(_ref, componentCls + "-tab", {
    margin: 0,
    padding: tabsCardHorizontalPadding,
    background: tabsCardHeadBackground,
    border: token.lineWidth + "px " + token.lineType + " " + colorSplit,
    transition: "all " + token.motionDurationSlow + " " + token.motionEaseInOut
  }), _defineProperty$1(_ref, componentCls + "-tab-active", {
    color: token.colorPrimary,
    background: token.colorBgContainer
  }), _defineProperty$1(_ref, componentCls + "-ink-bar", {
    visibility: 'hidden'
  }), _ref)), _defineProperty$1(_ref14, "&" + componentCls + "-top, &" + componentCls + "-bottom", _defineProperty$1({}, "> " + componentCls + "-nav, > div > " + componentCls + "-nav", _defineProperty$1({}, componentCls + "-tab + " + componentCls + "-tab", {
    marginLeft: {
      _skip_check_: true,
      value: tabsCardGutter + "px"
    }
  }))), _defineProperty$1(_ref14, "&" + componentCls + "-top", _defineProperty$1({}, "> " + componentCls + "-nav, > div > " + componentCls + "-nav", (_ref4 = {}, _defineProperty$1(_ref4, componentCls + "-tab", {
    borderRadius: token.borderRadiusLG + "px " + token.borderRadiusLG + "px 0 0"
  }), _defineProperty$1(_ref4, componentCls + "-tab-active", {
    borderBottomColor: token.colorBgContainer
  }), _ref4))), _defineProperty$1(_ref14, "&" + componentCls + "-bottom", _defineProperty$1({}, "> " + componentCls + "-nav, > div > " + componentCls + "-nav", (_ref6 = {}, _defineProperty$1(_ref6, componentCls + "-tab", {
    borderRadius: "0 0 " + token.borderRadiusLG + "px " + token.borderRadiusLG + "px"
  }), _defineProperty$1(_ref6, componentCls + "-tab-active", {
    borderTopColor: token.colorBgContainer
  }), _ref6))), _defineProperty$1(_ref14, "&" + componentCls + "-left, &" + componentCls + "-right", _defineProperty$1({}, "> " + componentCls + "-nav, > div > " + componentCls + "-nav", _defineProperty$1({}, componentCls + "-tab + " + componentCls + "-tab", {
    marginTop: tabsCardGutter + "px"
  }))), _defineProperty$1(_ref14, "&" + componentCls + "-left", _defineProperty$1({}, "> " + componentCls + "-nav, > div > " + componentCls + "-nav", (_ref10 = {}, _defineProperty$1(_ref10, componentCls + "-tab", {
    borderRadius: {
      _skip_check_: true,
      value: token.borderRadiusLG + "px 0 0 " + token.borderRadiusLG + "px"
    }
  }), _defineProperty$1(_ref10, componentCls + "-tab-active", {
    borderRightColor: {
      _skip_check_: true,
      value: token.colorBgContainer
    }
  }), _ref10))), _defineProperty$1(_ref14, "&" + componentCls + "-right", _defineProperty$1({}, "> " + componentCls + "-nav, > div > " + componentCls + "-nav", (_ref12 = {}, _defineProperty$1(_ref12, componentCls + "-tab", {
    borderRadius: {
      _skip_check_: true,
      value: "0 " + token.borderRadiusLG + "px " + token.borderRadiusLG + "px 0"
    }
  }), _defineProperty$1(_ref12, componentCls + "-tab-active", {
    borderLeftColor: {
      _skip_check_: true,
      value: token.colorBgContainer
    }
  }), _ref12))), _ref14));
};
var genDropdownStyle = function genDropdownStyle(token) {
  var componentCls = token.componentCls,
    tabsHoverColor = token.tabsHoverColor,
    dropdownEdgeChildVerticalPadding = token.dropdownEdgeChildVerticalPadding;
  return _defineProperty$1({}, componentCls + "-dropdown", _extends$2(_extends$2({}, resetComponent(token)), _defineProperty$1({
    position: 'absolute',
    top: -9999,
    left: {
      _skip_check_: true,
      value: -9999
    },
    zIndex: token.zIndexPopup,
    display: 'block',
    '&-hidden': {
      display: 'none'
    }
  }, componentCls + "-dropdown-menu", {
    maxHeight: token.tabsDropdownHeight,
    margin: 0,
    padding: dropdownEdgeChildVerticalPadding + "px 0",
    overflowX: 'hidden',
    overflowY: 'auto',
    textAlign: {
      _skip_check_: true,
      value: 'left'
    },
    listStyleType: 'none',
    backgroundColor: token.colorBgContainer,
    backgroundClip: 'padding-box',
    borderRadius: token.borderRadiusLG,
    outline: 'none',
    boxShadow: token.boxShadow,
    '&-item': _extends$2(_extends$2({}, textEllipsis), {
      display: 'flex',
      alignItems: 'center',
      minWidth: token.tabsDropdownWidth,
      margin: 0,
      padding: token.paddingXXS + "px " + token.paddingSM + "px",
      color: token.colorText,
      fontWeight: 'normal',
      fontSize: token.fontSize,
      lineHeight: token.lineHeight,
      cursor: 'pointer',
      transition: "all " + token.motionDurationSlow,
      '> span': {
        flex: 1,
        whiteSpace: 'nowrap'
      },
      '&-remove': {
        flex: 'none',
        marginLeft: {
          _skip_check_: true,
          value: token.marginSM
        },
        color: token.colorTextDescription,
        fontSize: token.fontSizeSM,
        background: 'transparent',
        border: 0,
        cursor: 'pointer',
        '&:hover': {
          color: tabsHoverColor
        }
      },
      '&:hover': {
        background: token.controlItemBgHover
      },
      '&-disabled': {
        '&, &:hover': {
          color: token.colorTextDisabled,
          background: 'transparent',
          cursor: 'not-allowed'
        }
      }
    })
  })));
};
var genPositionStyle = function genPositionStyle(token) {
  var _ref17, _ref18, _ref23, _ref24, _ref25, _ref29, _ref32, _ref33;
  var componentCls = token.componentCls,
    margin = token.margin,
    colorSplit = token.colorSplit;
  return _ref33 = {}, _defineProperty$1(_ref33, componentCls + "-top, " + componentCls + "-bottom", _defineProperty$1({
    flexDirection: 'column'
  }, "> " + componentCls + "-nav, > div > " + componentCls + "-nav", (_ref18 = {
    margin: "0 0 " + margin + "px 0",
    '&::before': {
      position: 'absolute',
      right: {
        _skip_check_: true,
        value: 0
      },
      left: {
        _skip_check_: true,
        value: 0
      },
      borderBottom: token.lineWidth + "px " + token.lineType + " " + colorSplit,
      content: "''"
    }
  }, _defineProperty$1(_ref18, componentCls + "-ink-bar", {
    height: token.lineWidthBold,
    '&-animated': {
      transition: "width " + token.motionDurationSlow + ", left " + token.motionDurationSlow + ",\n            right " + token.motionDurationSlow
    }
  }), _defineProperty$1(_ref18, componentCls + "-nav-wrap", (_ref17 = {
    '&::before, &::after': {
      top: 0,
      bottom: 0,
      width: token.controlHeight
    },
    '&::before': {
      left: {
        _skip_check_: true,
        value: 0
      },
      boxShadow: token.boxShadowTabsOverflowLeft
    },
    '&::after': {
      right: {
        _skip_check_: true,
        value: 0
      },
      boxShadow: token.boxShadowTabsOverflowRight
    }
  }, _defineProperty$1(_ref17, "&" + componentCls + "-nav-wrap-ping-left::before", {
    opacity: 1
  }), _defineProperty$1(_ref17, "&" + componentCls + "-nav-wrap-ping-right::after", {
    opacity: 1
  }), _ref17)), _ref18))), _defineProperty$1(_ref33, componentCls + "-top", _defineProperty$1({}, "> " + componentCls + "-nav,\n        > div > " + componentCls + "-nav", _defineProperty$1({
    '&::before': {
      bottom: 0
    }
  }, componentCls + "-ink-bar", {
    bottom: 0
  }))), _defineProperty$1(_ref33, componentCls + "-bottom", (_ref23 = {}, _defineProperty$1(_ref23, "> " + componentCls + "-nav, > div > " + componentCls + "-nav", _defineProperty$1({
    order: 1,
    marginTop: margin + "px",
    marginBottom: 0,
    '&::before': {
      top: 0
    }
  }, componentCls + "-ink-bar", {
    top: 0
  })), _defineProperty$1(_ref23, "> " + componentCls + "-content-holder, > div > " + componentCls + "-content-holder", {
    order: 0
  }), _ref23)), _defineProperty$1(_ref33, componentCls + "-left, " + componentCls + "-right", _defineProperty$1({}, "> " + componentCls + "-nav, > div > " + componentCls + "-nav", (_ref25 = {
    flexDirection: 'column',
    minWidth: token.controlHeight * 1.25
  }, _defineProperty$1(_ref25, componentCls + "-tab", {
    padding: token.paddingXS + "px " + token.paddingLG + "px",
    textAlign: 'center'
  }), _defineProperty$1(_ref25, componentCls + "-tab + " + componentCls + "-tab", {
    margin: token.margin + "px 0 0 0"
  }), _defineProperty$1(_ref25, componentCls + "-nav-wrap", (_ref24 = {
    flexDirection: 'column',
    '&::before, &::after': {
      right: {
        _skip_check_: true,
        value: 0
      },
      left: {
        _skip_check_: true,
        value: 0
      },
      height: token.controlHeight
    },
    '&::before': {
      top: 0,
      boxShadow: token.boxShadowTabsOverflowTop
    },
    '&::after': {
      bottom: 0,
      boxShadow: token.boxShadowTabsOverflowBottom
    }
  }, _defineProperty$1(_ref24, "&" + componentCls + "-nav-wrap-ping-top::before", {
    opacity: 1
  }), _defineProperty$1(_ref24, "&" + componentCls + "-nav-wrap-ping-bottom::after", {
    opacity: 1
  }), _ref24)), _defineProperty$1(_ref25, componentCls + "-ink-bar", {
    width: token.lineWidthBold,
    '&-animated': {
      transition: "height " + token.motionDurationSlow + ", top " + token.motionDurationSlow
    }
  }), _defineProperty$1(_ref25, componentCls + "-nav-list, " + componentCls + "-nav-operations", {
    flex: '1 0 auto',
    flexDirection: 'column'
  }), _ref25))), _defineProperty$1(_ref33, componentCls + "-left", (_ref29 = {}, _defineProperty$1(_ref29, "> " + componentCls + "-nav, > div > " + componentCls + "-nav", _defineProperty$1({}, componentCls + "-ink-bar", {
    right: {
      _skip_check_: true,
      value: 0
    }
  })), _defineProperty$1(_ref29, "> " + componentCls + "-content-holder, > div > " + componentCls + "-content-holder", _defineProperty$1({
    marginLeft: {
      _skip_check_: true,
      value: "-" + token.lineWidth + "px"
    },
    borderLeft: {
      _skip_check_: true,
      value: token.lineWidth + "px " + token.lineType + " " + token.colorBorder
    }
  }, "> " + componentCls + "-content > " + componentCls + "-tabpane", {
    paddingLeft: {
      _skip_check_: true,
      value: token.paddingLG
    }
  })), _ref29)), _defineProperty$1(_ref33, componentCls + "-right", (_ref32 = {}, _defineProperty$1(_ref32, "> " + componentCls + "-nav, > div > " + componentCls + "-nav", _defineProperty$1({
    order: 1
  }, componentCls + "-ink-bar", {
    left: {
      _skip_check_: true,
      value: 0
    }
  })), _defineProperty$1(_ref32, "> " + componentCls + "-content-holder, > div > " + componentCls + "-content-holder", _defineProperty$1({
    order: 0,
    marginRight: {
      _skip_check_: true,
      value: -token.lineWidth
    },
    borderRight: {
      _skip_check_: true,
      value: token.lineWidth + "px " + token.lineType + " " + token.colorBorder
    }
  }, "> " + componentCls + "-content > " + componentCls + "-tabpane", {
    paddingRight: {
      _skip_check_: true,
      value: token.paddingLG
    }
  })), _ref32)), _ref33;
};
var genSizeStyle$2 = function genSizeStyle(token) {
  var _ref41, _ref44, _ref45;
  var componentCls = token.componentCls,
    padding = token.padding;
  return _ref45 = {}, _defineProperty$1(_ref45, componentCls, {
    '&-small': _defineProperty$1({}, "> " + componentCls + "-nav", _defineProperty$1({}, componentCls + "-tab", {
      padding: token.paddingXS + "px 0",
      fontSize: token.fontSize
    })),
    '&-large': _defineProperty$1({}, "> " + componentCls + "-nav", _defineProperty$1({}, componentCls + "-tab", {
      padding: padding + "px 0",
      fontSize: token.fontSizeLG
    }))
  }), _defineProperty$1(_ref45, componentCls + "-card", (_ref44 = {}, _defineProperty$1(_ref44, "&" + componentCls + "-small", (_ref41 = {}, _defineProperty$1(_ref41, "> " + componentCls + "-nav", _defineProperty$1({}, componentCls + "-tab", {
    padding: token.paddingXXS * 1.5 + "px " + padding + "px"
  })), _defineProperty$1(_ref41, "&" + componentCls + "-bottom", _defineProperty$1({}, "> " + componentCls + "-nav " + componentCls + "-tab", {
    borderRadius: "0 0 " + token.borderRadius + "px " + token.borderRadius + "px"
  })), _defineProperty$1(_ref41, "&" + componentCls + "-top", _defineProperty$1({}, "> " + componentCls + "-nav " + componentCls + "-tab", {
    borderRadius: token.borderRadius + "px " + token.borderRadius + "px 0 0"
  })), _defineProperty$1(_ref41, "&" + componentCls + "-right", _defineProperty$1({}, "> " + componentCls + "-nav " + componentCls + "-tab", {
    borderRadius: {
      _skip_check_: true,
      value: "0 " + token.borderRadius + "px " + token.borderRadius + "px 0"
    }
  })), _defineProperty$1(_ref41, "&" + componentCls + "-left", _defineProperty$1({}, "> " + componentCls + "-nav " + componentCls + "-tab", {
    borderRadius: {
      _skip_check_: true,
      value: token.borderRadius + "px 0 0 " + token.borderRadius + "px"
    }
  })), _ref41)), _defineProperty$1(_ref44, "&" + componentCls + "-large", _defineProperty$1({}, "> " + componentCls + "-nav", _defineProperty$1({}, componentCls + "-tab", {
    padding: token.paddingXS + "px " + padding + "px " + token.paddingXXS * 1.5 + "px"
  }))), _ref44)), _ref45;
};
var genTabStyle = function genTabStyle(token) {
  var _tabCls, _ref46;
  var componentCls = token.componentCls,
    tabsActiveColor = token.tabsActiveColor,
    tabsHoverColor = token.tabsHoverColor,
    iconCls = token.iconCls,
    tabsHorizontalGutter = token.tabsHorizontalGutter;
  var tabCls = componentCls + "-tab";
  return _ref46 = {}, _defineProperty$1(_ref46, tabCls, (_tabCls = {
    position: 'relative',
    display: 'inline-flex',
    alignItems: 'center',
    padding: token.paddingSM + "px 0",
    fontSize: token.fontSize + "px",
    background: 'transparent',
    border: 0,
    outline: 'none',
    cursor: 'pointer',
    '&-btn, &-remove': _extends$2({
      '&:focus:not(:focus-visible), &:active': {
        color: tabsActiveColor
      }
    }, genFocusStyle(token)),
    '&-btn': {
      outline: 'none',
      transition: 'all 0.3s'
    },
    '&-remove': {
      flex: 'none',
      marginRight: {
        _skip_check_: true,
        value: -token.marginXXS
      },
      marginLeft: {
        _skip_check_: true,
        value: token.marginXS
      },
      color: token.colorTextDescription,
      fontSize: token.fontSizeSM,
      background: 'transparent',
      border: 'none',
      outline: 'none',
      cursor: 'pointer',
      transition: "all " + token.motionDurationSlow,
      '&:hover': {
        color: token.colorTextHeading
      }
    },
    '&:hover': {
      color: tabsHoverColor
    }
  }, _defineProperty$1(_tabCls, "&" + tabCls + "-active " + tabCls + "-btn", {
    color: token.colorPrimary,
    textShadow: token.tabsActiveTextShadow
  }), _defineProperty$1(_tabCls, "&" + tabCls + "-disabled", {
    color: token.colorTextDisabled,
    cursor: 'not-allowed'
  }), _defineProperty$1(_tabCls, "&" + tabCls + "-disabled " + tabCls + "-btn, &" + tabCls + "-disabled " + componentCls + "-remove", {
    '&:focus, &:active': {
      color: token.colorTextDisabled
    }
  }), _defineProperty$1(_tabCls, "& " + tabCls + "-remove " + iconCls, {
    margin: 0
  }), _defineProperty$1(_tabCls, iconCls, {
    marginRight: {
      _skip_check_: true,
      value: token.marginSM
    }
  }), _tabCls)), _defineProperty$1(_ref46, tabCls + " + " + tabCls, {
    margin: {
      _skip_check_: true,
      value: "0 0 0 " + tabsHorizontalGutter + "px"
    }
  }), _ref46;
};
var genRtlStyle$1 = function genRtlStyle(token) {
  var _ref48, _ref50, _ref51, _rtlCls, _ref55;
  var componentCls = token.componentCls,
    tabsHorizontalGutter = token.tabsHorizontalGutter,
    iconCls = token.iconCls,
    tabsCardGutter = token.tabsCardGutter;
  var rtlCls = componentCls + "-rtl";
  return _ref55 = {}, _defineProperty$1(_ref55, rtlCls, (_rtlCls = {
    direction: 'rtl'
  }, _defineProperty$1(_rtlCls, componentCls + "-nav", _defineProperty$1({}, componentCls + "-tab", (_ref48 = {
    margin: {
      _skip_check_: true,
      value: "0 0 0 " + tabsHorizontalGutter + "px"
    }
  }, _defineProperty$1(_ref48, componentCls + "-tab:last-of-type", {
    marginLeft: {
      _skip_check_: true,
      value: 0
    }
  }), _defineProperty$1(_ref48, iconCls, {
    marginRight: {
      _skip_check_: true,
      value: 0
    },
    marginLeft: {
      _skip_check_: true,
      value: token.marginSM + "px"
    }
  }), _defineProperty$1(_ref48, componentCls + "-tab-remove", _defineProperty$1({
    marginRight: {
      _skip_check_: true,
      value: token.marginXS + "px"
    },
    marginLeft: {
      _skip_check_: true,
      value: "-" + token.marginXXS + "px"
    }
  }, iconCls, {
    margin: 0
  })), _ref48))), _defineProperty$1(_rtlCls, "&" + componentCls + "-left", (_ref50 = {}, _defineProperty$1(_ref50, "> " + componentCls + "-nav", {
    order: 1
  }), _defineProperty$1(_ref50, "> " + componentCls + "-content-holder", {
    order: 0
  }), _ref50)), _defineProperty$1(_rtlCls, "&" + componentCls + "-right", (_ref51 = {}, _defineProperty$1(_ref51, "> " + componentCls + "-nav", {
    order: 0
  }), _defineProperty$1(_ref51, "> " + componentCls + "-content-holder", {
    order: 1
  }), _ref51)), _defineProperty$1(_rtlCls, "&" + componentCls + "-card" + componentCls + "-top, &" + componentCls + "-card" + componentCls + "-bottom", _defineProperty$1({}, "> " + componentCls + "-nav, > div > " + componentCls + "-nav", _defineProperty$1({}, componentCls + "-tab + " + componentCls + "-tab", {
    marginRight: {
      _skip_check_: true,
      value: tabsCardGutter + "px"
    },
    marginLeft: {
      _skip_check_: true,
      value: 0
    }
  }))), _rtlCls)), _defineProperty$1(_ref55, componentCls + "-dropdown-rtl", {
    direction: 'rtl'
  }), _defineProperty$1(_ref55, componentCls + "-menu-item", _defineProperty$1({}, componentCls + "-dropdown-rtl", {
    textAlign: {
      _skip_check_: true,
      value: 'right'
    }
  })), _ref55;
};
var genTabsStyle = function genTabsStyle(token) {
  var _ref56, _extends3, _extends4, _ref60;
  var componentCls = token.componentCls,
    tabsCardHorizontalPadding = token.tabsCardHorizontalPadding,
    tabsCardHeight = token.tabsCardHeight,
    tabsCardGutter = token.tabsCardGutter,
    tabsHoverColor = token.tabsHoverColor,
    tabsActiveColor = token.tabsActiveColor,
    colorSplit = token.colorSplit;
  return _ref60 = {}, _defineProperty$1(_ref60, componentCls, _extends$2(_extends$2(_extends$2(_extends$2({}, resetComponent(token)), (_extends3 = {
    display: 'flex'
  }, _defineProperty$1(_extends3, "> " + componentCls + "-nav, > div > " + componentCls + "-nav", (_ref56 = {
    position: 'relative',
    display: 'flex',
    flex: 'none',
    alignItems: 'center'
  }, _defineProperty$1(_ref56, componentCls + "-nav-wrap", {
    position: 'relative',
    display: 'flex',
    flex: 'auto',
    alignSelf: 'stretch',
    overflow: 'hidden',
    whiteSpace: 'nowrap',
    transform: 'translate(0)',
    // >>>>> Ping shadow
    '&::before, &::after': {
      position: 'absolute',
      zIndex: 1,
      opacity: 0,
      transition: "opacity " + token.motionDurationSlow,
      content: "''",
      pointerEvents: 'none'
    }
  }), _defineProperty$1(_ref56, componentCls + "-nav-list", {
    position: 'relative',
    display: 'flex',
    transition: "opacity " + token.motionDurationSlow
  }), _defineProperty$1(_ref56, componentCls + "-nav-operations", {
    display: 'flex',
    alignSelf: 'stretch'
  }), _defineProperty$1(_ref56, componentCls + "-nav-operations-hidden", {
    position: 'absolute',
    visibility: 'hidden',
    pointerEvents: 'none'
  }), _defineProperty$1(_ref56, componentCls + "-nav-more", {
    position: 'relative',
    padding: tabsCardHorizontalPadding,
    background: 'transparent',
    border: 0,
    '&::after': {
      position: 'absolute',
      right: {
        _skip_check_: true,
        value: 0
      },
      bottom: 0,
      left: {
        _skip_check_: true,
        value: 0
      },
      height: token.controlHeightLG / 8,
      transform: 'translateY(100%)',
      content: "''"
    }
  }), _defineProperty$1(_ref56, componentCls + "-nav-add", _extends$2({
    minWidth: tabsCardHeight + "px",
    marginLeft: {
      _skip_check_: true,
      value: tabsCardGutter + "px"
    },
    padding: "0 " + token.paddingXS + "px",
    background: 'transparent',
    border: token.lineWidth + "px " + token.lineType + " " + colorSplit,
    borderRadius: token.borderRadiusLG + "px " + token.borderRadiusLG + "px 0 0",
    outline: 'none',
    cursor: 'pointer',
    transition: "all " + token.motionDurationSlow + " " + token.motionEaseInOut,
    '&:hover': {
      color: tabsHoverColor
    },
    '&:active, &:focus:not(:focus-visible)': {
      color: tabsActiveColor
    }
  }, genFocusStyle(token))), _ref56)), _defineProperty$1(_extends3, componentCls + "-extra-content", {
    flex: 'none'
  }), _defineProperty$1(_extends3, componentCls + "-ink-bar", {
    position: 'absolute',
    background: token.colorPrimary,
    pointerEvents: 'none'
  }), _extends3)), genTabStyle(token)), (_extends4 = {}, _defineProperty$1(_extends4, componentCls + "-content", {
    position: 'relative',
    width: '100%'
  }), _defineProperty$1(_extends4, componentCls + "-content-holder", {
    flex: 'auto',
    minWidth: 0,
    minHeight: 0
  }), _defineProperty$1(_extends4, componentCls + "-tabpane", {
    outline: 'none',
    '&-hidden': {
      display: 'none'
    }
  }), _extends4))), _defineProperty$1(_ref60, componentCls + "-centered", _defineProperty$1({}, "> " + componentCls + "-nav, > div > " + componentCls + "-nav", _defineProperty$1({}, componentCls + "-nav-wrap", _defineProperty$1({}, "&:not([class*='" + componentCls + "-nav-wrap-ping'])", {
    justifyContent: 'center'
  })))), _ref60;
};
// ============================== Export ==============================
const useStyle$d = genComponentStyleHook('Tabs', function (token) {
  var tabsCardHeight = token.controlHeightLG;
  var tabsToken = merge$2(token, {
    tabsHoverColor: token.colorPrimaryHover,
    tabsActiveColor: token.colorPrimaryActive,
    tabsCardHorizontalPadding: (tabsCardHeight - Math.round(token.fontSize * token.lineHeight)) / 2 - token.lineWidth + "px " + token.padding + "px",
    tabsCardHeight: tabsCardHeight,
    tabsCardGutter: token.marginXXS / 2,
    tabsHorizontalGutter: 32,
    tabsCardHeadBackground: token.colorFillAlter,
    dropdownEdgeChildVerticalPadding: token.paddingXXS,
    tabsActiveTextShadow: '0 0 0.25px currentcolor',
    tabsDropdownHeight: 200,
    tabsDropdownWidth: 120
  });
  return [genSizeStyle$2(tabsToken), genRtlStyle$1(tabsToken), genPositionStyle(tabsToken), genDropdownStyle(tabsToken), genCardStyle$1(tabsToken), genTabsStyle(tabsToken), genMotionStyle$1(tabsToken)];
}, function (token) {
  return {
    zIndexPopup: token.zIndexPopupBase + 50
  };
});

var __rest$z = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function Tabs(_a) {
  var type = _a.type,
    className = _a.className,
    propSize = _a.size,
    _onEdit = _a.onEdit,
    hideAdd = _a.hideAdd,
    centered = _a.centered,
    addIcon = _a.addIcon,
    popupClassName = _a.popupClassName,
    children = _a.children,
    items = _a.items,
    animated = _a.animated,
    props = __rest$z(_a, ["type", "className", "size", "onEdit", "hideAdd", "centered", "addIcon", "popupClassName", "children", "items", "animated"]);
  var customizePrefixCls = props.prefixCls,
    _props$moreIcon = props.moreIcon,
    moreIcon = _props$moreIcon === void 0 ?
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(EllipsisOutlined$1, {}) : _props$moreIcon;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction,
    getPopupContainer = _React$useContext.getPopupContainer;
  var prefixCls = getPrefixCls('tabs', customizePrefixCls);
  var _useStyle = useStyle$d(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var editable;
  if (type === 'editable-card') {
    editable = {
      onEdit: function onEdit(editType, _ref) {
        var key = _ref.key,
          event = _ref.event;
        _onEdit === null || _onEdit === void 0 ? void 0 : _onEdit(editType === 'add' ? event : key, editType);
      },
      removeIcon:
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(CloseOutlined$1, {}),
      addIcon: addIcon ||
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(PlusOutlined$1, {}),
      showAdd: hideAdd !== true
    };
  }
  var rootPrefixCls = getPrefixCls();
  var mergedItems = useLegacyItems(items, children);
  var mergedAnimated = useAnimateConfig(prefixCls, animated);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(SizeContext.Consumer, {
    children: function (contextSize) {
      var _classNames;
      var size = propSize !== undefined ? propSize : contextSize;
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(ForwardTabs, {
          direction: direction,
          getPopupContainer: getPopupContainer,
          moreTransitionName: rootPrefixCls + "-slide-up",
          ...props,
          items: mergedItems,
          className: classNames$1((_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-" + size, size), _defineProperty$1(_classNames, prefixCls + "-card", ['card', 'editable-card'].includes(type)), _defineProperty$1(_classNames, prefixCls + "-editable-card", type === 'editable-card'), _defineProperty$1(_classNames, prefixCls + "-centered", centered), _classNames), className, hashId),
          popupClassName: classNames$1(popupClassName, hashId),
          editable: editable,
          moreIcon: moreIcon,
          prefixCls: prefixCls,
          animated: mergedAnimated
        })
      );
    }
  }));
}
Tabs.TabPane = TabPane$1;

var __rest$y = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var Grid = function Grid(_a) {
  var prefixCls = _a.prefixCls,
    className = _a.className,
    _a$hoverable = _a.hoverable,
    hoverable = _a$hoverable === void 0 ? true : _a$hoverable,
    props = __rest$y(_a, ["prefixCls", "className", "hoverable"]);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(ConfigConsumer, {
      children: function (_ref) {
        var getPrefixCls = _ref.getPrefixCls;
        var prefix = getPrefixCls('card', prefixCls);
        var classString = classNames$1(prefix + "-grid", className, _defineProperty$1({}, prefix + "-grid-hoverable", hoverable));
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("div", {
            ...props,
            className: classString
          })
        );
      }
    })
  );
};
const Grid$1 = Grid;

// ============================== Styles ==============================
// ============================== Head ==============================
var genCardHeadStyle = function genCardHeadStyle(token) {
  var antCls = token.antCls,
    componentCls = token.componentCls,
    cardHeadHeight = token.cardHeadHeight,
    cardHeadPadding = token.cardHeadPadding,
    cardPaddingBase = token.cardPaddingBase,
    cardHeadTabsMarginBottom = token.cardHeadTabsMarginBottom;
  return _extends$2(_extends$2({
    minHeight: cardHeadHeight,
    marginBottom: -1,
    padding: "0 " + cardPaddingBase + "px",
    color: token.colorTextHeading,
    fontWeight: token.fontWeightStrong,
    fontSize: token.fontSizeLG,
    background: 'transparent',
    borderBottom: token.lineWidth + "px " + token.lineType + " " + token.colorBorderSecondary,
    borderRadius: token.borderRadiusLG + "px " + token.borderRadiusLG + "px 0 0"
  }, clearFix()), _defineProperty$1({
    '&-wrapper': {
      display: 'flex',
      alignItems: 'center'
    },
    '&-title': _extends$2(_extends$2({
      display: 'inline-block',
      flex: 1,
      padding: cardHeadPadding + "px 0"
    }, textEllipsis), _defineProperty$1({}, "\n          > " + componentCls + "-typography,\n          > " + componentCls + "-typography-edit-content\n        ", {
      insetInlineStart: 0,
      marginTop: 0,
      marginBottom: 0
    }))
  }, antCls + "-tabs-top", {
    clear: 'both',
    marginBottom: cardHeadTabsMarginBottom,
    color: token.colorText,
    fontWeight: 'normal',
    fontSize: token.fontSize,
    '&-bar': {
      borderBottom: token.lineWidth + "px " + token.lineType + " " + token.colorBorderSecondary
    }
  }));
};
// ============================== Grid ==============================
var genCardGridStyle = function genCardGridStyle(token) {
  var cardPaddingBase = token.cardPaddingBase,
    colorBorderSecondary = token.colorBorderSecondary,
    cardShadow = token.cardShadow,
    lineWidth = token.lineWidth;
  return {
    width: '33.33%',
    padding: cardPaddingBase,
    border: 0,
    borderRadius: 0,
    boxShadow: "\n      " + lineWidth + "px 0 0 0 " + colorBorderSecondary + ",\n      0 " + lineWidth + "px 0 0 " + colorBorderSecondary + ",\n      " + lineWidth + "px " + lineWidth + "px 0 0 " + colorBorderSecondary + ",\n      " + lineWidth + "px 0 0 0 " + colorBorderSecondary + " inset,\n      0 " + lineWidth + "px 0 0 " + colorBorderSecondary + " inset;\n    ",
    transition: "all " + token.motionDurationMid,
    '&-hoverable:hover': {
      position: 'relative',
      zIndex: 1,
      boxShadow: cardShadow
    }
  };
};
// ============================== Actions ==============================
var genCardActionsStyle = function genCardActionsStyle(token) {
  var _span;
  var componentCls = token.componentCls,
    iconCls = token.iconCls,
    cardActionsLiMargin = token.cardActionsLiMargin,
    cardActionsIconSize = token.cardActionsIconSize,
    colorBorderSecondary = token.colorBorderSecondary;
  return _extends$2(_extends$2({
    margin: 0,
    padding: 0,
    listStyle: 'none',
    background: token.colorBgContainer,
    borderTop: token.lineWidth + "px " + token.lineType + " " + colorBorderSecondary,
    display: 'flex',
    borderRadius: "0 0 " + token.borderRadiusLG + "px " + token.borderRadiusLG + "px "
  }, clearFix()), {
    '& > li': {
      margin: cardActionsLiMargin,
      color: token.colorTextDescription,
      textAlign: 'center',
      '> span': (_span = {
        position: 'relative',
        display: 'block',
        minWidth: token.cardActionsIconSize * 2,
        fontSize: token.fontSize,
        lineHeight: token.lineHeight,
        cursor: 'pointer',
        '&:hover': {
          color: token.colorPrimary,
          transition: "color " + token.motionDurationMid
        }
      }, _defineProperty$1(_span, "a:not(" + componentCls + "-btn), > " + iconCls, {
        display: 'inline-block',
        width: '100%',
        color: token.colorTextDescription,
        lineHeight: token.fontSize * token.lineHeight + "px",
        transition: "color " + token.motionDurationMid,
        '&:hover': {
          color: token.colorPrimary
        }
      }), _defineProperty$1(_span, "> " + iconCls, {
        fontSize: cardActionsIconSize,
        lineHeight: cardActionsIconSize * token.lineHeight + "px"
      }), _span),
      '&:not(:last-child)': {
        borderInlineEnd: token.lineWidth + "px " + token.lineType + " " + colorBorderSecondary
      }
    }
  });
};
// ============================== Meta ==============================
var genCardMetaStyle = function genCardMetaStyle(token) {
  return _extends$2(_extends$2({
    margin: "-" + token.marginXXS + "px 0",
    display: 'flex'
  }, clearFix()), {
    '&-avatar': {
      paddingInlineEnd: token.padding
    },
    '&-detail': {
      overflow: 'hidden',
      flex: 1,
      '> div:not(:last-child)': {
        marginBottom: token.marginXS
      }
    },
    '&-title': _extends$2({
      color: token.colorTextHeading,
      fontWeight: token.fontWeightStrong,
      fontSize: token.fontSizeLG
    }, textEllipsis),
    '&-description': {
      color: token.colorTextDescription
    }
  });
};
// ============================== Inner ==============================
var genCardTypeInnerStyle = function genCardTypeInnerStyle(token) {
  var _ref;
  var componentCls = token.componentCls,
    cardPaddingBase = token.cardPaddingBase,
    colorFillAlter = token.colorFillAlter,
    cardInnerHeadPadding = token.cardInnerHeadPadding;
  return _ref = {}, _defineProperty$1(_ref, componentCls + "-head", {
    padding: "0 " + cardPaddingBase + "px",
    background: colorFillAlter,
    '&-title': {
      padding: cardInnerHeadPadding + "px 0",
      fontSize: token.fontSize
    }
  }), _defineProperty$1(_ref, componentCls + "-body", {
    padding: token.padding + "px " + cardPaddingBase + "px"
  }), _defineProperty$1(_ref, componentCls + "-extra", {
    padding: cardInnerHeadPadding + 1.5 + "px 0"
  }), _ref;
};
// ============================== Loading ==============================
var genCardLoadingStyle = function genCardLoadingStyle(token) {
  var componentCls = token.componentCls;
  return _defineProperty$1({
    overflow: 'hidden'
  }, componentCls + "-body", {
    userSelect: 'none'
  });
};
// ============================== Basic ==============================
var genCardStyle = function genCardStyle(token) {
  var _extends4, _ref4, _ref5, _ref7;
  var componentCls = token.componentCls,
    cardShadow = token.cardShadow,
    cardHeadHeight = token.cardHeadHeight,
    cardHeadPadding = token.cardHeadPadding,
    colorBorderSecondary = token.colorBorderSecondary,
    boxShadow = token.boxShadow,
    cardPaddingBase = token.cardPaddingBase;
  return _ref7 = {}, _defineProperty$1(_ref7, componentCls, _extends$2(_extends$2({}, resetComponent(token)), (_extends4 = {
    position: 'relative',
    background: token.colorBgContainer,
    borderRadius: token.borderRadiusLG
  }, _defineProperty$1(_extends4, "&:not(" + componentCls + "-bordered)", {
    boxShadow: boxShadow
  }), _defineProperty$1(_extends4, componentCls + "-head", genCardHeadStyle(token)), _defineProperty$1(_extends4, componentCls + "-extra", {
    // https://stackoverflow.com/a/22429853/3040605
    marginInlineStart: 'auto',
    padding: '',
    color: '',
    fontWeight: 'normal',
    fontSize: token.fontSize
  }), _defineProperty$1(_extends4, componentCls + "-body", _extends$2({
    padding: cardPaddingBase,
    borderRadius: " 0 0 " + token.borderRadiusLG + "px " + token.borderRadiusLG + "px"
  }, clearFix())), _defineProperty$1(_extends4, componentCls + "-grid", genCardGridStyle(token)), _defineProperty$1(_extends4, componentCls + "-cover", {
    '> *': {
      display: 'block',
      width: '100%'
    },
    img: {
      borderRadius: token.borderRadiusLG + "px " + token.borderRadiusLG + "px 0 0"
    }
  }), _defineProperty$1(_extends4, componentCls + "-actions", genCardActionsStyle(token)), _defineProperty$1(_extends4, componentCls + "-meta", genCardMetaStyle(token)), _extends4))), _defineProperty$1(_ref7, componentCls + "-bordered", _defineProperty$1({
    border: token.lineWidth + "px " + token.lineType + " " + colorBorderSecondary
  }, componentCls + "-cover", {
    marginTop: -1,
    marginInlineStart: -1,
    marginInlineEnd: -1
  })), _defineProperty$1(_ref7, componentCls + "-hoverable", {
    cursor: 'pointer',
    transition: "box-shadow " + token.motionDurationMid + ", border-color " + token.motionDurationMid,
    '&:hover': {
      borderColor: 'transparent',
      boxShadow: cardShadow
    }
  }), _defineProperty$1(_ref7, componentCls + "-contain-grid", (_ref4 = {}, _defineProperty$1(_ref4, componentCls + "-body", {
    display: 'flex',
    flexWrap: 'wrap'
  }), _defineProperty$1(_ref4, "&:not(" + componentCls + "-loading) " + componentCls + "-body", {
    marginBlockStart: -token.lineWidth,
    marginInlineStart: -token.lineWidth,
    padding: 0
  }), _ref4)), _defineProperty$1(_ref7, componentCls + "-contain-tabs", _defineProperty$1({}, "> " + componentCls + "-head", (_ref5 = {}, _defineProperty$1(_ref5, componentCls + "-head-title", {
    minHeight: cardHeadHeight - cardHeadPadding,
    paddingBottom: 0
  }), _defineProperty$1(_ref5, componentCls + "-extra", {
    paddingBottom: 0
  }), _ref5))), _defineProperty$1(_ref7, componentCls + "-type-inner", genCardTypeInnerStyle(token)), _defineProperty$1(_ref7, componentCls + "-loading", genCardLoadingStyle(token)), _defineProperty$1(_ref7, componentCls + "-rtl", {
    direction: 'rtl'
  }), _ref7;
};
// ============================== Size ==============================
var genCardSizeStyle = function genCardSizeStyle(token) {
  var _ref8, _ref10;
  var componentCls = token.componentCls,
    cardPaddingSM = token.cardPaddingSM,
    fontSize = token.fontSize,
    lineHeight = token.lineHeight,
    cardHeaderHeightSM = token.cardHeaderHeightSM;
  var cardHeadPaddingSM = (cardHeaderHeightSM - fontSize * lineHeight) / 2;
  return _defineProperty$1({}, componentCls + "-small", (_ref10 = {}, _defineProperty$1(_ref10, "> " + componentCls + "-head", _defineProperty$1({
    minHeight: cardHeaderHeightSM,
    padding: "0 " + cardPaddingSM + "px",
    fontSize: token.fontSize
  }, "> " + componentCls + "-head-wrapper", (_ref8 = {}, _defineProperty$1(_ref8, "> " + componentCls + "-head-title", {
    padding: cardHeadPaddingSM + "px 0"
  }), _defineProperty$1(_ref8, "> " + componentCls + "-extra", {
    padding: cardHeadPaddingSM + "px 0",
    fontSize: token.fontSize
  }), _ref8))), _defineProperty$1(_ref10, "> " + componentCls + "-body", {
    padding: cardPaddingSM
  }), _ref10));
};
// ============================== Export ==============================
const useStyle$c = genComponentStyleHook('Card', function (token) {
  var cardToken = merge$2(token, {
    cardShadow: token.boxShadowCard,
    cardHeaderHeight: token.fontSizeLG * token.lineHeightLG + token.padding * 2,
    cardHeaderHeightSM: token.fontSize * token.lineHeight + token.paddingXS * 2,
    cardHeadPadding: token.padding,
    cardPaddingBase: token.paddingLG,
    cardHeadTabsMarginBottom: -token.padding - token.lineWidth,
    cardInnerHeadPadding: token.paddingSM,
    cardActionsLiMargin: token.paddingSM + "px 0",
    cardActionsIconSize: token.fontSize,
    cardPaddingSM: 12 // Fixed padding.
  });

  return [
  // Style
  genCardStyle(cardToken),
  // Size
  genCardSizeStyle(cardToken)];
});

var __rest$x = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function getAction(actions) {
  var actionList = actions.map(function (action, index) {
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      // eslint-disable-next-line react/no-array-index-key
      jsx$1("li", {
        style: {
          width: 100 / actions.length + "%"
        },
        children: /*#__PURE__*/jsx$1("span", {
          children: action
        })
      }, "action-" + index)
    );
  });
  return actionList;
}
var Card$2 = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _extends2, _classNames;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var size = react.exports.useContext(SizeContext);
  var onTabChange = function onTabChange(key) {
    var _a;
    (_a = props.onTabChange) === null || _a === void 0 ? void 0 : _a.call(props, key);
  };
  var isContainGrid = function isContainGrid() {
    var containGrid;
    react.exports.Children.forEach(props.children, function (element) {
      if (element && element.type && element.type === Grid$1) {
        containGrid = true;
      }
    });
    return containGrid;
  };
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    extra = props.extra,
    _props$headStyle = props.headStyle,
    headStyle = _props$headStyle === void 0 ? {} : _props$headStyle,
    _props$bodyStyle = props.bodyStyle,
    bodyStyle = _props$bodyStyle === void 0 ? {} : _props$bodyStyle,
    title = props.title,
    loading = props.loading,
    _props$bordered = props.bordered,
    bordered = _props$bordered === void 0 ? true : _props$bordered,
    customizeSize = props.size,
    type = props.type,
    cover = props.cover,
    actions = props.actions,
    tabList = props.tabList,
    children = props.children,
    activeTabKey = props.activeTabKey,
    defaultActiveTabKey = props.defaultActiveTabKey,
    tabBarExtraContent = props.tabBarExtraContent,
    hoverable = props.hoverable,
    _props$tabProps = props.tabProps,
    tabProps = _props$tabProps === void 0 ? {} : _props$tabProps,
    others = __rest$x(props, ["prefixCls", "className", "extra", "headStyle", "bodyStyle", "title", "loading", "bordered", "size", "type", "cover", "actions", "tabList", "children", "activeTabKey", "defaultActiveTabKey", "tabBarExtraContent", "hoverable", "tabProps"]);
  var prefixCls = getPrefixCls('card', customizePrefixCls);
  var _useStyle = useStyle$c(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var loadingBlock =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(Skeleton$1, {
    loading: true,
    active: true,
    paragraph: {
      rows: 4
    },
    title: false,
    children: children
  });
  var hasActiveTabKey = activeTabKey !== undefined;
  var extraProps = _extends$2(_extends$2({}, tabProps), (_extends2 = {}, _defineProperty$1(_extends2, hasActiveTabKey ? 'activeKey' : 'defaultActiveKey', hasActiveTabKey ? activeTabKey : defaultActiveTabKey), _defineProperty$1(_extends2, "tabBarExtraContent", tabBarExtraContent), _extends2));
  var head;
  var tabs = tabList && tabList.length ?
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(Tabs, {
    size: "large",
    ...extraProps,
    className: prefixCls + "-head-tabs",
    onChange: onTabChange,
    items: tabList.map(function (item) {
      var _a;
      return {
        label: item.tab,
        key: item.key,
        disabled: (_a = item.disabled) !== null && _a !== void 0 ? _a : false
      };
    })
  }) : null;
  if (title || extra || tabs) {
    head =
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("div", {
      className: prefixCls + "-head",
      style: headStyle,
      children: [/*#__PURE__*/jsxs("div", {
        className: prefixCls + "-head-wrapper",
        children: [title &&
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("div", {
          className: prefixCls + "-head-title",
          children: title
        }), extra &&
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("div", {
          className: prefixCls + "-extra",
          children: extra
        })]
      }), tabs]
    });
  }
  var coverDom = cover ?
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    className: prefixCls + "-cover",
    children: cover
  }) : null;
  var body =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    className: prefixCls + "-body",
    style: bodyStyle,
    children: loading ? loadingBlock : children
  });
  var actionDom = actions && actions.length ?
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("ul", {
    className: prefixCls + "-actions",
    children: getAction(actions)
  }) : null;
  var divProps = omit$1(others, ['onTabChange']);
  var mergedSize = customizeSize || size;
  var classString = classNames$1(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-loading", loading), _defineProperty$1(_classNames, prefixCls + "-bordered", bordered), _defineProperty$1(_classNames, prefixCls + "-hoverable", hoverable), _defineProperty$1(_classNames, prefixCls + "-contain-grid", isContainGrid()), _defineProperty$1(_classNames, prefixCls + "-contain-tabs", tabList && tabList.length), _defineProperty$1(_classNames, prefixCls + "-" + mergedSize, mergedSize), _defineProperty$1(_classNames, prefixCls + "-type-" + type, !!type), _defineProperty$1(_classNames, prefixCls + "-rtl", direction === 'rtl'), _classNames), className, hashId);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsxs("div", {
    ref: ref,
    ...divProps,
    className: classString,
    children: [head, coverDom, body, actionDom]
  }));
});
const InternalCard = Card$2;

var __rest$w = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var Meta = function Meta(props) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(ConfigConsumer, {
      children: function (_ref) {
        var getPrefixCls = _ref.getPrefixCls;
        var customizePrefixCls = props.prefixCls,
          className = props.className,
          avatar = props.avatar,
          title = props.title,
          description = props.description,
          others = __rest$w(props, ["prefixCls", "className", "avatar", "title", "description"]);
        var prefixCls = getPrefixCls('card', customizePrefixCls);
        var classString = classNames$1(prefixCls + "-meta", className);
        var avatarDom = avatar ?
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("div", {
          className: prefixCls + "-meta-avatar",
          children: avatar
        }) : null;
        var titleDom = title ?
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("div", {
          className: prefixCls + "-meta-title",
          children: title
        }) : null;
        var descriptionDom = description ?
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("div", {
          className: prefixCls + "-meta-description",
          children: description
        }) : null;
        var MetaDetail = titleDom || descriptionDom ?
        /*#__PURE__*/
        /*#__PURE__*/
        jsxs("div", {
          className: prefixCls + "-meta-detail",
          children: [titleDom, descriptionDom]
        }) : null;
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsxs("div", {
            ...others,
            className: classString,
            children: [avatarDom, MetaDetail]
          })
        );
      }
    })
  );
};
const Meta$1 = Meta;

var Card = InternalCard;
Card.Grid = Grid$1;
Card.Meta = Meta$1;
const Card$1 = Card;

/* eslint-disable no-undefined,no-param-reassign,no-shadow */

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)
 *                                            are most useful.
 * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,
 *                                            as-is, to `callback` when the throttled-function is executed.
 * @param {object} [options] -              An object to configure options.
 * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds
 *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed
 *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for
 *                                            `delay` milliseconds, the internal counter is reset).
 * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback
 *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that
 *                                            callback will never executed if both noLeading = true and noTrailing = true.
 * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is
 *                                            false (at end), schedule `callback` to execute after `delay` ms.
 *
 * @returns {Function} A new, throttled, function.
 */
function throttle (delay, callback, options) {
  var _ref = options || {},
      _ref$noTrailing = _ref.noTrailing,
      noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing,
      _ref$noLeading = _ref.noLeading,
      noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading,
      _ref$debounceMode = _ref.debounceMode,
      debounceMode = _ref$debounceMode === void 0 ? undefined : _ref$debounceMode;
  /*
   * After wrapper has stopped being called, this timeout ensures that
   * `callback` is executed at the proper times in `throttle` and `end`
   * debounce modes.
   */


  var timeoutID;
  var cancelled = false; // Keep track of the last time `callback` was executed.

  var lastExec = 0; // Function to clear existing timeout

  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  } // Function to cancel next exec


  function cancel(options) {
    var _ref2 = options || {},
        _ref2$upcomingOnly = _ref2.upcomingOnly,
        upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;

    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  /*
   * The `wrapper` function encapsulates all of the throttling / debouncing
   * functionality and when executed will limit the rate at which `callback`
   * is executed.
   */


  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }

    var self = this;
    var elapsed = Date.now() - lastExec;

    if (cancelled) {
      return;
    } // Execute `callback` and update the `lastExec` timestamp.


    function exec() {
      lastExec = Date.now();
      callback.apply(self, arguments_);
    }
    /*
     * If `debounceMode` is true (at begin) this is used to clear the flag
     * to allow future `callback` executions.
     */


    function clear() {
      timeoutID = undefined;
    }

    if (!noLeading && debounceMode && !timeoutID) {
      /*
       * Since `wrapper` is being called for the first time and
       * `debounceMode` is true (at begin), execute `callback`
       * and noLeading != true.
       */
      exec();
    }

    clearExistingTimeout();

    if (debounceMode === undefined && elapsed > delay) {
      if (noLeading) {
        /*
         * In throttle mode with noLeading, if `delay` time has
         * been exceeded, update `lastExec` and schedule `callback`
         * to execute after `delay` ms.
         */
        lastExec = Date.now();

        if (!noTrailing) {
          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
        }
      } else {
        /*
         * In throttle mode without noLeading, if `delay` time has been exceeded, execute
         * `callback`.
         */
        exec();
      }
    } else if (noTrailing !== true) {
      /*
       * In trailing throttle mode, since `delay` time has not been
       * exceeded, schedule `callback` to execute `delay` ms after most
       * recent execution.
       *
       * If `debounceMode` is true (at begin), schedule `clear` to execute
       * after `delay` ms.
       *
       * If `debounceMode` is false (at end), schedule `callback` to
       * execute after `delay` ms.
       */
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
    }
  }

  wrapper.cancel = cancel; // Return the wrapper function.

  return wrapper;
}

/* eslint-disable no-undefined */
/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                        to `callback` when the debounced-function is executed.
 * @param {object} [options] -           An object to configure options.
 * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
 *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
 *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
 *
 * @returns {Function} A new, debounced function.
 */

function debounce$1 (delay, callback, options) {
  var _ref = options || {},
      _ref$atBegin = _ref.atBegin,
      atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;

  return throttle(delay, callback, {
    debounceMode: atBegin !== false
  });
}

function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
  var filteredKeys = new Set();
  halfCheckedKeys.forEach(function (key) {
    if (!checkedKeys.has(key)) {
      filteredKeys.add(key);
    }
  });
  return filteredKeys;
}
function isCheckDisabled(node) {
  var _ref = node || {},
    disabled = _ref.disabled,
    disableCheckbox = _ref.disableCheckbox,
    checkable = _ref.checkable;
  return !!(disabled || disableCheckbox) || checkable === false;
}
// Fill miss keys
function fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  var checkedKeys = new Set(keys);
  var halfCheckedKeys = new Set();
  // Add checked keys top to bottom
  for (var level = 0; level <= maxLevel; level += 1) {
    var entities = levelEntities.get(level) || new Set();
    entities.forEach(function (entity) {
      var key = entity.key,
        node = entity.node,
        _entity$children = entity.children,
        children = _entity$children === void 0 ? [] : _entity$children;
      if (checkedKeys.has(key) && !syntheticGetCheckDisabled(node)) {
        children.filter(function (childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function (childEntity) {
          checkedKeys.add(childEntity.key);
        });
      }
    });
  }
  // Add checked keys from bottom to top
  var visitedKeys = new Set();
  for (var _level = maxLevel; _level >= 0; _level -= 1) {
    var _entities = levelEntities.get(_level) || new Set();
    _entities.forEach(function (entity) {
      var parent = entity.parent,
        node = entity.node;
      // Skip if no need to check
      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      // Skip if parent is disabled
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      var allChecked = true;
      var partialChecked = false;
      (parent.children || []).filter(function (childEntity) {
        return !syntheticGetCheckDisabled(childEntity.node);
      }).forEach(function (_ref2) {
        var key = _ref2.key;
        var checked = checkedKeys.has(key);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
          partialChecked = true;
        }
      });
      if (allChecked) {
        checkedKeys.add(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
// Remove useless key
function cleanConductCheck(keys, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  var checkedKeys = new Set(keys);
  var halfCheckedKeys = new Set(halfKeys);
  // Remove checked keys from top to bottom
  for (var level = 0; level <= maxLevel; level += 1) {
    var entities = levelEntities.get(level) || new Set();
    entities.forEach(function (entity) {
      var key = entity.key,
        node = entity.node,
        _entity$children2 = entity.children,
        children = _entity$children2 === void 0 ? [] : _entity$children2;
      if (!checkedKeys.has(key) && !halfCheckedKeys.has(key) && !syntheticGetCheckDisabled(node)) {
        children.filter(function (childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function (childEntity) {
          checkedKeys.delete(childEntity.key);
        });
      }
    });
  }
  // Remove checked keys form bottom to top
  halfCheckedKeys = new Set();
  var visitedKeys = new Set();
  for (var _level2 = maxLevel; _level2 >= 0; _level2 -= 1) {
    var _entities2 = levelEntities.get(_level2) || new Set();
    _entities2.forEach(function (entity) {
      var parent = entity.parent,
        node = entity.node;
      // Skip if no need to check
      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      // Skip if parent is disabled
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      var allChecked = true;
      var partialChecked = false;
      (parent.children || []).filter(function (childEntity) {
        return !syntheticGetCheckDisabled(childEntity.node);
      }).forEach(function (_ref3) {
        var key = _ref3.key;
        var checked = checkedKeys.has(key);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key))) {
          partialChecked = true;
        }
      });
      if (!allChecked) {
        checkedKeys.delete(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
/**
 * Conduct with keys.
 * @param keyList current key list
 * @param keyEntities key - dataEntity map
 * @param mode `fill` to fill missing key, `clean` to remove useless key
 */
function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {
  var warningMissKeys = [];
  var syntheticGetCheckDisabled;
  if (getCheckDisabled) {
    syntheticGetCheckDisabled = getCheckDisabled;
  } else {
    syntheticGetCheckDisabled = isCheckDisabled;
  }
  // We only handle exist keys
  var keys = new Set(keyList.filter(function (key) {
    var hasEntity = !!keyEntities[key];
    if (!hasEntity) {
      warningMissKeys.push(key);
    }
    return hasEntity;
  }));
  var levelEntities = new Map();
  var maxLevel = 0;
  // Convert entities by level for calculation
  Object.keys(keyEntities).forEach(function (key) {
    var entity = keyEntities[key];
    var level = entity.level;
    var levelSet = levelEntities.get(level);
    if (!levelSet) {
      levelSet = new Set();
      levelEntities.set(level, levelSet);
    }
    levelSet.add(entity);
    maxLevel = Math.max(maxLevel, level);
  });
  warningOnce(!warningMissKeys.length, "Tree missing follow keys: ".concat(warningMissKeys.slice(0, 100).map(function (key) {
    return "'".concat(key, "'");
  }).join(', ')));
  var result;
  if (checked === true) {
    result = fillConductCheck(keys, levelEntities, maxLevel, syntheticGetCheckDisabled);
  } else {
    result = cleanConductCheck(keys, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);
  }
  return result;
}

/**
 * Webpack has bug for import loop, which is not the same behavior as ES module.
 * When util.js imports the TreeNode for tree generate will cause treeContextTypes be empty.
 */
var TreeContext = /*#__PURE__*/react.exports.createContext(null);

var Indent = function Indent(_ref) {
  var prefixCls = _ref.prefixCls,
    level = _ref.level,
    isStart = _ref.isStart,
    isEnd = _ref.isEnd;
  var baseClassName = "".concat(prefixCls, "-indent-unit");
  var list = [];
  for (var i = 0; i < level; i += 1) {
    var _classNames;
    list.push(
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      className: classNames$1(baseClassName, (_classNames = {}, _defineProperty$1(_classNames, "".concat(baseClassName, "-start"), isStart[i]), _defineProperty$1(_classNames, "".concat(baseClassName, "-end"), isEnd[i]), _classNames))
    }, i));
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      "aria-hidden": "true",
      className: "".concat(prefixCls, "-indent"),
      children: list
    })
  );
};
const Indent$1 = /*#__PURE__*/react.exports.memo(Indent);

var _excluded$n = ["eventKey", "className", "style", "dragOver", "dragOverGapTop", "dragOverGapBottom", "isLeaf", "isStart", "isEnd", "expanded", "selected", "checked", "halfChecked", "loading", "domRef", "active", "data", "onMouseMove", "selectable"];
var ICON_OPEN = 'open';
var ICON_CLOSE = 'close';
var defaultTitle = '---';
var InternalTreeNode = /*#__PURE__*/function (_React$Component) {
  _inherits(InternalTreeNode, _React$Component);
  var _super = _createSuper(InternalTreeNode);
  function InternalTreeNode() {
    var _this;
    _classCallCheck(this, InternalTreeNode);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      dragNodeHighlight: false
    };
    _this.selectHandle = void 0;
    _this.onSelectorClick = function (e) {
      // Click trigger before select/check operation
      var onNodeClick = _this.props.context.onNodeClick;
      onNodeClick(e, convertNodePropsToEventData(_this.props));
      if (_this.isSelectable()) {
        _this.onSelect(e);
      } else {
        _this.onCheck(e);
      }
    };
    _this.onSelectorDoubleClick = function (e) {
      var onNodeDoubleClick = _this.props.context.onNodeDoubleClick;
      onNodeDoubleClick(e, convertNodePropsToEventData(_this.props));
    };
    _this.onSelect = function (e) {
      if (_this.isDisabled()) return;
      var onNodeSelect = _this.props.context.onNodeSelect;
      e.preventDefault();
      onNodeSelect(e, convertNodePropsToEventData(_this.props));
    };
    _this.onCheck = function (e) {
      if (_this.isDisabled()) return;
      var _this$props = _this.props,
        disableCheckbox = _this$props.disableCheckbox,
        checked = _this$props.checked;
      var onNodeCheck = _this.props.context.onNodeCheck;
      if (!_this.isCheckable() || disableCheckbox) return;
      e.preventDefault();
      var targetChecked = !checked;
      onNodeCheck(e, convertNodePropsToEventData(_this.props), targetChecked);
    };
    _this.onMouseEnter = function (e) {
      var onNodeMouseEnter = _this.props.context.onNodeMouseEnter;
      onNodeMouseEnter(e, convertNodePropsToEventData(_this.props));
    };
    _this.onMouseLeave = function (e) {
      var onNodeMouseLeave = _this.props.context.onNodeMouseLeave;
      onNodeMouseLeave(e, convertNodePropsToEventData(_this.props));
    };
    _this.onContextMenu = function (e) {
      var onNodeContextMenu = _this.props.context.onNodeContextMenu;
      onNodeContextMenu(e, convertNodePropsToEventData(_this.props));
    };
    _this.onDragStart = function (e) {
      var onNodeDragStart = _this.props.context.onNodeDragStart;
      e.stopPropagation();
      _this.setState({
        dragNodeHighlight: true
      });
      onNodeDragStart(e, _assertThisInitialized(_this));
      try {
        // ie throw error
        // firefox-need-it
        e.dataTransfer.setData('text/plain', '');
      } catch (error) {
        // empty
      }
    };
    _this.onDragEnter = function (e) {
      var onNodeDragEnter = _this.props.context.onNodeDragEnter;
      e.preventDefault();
      e.stopPropagation();
      onNodeDragEnter(e, _assertThisInitialized(_this));
    };
    _this.onDragOver = function (e) {
      var onNodeDragOver = _this.props.context.onNodeDragOver;
      e.preventDefault();
      e.stopPropagation();
      onNodeDragOver(e, _assertThisInitialized(_this));
    };
    _this.onDragLeave = function (e) {
      var onNodeDragLeave = _this.props.context.onNodeDragLeave;
      e.stopPropagation();
      onNodeDragLeave(e, _assertThisInitialized(_this));
    };
    _this.onDragEnd = function (e) {
      var onNodeDragEnd = _this.props.context.onNodeDragEnd;
      e.stopPropagation();
      _this.setState({
        dragNodeHighlight: false
      });
      onNodeDragEnd(e, _assertThisInitialized(_this));
    };
    _this.onDrop = function (e) {
      var onNodeDrop = _this.props.context.onNodeDrop;
      e.preventDefault();
      e.stopPropagation();
      _this.setState({
        dragNodeHighlight: false
      });
      onNodeDrop(e, _assertThisInitialized(_this));
    };
    _this.onExpand = function (e) {
      var _this$props2 = _this.props,
        loading = _this$props2.loading,
        onNodeExpand = _this$props2.context.onNodeExpand;
      if (loading) return;
      onNodeExpand(e, convertNodePropsToEventData(_this.props));
    };
    _this.setSelectHandle = function (node) {
      _this.selectHandle = node;
    };
    _this.getNodeState = function () {
      var expanded = _this.props.expanded;
      if (_this.isLeaf()) {
        return null;
      }
      return expanded ? ICON_OPEN : ICON_CLOSE;
    };
    _this.hasChildren = function () {
      var eventKey = _this.props.eventKey;
      var keyEntities = _this.props.context.keyEntities;
      var _ref = keyEntities[eventKey] || {},
        children = _ref.children;
      return !!(children || []).length;
    };
    _this.isLeaf = function () {
      var _this$props3 = _this.props,
        isLeaf = _this$props3.isLeaf,
        loaded = _this$props3.loaded;
      var loadData = _this.props.context.loadData;
      var hasChildren = _this.hasChildren();
      if (isLeaf === false) {
        return false;
      }
      return isLeaf || !loadData && !hasChildren || loadData && loaded && !hasChildren;
    };
    _this.isDisabled = function () {
      var disabled = _this.props.disabled;
      var treeDisabled = _this.props.context.disabled;
      return !!(treeDisabled || disabled);
    };
    _this.isCheckable = function () {
      var checkable = _this.props.checkable;
      var treeCheckable = _this.props.context.checkable;
      // Return false if tree or treeNode is not checkable
      if (!treeCheckable || checkable === false) return false;
      return treeCheckable;
    };
    _this.syncLoadData = function (props) {
      var expanded = props.expanded,
        loading = props.loading,
        loaded = props.loaded;
      var _this$props$context = _this.props.context,
        loadData = _this$props$context.loadData,
        onNodeLoad = _this$props$context.onNodeLoad;
      if (loading) {
        return;
      }
      // read from state to avoid loadData at same time
      if (loadData && expanded && !_this.isLeaf()) {
        // We needn't reload data when has children in sync logic
        // It's only needed in node expanded
        if (!_this.hasChildren() && !loaded) {
          onNodeLoad(convertNodePropsToEventData(_this.props));
        }
      }
    };
    _this.isDraggable = function () {
      var _this$props4 = _this.props,
        data = _this$props4.data,
        draggable = _this$props4.context.draggable;
      return !!(draggable && (!draggable.nodeDraggable || draggable.nodeDraggable(data)));
    };
    _this.renderDragHandler = function () {
      var _this$props$context2 = _this.props.context,
        draggable = _this$props$context2.draggable,
        prefixCls = _this$props$context2.prefixCls;
      return (draggable === null || draggable === void 0 ? void 0 : draggable.icon) ?
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        className: "".concat(prefixCls, "-draggable-icon"),
        children: draggable.icon
      }) : null;
    };
    _this.renderSwitcherIconDom = function (isLeaf) {
      var switcherIconFromProps = _this.props.switcherIcon;
      var switcherIconFromCtx = _this.props.context.switcherIcon;
      var switcherIcon = switcherIconFromProps || switcherIconFromCtx;
      // if switcherIconDom is null, no render switcher span
      if (typeof switcherIcon === 'function') {
        return switcherIcon(_objectSpread2$1(_objectSpread2$1({}, _this.props), {}, {
          isLeaf: isLeaf
        }));
      }
      return switcherIcon;
    };
    _this.renderSwitcher = function () {
      var expanded = _this.props.expanded;
      var prefixCls = _this.props.context.prefixCls;
      if (_this.isLeaf()) {
        // if switcherIconDom is null, no render switcher span
        var _switcherIconDom = _this.renderSwitcherIconDom(true);
        return _switcherIconDom !== false ?
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("span", {
          className: classNames$1("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher-noop")),
          children: _switcherIconDom
        }) : null;
      }
      var switcherCls = classNames$1("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher_").concat(expanded ? ICON_OPEN : ICON_CLOSE));
      var switcherIconDom = _this.renderSwitcherIconDom(false);
      return switcherIconDom !== false ?
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        onClick: _this.onExpand,
        className: switcherCls,
        children: switcherIconDom
      }) : null;
    };
    _this.renderCheckbox = function () {
      var _this$props5 = _this.props,
        checked = _this$props5.checked,
        halfChecked = _this$props5.halfChecked,
        disableCheckbox = _this$props5.disableCheckbox;
      var prefixCls = _this.props.context.prefixCls;
      var disabled = _this.isDisabled();
      var checkable = _this.isCheckable();
      if (!checkable) return null;
      // [Legacy] Custom element should be separate with `checkable` in future
      var $custom = typeof checkable !== 'boolean' ? checkable : null;
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("span", {
          className: classNames$1("".concat(prefixCls, "-checkbox"), checked && "".concat(prefixCls, "-checkbox-checked"), !checked && halfChecked && "".concat(prefixCls, "-checkbox-indeterminate"), (disabled || disableCheckbox) && "".concat(prefixCls, "-checkbox-disabled")),
          onClick: _this.onCheck,
          children: $custom
        })
      );
    };
    _this.renderIcon = function () {
      var loading = _this.props.loading;
      var prefixCls = _this.props.context.prefixCls;
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("span", {
          className: classNames$1("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__").concat(_this.getNodeState() || 'docu'), loading && "".concat(prefixCls, "-icon_loading"))
        })
      );
    };
    _this.renderSelector = function () {
      var dragNodeHighlight = _this.state.dragNodeHighlight;
      var _this$props6 = _this.props,
        title = _this$props6.title,
        selected = _this$props6.selected,
        icon = _this$props6.icon,
        loading = _this$props6.loading,
        data = _this$props6.data;
      var _this$props$context3 = _this.props.context,
        prefixCls = _this$props$context3.prefixCls,
        showIcon = _this$props$context3.showIcon,
        treeIcon = _this$props$context3.icon,
        loadData = _this$props$context3.loadData,
        titleRender = _this$props$context3.titleRender;
      var disabled = _this.isDisabled();
      var wrapClass = "".concat(prefixCls, "-node-content-wrapper");
      // Icon - Still show loading icon when loading without showIcon
      var $icon;
      if (showIcon) {
        var currentIcon = icon || treeIcon;
        $icon = currentIcon ?
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("span", {
          className: classNames$1("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__customize")),
          children: typeof currentIcon === 'function' ? currentIcon(_this.props) : currentIcon
        }) : _this.renderIcon();
      } else if (loadData && loading) {
        $icon = _this.renderIcon();
      }
      // Title
      var titleNode;
      if (typeof title === 'function') {
        titleNode = title(data);
      } else if (titleRender) {
        titleNode = titleRender(data);
      } else {
        titleNode = title;
      }
      var $title =
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        className: "".concat(prefixCls, "-title"),
        children: titleNode
      });
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsxs("span", {
          ref: _this.setSelectHandle,
          title: typeof title === 'string' ? title : '',
          className: classNames$1("".concat(wrapClass), "".concat(wrapClass, "-").concat(_this.getNodeState() || 'normal'), !disabled && (selected || dragNodeHighlight) && "".concat(prefixCls, "-node-selected")),
          onMouseEnter: _this.onMouseEnter,
          onMouseLeave: _this.onMouseLeave,
          onContextMenu: _this.onContextMenu,
          onClick: _this.onSelectorClick,
          onDoubleClick: _this.onSelectorDoubleClick,
          children: [$icon, $title, _this.renderDropIndicator()]
        })
      );
    };
    _this.renderDropIndicator = function () {
      var _this$props7 = _this.props,
        disabled = _this$props7.disabled,
        eventKey = _this$props7.eventKey;
      var _this$props$context4 = _this.props.context,
        draggable = _this$props$context4.draggable,
        dropLevelOffset = _this$props$context4.dropLevelOffset,
        dropPosition = _this$props$context4.dropPosition,
        prefixCls = _this$props$context4.prefixCls,
        indent = _this$props$context4.indent,
        dropIndicatorRender = _this$props$context4.dropIndicatorRender,
        dragOverNodeKey = _this$props$context4.dragOverNodeKey,
        direction = _this$props$context4.direction;
      var rootDraggable = !!draggable;
      // allowDrop is calculated in Tree.tsx, there is no need for calc it here
      var showIndicator = !disabled && rootDraggable && dragOverNodeKey === eventKey;
      return showIndicator ? dropIndicatorRender({
        dropPosition: dropPosition,
        dropLevelOffset: dropLevelOffset,
        indent: indent,
        prefixCls: prefixCls,
        direction: direction
      }) : null;
    };
    return _this;
  }
  _createClass(InternalTreeNode, [{
    key: "componentDidMount",
    value:
    // Isomorphic needn't load data in server side
    function componentDidMount() {
      this.syncLoadData(this.props);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.syncLoadData(this.props);
    }
  }, {
    key: "isSelectable",
    value: function isSelectable() {
      var selectable = this.props.selectable;
      var treeSelectable = this.props.context.selectable;
      // Ignore when selectable is undefined or null
      if (typeof selectable === 'boolean') {
        return selectable;
      }
      return treeSelectable;
    }
  }, {
    key: "render",
    value:
    // =========================== Render ===========================
    function render() {
      var _classNames;
      var _this$props8 = this.props,
        eventKey = _this$props8.eventKey,
        className = _this$props8.className,
        style = _this$props8.style,
        dragOver = _this$props8.dragOver,
        dragOverGapTop = _this$props8.dragOverGapTop,
        dragOverGapBottom = _this$props8.dragOverGapBottom,
        isLeaf = _this$props8.isLeaf,
        isStart = _this$props8.isStart,
        isEnd = _this$props8.isEnd,
        expanded = _this$props8.expanded,
        selected = _this$props8.selected,
        checked = _this$props8.checked,
        halfChecked = _this$props8.halfChecked,
        loading = _this$props8.loading,
        domRef = _this$props8.domRef,
        active = _this$props8.active;
        _this$props8.data;
        var onMouseMove = _this$props8.onMouseMove,
        selectable = _this$props8.selectable,
        otherProps = _objectWithoutProperties(_this$props8, _excluded$n);
      var _this$props$context5 = this.props.context,
        prefixCls = _this$props$context5.prefixCls,
        filterTreeNode = _this$props$context5.filterTreeNode,
        keyEntities = _this$props$context5.keyEntities,
        dropContainerKey = _this$props$context5.dropContainerKey,
        dropTargetKey = _this$props$context5.dropTargetKey,
        draggingNodeKey = _this$props$context5.draggingNodeKey;
      var disabled = this.isDisabled();
      var dataOrAriaAttributeProps = pickAttrs(otherProps, {
        aria: true,
        data: true
      });
      var _ref2 = keyEntities[eventKey] || {},
        level = _ref2.level;
      var isEndNode = isEnd[isEnd.length - 1];
      var mergedDraggable = this.isDraggable();
      var draggableWithoutDisabled = !disabled && mergedDraggable;
      var dragging = draggingNodeKey === eventKey;
      var ariaSelected = selectable !== undefined ? {
        'aria-selected': !!selectable
      } : undefined;
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsxs("div", {
          ref: domRef,
          className: classNames$1(className, "".concat(prefixCls, "-treenode"), (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-treenode-disabled"), disabled), _defineProperty$1(_classNames, "".concat(prefixCls, "-treenode-switcher-").concat(expanded ? 'open' : 'close'), !isLeaf), _defineProperty$1(_classNames, "".concat(prefixCls, "-treenode-checkbox-checked"), checked), _defineProperty$1(_classNames, "".concat(prefixCls, "-treenode-checkbox-indeterminate"), halfChecked), _defineProperty$1(_classNames, "".concat(prefixCls, "-treenode-selected"), selected), _defineProperty$1(_classNames, "".concat(prefixCls, "-treenode-loading"), loading), _defineProperty$1(_classNames, "".concat(prefixCls, "-treenode-active"), active), _defineProperty$1(_classNames, "".concat(prefixCls, "-treenode-leaf-last"), isEndNode), _defineProperty$1(_classNames, "".concat(prefixCls, "-treenode-draggable"), mergedDraggable), _defineProperty$1(_classNames, "dragging", dragging), _defineProperty$1(_classNames, 'drop-target', dropTargetKey === eventKey), _defineProperty$1(_classNames, 'drop-container', dropContainerKey === eventKey), _defineProperty$1(_classNames, 'drag-over', !disabled && dragOver), _defineProperty$1(_classNames, 'drag-over-gap-top', !disabled && dragOverGapTop), _defineProperty$1(_classNames, 'drag-over-gap-bottom', !disabled && dragOverGapBottom), _defineProperty$1(_classNames, 'filter-node', filterTreeNode && filterTreeNode(convertNodePropsToEventData(this.props))), _classNames)),
          style: style,
          draggable: draggableWithoutDisabled,
          "aria-grabbed": dragging,
          onDragStart: draggableWithoutDisabled ? this.onDragStart : undefined,
          onDragEnter: mergedDraggable ? this.onDragEnter : undefined,
          onDragOver: mergedDraggable ? this.onDragOver : undefined,
          onDragLeave: mergedDraggable ? this.onDragLeave : undefined,
          onDrop: mergedDraggable ? this.onDrop : undefined,
          onDragEnd: mergedDraggable ? this.onDragEnd : undefined,
          onMouseMove: onMouseMove,
          ...ariaSelected,
          ...dataOrAriaAttributeProps,
          children: [/*#__PURE__*/jsx$1(Indent$1, {
            prefixCls: prefixCls,
            level: level,
            isStart: isStart,
            isEnd: isEnd
          }), this.renderDragHandler(), this.renderSwitcher(), this.renderCheckbox(), this.renderSelector()]
        })
      );
    }
  }]);
  return InternalTreeNode;
}(react.exports.Component);
var ContextTreeNode = function ContextTreeNode(props) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(TreeContext.Consumer, {
      children: function (context) {
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(InternalTreeNode, {
            ...props,
            context: context
          })
        );
      }
    })
  );
};
ContextTreeNode.displayName = 'TreeNode';
ContextTreeNode.defaultProps = {
  title: defaultTitle
};
ContextTreeNode.isTreeNode = 1;

function arrDel(list, value) {
  if (!list) return [];
  var clone = list.slice();
  var index = clone.indexOf(value);
  if (index >= 0) {
    clone.splice(index, 1);
  }
  return clone;
}
function arrAdd(list, value) {
  var clone = (list || []).slice();
  if (clone.indexOf(value) === -1) {
    clone.push(value);
  }
  return clone;
}
function posToArr(pos) {
  return pos.split('-');
}
function getPosition(level, index) {
  return "".concat(level, "-").concat(index);
}
function isTreeNode(node) {
  return node && node.type && node.type.isTreeNode;
}
function getDragChildrenKeys(dragNodeKey, keyEntities) {
  // not contains self
  // self for left or right drag
  var dragChildrenKeys = [];
  var entity = keyEntities[dragNodeKey];
  function dig() {
    var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    list.forEach(function (_ref) {
      var key = _ref.key,
        children = _ref.children;
      dragChildrenKeys.push(key);
      dig(children);
    });
  }
  dig(entity.children);
  return dragChildrenKeys;
}
function isLastChild(treeNodeEntity) {
  if (treeNodeEntity.parent) {
    var posArr = posToArr(treeNodeEntity.pos);
    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
  }
  return false;
}
function isFirstChild(treeNodeEntity) {
  var posArr = posToArr(treeNodeEntity.pos);
  return Number(posArr[posArr.length - 1]) === 0;
}
// Only used when drag, not affect SSR.
function calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop, flattenedNodes, keyEntities, expandKeys, direction) {
  var _abstractDropNodeEnti;
  var clientX = event.clientX,
    clientY = event.clientY;
  var _event$target$getBoun = event.target.getBoundingClientRect(),
    top = _event$target$getBoun.top,
    height = _event$target$getBoun.height;
  // optional chain for testing
  var horizontalMouseOffset = (direction === 'rtl' ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);
  var rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;
  // find abstract drop node by horizontal offset
  var abstractDropNodeEntity = keyEntities[targetNode.props.eventKey];
  if (clientY < top + height / 2) {
    // first half, set abstract drop node to previous node
    var nodeIndex = flattenedNodes.findIndex(function (flattenedNode) {
      return flattenedNode.key === abstractDropNodeEntity.key;
    });
    var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;
    var prevNodeKey = flattenedNodes[prevNodeIndex].key;
    abstractDropNodeEntity = keyEntities[prevNodeKey];
  }
  var initialAbstractDropNodeKey = abstractDropNodeEntity.key;
  var abstractDragOverEntity = abstractDropNodeEntity;
  var dragOverNodeKey = abstractDropNodeEntity.key;
  var dropPosition = 0;
  var dropLevelOffset = 0;
  // Only allow cross level drop when dragging on a non-expanded node
  if (!expandKeys.includes(initialAbstractDropNodeKey)) {
    for (var i = 0; i < rawDropLevelOffset; i += 1) {
      if (isLastChild(abstractDropNodeEntity)) {
        abstractDropNodeEntity = abstractDropNodeEntity.parent;
        dropLevelOffset += 1;
      } else {
        break;
      }
    }
  }
  var abstractDragDataNode = dragNode.props.data;
  var abstractDropDataNode = abstractDropNodeEntity.node;
  var dropAllowed = true;
  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop({
    dragNode: abstractDragDataNode,
    dropNode: abstractDropDataNode,
    dropPosition: -1
  }) && abstractDropNodeEntity.key === targetNode.props.eventKey) {
    // first half of first node in first level
    dropPosition = -1;
  } else if ((abstractDragOverEntity.children || []).length && expandKeys.includes(dragOverNodeKey)) {
    // drop on expanded node
    // only allow drop inside
    if (allowDrop({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 0
    })) {
      dropPosition = 0;
    } else {
      dropAllowed = false;
    }
  } else if (dropLevelOffset === 0) {
    if (rawDropLevelOffset > -1.5) {
      // | Node     | <- abstractDropNode
      // | -^-===== | <- mousePosition
      // 1. try drop after
      // 2. do not allow drop
      if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    } else {
      // | Node     | <- abstractDropNode
      // | ---==^== | <- mousePosition
      // whether it has children or doesn't has children
      // always
      // 1. try drop inside
      // 2. try drop after
      // 3. do not allow drop
      if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 0
      })) {
        dropPosition = 0;
      } else if (allowDrop({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    }
  } else {
    // | Node1 | <- abstractDropNode
    //      |  Node2  |
    // --^--|----=====| <- mousePosition
    // 1. try insert after Node1
    // 2. do not allow drop
    if (allowDrop({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 1
    })) {
      dropPosition = 1;
    } else {
      dropAllowed = false;
    }
  }
  return {
    dropPosition: dropPosition,
    dropLevelOffset: dropLevelOffset,
    dropTargetKey: abstractDropNodeEntity.key,
    dropTargetPos: abstractDropNodeEntity.pos,
    dragOverNodeKey: dragOverNodeKey,
    dropContainerKey: dropPosition === 0 ? null : ((_abstractDropNodeEnti = abstractDropNodeEntity.parent) === null || _abstractDropNodeEnti === void 0 ? void 0 : _abstractDropNodeEnti.key) || null,
    dropAllowed: dropAllowed
  };
}
/**
 * Return selectedKeys according with multiple prop
 * @param selectedKeys
 * @param props
 * @returns [string]
 */
function calcSelectedKeys(selectedKeys, props) {
  if (!selectedKeys) return undefined;
  var multiple = props.multiple;
  if (multiple) {
    return selectedKeys.slice();
  }
  if (selectedKeys.length) {
    return [selectedKeys[0]];
  }
  return selectedKeys;
}
/**
 * Parse `checkedKeys` to { checkedKeys, halfCheckedKeys } style
 */
function parseCheckedKeys(keys) {
  if (!keys) {
    return null;
  }
  // Convert keys to object format
  var keyProps;
  if (Array.isArray(keys)) {
    // [Legacy] Follow the api doc
    keyProps = {
      checkedKeys: keys,
      halfCheckedKeys: undefined
    };
  } else if (_typeof$1(keys) === 'object') {
    keyProps = {
      checkedKeys: keys.checked || undefined,
      halfCheckedKeys: keys.halfChecked || undefined
    };
  } else {
    warningOnce(false, '`checkedKeys` is not an array or an object');
    return null;
  }
  return keyProps;
}
/**
 * If user use `autoExpandParent` we should get the list of parent node
 * @param keyList
 * @param keyEntities
 */
function conductExpandParent(keyList, keyEntities) {
  var expandedKeys = new Set();
  function conductUp(key) {
    if (expandedKeys.has(key)) return;
    var entity = keyEntities[key];
    if (!entity) return;
    expandedKeys.add(key);
    var parent = entity.parent,
      node = entity.node;
    if (node.disabled) return;
    if (parent) {
      conductUp(parent.key);
    }
  }
  (keyList || []).forEach(function (key) {
    conductUp(key);
  });
  return _toConsumableArray(expandedKeys);
}

var _excluded$m = ["children"];
function getKey(key, pos) {
  if (key !== null && key !== undefined) {
    return key;
  }
  return pos;
}
function fillFieldNames(fieldNames) {
  var _ref = fieldNames || {},
    title = _ref.title,
    _title = _ref._title,
    key = _ref.key,
    children = _ref.children;
  var mergedTitle = title || 'title';
  return {
    title: mergedTitle,
    _title: _title || [mergedTitle],
    key: key || 'key',
    children: children || 'children'
  };
}
/**
 * Convert `children` of Tree into `treeData` structure.
 */
function convertTreeToData(rootNodes) {
  function dig(node) {
    var treeNodes = toArray$6(node);
    return treeNodes.map(function (treeNode) {
      // Filter invalidate node
      if (!isTreeNode(treeNode)) {
        warningOnce(!treeNode, 'Tree/TreeNode can only accept TreeNode as children.');
        return null;
      }
      var key = treeNode.key;
      var _treeNode$props = treeNode.props,
        children = _treeNode$props.children,
        rest = _objectWithoutProperties(_treeNode$props, _excluded$m);
      var dataNode = _objectSpread2$1({
        key: key
      }, rest);
      var parsedChildren = dig(children);
      if (parsedChildren.length) {
        dataNode.children = parsedChildren;
      }
      return dataNode;
    }).filter(function (dataNode) {
      return dataNode;
    });
  }
  return dig(rootNodes);
}
/**
 * Flat nest tree data into flatten list. This is used for virtual list render.
 * @param treeNodeList Origin data node list
 * @param expandedKeys
 * need expanded keys, provides `true` means all expanded (used in `rc-tree-select`).
 */
function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
  var _fillFieldNames = fillFieldNames(fieldNames),
    fieldTitles = _fillFieldNames._title,
    fieldKey = _fillFieldNames.key,
    fieldChildren = _fillFieldNames.children;
  var expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
  var flattenList = [];
  function dig(list) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return list.map(function (treeNode, index) {
      var pos = getPosition(parent ? parent.pos : '0', index);
      var mergedKey = getKey(treeNode[fieldKey], pos);
      // Pick matched title in field title list
      var mergedTitle;
      for (var i = 0; i < fieldTitles.length; i += 1) {
        var fieldTitle = fieldTitles[i];
        if (treeNode[fieldTitle] !== undefined) {
          mergedTitle = treeNode[fieldTitle];
          break;
        }
      }
      // Add FlattenDataNode into list
      var flattenNode = _objectSpread2$1(_objectSpread2$1({}, omit(treeNode, [].concat(_toConsumableArray(fieldTitles), [fieldKey, fieldChildren]))), {}, {
        title: mergedTitle,
        key: mergedKey,
        parent: parent,
        pos: pos,
        children: null,
        data: treeNode,
        isStart: [].concat(_toConsumableArray(parent ? parent.isStart : []), [index === 0]),
        isEnd: [].concat(_toConsumableArray(parent ? parent.isEnd : []), [index === list.length - 1])
      });
      flattenList.push(flattenNode);
      // Loop treeNode children
      if (expandedKeys === true || expandedKeySet.has(mergedKey)) {
        flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
      } else {
        flattenNode.children = [];
      }
      return flattenNode;
    });
  }
  dig(treeNodeList);
  return flattenList;
}
/**
 * Traverse all the data by `treeData`.
 * Please not use it out of the `rc-tree` since we may refactor this code.
 */
function traverseDataNodes(dataNodes, callback,
// To avoid too many params, let use config instead of origin param
config) {
  var mergedConfig = {};
  if (_typeof$1(config) === 'object') {
    mergedConfig = config;
  } else {
    mergedConfig = {
      externalGetKey: config
    };
  }
  mergedConfig = mergedConfig || {};
  // Init config
  var _mergedConfig = mergedConfig,
    childrenPropName = _mergedConfig.childrenPropName,
    externalGetKey = _mergedConfig.externalGetKey,
    fieldNames = _mergedConfig.fieldNames;
  var _fillFieldNames2 = fillFieldNames(fieldNames),
    fieldKey = _fillFieldNames2.key,
    fieldChildren = _fillFieldNames2.children;
  var mergeChildrenPropName = childrenPropName || fieldChildren;
  // Get keys
  var syntheticGetKey;
  if (externalGetKey) {
    if (typeof externalGetKey === 'string') {
      syntheticGetKey = function syntheticGetKey(node) {
        return node[externalGetKey];
      };
    } else if (typeof externalGetKey === 'function') {
      syntheticGetKey = function syntheticGetKey(node) {
        return externalGetKey(node);
      };
    }
  } else {
    syntheticGetKey = function syntheticGetKey(node, pos) {
      return getKey(node[fieldKey], pos);
    };
  }
  // Process
  function processNode(node, index, parent, pathNodes) {
    var children = node ? node[mergeChildrenPropName] : dataNodes;
    var pos = node ? getPosition(parent.pos, index) : '0';
    var connectNodes = node ? [].concat(_toConsumableArray(pathNodes), [node]) : [];
    // Process node if is not root
    if (node) {
      var key = syntheticGetKey(node, pos);
      var data = {
        node: node,
        index: index,
        pos: pos,
        key: key,
        parentPos: parent.node ? parent.pos : null,
        level: parent.level + 1,
        nodes: connectNodes
      };
      callback(data);
    }
    // Process children node
    if (children) {
      children.forEach(function (subNode, subIndex) {
        processNode(subNode, subIndex, {
          node: node,
          pos: pos,
          level: parent ? parent.level + 1 : -1
        }, connectNodes);
      });
    }
  }
  processNode(null);
}
/**
 * Convert `treeData` into entity records.
 */
function convertDataToEntities(dataNodes) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    initWrapper = _ref2.initWrapper,
    processEntity = _ref2.processEntity,
    onProcessFinished = _ref2.onProcessFinished,
    externalGetKey = _ref2.externalGetKey,
    childrenPropName = _ref2.childrenPropName,
    fieldNames = _ref2.fieldNames;
  var /** @deprecated Use `config.externalGetKey` instead */
  legacyExternalGetKey = arguments.length > 2 ? arguments[2] : undefined;
  // Init config
  var mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
  var posEntities = {};
  var keyEntities = {};
  var wrapper = {
    posEntities: posEntities,
    keyEntities: keyEntities
  };
  if (initWrapper) {
    wrapper = initWrapper(wrapper) || wrapper;
  }
  traverseDataNodes(dataNodes, function (item) {
    var node = item.node,
      index = item.index,
      pos = item.pos,
      key = item.key,
      parentPos = item.parentPos,
      level = item.level,
      nodes = item.nodes;
    var entity = {
      node: node,
      nodes: nodes,
      index: index,
      key: key,
      pos: pos,
      level: level
    };
    var mergedKey = getKey(key, pos);
    posEntities[pos] = entity;
    keyEntities[mergedKey] = entity;
    // Fill children
    entity.parent = posEntities[parentPos];
    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }
    if (processEntity) {
      processEntity(entity, wrapper);
    }
  }, {
    externalGetKey: mergedExternalGetKey,
    childrenPropName: childrenPropName,
    fieldNames: fieldNames
  });
  if (onProcessFinished) {
    onProcessFinished(wrapper);
  }
  return wrapper;
}
/**
 * Get TreeNode props with Tree props.
 */
function getTreeNodeProps(key, _ref3) {
  var expandedKeys = _ref3.expandedKeys,
    selectedKeys = _ref3.selectedKeys,
    loadedKeys = _ref3.loadedKeys,
    loadingKeys = _ref3.loadingKeys,
    checkedKeys = _ref3.checkedKeys,
    halfCheckedKeys = _ref3.halfCheckedKeys,
    dragOverNodeKey = _ref3.dragOverNodeKey,
    dropPosition = _ref3.dropPosition,
    keyEntities = _ref3.keyEntities;
  var entity = keyEntities[key];
  var treeNodeProps = {
    eventKey: key,
    expanded: expandedKeys.indexOf(key) !== -1,
    selected: selectedKeys.indexOf(key) !== -1,
    loaded: loadedKeys.indexOf(key) !== -1,
    loading: loadingKeys.indexOf(key) !== -1,
    checked: checkedKeys.indexOf(key) !== -1,
    halfChecked: halfCheckedKeys.indexOf(key) !== -1,
    pos: String(entity ? entity.pos : ''),
    // [Legacy] Drag props
    // Since the interaction of drag is changed, the semantic of the props are
    // not accuracy, I think it should be finally removed
    dragOver: dragOverNodeKey === key && dropPosition === 0,
    dragOverGapTop: dragOverNodeKey === key && dropPosition === -1,
    dragOverGapBottom: dragOverNodeKey === key && dropPosition === 1
  };
  return treeNodeProps;
}
function convertNodePropsToEventData(props) {
  var data = props.data,
    expanded = props.expanded,
    selected = props.selected,
    checked = props.checked,
    loaded = props.loaded,
    loading = props.loading,
    halfChecked = props.halfChecked,
    dragOver = props.dragOver,
    dragOverGapTop = props.dragOverGapTop,
    dragOverGapBottom = props.dragOverGapBottom,
    pos = props.pos,
    active = props.active,
    eventKey = props.eventKey;
  var eventData = _objectSpread2$1(_objectSpread2$1({}, data), {}, {
    expanded: expanded,
    selected: selected,
    checked: checked,
    loaded: loaded,
    loading: loading,
    halfChecked: halfChecked,
    dragOver: dragOver,
    dragOverGapTop: dragOverGapTop,
    dragOverGapBottom: dragOverGapBottom,
    pos: pos,
    active: active,
    key: eventKey
  });
  if (!('props' in eventData)) {
    Object.defineProperty(eventData, 'props', {
      get: function get() {
        warningOnce(false, 'Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`.');
        return props;
      }
    });
  }
  return eventData;
}

// ============================== Motion ==============================
var antCheckboxEffect = new Keyframe('antCheckboxEffect', {
  '0%': {
    transform: 'scale(1)',
    opacity: 0.5
  },
  '100%': {
    transform: 'scale(1.6)',
    opacity: 0
  }
});
// ============================== Styles ==============================
var genCheckboxStyle = function genCheckboxStyle(token) {
  var _extends2, _ref2, _ref5, _ref6, _ref7, _ref8, _ref9, _ref10, _ref11;
  var checkboxCls = token.checkboxCls;
  var wrapperCls = checkboxCls + "-wrapper";
  return [(_ref2 = {}, _defineProperty$1(_ref2, checkboxCls + "-group", _extends$2(_extends$2({}, resetComponent(token)), {
    display: 'inline-flex'
  })), _defineProperty$1(_ref2, wrapperCls, _extends$2(_extends$2({}, resetComponent(token)), {
    display: 'inline-flex',
    alignItems: 'baseline',
    lineHeight: 'unset',
    cursor: 'pointer',
    // Fix checkbox & radio in flex align #30260
    '&:after': {
      display: 'inline-block',
      width: 0,
      overflow: 'hidden',
      content: "'\\a0'"
    },
    // Checkbox near checkbox
    '& + &': {
      marginInlineStart: token.marginXS
    },
    '&&-in-form-item': {
      'input[type="checkbox"]': {
        width: 14,
        height: 14 // FIXME: magic
      }
    }
  })), _defineProperty$1(_ref2, checkboxCls, _extends$2(_extends$2({}, resetComponent(token)), (_extends2 = {
    top: '0.2em',
    position: 'relative',
    whiteSpace: 'nowrap',
    lineHeight: 1,
    cursor: 'pointer'
  }, _defineProperty$1(_extends2, checkboxCls + "-input", _defineProperty$1({
    position: 'absolute',
    inset: 0,
    zIndex: 1,
    width: '100%',
    height: '100%',
    cursor: 'pointer',
    opacity: 0
  }, "&:focus-visible + " + checkboxCls + "-inner", _extends$2({}, genFocusOutline(token)))), _defineProperty$1(_extends2, checkboxCls + "-inner", {
    boxSizing: 'border-box',
    position: 'relative',
    top: 0,
    insetInlineStart: 0,
    display: 'block',
    width: token.checkboxSize,
    height: token.checkboxSize,
    direction: 'ltr',
    backgroundColor: token.colorBgContainer,
    border: token.lineWidth + "px " + token.lineType + " " + token.colorBorder,
    borderRadius: token.borderRadiusSM,
    borderCollapse: 'separate',
    transition: "all " + token.motionDurationSlow,
    '&:after': {
      boxSizing: 'border-box',
      position: 'absolute',
      top: '50%',
      insetInlineStart: '21.5%',
      display: 'table',
      width: token.checkboxSize / 14 * 5,
      height: token.checkboxSize / 14 * 8,
      border: token.lineWidthBold + "px solid " + token.colorWhite,
      borderTop: 0,
      borderInlineStart: 0,
      transform: 'rotate(45deg) scale(0) translate(-50%,-50%)',
      opacity: 0,
      content: '""',
      transition: "all " + token.motionDurationFast + " " + token.motionEaseInBack + ", opacity " + token.motionDurationFast
    }
  }), _defineProperty$1(_extends2, '& + span', {
    paddingInlineStart: token.paddingXS,
    paddingInlineEnd: token.paddingXS
  }), _extends2))), _ref2), // ================= Indeterminate =================
  _defineProperty$1({}, checkboxCls, {
    '&-indeterminate': _defineProperty$1({}, checkboxCls + "-inner", {
      '&:after': {
        top: '50%',
        insetInlineStart: '50%',
        width: token.fontSizeLG / 2,
        height: token.fontSizeLG / 2,
        backgroundColor: token.colorPrimary,
        border: 0,
        transform: 'translate(-50%, -50%) scale(1)',
        opacity: 1,
        content: '""'
      }
    })
  }), (_ref6 = {}, _defineProperty$1(_ref6, wrapperCls + ":hover " + checkboxCls + ":after", {
    visibility: 'visible'
  }), _defineProperty$1(_ref6, "\n        " + wrapperCls + ":not(" + wrapperCls + "-disabled),\n        " + checkboxCls + ":not(" + checkboxCls + "-disabled)\n      ", _defineProperty$1({}, "&:hover " + checkboxCls + "-inner", {
    borderColor: token.colorPrimary
  })), _defineProperty$1(_ref6, wrapperCls + ":not(" + wrapperCls + "-disabled)", (_ref5 = {}, _defineProperty$1(_ref5, "&:hover " + checkboxCls + "-checked:not(" + checkboxCls + "-disabled) " + checkboxCls + "-inner", {
    backgroundColor: token.colorPrimaryHover,
    borderColor: 'transparent'
  }), _defineProperty$1(_ref5, "&:hover " + checkboxCls + "-checked:not(" + checkboxCls + "-disabled):after", {
    borderColor: token.colorPrimaryHover
  }), _ref5)), _ref6), (_ref9 = {}, _defineProperty$1(_ref9, checkboxCls + "-checked", (_ref7 = {}, _defineProperty$1(_ref7, checkboxCls + "-inner", {
    backgroundColor: token.colorPrimary,
    borderColor: token.colorPrimary,
    '&:after': {
      opacity: 1,
      transform: 'rotate(45deg) scale(1) translate(-50%,-50%)',
      transition: "all " + token.motionDurationMid + " " + token.motionEaseOutBack + " " + token.motionDurationFast
    }
  }), _defineProperty$1(_ref7, '&:after', {
    position: 'absolute',
    top: 0,
    insetInlineStart: 0,
    width: '100%',
    height: '100%',
    borderRadius: token.borderRadiusSM,
    visibility: 'hidden',
    border: token.lineWidthBold + "px solid " + token.colorPrimary,
    animationName: antCheckboxEffect,
    animationDuration: token.motionDurationSlow,
    animationTimingFunction: 'ease-in-out',
    animationFillMode: 'backwards',
    content: '""',
    transition: "all " + token.motionDurationSlow
  }), _ref7)), _defineProperty$1(_ref9, "\n        " + wrapperCls + "-checked:not(" + wrapperCls + "-disabled),\n        " + checkboxCls + "-checked:not(" + checkboxCls + "-disabled)\n      ", (_ref8 = {}, _defineProperty$1(_ref8, "&:hover " + checkboxCls + "-inner", {
    backgroundColor: token.colorPrimaryHover,
    borderColor: 'transparent'
  }), _defineProperty$1(_ref8, "&:hover " + checkboxCls + ":after", {
    borderColor: token.colorPrimaryHover
  }), _ref8)), _ref9), (_ref11 = {}, _defineProperty$1(_ref11, wrapperCls + "-disabled", {
    cursor: 'not-allowed'
  }), _defineProperty$1(_ref11, checkboxCls + "-disabled", (_ref10 = {}, _defineProperty$1(_ref10, "&, " + checkboxCls + "-input", {
    cursor: 'not-allowed'
  }), _defineProperty$1(_ref10, checkboxCls + "-inner", {
    background: token.colorBgContainerDisabled,
    borderColor: token.colorBorder,
    '&:after': {
      borderColor: token.colorTextDisabled
    }
  }), _defineProperty$1(_ref10, '&:after', {
    display: 'none'
  }), _defineProperty$1(_ref10, '& + span', {
    color: token.colorTextDisabled
  }), _ref10)), _ref11)];
};
// ============================== Export ==============================
function getStyle(prefixCls, token) {
  var checkboxToken = merge$2(token, {
    checkboxCls: "." + prefixCls,
    checkboxSize: token.controlInteractiveSize
  });
  return [genCheckboxStyle(checkboxToken)];
}
const useStyle$b = genComponentStyleHook('Checkbox', function (token, _ref12) {
  var prefixCls = _ref12.prefixCls;
  return [getStyle(prefixCls, token)];
});

var __rest$v = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var GroupContext = /*#__PURE__*/react.exports.createContext(null);
var InternalCheckboxGroup = function InternalCheckboxGroup(_a, ref) {
  var defaultValue = _a.defaultValue,
    children = _a.children,
    _a$options = _a.options,
    options = _a$options === void 0 ? [] : _a$options,
    customizePrefixCls = _a.prefixCls,
    className = _a.className,
    style = _a.style,
    onChange = _a.onChange,
    restProps = __rest$v(_a, ["defaultValue", "children", "options", "prefixCls", "className", "style", "onChange"]);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var _React$useState = react.exports.useState(restProps.value || defaultValue || []),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    value = _React$useState2[0],
    setValue = _React$useState2[1];
  var _React$useState3 = react.exports.useState([]),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    registeredValues = _React$useState4[0],
    setRegisteredValues = _React$useState4[1];
  react.exports.useEffect(function () {
    if ('value' in restProps) {
      setValue(restProps.value || []);
    }
  }, [restProps.value]);
  var getOptions = function getOptions() {
    return options.map(function (option) {
      if (typeof option === 'string' || typeof option === 'number') {
        return {
          label: option,
          value: option
        };
      }
      return option;
    });
  };
  var cancelValue = function cancelValue(val) {
    setRegisteredValues(function (prevValues) {
      return prevValues.filter(function (v) {
        return v !== val;
      });
    });
  };
  var registerValue = function registerValue(val) {
    setRegisteredValues(function (prevValues) {
      return [].concat(_toConsumableArray(prevValues), [val]);
    });
  };
  var toggleOption = function toggleOption(option) {
    var optionIndex = value.indexOf(option.value);
    var newValue = _toConsumableArray(value);
    if (optionIndex === -1) {
      newValue.push(option.value);
    } else {
      newValue.splice(optionIndex, 1);
    }
    if (!('value' in restProps)) {
      setValue(newValue);
    }
    var opts = getOptions();
    onChange === null || onChange === void 0 ? void 0 : onChange(newValue.filter(function (val) {
      return registeredValues.includes(val);
    }).sort(function (a, b) {
      var indexA = opts.findIndex(function (opt) {
        return opt.value === a;
      });
      var indexB = opts.findIndex(function (opt) {
        return opt.value === b;
      });
      return indexA - indexB;
    }));
  };
  var prefixCls = getPrefixCls('checkbox', customizePrefixCls);
  var groupPrefixCls = prefixCls + "-group";
  var _useStyle = useStyle$b(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var domProps = omit$1(restProps, ['value', 'disabled']);
  if (options && options.length > 0) {
    children = getOptions().map(function (option) {
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(InternalCheckbox$1, {
          prefixCls: prefixCls,
          disabled: 'disabled' in option ? option.disabled : restProps.disabled,
          value: option.value,
          checked: value.includes(option.value),
          onChange: option.onChange,
          className: groupPrefixCls + "-item",
          style: option.style,
          children: option.label
        }, option.value.toString())
      );
    });
  }
  // eslint-disable-next-line react/jsx-no-constructed-context-values
  var context = {
    toggleOption: toggleOption,
    value: value,
    disabled: restProps.disabled,
    name: restProps.name,
    // https://github.com/ant-design/ant-design/issues/16376
    registerValue: registerValue,
    cancelValue: cancelValue
  };
  var classString = classNames$1(groupPrefixCls, _defineProperty$1({}, groupPrefixCls + "-rtl", direction === 'rtl'), className, hashId);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    className: classString,
    style: style,
    ...domProps,
    ref: ref,
    children: /*#__PURE__*/jsx$1(GroupContext.Provider, {
      value: context,
      children: children
    })
  }));
};
var CheckboxGroup = /*#__PURE__*/react.exports.forwardRef(InternalCheckboxGroup);
const Group$3 = /*#__PURE__*/react.exports.memo(CheckboxGroup);

var __rest$u = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var InternalCheckbox = function InternalCheckbox(_a, ref) {
  var _classNames;
  var _b;
  var customizePrefixCls = _a.prefixCls,
    className = _a.className,
    children = _a.children,
    _a$indeterminate = _a.indeterminate,
    indeterminate = _a$indeterminate === void 0 ? false : _a$indeterminate,
    style = _a.style,
    onMouseEnter = _a.onMouseEnter,
    onMouseLeave = _a.onMouseLeave,
    _a$skipGroup = _a.skipGroup,
    skipGroup = _a$skipGroup === void 0 ? false : _a$skipGroup,
    disabled = _a.disabled,
    restProps = __rest$u(_a, ["prefixCls", "className", "children", "indeterminate", "style", "onMouseEnter", "onMouseLeave", "skipGroup", "disabled"]);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var checkboxGroup = react.exports.useContext(GroupContext);
  var _React$useContext2 = react.exports.useContext(FormItemInputContext),
    isFormItemInput = _React$useContext2.isFormItemInput;
  var contextDisabled = react.exports.useContext(DisabledContext);
  var mergedDisabled = (_b = (checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.disabled) || disabled) !== null && _b !== void 0 ? _b : contextDisabled;
  var prevValue = react.exports.useRef(restProps.value);
  react.exports.useEffect(function () {
    checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.registerValue(restProps.value);
  }, []);
  react.exports.useEffect(function () {
    if (skipGroup) {
      return;
    }
    if (restProps.value !== prevValue.current) {
      checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.cancelValue(prevValue.current);
      checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.registerValue(restProps.value);
      prevValue.current = restProps.value;
    }
    return function () {
      return checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.cancelValue(restProps.value);
    };
  }, [restProps.value]);
  var prefixCls = getPrefixCls('checkbox', customizePrefixCls);
  var _useStyle = useStyle$b(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var checkboxProps = _extends$2({}, restProps);
  if (checkboxGroup && !skipGroup) {
    checkboxProps.onChange = function () {
      if (restProps.onChange) {
        restProps.onChange.apply(restProps, arguments);
      }
      if (checkboxGroup.toggleOption) {
        checkboxGroup.toggleOption({
          label: children,
          value: restProps.value
        });
      }
    };
    checkboxProps.name = checkboxGroup.name;
    checkboxProps.checked = checkboxGroup.value.includes(restProps.value);
  }
  var classString = classNames$1((_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-wrapper", true), _defineProperty$1(_classNames, prefixCls + "-rtl", direction === 'rtl'), _defineProperty$1(_classNames, prefixCls + "-wrapper-checked", checkboxProps.checked), _defineProperty$1(_classNames, prefixCls + "-wrapper-disabled", mergedDisabled), _defineProperty$1(_classNames, prefixCls + "-wrapper-in-form-item", isFormItemInput), _classNames), className, hashId);
  var checkboxClass = classNames$1(_defineProperty$1({}, prefixCls + "-indeterminate", indeterminate), hashId);
  var ariaChecked = indeterminate ? 'mixed' : undefined;
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  // eslint-disable-next-line jsx-a11y/label-has-associated-control
  jsxs("label", {
    className: classString,
    style: style,
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    children: [/*#__PURE__*/jsx$1(Checkbox$3, {
      "aria-checked": ariaChecked,
      ...checkboxProps,
      prefixCls: prefixCls,
      className: checkboxClass,
      disabled: mergedDisabled,
      ref: ref
    }), children !== undefined &&
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      children: children
    })]
  }));
};
var Checkbox$2 = /*#__PURE__*/react.exports.forwardRef(InternalCheckbox);
const InternalCheckbox$1 = Checkbox$2;

var Checkbox = InternalCheckbox$1;
Checkbox.Group = Group$3;
Checkbox.__ANT_CHECKBOX = true;
const Checkbox$1 = Checkbox;

var RowContext = /*#__PURE__*/react.exports.createContext({});
const RowContext$1 = RowContext;

// ============================== Row-Shared ==============================
var genGridRowStyle = function genGridRowStyle(token) {
  var componentCls = token.componentCls;
  return _defineProperty$1({}, componentCls, {
    display: 'flex',
    flexFlow: 'row wrap',
    minWidth: 0,
    '&::before, &::after': {
      display: 'flex'
    },
    '&-no-wrap': {
      flexWrap: 'nowrap'
    },
    // The origin of the X-axis
    '&-start': {
      justifyContent: 'flex-start'
    },
    // The center of the X-axis
    '&-center': {
      justifyContent: 'center'
    },
    // The opposite of the X-axis
    '&-end': {
      justifyContent: 'flex-end'
    },
    '&-space-between': {
      justifyContent: 'space-between'
    },
    '&-space-around ': {
      justifyContent: 'space-around'
    },
    // Align at the top
    '&-top': {
      alignItems: 'flex-start'
    },
    // Align at the center
    '&-middle': {
      alignItems: 'center'
    },
    '&-bottom': {
      alignItems: 'flex-end'
    }
  });
};
// ============================== Col-Shared ==============================
var genGridColStyle = function genGridColStyle(token) {
  var componentCls = token.componentCls;
  return _defineProperty$1({}, componentCls, {
    position: 'relative',
    maxWidth: '100%',
    // Prevent columns from collapsing when empty
    minHeight: 1
  });
};
var genLoopGridColumnsStyle = function genLoopGridColumnsStyle(token, sizeCls) {
  var componentCls = token.componentCls,
    gridColumns = token.gridColumns;
  var gridColumnsStyle = {};
  for (var i = gridColumns; i >= 0; i--) {
    if (i === 0) {
      gridColumnsStyle["" + componentCls + sizeCls + "-" + i] = {
        display: 'none'
      };
      gridColumnsStyle[componentCls + "-push-" + i] = {
        insetInlineStart: 'auto'
      };
      gridColumnsStyle[componentCls + "-pull-" + i] = {
        insetInlineEnd: 'auto'
      };
      gridColumnsStyle["" + componentCls + sizeCls + "-push-" + i] = {
        insetInlineStart: 'auto'
      };
      gridColumnsStyle["" + componentCls + sizeCls + "-pull-" + i] = {
        insetInlineEnd: 'auto'
      };
      gridColumnsStyle["" + componentCls + sizeCls + "-offset-" + i] = {
        marginInlineEnd: 0
      };
      gridColumnsStyle["" + componentCls + sizeCls + "-order-" + i] = {
        order: 0
      };
    } else {
      gridColumnsStyle["" + componentCls + sizeCls + "-" + i] = {
        display: 'block',
        flex: "0 0 " + i / gridColumns * 100 + "%",
        maxWidth: i / gridColumns * 100 + "%"
      };
      gridColumnsStyle["" + componentCls + sizeCls + "-push-" + i] = {
        insetInlineStart: i / gridColumns * 100 + "%"
      };
      gridColumnsStyle["" + componentCls + sizeCls + "-pull-" + i] = {
        insetInlineEnd: i / gridColumns * 100 + "%"
      };
      gridColumnsStyle["" + componentCls + sizeCls + "-offset-" + i] = {
        marginInlineStart: i / gridColumns * 100 + "%"
      };
      gridColumnsStyle["" + componentCls + sizeCls + "-order-" + i] = {
        order: i
      };
    }
  }
  return gridColumnsStyle;
};
var genGridStyle = function genGridStyle(token, sizeCls) {
  return genLoopGridColumnsStyle(token, sizeCls);
};
var genGridMediaStyle = function genGridMediaStyle(token, screenSize, sizeCls) {
  return _defineProperty$1({}, "@media (min-width: " + screenSize + "px)", _extends$2({}, genGridStyle(token, sizeCls)));
};
// ============================== Export ==============================
var useRowStyle = genComponentStyleHook('Grid', function (token) {
  return [genGridRowStyle(token)];
});
var useColStyle = genComponentStyleHook('Grid', function (token) {
  var gridToken = merge$2(token, {
    gridColumns: 24 // Row is divided into 24 parts in Grid
  });

  var gridMediaSizesMap = {
    '-sm': gridToken.screenSMMin,
    '-md': gridToken.screenMDMin,
    '-lg': gridToken.screenLGMin,
    '-xl': gridToken.screenXLMin,
    '-xxl': gridToken.screenXXLMin
  };
  return [genGridColStyle(gridToken), genGridStyle(gridToken, ''), genGridStyle(gridToken, '-xs'), Object.keys(gridMediaSizesMap).map(function (key) {
    return genGridMediaStyle(gridToken, gridMediaSizesMap[key], key);
  }).reduce(function (pre, cur) {
    return _extends$2(_extends$2({}, pre), cur);
  }, {})];
});

var __rest$t = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function parseFlex(flex) {
  if (typeof flex === 'number') {
    return flex + " " + flex + " auto";
  }
  if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
    return "0 0 " + flex;
  }
  return flex;
}
var sizes = ['xs', 'sm', 'md', 'lg', 'xl', 'xxl'];
var Col = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _classNames;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var _React$useContext2 = react.exports.useContext(RowContext$1),
    gutter = _React$useContext2.gutter,
    wrap = _React$useContext2.wrap,
    supportFlexGap = _React$useContext2.supportFlexGap;
  var customizePrefixCls = props.prefixCls,
    span = props.span,
    order = props.order,
    offset = props.offset,
    push = props.push,
    pull = props.pull,
    className = props.className,
    children = props.children,
    flex = props.flex,
    style = props.style,
    others = __rest$t(props, ["prefixCls", "span", "order", "offset", "push", "pull", "className", "children", "flex", "style"]);
  var prefixCls = getPrefixCls('col', customizePrefixCls);
  var _useColStyle = useColStyle(prefixCls),
    _useColStyle2 = _slicedToArray(_useColStyle, 2),
    wrapSSR = _useColStyle2[0],
    hashId = _useColStyle2[1];
  var sizeClassObj = {};
  sizes.forEach(function (size) {
    var _extends2;
    var sizeProps = {};
    var propSize = props[size];
    if (typeof propSize === 'number') {
      sizeProps.span = propSize;
    } else if (_typeof$1(propSize) === 'object') {
      sizeProps = propSize || {};
    }
    delete others[size];
    sizeClassObj = _extends$2(_extends$2({}, sizeClassObj), (_extends2 = {}, _defineProperty$1(_extends2, prefixCls + "-" + size + "-" + sizeProps.span, sizeProps.span !== undefined), _defineProperty$1(_extends2, prefixCls + "-" + size + "-order-" + sizeProps.order, sizeProps.order || sizeProps.order === 0), _defineProperty$1(_extends2, prefixCls + "-" + size + "-offset-" + sizeProps.offset, sizeProps.offset || sizeProps.offset === 0), _defineProperty$1(_extends2, prefixCls + "-" + size + "-push-" + sizeProps.push, sizeProps.push || sizeProps.push === 0), _defineProperty$1(_extends2, prefixCls + "-" + size + "-pull-" + sizeProps.pull, sizeProps.pull || sizeProps.pull === 0), _defineProperty$1(_extends2, prefixCls + "-rtl", direction === 'rtl'), _extends2));
  });
  var classes = classNames$1(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-" + span, span !== undefined), _defineProperty$1(_classNames, prefixCls + "-order-" + order, order), _defineProperty$1(_classNames, prefixCls + "-offset-" + offset, offset), _defineProperty$1(_classNames, prefixCls + "-push-" + push, push), _defineProperty$1(_classNames, prefixCls + "-pull-" + pull, pull), _classNames), className, sizeClassObj, hashId);
  var mergedStyle = {};
  // Horizontal gutter use padding
  if (gutter && gutter[0] > 0) {
    var horizontalGutter = gutter[0] / 2;
    mergedStyle.paddingLeft = horizontalGutter;
    mergedStyle.paddingRight = horizontalGutter;
  }
  // Vertical gutter use padding when gap not support
  if (gutter && gutter[1] > 0 && !supportFlexGap) {
    var verticalGutter = gutter[1] / 2;
    mergedStyle.paddingTop = verticalGutter;
    mergedStyle.paddingBottom = verticalGutter;
  }
  if (flex) {
    mergedStyle.flex = parseFlex(flex);
    // Hack for Firefox to avoid size issue
    // https://github.com/ant-design/ant-design/pull/20023#issuecomment-564389553
    if (wrap === false && !mergedStyle.minWidth) {
      mergedStyle.minWidth = 0;
    }
  }
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    ...others,
    style: _extends$2(_extends$2({}, mergedStyle), style),
    className: classes,
    ref: ref,
    children: children
  }));
});
const Col$1 = Col;

var __rest$s = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function useMergePropByScreen(oriProp, screen) {
  var _React$useState = react.exports.useState(typeof oriProp === 'string' ? oriProp : ''),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    prop = _React$useState2[0],
    setProp = _React$useState2[1];
  var clacMergeAlignOrJustify = function clacMergeAlignOrJustify() {
    if (_typeof$1(oriProp) !== 'object') {
      return;
    }
    for (var i = 0; i < responsiveArray.length; i++) {
      var breakpoint = responsiveArray[i];
      // if do not match, do nothing
      if (!screen[breakpoint]) continue;
      var curVal = oriProp[breakpoint];
      if (curVal !== undefined) {
        setProp(curVal);
        return;
      }
    }
  };
  react.exports.useEffect(function () {
    clacMergeAlignOrJustify();
  }, [JSON.stringify(oriProp), screen]);
  return prop;
}
var Row = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _classNames;
  var customizePrefixCls = props.prefixCls,
    justify = props.justify,
    align = props.align,
    className = props.className,
    style = props.style,
    children = props.children,
    _props$gutter = props.gutter,
    gutter = _props$gutter === void 0 ? 0 : _props$gutter,
    wrap = props.wrap,
    others = __rest$s(props, ["prefixCls", "justify", "align", "className", "style", "children", "gutter", "wrap"]);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var _React$useState3 = react.exports.useState({
      xs: true,
      sm: true,
      md: true,
      lg: true,
      xl: true,
      xxl: true
    }),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    screens = _React$useState4[0],
    setScreens = _React$useState4[1];
  // to save screens info when responsiveObserve callback had been call
  var _React$useState5 = react.exports.useState({
      xs: false,
      sm: false,
      md: false,
      lg: false,
      xl: false,
      xxl: false
    }),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    curScreens = _React$useState6[0],
    setCurScreens = _React$useState6[1];
  // ================================== calc reponsive data ==================================
  var mergeAlign = useMergePropByScreen(align, curScreens);
  var mergeJustify = useMergePropByScreen(justify, curScreens);
  var supportFlexGap = useFlexGapSupport();
  var gutterRef = react.exports.useRef(gutter);
  var responsiveObserve = useResponsiveObserver();
  // ================================== Effect ==================================
  react.exports.useEffect(function () {
    var token = responsiveObserve.subscribe(function (screen) {
      setCurScreens(screen);
      var currentGutter = gutterRef.current || 0;
      if (!Array.isArray(currentGutter) && _typeof$1(currentGutter) === 'object' || Array.isArray(currentGutter) && (_typeof$1(currentGutter[0]) === 'object' || _typeof$1(currentGutter[1]) === 'object')) {
        setScreens(screen);
      }
    });
    return function () {
      return responsiveObserve.unsubscribe(token);
    };
  }, []);
  // ================================== Render ==================================
  var getGutter = function getGutter() {
    var results = [undefined, undefined];
    var normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, undefined];
    normalizedGutter.forEach(function (g, index) {
      if (_typeof$1(g) === 'object') {
        for (var i = 0; i < responsiveArray.length; i++) {
          var breakpoint = responsiveArray[i];
          if (screens[breakpoint] && g[breakpoint] !== undefined) {
            results[index] = g[breakpoint];
            break;
          }
        }
      } else {
        results[index] = g;
      }
    });
    return results;
  };
  var prefixCls = getPrefixCls('row', customizePrefixCls);
  var _useRowStyle = useRowStyle(prefixCls),
    _useRowStyle2 = _slicedToArray(_useRowStyle, 2),
    wrapSSR = _useRowStyle2[0],
    hashId = _useRowStyle2[1];
  var gutters = getGutter();
  var classes = classNames$1(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-no-wrap", wrap === false), _defineProperty$1(_classNames, prefixCls + "-" + mergeJustify, mergeJustify), _defineProperty$1(_classNames, prefixCls + "-" + mergeAlign, mergeAlign), _defineProperty$1(_classNames, prefixCls + "-rtl", direction === 'rtl'), _classNames), className, hashId);
  // Add gutter related style
  var rowStyle = {};
  var horizontalGutter = gutters[0] != null && gutters[0] > 0 ? gutters[0] / -2 : undefined;
  var verticalGutter = gutters[1] != null && gutters[1] > 0 ? gutters[1] / -2 : undefined;
  if (horizontalGutter) {
    rowStyle.marginLeft = horizontalGutter;
    rowStyle.marginRight = horizontalGutter;
  }
  if (supportFlexGap) {
    // Set gap direct if flex gap support
    var _gutters = _slicedToArray(gutters, 2);
    rowStyle.rowGap = _gutters[1];
  } else if (verticalGutter) {
    rowStyle.marginTop = verticalGutter;
    rowStyle.marginBottom = verticalGutter;
  }
  // "gutters" is a new array in each rendering phase, it'll make 'React.useMemo' effectless.
  // So we deconstruct "gutters" variable here.
  var _gutters2 = _slicedToArray(gutters, 2),
    gutterH = _gutters2[0],
    gutterV = _gutters2[1];
  var rowContext = react.exports.useMemo(function () {
    return {
      gutter: [gutterH, gutterV],
      wrap: wrap,
      supportFlexGap: supportFlexGap
    };
  }, [gutterH, gutterV, wrap, supportFlexGap]);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(RowContext$1.Provider, {
    value: rowContext,
    children: /*#__PURE__*/jsx$1("div", {
      ...others,
      className: classes,
      style: _extends$2(_extends$2({}, rowStyle), style),
      ref: ref,
      children: children
    })
  }));
});
const Row$1 = Row;

var OrderContext = /*#__PURE__*/react.exports.createContext(null);

var EMPTY_LIST$3 = [];
/**
 * Will add `div` to document. Nest call will keep order
 * @param render Render DOM in document
 */

function useDom(render, debug) {
  var _React$useState = react.exports.useState(function () {
    if (!canUseDom()) {
      return null;
    }

    var defaultEle = document.createElement('div');

    return defaultEle;
  }),
      _React$useState2 = _slicedToArray(_React$useState, 1),
      ele = _React$useState2[0]; // ========================== Order ==========================


  var queueCreate = react.exports.useContext(OrderContext);

  var _React$useState3 = react.exports.useState(EMPTY_LIST$3),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      queue = _React$useState4[0],
      setQueue = _React$useState4[1];

  var mergedQueueCreate = queueCreate || function (appendFn) {
    setQueue(function (origin) {
      var newQueue = [appendFn].concat(_toConsumableArray(origin));
      return newQueue;
    });
  }; // =========================== DOM ===========================


  function append() {
    if (!ele.parentElement) {
      document.body.appendChild(ele);
    }
  }

  function cleanup() {
    var _ele$parentElement;

    (_ele$parentElement = ele.parentElement) === null || _ele$parentElement === void 0 ? void 0 : _ele$parentElement.removeChild(ele);
  }

  useLayoutEffect$3(function () {
    if (render) {
      if (queueCreate) {
        queueCreate(append);
      } else {
        append();
      }
    } else {
      cleanup();
    }

    return cleanup;
  }, [render]);
  useLayoutEffect$3(function () {
    if (queue.length) {
      queue.forEach(function (appendFn) {
        return appendFn();
      });
      setQueue(EMPTY_LIST$3);
    }
  }, [queue]);
  return [ele, mergedQueueCreate];
}

/* eslint-disable no-param-reassign */
var cached;
function getScrollBarSize(fresh) {
  if (typeof document === 'undefined') {
    return 0;
  }
  if (fresh || cached === undefined) {
    var inner = document.createElement('div');
    inner.style.width = '100%';
    inner.style.height = '200px';
    var outer = document.createElement('div');
    var outerStyle = outer.style;
    outerStyle.position = 'absolute';
    outerStyle.top = '0';
    outerStyle.left = '0';
    outerStyle.pointerEvents = 'none';
    outerStyle.visibility = 'hidden';
    outerStyle.width = '200px';
    outerStyle.height = '150px';
    outerStyle.overflow = 'hidden';
    outer.appendChild(inner);
    document.body.appendChild(outer);
    var widthContained = inner.offsetWidth;
    outer.style.overflow = 'scroll';
    var widthScroll = inner.offsetWidth;
    if (widthContained === widthScroll) {
      widthScroll = outer.clientWidth;
    }
    document.body.removeChild(outer);
    cached = widthContained - widthScroll;
  }
  return cached;
}
function ensureSize(str) {
  var match = str.match(/^(.*)px$/);
  var value = Number(match === null || match === void 0 ? void 0 : match[1]);
  return Number.isNaN(value) ? getScrollBarSize() : value;
}
function getTargetScrollBarSize(target) {
  if (typeof document === 'undefined' || !target || !(target instanceof Element)) {
    return {
      width: 0,
      height: 0
    };
  }
  var _getComputedStyle = getComputedStyle(target, '::-webkit-scrollbar'),
    width = _getComputedStyle.width,
    height = _getComputedStyle.height;
  return {
    width: ensureSize(width),
    height: ensureSize(height)
  };
}

/**
 * Test usage export. Do not use in your production
 */
function isBodyOverflowing() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}

var UNIQUE_ID = "rc-util-locker-".concat(Date.now());
var uuid$3 = 0;
function useScrollLocker(lock) {
  var mergedLock = !!lock;

  var _React$useState = react.exports.useState(function () {
    uuid$3 += 1;
    return "".concat(UNIQUE_ID, "_").concat(uuid$3);
  }),
      _React$useState2 = _slicedToArray(_React$useState, 1),
      id = _React$useState2[0];

  useLayoutEffect$3(function () {
    if (mergedLock) {
      var scrollbarSize = getScrollBarSize();
      var isOverflow = isBodyOverflowing();
      updateCSS("\nhtml body {\n  overflow-y: hidden;\n  ".concat(isOverflow ? "width: calc(100% - ".concat(scrollbarSize, "px);") : '', "\n}"), id);
    } else {
      removeCSS(id);
    }

    return function () {
      removeCSS(id);
    };
  }, [mergedLock, id]);
}

var inline = false;
function inlineMock(nextInline) {
  if (typeof nextInline === 'boolean') {
    inline = nextInline;
  }

  return inline;
}

var getPortalContainer = function getPortalContainer(getContainer) {
  if (getContainer === false) {
    return false;
  }
  if (!canUseDom() || !getContainer) {
    return null;
  }
  if (typeof getContainer === 'string') {
    return document.querySelector(getContainer);
  }
  if (typeof getContainer === 'function') {
    return getContainer();
  }
  return getContainer;
};
var Portal = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var open = props.open,
    autoLock = props.autoLock,
    getContainer = props.getContainer;
    props.debug;
    var _props$autoDestroy = props.autoDestroy,
    autoDestroy = _props$autoDestroy === void 0 ? true : _props$autoDestroy,
    children = props.children;
  var _React$useState = react.exports.useState(open),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    shouldRender = _React$useState2[0],
    setShouldRender = _React$useState2[1];
  var mergedRender = shouldRender || open; // ====================== Should Render ======================

  react.exports.useEffect(function () {
    if (autoDestroy || open) {
      setShouldRender(open);
    }
  }, [open, autoDestroy]); // ======================== Container ========================

  var _React$useState3 = react.exports.useState(function () {
      return getPortalContainer(getContainer);
    }),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    innerContainer = _React$useState4[0],
    setInnerContainer = _React$useState4[1];
  react.exports.useEffect(function () {
    var customizeContainer = getPortalContainer(getContainer); // Tell component that we check this in effect which is safe to be `null`

    setInnerContainer(customizeContainer !== null && customizeContainer !== void 0 ? customizeContainer : null);
  });
  var _useDom = useDom(mergedRender && !innerContainer),
    _useDom2 = _slicedToArray(_useDom, 2),
    defaultContainer = _useDom2[0],
    queueCreate = _useDom2[1];
  var mergedContainer = innerContainer !== null && innerContainer !== void 0 ? innerContainer : defaultContainer; // ========================= Locker ==========================

  useScrollLocker(autoLock && open && canUseDom() && (mergedContainer === defaultContainer || mergedContainer === document.body)); // =========================== Ref ===========================

  var childRef = null;
  if (children && supportRef$1(children) && ref) {
    var _ref = children;
    childRef = _ref.ref;
  }
  var mergedRef = useComposeRef(childRef, ref); // ========================= Render ==========================
  // Do not render when nothing need render
  // When innerContainer is `undefined`, it may not ready since user use ref in the same render

  if (!mergedRender || !canUseDom() || innerContainer === undefined) {
    return null;
  } // Render inline

  var renderInline = mergedContainer === false || inlineMock();
  var reffedChildren = children;
  if (ref) {
    reffedChildren = /*#__PURE__*/react.exports.cloneElement(children, {
      ref: mergedRef
    });
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(OrderContext.Provider, {
      value: queueCreate,
      children: renderInline ? reffedChildren : /*#__PURE__*/reactDom.exports.createPortal(reffedChildren, mergedContainer)
    })
  );
});

function useDebounce(value) {
  var _React$useState = react.exports.useState(value),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    cacheValue = _React$useState2[0],
    setCacheValue = _React$useState2[1];
  react.exports.useEffect(function () {
    var timeout = setTimeout(function () {
      setCacheValue(value);
    }, value.length ? 0 : 10);
    return function () {
      clearTimeout(timeout);
    };
  }, [value]);
  return cacheValue;
}

var genFormValidateMotionStyle = function genFormValidateMotionStyle(token) {
  var _helpItemCls;
  var componentCls = token.componentCls;
  var helpCls = componentCls + "-show-help";
  var helpItemCls = componentCls + "-show-help-item";
  return _defineProperty$1({}, helpCls, _defineProperty$1({
    // Explain holder
    transition: "opacity " + token.motionDurationSlow + " " + token.motionEaseInOut,
    '&-appear, &-enter': {
      opacity: 0,
      '&-active': {
        opacity: 1
      }
    },
    '&-leave': {
      opacity: 1,
      '&-active': {
        opacity: 0
      }
    }
  }, helpItemCls, (_helpItemCls = {
    overflow: 'hidden',
    transition: "height " + token.motionDurationSlow + " " + token.motionEaseInOut + ",\n                     opacity " + token.motionDurationSlow + " " + token.motionEaseInOut + ",\n                     transform " + token.motionDurationSlow + " " + token.motionEaseInOut + " !important"
  }, _defineProperty$1(_helpItemCls, "&" + helpItemCls + "-appear, &" + helpItemCls + "-enter", _defineProperty$1({
    transform: "translateY(-5px)",
    opacity: 0
  }, "&-active", {
    transform: 'translateY(0)',
    opacity: 1
  })), _defineProperty$1(_helpItemCls, "&" + helpItemCls + "-leave-active", {
    transform: "translateY(-5px)"
  }), _helpItemCls)));
};
const genFormValidateMotionStyle$1 = genFormValidateMotionStyle;

var resetForm = function resetForm(token) {
  var _ref;
  return _ref = {
    legend: {
      display: 'block',
      width: '100%',
      marginBottom: token.marginLG,
      padding: 0,
      color: token.colorTextDescription,
      fontSize: token.fontSizeLG,
      lineHeight: 'inherit',
      border: 0,
      borderBottom: token.lineWidth + "px " + token.lineType + " " + token.colorBorder
    },
    label: {
      fontSize: token.fontSize
    },
    'input[type="search"]': {
      boxSizing: 'border-box'
    },
    // Position radios and checkboxes better
    'input[type="radio"], input[type="checkbox"]': {
      lineHeight: 'normal'
    },
    'input[type="file"]': {
      display: 'block'
    },
    // Make range inputs behave like textual form controls
    'input[type="range"]': {
      display: 'block',
      width: '100%'
    },
    // Make multiple select elements height not fixed
    'select[multiple], select[size]': {
      height: 'auto'
    }
  }, _defineProperty$1(_ref, "input[type='file']:focus,\n  input[type='radio']:focus,\n  input[type='checkbox']:focus", {
    outline: 0,
    boxShadow: "0 0 0 " + token.controlOutlineWidth + "px " + token.controlOutline
  }), _defineProperty$1(_ref, "output", {
    display: 'block',
    paddingTop: 15,
    color: token.colorText,
    fontSize: token.fontSize,
    lineHeight: token.lineHeight
  }), _ref;
};
var genFormSize = function genFormSize(token, height) {
  var _formItemCls;
  var formItemCls = token.formItemCls;
  return _defineProperty$1({}, formItemCls, (_formItemCls = {}, _defineProperty$1(_formItemCls, formItemCls + "-label > label", {
    height: height
  }), _defineProperty$1(_formItemCls, formItemCls + "-control-input", {
    minHeight: height
  }), _formItemCls));
};
var genFormStyle = function genFormStyle(token) {
  var _extends2;
  var componentCls = token.componentCls;
  return _defineProperty$1({}, token.componentCls, _extends$2(_extends$2(_extends$2({}, resetComponent(token)), resetForm(token)), (_extends2 = {}, _defineProperty$1(_extends2, componentCls + "-text", {
    display: 'inline-block',
    paddingInlineEnd: token.paddingSM
  }), _defineProperty$1(_extends2, '&-small', _extends$2({}, genFormSize(token, token.controlHeightSM))), _defineProperty$1(_extends2, '&-large', _extends$2({}, genFormSize(token, token.controlHeightLG))), _extends2)));
};
var genFormItemStyle = function genFormItemStyle(token) {
  var _label, _ref6, _extends3;
  var formItemCls = token.formItemCls,
    iconCls = token.iconCls,
    componentCls = token.componentCls,
    rootPrefixCls = token.rootPrefixCls;
  return _defineProperty$1({}, formItemCls, _extends$2(_extends$2({}, resetComponent(token)), (_extends3 = {
    marginBottom: token.marginLG,
    verticalAlign: 'top',
    '&-with-help': {
      transition: 'none'
    }
  }, _defineProperty$1(_extends3, "&-hidden,\n        &-hidden." + rootPrefixCls + "-row", {
    // https://github.com/ant-design/ant-design/issues/26141
    display: 'none'
  }), _defineProperty$1(_extends3, '&-has-warning', _defineProperty$1({}, formItemCls + "-split", {
    color: token.colorError
  })), _defineProperty$1(_extends3, '&-has-error', _defineProperty$1({}, formItemCls + "-split", {
    color: token.colorWarning
  })), _defineProperty$1(_extends3, formItemCls + "-label", {
    display: 'inline-block',
    flexGrow: 0,
    overflow: 'hidden',
    whiteSpace: 'nowrap',
    textAlign: 'end',
    verticalAlign: 'middle',
    '&-left': {
      textAlign: 'start'
    },
    '&-wrap': {
      overflow: 'unset',
      lineHeight: token.lineHeight + " - 0.25em",
      whiteSpace: 'unset'
    },
    '> label': (_label = {
      position: 'relative',
      display: 'inline-flex',
      alignItems: 'center',
      maxWidth: '100%',
      height: token.controlHeight,
      color: token.colorTextHeading,
      fontSize: token.fontSize
    }, _defineProperty$1(_label, "> " + iconCls, {
      fontSize: token.fontSize,
      verticalAlign: 'top'
    }), _defineProperty$1(_label, "&" + formItemCls + "-required:not(" + formItemCls + "-required-mark-optional)::before", _defineProperty$1({
      display: 'inline-block',
      marginInlineEnd: token.marginXXS,
      color: token.colorError,
      fontSize: token.fontSize,
      fontFamily: 'SimSun, sans-serif',
      lineHeight: 1,
      content: '"*"'
    }, componentCls + "-hide-required-mark &", {
      display: 'none'
    })), _defineProperty$1(_label, formItemCls + "-optional", _defineProperty$1({
      display: 'inline-block',
      marginInlineStart: token.marginXXS,
      color: token.colorTextDescription
    }, componentCls + "-hide-required-mark &", {
      display: 'none'
    })), _defineProperty$1(_label, formItemCls + "-tooltip", {
      color: token.colorTextDescription,
      cursor: 'help',
      writingMode: 'horizontal-tb',
      marginInlineStart: token.marginXXS
    }), _defineProperty$1(_label, '&::after', {
      content: '":"',
      position: 'relative',
      marginBlock: 0,
      marginInlineStart: token.marginXXS / 2,
      marginInlineEnd: token.marginXS
    }), _defineProperty$1(_label, "&" + formItemCls + "-no-colon::after", {
      content: '" "'
    }), _label)
  }), _defineProperty$1(_extends3, formItemCls + "-control", (_ref6 = {
    display: 'flex',
    flexDirection: 'column',
    flexGrow: 1
  }, _defineProperty$1(_ref6, "&:first-child:not([class^=\"'" + rootPrefixCls + "-col-'\"]):not([class*=\"' " + rootPrefixCls + "-col-'\"])", {
    width: '100%'
  }), _defineProperty$1(_ref6, '&-input', {
    position: 'relative',
    display: 'flex',
    alignItems: 'center',
    minHeight: token.controlHeight,
    '&-content': {
      flex: 'auto',
      maxWidth: '100%'
    }
  }), _ref6)), _defineProperty$1(_extends3, formItemCls, {
    '&-explain, &-extra': {
      clear: 'both',
      color: token.colorTextDescription,
      fontSize: token.fontSize,
      lineHeight: token.lineHeight
    },
    '&-explain-connected': {
      width: '100%'
    },
    '&-extra': {
      minHeight: token.controlHeightSM,
      transition: "color " + token.motionDurationMid + " " + token.motionEaseOut // sync input color transition
    },

    '&-explain': {
      '&-error': {
        color: token.colorError
      },
      '&-warning': {
        color: token.colorWarning
      }
    }
  }), _defineProperty$1(_extends3, "&-with-help " + formItemCls + "-explain", {
    height: 'auto',
    opacity: 1
  }), _defineProperty$1(_extends3, formItemCls + "-feedback-icon", {
    fontSize: token.fontSize,
    textAlign: 'center',
    visibility: 'visible',
    animationName: zoomIn,
    animationDuration: token.motionDurationMid,
    animationTimingFunction: token.motionEaseOutBack,
    pointerEvents: 'none',
    '&-success': {
      color: token.colorSuccess
    },
    '&-error': {
      color: token.colorError
    },
    '&-warning': {
      color: token.colorWarning
    },
    '&-validating': {
      color: token.colorPrimary
    }
  }), _extends3)));
};
var genHorizontalStyle = function genHorizontalStyle(token) {
  var _ref8;
  var componentCls = token.componentCls,
    formItemCls = token.formItemCls,
    rootPrefixCls = token.rootPrefixCls;
  return _defineProperty$1({}, componentCls + "-horizontal", (_ref8 = {}, _defineProperty$1(_ref8, formItemCls + "-label", {
    flexGrow: 0
  }), _defineProperty$1(_ref8, formItemCls + "-control", {
    flex: '1 1 0',
    // https://github.com/ant-design/ant-design/issues/32777
    // https://github.com/ant-design/ant-design/issues/33773
    minWidth: 0
  }), _defineProperty$1(_ref8, formItemCls + "-label." + rootPrefixCls + "-col-24 + " + formItemCls + "-control", {
    minWidth: 'unset'
  }), _ref8));
};
var genInlineStyle = function genInlineStyle(token) {
  var _formItemCls2;
  var componentCls = token.componentCls,
    formItemCls = token.formItemCls;
  return _defineProperty$1({}, componentCls + "-inline", _defineProperty$1({
    display: 'flex',
    flexWrap: 'wrap'
  }, formItemCls, (_formItemCls2 = {
    flex: 'none',
    flexWrap: 'nowrap',
    marginInlineEnd: token.margin,
    marginBottom: 0,
    '&-with-help': {
      marginBottom: token.marginLG
    }
  }, _defineProperty$1(_formItemCls2, "> " + formItemCls + "-label,\n        > " + formItemCls + "-control", {
    display: 'inline-block',
    verticalAlign: 'top'
  }), _defineProperty$1(_formItemCls2, "> " + formItemCls + "-label", {
    flex: 'none'
  }), _defineProperty$1(_formItemCls2, componentCls + "-text", {
    display: 'inline-block'
  }), _defineProperty$1(_formItemCls2, formItemCls + "-has-feedback", {
    display: 'inline-block'
  }), _formItemCls2)));
};
var makeVerticalLayoutLabel = function makeVerticalLayoutLabel(token) {
  return {
    margin: 0,
    padding: "0 0 " + token.paddingXS + "px",
    whiteSpace: 'initial',
    textAlign: 'start',
    '> label': {
      margin: 0,
      '&::after': {
        display: 'none'
      }
    }
  };
};
var makeVerticalLayout = function makeVerticalLayout(token) {
  var _ref12;
  var componentCls = token.componentCls,
    formItemCls = token.formItemCls;
  return _ref12 = {}, _defineProperty$1(_ref12, formItemCls + " " + formItemCls + "-label", makeVerticalLayoutLabel(token)), _defineProperty$1(_ref12, componentCls, _defineProperty$1({}, formItemCls, _defineProperty$1({
    flexWrap: 'wrap'
  }, formItemCls + "-label,\n          " + formItemCls + "-control", {
    flex: '0 0 100%',
    maxWidth: '100%'
  }))), _ref12;
};
var genVerticalStyle = function genVerticalStyle(token) {
  var _ref18;
  var componentCls = token.componentCls,
    formItemCls = token.formItemCls,
    rootPrefixCls = token.rootPrefixCls;
  return _ref18 = {}, _defineProperty$1(_ref18, componentCls + "-vertical", _defineProperty$1({}, formItemCls, _defineProperty$1({
    '&-row': {
      flexDirection: 'column'
    },
    '&-label > label': {
      height: 'auto'
    }
  }, componentCls + "-item-control", {
    width: '100%'
  }))), _defineProperty$1(_ref18, componentCls + "-vertical " + formItemCls + "-label,\n      ." + rootPrefixCls + "-col-24" + formItemCls + "-label,\n      ." + rootPrefixCls + "-col-xl-24" + formItemCls + "-label", makeVerticalLayoutLabel(token)), _defineProperty$1(_ref18, "@media (max-width: " + token.screenXSMax + "px)", [makeVerticalLayout(token), _defineProperty$1({}, componentCls, _defineProperty$1({}, "." + rootPrefixCls + "-col-xs-24" + formItemCls + "-label", makeVerticalLayoutLabel(token)))]), _defineProperty$1(_ref18, "@media (max-width: " + token.screenSMMax + "px)", _defineProperty$1({}, componentCls, _defineProperty$1({}, "." + rootPrefixCls + "-col-sm-24" + formItemCls + "-label", makeVerticalLayoutLabel(token)))), _defineProperty$1(_ref18, "@media (max-width: " + token.screenMDMax + "px)", _defineProperty$1({}, componentCls, _defineProperty$1({}, "." + rootPrefixCls + "-col-md-24" + formItemCls + "-label", makeVerticalLayoutLabel(token)))), _defineProperty$1(_ref18, "@media (max-width: " + token.screenLGMax + "px)", _defineProperty$1({}, componentCls, _defineProperty$1({}, "." + rootPrefixCls + "-col-lg-24" + formItemCls + "-label", makeVerticalLayoutLabel(token)))), _ref18;
};
// ============================== Export ==============================
const useStyle$a = genComponentStyleHook('Form', function (token, _ref19) {
  var rootPrefixCls = _ref19.rootPrefixCls;
  var formToken = merge$2(token, {
    formItemCls: token.componentCls + "-item",
    rootPrefixCls: rootPrefixCls
  });
  return [genFormStyle(formToken), genFormItemStyle(formToken), genFormValidateMotionStyle$1(formToken), genHorizontalStyle(formToken), genInlineStyle(formToken), genVerticalStyle(formToken), genCollapseMotion$1(formToken), zoomIn];
});

var EMPTY_LIST$2 = [];
function toErrorEntity(error, errorStatus, prefix) {
  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  return {
    key: typeof error === 'string' ? error : prefix + "-" + index,
    error: error,
    errorStatus: errorStatus
  };
}
function ErrorList(_ref) {
  var help = _ref.help,
    helpStatus = _ref.helpStatus,
    _ref$errors = _ref.errors,
    errors = _ref$errors === void 0 ? EMPTY_LIST$2 : _ref$errors,
    _ref$warnings = _ref.warnings,
    warnings = _ref$warnings === void 0 ? EMPTY_LIST$2 : _ref$warnings,
    rootClassName = _ref.className,
    fieldId = _ref.fieldId,
    onVisibleChanged = _ref.onVisibleChanged;
  var _React$useContext = react.exports.useContext(FormItemPrefixContext),
    prefixCls = _React$useContext.prefixCls;
  var baseClassName = prefixCls + "-item-explain";
  var _useStyle = useStyle$a(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    hashId = _useStyle2[1];
  var collapseMotion = react.exports.useMemo(function () {
    return initCollapseMotion$1(prefixCls);
  }, [prefixCls]);
  // We have to debounce here again since somewhere use ErrorList directly still need no shaking
  // ref: https://github.com/ant-design/ant-design/issues/36336
  var debounceErrors = useDebounce(errors);
  var debounceWarnings = useDebounce(warnings);
  var fullKeyList = react.exports.useMemo(function () {
    if (help !== undefined && help !== null) {
      return [toErrorEntity(help, helpStatus, 'help')];
    }
    return [].concat(_toConsumableArray(debounceErrors.map(function (error, index) {
      return toErrorEntity(error, 'error', 'error', index);
    })), _toConsumableArray(debounceWarnings.map(function (warning, index) {
      return toErrorEntity(warning, 'warning', 'warning', index);
    })));
  }, [help, helpStatus, debounceErrors, debounceWarnings]);
  var helpProps = {};
  if (fieldId) {
    helpProps.id = fieldId + "_help";
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(CSSMotion, {
      motionDeadline: collapseMotion.motionDeadline,
      motionName: prefixCls + "-show-help",
      visible: !!fullKeyList.length,
      onVisibleChanged: onVisibleChanged,
      children: function (holderProps) {
        var holderClassName = holderProps.className,
          holderStyle = holderProps.style;
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("div", {
            ...helpProps,
            className: classNames$1(baseClassName, holderClassName, rootClassName, hashId),
            style: holderStyle,
            role: "alert",
            children: /*#__PURE__*/jsx$1(CSSMotionList, {
              keys: fullKeyList,
              ...initCollapseMotion$1(prefixCls),
              motionName: prefixCls + "-show-help-item",
              component: false,
              children: function (itemProps) {
                var key = itemProps.key,
                  error = itemProps.error,
                  errorStatus = itemProps.errorStatus,
                  itemClassName = itemProps.className,
                  itemStyle = itemProps.style;
                return (
                  /*#__PURE__*/
                  /*#__PURE__*/
                  jsx$1("div", {
                    className: classNames$1(itemClassName, _defineProperty$1({}, baseClassName + "-" + errorStatus, errorStatus)),
                    style: itemStyle,
                    children: error
                  }, key)
                );
              }
            })
          })
        );
      }
    })
  );
}

let e=e=>"object"==typeof e&&null!=e&&1===e.nodeType,t$1=(e,t)=>(!t||"hidden"!==e)&&("visible"!==e&&"clip"!==e),n=(e,n)=>{if(e.clientHeight<e.scrollHeight||e.clientWidth<e.scrollWidth){let l=getComputedStyle(e,null);return t$1(l.overflowY,n)||t$1(l.overflowX,n)||(e=>{let t=(e=>{if(!e.ownerDocument||!e.ownerDocument.defaultView)return null;try{return e.ownerDocument.defaultView.frameElement}catch(e){return null}})(e);return !!t&&(t.clientHeight<e.scrollHeight||t.clientWidth<e.scrollWidth)})(e)}return !1},l=(e,t,n,l,i,o,r,d)=>o<e&&r>t||o>e&&r<t?0:o<=e&&d<=n||r>=t&&d>=n?o-e-l:r>t&&d<n||o<e&&d>n?r-t+i:0,i$1=e=>{let t=e.parentElement;return null==t?e.getRootNode().host||null:t};var o$1=(t,o)=>{var r,d,h,f,u,s;if("undefined"==typeof document)return [];let{scrollMode:a,block:c,inline:g,boundary:m,skipOverflowHiddenElements:p}=o,w="function"==typeof m?m:e=>e!==m;if(!e(t))throw new TypeError("Invalid target");let W=document.scrollingElement||document.documentElement,H=[],b=t;for(;e(b)&&w(b);){if(b=i$1(b),b===W){H.push(b);break}null!=b&&b===document.body&&n(b)&&!n(document.documentElement)||null!=b&&n(b,p)&&H.push(b);}let v=null!=(d=null==(r=window.visualViewport)?void 0:r.width)?d:innerWidth,y=null!=(f=null==(h=window.visualViewport)?void 0:h.height)?f:innerHeight,E=null!=(u=window.scrollX)?u:pageXOffset,M=null!=(s=window.scrollY)?s:pageYOffset,{height:x,width:I,top:C,right:R,bottom:T,left:V}=t.getBoundingClientRect(),k="start"===c||"nearest"===c?C:"end"===c?T:C+x/2,B="center"===g?V+I/2:"end"===g?R:V,D=[];for(let e=0;e<H.length;e++){let t=H[e],{height:n,width:i,top:o,right:r,bottom:d,left:h}=t.getBoundingClientRect();if("if-needed"===a&&C>=0&&V>=0&&T<=y&&R<=v&&C>=o&&T<=d&&V>=h&&R<=r)return D;let f=getComputedStyle(t),u=parseInt(f.borderLeftWidth,10),s=parseInt(f.borderTopWidth,10),m=parseInt(f.borderRightWidth,10),p=parseInt(f.borderBottomWidth,10),w=0,b=0,O="offsetWidth"in t?t.offsetWidth-t.clientWidth-u-m:0,X="offsetHeight"in t?t.offsetHeight-t.clientHeight-s-p:0,Y="offsetWidth"in t?0===t.offsetWidth?0:i/t.offsetWidth:0,L="offsetHeight"in t?0===t.offsetHeight?0:n/t.offsetHeight:0;if(W===t)w="start"===c?k:"end"===c?k-y:"nearest"===c?l(M,M+y,y,s,p,M+k,M+k+x,x):k-y/2,b="start"===g?B:"center"===g?B-v/2:"end"===g?B-v:l(E,E+v,v,u,m,E+B,E+B+I,I),w=Math.max(0,w+M),b=Math.max(0,b+E);else {w="start"===c?k-o-s:"end"===c?k-d+p+X:"nearest"===c?l(o,d,n,s,p+X,k,k+x,x):k-(o+n/2)+X/2,b="start"===g?B-h-u:"center"===g?B-(h+i/2)+O/2:"end"===g?B-r+m+O:l(h,r,i,u,m+O,B,B+I,I);let{scrollLeft:e,scrollTop:f}=t;w=Math.max(0,Math.min(f+w/L,t.scrollHeight-n/L+X)),b=Math.max(0,Math.min(e+b/Y,t.scrollWidth-i/Y+O)),k+=f-w,B+=e-b;}D.push({el:t,top:w,left:b});}return D};

let t=e=>!1===e?{block:"end",inline:"nearest"}:(e=>e===Object(e)&&0!==Object.keys(e).length)(e)?e:{block:"start",inline:"nearest"};function o(o,l){let n=o.isConnected||o.ownerDocument.documentElement.contains(o);if((e=>"object"==typeof e&&"function"==typeof e.behavior)(l))return l.behavior(n?o$1(o,l):[]);if(!n)return;let r=t(l),c=o$1(o,r),i="scrollBehavior"in document.body.style;c.forEach((e=>{let{el:t,top:o,left:l}=e;t.scroll&&i?t.scroll({top:o,left:l,behavior:r.behavior}):(t.scrollTop=o,t.scrollLeft=l);}));}

// form item name black list.  in form ,you can use form.id get the form item element.
// use object hasOwnProperty will get better performance if black list is longer.
var formItemNameBlackList = ['parentNode'];
// default form item id prefix.
var defaultItemNamePrefixCls = 'form_item';
function toArray$3(candidate) {
  if (candidate === undefined || candidate === false) return [];
  return Array.isArray(candidate) ? candidate : [candidate];
}
function getFieldId(namePath, formName) {
  if (!namePath.length) return undefined;
  var mergedId = namePath.join('_');
  if (formName) {
    return formName + "_" + mergedId;
  }
  var isIllegalName = formItemNameBlackList.includes(mergedId);
  return isIllegalName ? defaultItemNamePrefixCls + "_" + mergedId : mergedId;
}

function toNamePathStr(name) {
  var namePath = toArray$3(name);
  return namePath.join('_');
}
function useForm(form) {
  var _useRcForm = useForm$1(),
    _useRcForm2 = _slicedToArray(_useRcForm, 1),
    rcForm = _useRcForm2[0];
  var itemsRef = react.exports.useRef({});
  var wrapForm = react.exports.useMemo(function () {
    return form !== null && form !== void 0 ? form : _extends$2(_extends$2({}, rcForm), {
      __INTERNAL__: {
        itemRef: function itemRef(name) {
          return function (node) {
            var namePathStr = toNamePathStr(name);
            if (node) {
              itemsRef.current[namePathStr] = node;
            } else {
              delete itemsRef.current[namePathStr];
            }
          };
        }
      },
      scrollToField: function scrollToField(name) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var namePath = toArray$3(name);
        var fieldId = getFieldId(namePath, wrapForm.__INTERNAL__.name);
        var node = fieldId ? document.getElementById(fieldId) : null;
        if (node) {
          o(node, _extends$2({
            scrollMode: 'if-needed',
            block: 'nearest'
          }, options));
        }
      },
      getFieldInstance: function getFieldInstance(name) {
        var namePathStr = toNamePathStr(name);
        return itemsRef.current[namePathStr];
      }
    });
  }, [form, rcForm]);
  return [wrapForm];
}

var __rest$r = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var InternalForm = function InternalForm(props, ref) {
  var _classNames;
  var contextSize = react.exports.useContext(SizeContext);
  var contextDisabled = react.exports.useContext(DisabledContext);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction,
    contextForm = _React$useContext.form;
  var customizePrefixCls = props.prefixCls,
    _props$className = props.className,
    className = _props$className === void 0 ? '' : _props$className,
    _props$size = props.size,
    size = _props$size === void 0 ? contextSize : _props$size,
    _props$disabled = props.disabled,
    disabled = _props$disabled === void 0 ? contextDisabled : _props$disabled,
    form = props.form,
    colon = props.colon,
    labelAlign = props.labelAlign,
    labelWrap = props.labelWrap,
    labelCol = props.labelCol,
    wrapperCol = props.wrapperCol,
    hideRequiredMark = props.hideRequiredMark,
    _props$layout = props.layout,
    layout = _props$layout === void 0 ? 'horizontal' : _props$layout,
    scrollToFirstError = props.scrollToFirstError,
    requiredMark = props.requiredMark,
    onFinishFailed = props.onFinishFailed,
    name = props.name,
    restFormProps = __rest$r(props, ["prefixCls", "className", "size", "disabled", "form", "colon", "labelAlign", "labelWrap", "labelCol", "wrapperCol", "hideRequiredMark", "layout", "scrollToFirstError", "requiredMark", "onFinishFailed", "name"]);
  var mergedRequiredMark = react.exports.useMemo(function () {
    if (requiredMark !== undefined) {
      return requiredMark;
    }
    if (contextForm && contextForm.requiredMark !== undefined) {
      return contextForm.requiredMark;
    }
    if (hideRequiredMark) {
      return false;
    }
    return true;
  }, [hideRequiredMark, requiredMark, contextForm]);
  var mergedColon = colon !== null && colon !== void 0 ? colon : contextForm === null || contextForm === void 0 ? void 0 : contextForm.colon;
  var prefixCls = getPrefixCls('form', customizePrefixCls);
  // Style
  var _useStyle = useStyle$a(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var formClassName = classNames$1(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-" + layout, true), _defineProperty$1(_classNames, prefixCls + "-hide-required-mark", mergedRequiredMark === false), _defineProperty$1(_classNames, prefixCls + "-rtl", direction === 'rtl'), _defineProperty$1(_classNames, prefixCls + "-" + size, size), _classNames), hashId, className);
  var _useForm = useForm(form),
    _useForm2 = _slicedToArray(_useForm, 1),
    wrapForm = _useForm2[0];
  var __INTERNAL__ = wrapForm.__INTERNAL__;
  __INTERNAL__.name = name;
  var formContextValue = react.exports.useMemo(function () {
    return {
      name: name,
      labelAlign: labelAlign,
      labelCol: labelCol,
      labelWrap: labelWrap,
      wrapperCol: wrapperCol,
      vertical: layout === 'vertical',
      colon: mergedColon,
      requiredMark: mergedRequiredMark,
      itemRef: __INTERNAL__.itemRef,
      form: wrapForm
    };
  }, [name, labelAlign, labelCol, wrapperCol, layout, mergedColon, mergedRequiredMark, wrapForm]);
  react.exports.useImperativeHandle(ref, function () {
    return wrapForm;
  });
  var onInternalFinishFailed = function onInternalFinishFailed(errorInfo) {
    onFinishFailed === null || onFinishFailed === void 0 ? void 0 : onFinishFailed(errorInfo);
    var defaultScrollToFirstError = {
      block: 'nearest'
    };
    if (scrollToFirstError && errorInfo.errorFields.length) {
      if (_typeof$1(scrollToFirstError) === 'object') {
        defaultScrollToFirstError = scrollToFirstError;
      }
      wrapForm.scrollToField(errorInfo.errorFields[0].name, defaultScrollToFirstError);
    }
  };
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(DisabledContextProvider, {
    disabled: disabled,
    children: /*#__PURE__*/jsx$1(SizeContextProvider, {
      size: size,
      children: /*#__PURE__*/jsx$1(FormContext.Provider, {
        value: formContextValue,
        children: /*#__PURE__*/jsx$1(RefForm, {
          id: name,
          ...restFormProps,
          name: name,
          onFinishFailed: onInternalFinishFailed,
          form: wrapForm,
          className: formClassName
        })
      })
    })
  }));
};
var Form$2 = /*#__PURE__*/react.exports.forwardRef(InternalForm);
const InternalForm$1 = Form$2;

var useFormItemStatus = function useFormItemStatus() {
  var _useContext = react.exports.useContext(FormItemInputContext),
    status = _useContext.status;
  return {
    status: status
  };
};
// Only used for compatible package. Not promise this will work on future version.
useFormItemStatus.Context = FormItemInputContext;
const useFormItemStatus$1 = useFormItemStatus;

function useFrameState(defaultValue) {
  var _React$useState = react.exports.useState(defaultValue),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    value = _React$useState2[0],
    setValue = _React$useState2[1];
  var frameRef = react.exports.useRef(null);
  var batchRef = react.exports.useRef([]);
  var destroyRef = react.exports.useRef(false);
  react.exports.useEffect(function () {
    destroyRef.current = false;
    return function () {
      destroyRef.current = true;
      raf$2.cancel(frameRef.current);
      frameRef.current = null;
    };
  }, []);
  function setFrameValue(updater) {
    if (destroyRef.current) {
      return;
    }
    if (frameRef.current === null) {
      batchRef.current = [];
      frameRef.current = raf$2(function () {
        frameRef.current = null;
        setValue(function (prevValue) {
          var current = prevValue;
          batchRef.current.forEach(function (func) {
            current = func(current);
          });
          return current;
        });
      });
    }
    batchRef.current.push(updater);
  }
  return [value, setFrameValue];
}

function useItemRef() {
  var _React$useContext = react.exports.useContext(FormContext),
    itemRef = _React$useContext.itemRef;
  var cacheRef = react.exports.useRef({});
  function getRef(name, children) {
    var childrenRef = children && _typeof$1(children) === 'object' && children.ref;
    var nameStr = name.join('_');
    if (cacheRef.current.name !== nameStr || cacheRef.current.originRef !== childrenRef) {
      cacheRef.current.name = nameStr;
      cacheRef.current.originRef = childrenRef;
      cacheRef.current.ref = composeRef(itemRef(name), childrenRef);
    }
    return cacheRef.current.ref;
  }
  return getRef;
}

// This icon file is generated automatically.
var QuestionCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, "name": "question-circle", "theme": "outlined" };
const QuestionCircleOutlinedSvg = QuestionCircleOutlined$2;

var QuestionCircleOutlined = function QuestionCircleOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: QuestionCircleOutlinedSvg
      })
    })
  );
};
QuestionCircleOutlined.displayName = 'QuestionCircleOutlined';
const QuestionCircleOutlined$1 = /*#__PURE__*/react.exports.forwardRef(QuestionCircleOutlined);

var __rest$q = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function toTooltipProps(tooltip) {
  if (!tooltip) {
    return null;
  }
  if (_typeof$1(tooltip) === 'object' && ! /*#__PURE__*/react.exports.isValidElement(tooltip)) {
    return tooltip;
  }
  return {
    title: tooltip
  };
}
var FormItemLabel = function FormItemLabel(_ref) {
  var prefixCls = _ref.prefixCls,
    label = _ref.label,
    htmlFor = _ref.htmlFor,
    labelCol = _ref.labelCol,
    labelAlign = _ref.labelAlign,
    colon = _ref.colon,
    required = _ref.required,
    requiredMark = _ref.requiredMark,
    tooltip = _ref.tooltip;
  var _useLocaleReceiver = useLocaleReceiver('Form'),
    _useLocaleReceiver2 = _slicedToArray(_useLocaleReceiver, 1),
    formLocale = _useLocaleReceiver2[0];
  if (!label) return null;
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(FormContext.Consumer, {
      children: function (_ref2) {
        var _classNames2;
        var vertical = _ref2.vertical,
          contextLabelAlign = _ref2.labelAlign,
          contextLabelCol = _ref2.labelCol,
          labelWrap = _ref2.labelWrap,
          contextColon = _ref2.colon;
        var _a;
        var mergedLabelCol = labelCol || contextLabelCol || {};
        var mergedLabelAlign = labelAlign || contextLabelAlign;
        var labelClsBasic = prefixCls + "-item-label";
        var labelColClassName = classNames$1(labelClsBasic, mergedLabelAlign === 'left' && labelClsBasic + "-left", mergedLabelCol.className, _defineProperty$1({}, labelClsBasic + "-wrap", !!labelWrap));
        var labelChildren = label;
        // Keep label is original where there should have no colon
        var computedColon = colon === true || contextColon !== false && colon !== false;
        var haveColon = computedColon && !vertical;
        // Remove duplicated user input colon
        if (haveColon && typeof label === 'string' && label.trim() !== '') {
          labelChildren = label.replace(/[:|]\s*$/, '');
        }
        // Tooltip
        var tooltipProps = toTooltipProps(tooltip);
        if (tooltipProps) {
          var _tooltipProps$icon = tooltipProps.icon,
            icon = _tooltipProps$icon === void 0 ?
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1(QuestionCircleOutlined$1, {}) : _tooltipProps$icon,
            restTooltipProps = __rest$q(tooltipProps, ["icon"]);
          var tooltipNode =
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(Tooltip$1, {
            ...restTooltipProps,
            children: /*#__PURE__*/react.exports.cloneElement(icon, {
              className: prefixCls + "-item-tooltip",
              title: ''
            })
          });
          labelChildren =
          /*#__PURE__*/
          /*#__PURE__*/
          jsxs(Fragment, {
            children: [labelChildren, tooltipNode]
          });
        }
        // Add required mark if optional
        if (requiredMark === 'optional' && !required) {
          labelChildren =
          /*#__PURE__*/
          /*#__PURE__*/
          jsxs(Fragment, {
            children: [labelChildren, /*#__PURE__*/jsx$1("span", {
              className: prefixCls + "-item-optional",
              title: "",
              children: (formLocale === null || formLocale === void 0 ? void 0 : formLocale.optional) || ((_a = defaultLocale.Form) === null || _a === void 0 ? void 0 : _a.optional)
            })]
          });
        }
        var labelClassName = classNames$1((_classNames2 = {}, _defineProperty$1(_classNames2, prefixCls + "-item-required", required), _defineProperty$1(_classNames2, prefixCls + "-item-required-mark-optional", requiredMark === 'optional'), _defineProperty$1(_classNames2, prefixCls + "-item-no-colon", !computedColon), _classNames2));
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(Col$1, {
            ...mergedLabelCol,
            className: labelColClassName,
            children: /*#__PURE__*/jsx$1("label", {
              htmlFor: htmlFor,
              className: labelClassName,
              title: typeof label === 'string' ? label : '',
              children: labelChildren
            })
          })
        );
      }
    }, "label")
  );
};
const FormItemLabel$1 = FormItemLabel;

var FormItemInput = function FormItemInput(props) {
  var prefixCls = props.prefixCls,
    status = props.status,
    wrapperCol = props.wrapperCol,
    children = props.children,
    errors = props.errors,
    warnings = props.warnings,
    formItemRender = props._internalItemRender,
    extra = props.extra,
    help = props.help,
    fieldId = props.fieldId,
    marginBottom = props.marginBottom,
    onErrorVisibleChanged = props.onErrorVisibleChanged;
  var baseClassName = prefixCls + "-item";
  var formContext = react.exports.useContext(FormContext);
  var mergedWrapperCol = wrapperCol || formContext.wrapperCol || {};
  var className = classNames$1(baseClassName + "-control", mergedWrapperCol.className);
  // Pass to sub FormItem should not with col info
  var subFormContext = react.exports.useMemo(function () {
    return _extends$2({}, formContext);
  }, [formContext]);
  delete subFormContext.labelCol;
  delete subFormContext.wrapperCol;
  var inputDom =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    className: baseClassName + "-control-input",
    children: /*#__PURE__*/jsx$1("div", {
      className: baseClassName + "-control-input-content",
      children: children
    })
  });
  var formItemContext = react.exports.useMemo(function () {
    return {
      prefixCls: prefixCls,
      status: status
    };
  }, [prefixCls, status]);
  var errorListDom = marginBottom !== null || errors.length || warnings.length ?
  /*#__PURE__*/
  /*#__PURE__*/
  jsxs("div", {
    style: {
      display: 'flex',
      flexWrap: 'nowrap'
    },
    children: [/*#__PURE__*/jsx$1(FormItemPrefixContext.Provider, {
      value: formItemContext,
      children: /*#__PURE__*/jsx$1(ErrorList, {
        fieldId: fieldId,
        errors: errors,
        warnings: warnings,
        help: help,
        helpStatus: status,
        className: baseClassName + "-explain-connected",
        onVisibleChanged: onErrorVisibleChanged
      })
    }), !!marginBottom &&
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      style: {
        width: 0,
        height: marginBottom
      }
    })]
  }) : null;
  var extraProps = {};
  if (fieldId) {
    extraProps.id = fieldId + "_extra";
  }
  // If extra = 0, && will goes wrong
  // 0&&error -> 0
  var extraDom = extra ?
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    ...extraProps,
    className: baseClassName + "-extra",
    children: extra
  }) : null;
  var dom = formItemRender && formItemRender.mark === 'pro_table_render' && formItemRender.render ? formItemRender.render(props, {
    input: inputDom,
    errorList: errorListDom,
    extra: extraDom
  }) :
  /*#__PURE__*/
  /*#__PURE__*/
  jsxs(Fragment, {
    children: [inputDom, errorListDom, extraDom]
  });
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(FormContext.Provider, {
      value: subFormContext,
      children: /*#__PURE__*/jsx$1(Col$1, {
        ...mergedWrapperCol,
        className: className,
        children: dom
      })
    })
  );
};
const FormItemInput$1 = FormItemInput;

var __rest$p = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var iconMap = {
  success: CheckCircleFilled$1,
  warning: ExclamationCircleFilled$1,
  error: CloseCircleFilled$1,
  validating: LoadingOutlined$1
};
function ItemHolder(props) {
  var _itemClassName;
  var prefixCls = props.prefixCls,
    className = props.className,
    style = props.style,
    help = props.help,
    errors = props.errors,
    warnings = props.warnings,
    validateStatus = props.validateStatus,
    meta = props.meta,
    hasFeedback = props.hasFeedback,
    hidden = props.hidden,
    children = props.children,
    fieldId = props.fieldId,
    isRequired = props.isRequired,
    onSubItemMetaChange = props.onSubItemMetaChange,
    restProps = __rest$p(props, ["prefixCls", "className", "style", "help", "errors", "warnings", "validateStatus", "meta", "hasFeedback", "hidden", "children", "fieldId", "isRequired", "onSubItemMetaChange"]);
  var itemPrefixCls = prefixCls + "-item";
  var _React$useContext = react.exports.useContext(FormContext),
    requiredMark = _React$useContext.requiredMark;
  // ======================== Margin ========================
  var itemRef = react.exports.useRef(null);
  var debounceErrors = useDebounce(errors);
  var debounceWarnings = useDebounce(warnings);
  var hasHelp = help !== undefined && help !== null;
  var hasError = !!(hasHelp || errors.length || warnings.length);
  var _React$useState = react.exports.useState(null),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    marginBottom = _React$useState2[0],
    setMarginBottom = _React$useState2[1];
  useLayoutEffect$1(function () {
    if (hasError && itemRef.current) {
      var itemStyle = getComputedStyle(itemRef.current);
      setMarginBottom(parseInt(itemStyle.marginBottom, 10));
    }
  }, [hasError]);
  var onErrorVisibleChanged = function onErrorVisibleChanged(nextVisible) {
    if (!nextVisible) {
      setMarginBottom(null);
    }
  };
  // ======================== Status ========================
  var mergedValidateStatus = '';
  if (validateStatus !== undefined) {
    mergedValidateStatus = validateStatus;
  } else if (meta.validating) {
    mergedValidateStatus = 'validating';
  } else if (debounceErrors.length) {
    mergedValidateStatus = 'error';
  } else if (debounceWarnings.length) {
    mergedValidateStatus = 'warning';
  } else if (meta.touched) {
    mergedValidateStatus = 'success';
  }
  var formItemStatusContext = react.exports.useMemo(function () {
    var feedbackIcon;
    if (hasFeedback) {
      var IconNode = mergedValidateStatus && iconMap[mergedValidateStatus];
      feedbackIcon = IconNode ?
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        className: classNames$1(itemPrefixCls + "-feedback-icon", itemPrefixCls + "-feedback-icon-" + mergedValidateStatus),
        children: /*#__PURE__*/jsx$1(IconNode, {})
      }) : null;
    }
    return {
      status: mergedValidateStatus,
      hasFeedback: hasFeedback,
      feedbackIcon: feedbackIcon,
      isFormItemInput: true
    };
  }, [mergedValidateStatus, hasFeedback]);
  // ======================== Render ========================
  var itemClassName = (_itemClassName = {}, _defineProperty$1(_itemClassName, itemPrefixCls, true), _defineProperty$1(_itemClassName, itemPrefixCls + "-with-help", hasHelp || debounceErrors.length || debounceWarnings.length), _defineProperty$1(_itemClassName, "" + className, !!className), _defineProperty$1(_itemClassName, itemPrefixCls + "-has-feedback", mergedValidateStatus && hasFeedback), _defineProperty$1(_itemClassName, itemPrefixCls + "-has-success", mergedValidateStatus === 'success'), _defineProperty$1(_itemClassName, itemPrefixCls + "-has-warning", mergedValidateStatus === 'warning'), _defineProperty$1(_itemClassName, itemPrefixCls + "-has-error", mergedValidateStatus === 'error'), _defineProperty$1(_itemClassName, itemPrefixCls + "-is-validating", mergedValidateStatus === 'validating'), _defineProperty$1(_itemClassName, itemPrefixCls + "-hidden", hidden), _itemClassName);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("div", {
      className: classNames$1(itemClassName),
      style: style,
      ref: itemRef,
      children: [/*#__PURE__*/jsxs(Row$1, {
        className: itemPrefixCls + "-row",
        ...omit$1(restProps, ['_internalItemRender', 'colon', 'dependencies', 'extra', 'fieldKey', 'getValueFromEvent', 'getValueProps', 'htmlFor', 'id', 'initialValue', 'isListField', 'label', 'labelAlign', 'labelCol', 'labelWrap', 'messageVariables', 'name', 'normalize', 'noStyle', 'preserve', 'required', 'requiredMark', 'rules', 'shouldUpdate', 'trigger', 'tooltip', 'validateFirst', 'validateTrigger', 'valuePropName', 'wrapperCol']),
        children: [/*#__PURE__*/jsx$1(FormItemLabel$1, {
          htmlFor: fieldId,
          required: isRequired,
          requiredMark: requiredMark,
          ...props,
          prefixCls: prefixCls
        }), /*#__PURE__*/jsx$1(FormItemInput$1, {
          ...props,
          ...meta,
          errors: debounceErrors,
          warnings: debounceWarnings,
          prefixCls: prefixCls,
          status: mergedValidateStatus,
          help: help,
          marginBottom: marginBottom,
          onErrorVisibleChanged: onErrorVisibleChanged,
          children: /*#__PURE__*/jsx$1(NoStyleItemContext.Provider, {
            value: onSubItemMetaChange,
            children: /*#__PURE__*/jsx$1(FormItemInputContext.Provider, {
              value: formItemStatusContext,
              children: children
            })
          })
        })]
      }), !!marginBottom &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("div", {
        className: itemPrefixCls + "-margin-offset",
        style: {
          marginBottom: -marginBottom
        }
      })]
    })
  );
}

var NAME_SPLIT = '__SPLIT__';
var MemoInput = /*#__PURE__*/react.exports.memo(function (_ref) {
  var children = _ref.children;
  return children;
}, function (prev, next) {
  return prev.value === next.value && prev.update === next.update && prev.childProps.length === next.childProps.length && prev.childProps.every(function (value, index) {
    return value === next.childProps[index];
  });
});
function hasValidName(name) {
  return !(name === undefined || name === null);
}
function genEmptyMeta() {
  return {
    errors: [],
    warnings: [],
    touched: false,
    validating: false,
    name: []
  };
}
function InternalFormItem(props) {
  var name = props.name,
    noStyle = props.noStyle,
    className = props.className,
    dependencies = props.dependencies,
    customizePrefixCls = props.prefixCls,
    shouldUpdate = props.shouldUpdate,
    rules = props.rules,
    children = props.children,
    required = props.required,
    label = props.label,
    messageVariables = props.messageVariables,
    _props$trigger = props.trigger,
    trigger = _props$trigger === void 0 ? 'onChange' : _props$trigger,
    validateTrigger = props.validateTrigger,
    hidden = props.hidden;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls;
  var _React$useContext2 = react.exports.useContext(FormContext),
    formName = _React$useContext2.name;
  var isRenderProps = typeof children === 'function';
  var notifyParentMetaChange = react.exports.useContext(NoStyleItemContext);
  var _React$useContext3 = react.exports.useContext(Context$1),
    contextValidateTrigger = _React$useContext3.validateTrigger;
  var mergedValidateTrigger = validateTrigger !== undefined ? validateTrigger : contextValidateTrigger;
  var hasName = hasValidName(name);
  var prefixCls = getPrefixCls('form', customizePrefixCls);
  // Style
  var _useStyle = useStyle$a(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  // ========================= MISC =========================
  // Get `noStyle` required info
  var listContext = react.exports.useContext(ListContext);
  var fieldKeyPathRef = react.exports.useRef();
  // ======================== Errors ========================
  // >>>>> Collect sub field errors
  var _useFrameState = useFrameState({}),
    _useFrameState2 = _slicedToArray(_useFrameState, 2),
    subFieldErrors = _useFrameState2[0],
    setSubFieldErrors = _useFrameState2[1];
  // >>>>> Current field errors
  var _useState = useSafeState(function () {
      return genEmptyMeta();
    }),
    _useState2 = _slicedToArray(_useState, 2),
    meta = _useState2[0],
    setMeta = _useState2[1];
  var onMetaChange = function onMetaChange(nextMeta) {
    // This keyInfo is not correct when field is removed
    // Since origin keyManager no longer keep the origin key anymore
    // Which means we need cache origin one and reuse when removed
    var keyInfo = listContext === null || listContext === void 0 ? void 0 : listContext.getKey(nextMeta.name);
    // Destroy will reset all the meta
    setMeta(nextMeta.destroy ? genEmptyMeta() : nextMeta, true);
    // Bump to parent since noStyle
    if (noStyle && notifyParentMetaChange) {
      var namePath = nextMeta.name;
      if (!nextMeta.destroy) {
        if (keyInfo !== undefined) {
          var _keyInfo = _slicedToArray(keyInfo, 2),
            fieldKey = _keyInfo[0],
            restPath = _keyInfo[1];
          namePath = [fieldKey].concat(_toConsumableArray(restPath));
          fieldKeyPathRef.current = namePath;
        }
      } else {
        // Use origin cache data
        namePath = fieldKeyPathRef.current || namePath;
      }
      notifyParentMetaChange(nextMeta, namePath);
    }
  };
  // >>>>> Collect noStyle Field error to the top FormItem
  var onSubItemMetaChange = function onSubItemMetaChange(subMeta, uniqueKeys) {
    // Only `noStyle` sub item will trigger
    setSubFieldErrors(function (prevSubFieldErrors) {
      var clone = _extends$2({}, prevSubFieldErrors);
      // name: ['user', 1] + key: [4] = ['user', 4]
      var mergedNamePath = [].concat(_toConsumableArray(subMeta.name.slice(0, -1)), _toConsumableArray(uniqueKeys));
      var mergedNameKey = mergedNamePath.join(NAME_SPLIT);
      if (subMeta.destroy) {
        // Remove
        delete clone[mergedNameKey];
      } else {
        // Update
        clone[mergedNameKey] = subMeta;
      }
      return clone;
    });
  };
  // >>>>> Get merged errors
  var _React$useMemo = react.exports.useMemo(function () {
      var errorList = _toConsumableArray(meta.errors);
      var warningList = _toConsumableArray(meta.warnings);
      Object.values(subFieldErrors).forEach(function (subFieldError) {
        errorList.push.apply(errorList, _toConsumableArray(subFieldError.errors || []));
        warningList.push.apply(warningList, _toConsumableArray(subFieldError.warnings || []));
      });
      return [errorList, warningList];
    }, [subFieldErrors, meta.errors, meta.warnings]),
    _React$useMemo2 = _slicedToArray(_React$useMemo, 2),
    mergedErrors = _React$useMemo2[0],
    mergedWarnings = _React$useMemo2[1];
  // ===================== Children Ref =====================
  var getItemRef = useItemRef();
  // ======================== Render ========================
  function renderLayout(baseChildren, fieldId, isRequired) {
    if (noStyle && !hidden) {
      return baseChildren;
    }
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(ItemHolder, {
        ...props,
        className: classNames$1(className, hashId),
        prefixCls: prefixCls,
        fieldId: fieldId,
        isRequired: isRequired,
        errors: mergedErrors,
        warnings: mergedWarnings,
        meta: meta,
        onSubItemMetaChange: onSubItemMetaChange,
        children: baseChildren
      }, "row")
    );
  }
  if (!hasName && !isRenderProps && !dependencies) {
    return wrapSSR(renderLayout(children));
  }
  var variables = {};
  if (typeof label === 'string') {
    variables.label = label;
  } else if (name) {
    variables.label = String(name);
  }
  if (messageVariables) {
    variables = _extends$2(_extends$2({}, variables), messageVariables);
  }
  // >>>>> With Field
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(WrapperField, {
    ...props,
    messageVariables: variables,
    trigger: trigger,
    validateTrigger: mergedValidateTrigger,
    onMetaChange: onMetaChange,
    children: function (control, renderMeta, context) {
      var mergedName = toArray$3(name).length && renderMeta ? renderMeta.name : [];
      var fieldId = getFieldId(mergedName, formName);
      var isRequired = required !== undefined ? required : !!(rules && rules.some(function (rule) {
        if (rule && _typeof$1(rule) === 'object' && rule.required && !rule.warningOnly) {
          return true;
        }
        if (typeof rule === 'function') {
          var ruleEntity = rule(context);
          return ruleEntity && ruleEntity.required && !ruleEntity.warningOnly;
        }
        return false;
      }));
      // ======================= Children =======================
      var mergedControl = _extends$2({}, control);
      var childNode = null;
      if (Array.isArray(children) && hasName) {
        childNode = children;
      } else if (isRenderProps && (!(shouldUpdate || dependencies) || hasName)) ; else if (dependencies && !isRenderProps && !hasName) ; else if (isValidElement(children)) {
        var childProps = _extends$2(_extends$2({}, children.props), mergedControl);
        if (!childProps.id) {
          childProps.id = fieldId;
        }
        if (props.help || mergedErrors.length > 0 || mergedWarnings.length > 0 || props.extra) {
          var describedbyArr = [];
          if (props.help || mergedErrors.length > 0) {
            describedbyArr.push(fieldId + "_help");
          }
          if (props.extra) {
            describedbyArr.push(fieldId + "_extra");
          }
          childProps['aria-describedby'] = describedbyArr.join(' ');
        }
        if (mergedErrors.length > 0) {
          childProps['aria-invalid'] = 'true';
        }
        if (isRequired) {
          childProps['aria-required'] = 'true';
        }
        if (supportRef(children)) {
          childProps.ref = getItemRef(mergedName, children);
        }
        // We should keep user origin event handler
        var triggers = new Set([].concat(_toConsumableArray(toArray$3(trigger)), _toConsumableArray(toArray$3(mergedValidateTrigger))));
        triggers.forEach(function (eventName) {
          childProps[eventName] = function () {
            var _a2, _c2;
            var _a, _b, _c;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            (_a = mergedControl[eventName]) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [mergedControl].concat(args));
            (_c = (_b = children.props)[eventName]) === null || _c === void 0 ? void 0 : (_c2 = _c).call.apply(_c2, [_b].concat(args));
          };
        });
        // List of props that need to be watched for changes -> if changes are detected in MemoInput -> rerender
        var watchingChildProps = [childProps['aria-required'], childProps['aria-invalid'], childProps['aria-describedby']];
        childNode =
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(MemoInput, {
          value: mergedControl[props.valuePropName || 'value'],
          update: children,
          childProps: watchingChildProps,
          children: cloneElement(children, childProps)
        });
      } else if (isRenderProps && (shouldUpdate || dependencies) && !hasName) {
        childNode = children(context);
      } else {
        childNode = children;
      }
      return renderLayout(childNode, fieldId, isRequired);
    }
  }));
}
var FormItem = InternalFormItem;
FormItem.useStatus = useFormItemStatus$1;
const Item$1 = FormItem;

var __rest$o = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var FormList = function FormList(_a) {
  var customizePrefixCls = _a.prefixCls,
    children = _a.children,
    props = __rest$o(_a, ["prefixCls", "children"]);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls('form', customizePrefixCls);
  var contextValue = react.exports.useMemo(function () {
    return {
      prefixCls: prefixCls,
      status: 'error'
    };
  }, [prefixCls]);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(List$3, {
      ...props,
      children: function (fields, operation, meta) {
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(FormItemPrefixContext.Provider, {
            value: contextValue,
            children: children(fields.map(function (field) {
              return _extends$2(_extends$2({}, field), {
                fieldKey: field.key
              });
            }), operation, {
              errors: meta.errors,
              warnings: meta.warnings
            })
          })
        );
      }
    })
  );
};
const List$1 = FormList;

function useFormInstance() {
  var _useContext = react.exports.useContext(FormContext),
    form = _useContext.form;
  return form;
}

var Form = InternalForm$1;
Form.Item = Item$1;
Form.List = List$1;
Form.ErrorList = ErrorList;
Form.useForm = useForm;
Form.useFormInstance = useFormInstance;
Form.useWatch = useWatch;
Form.Provider = FormProvider;
Form.create = function () {
};
const Form$1 = Form;

// This icon file is generated automatically.
var EyeOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
const EyeOutlinedSvg = EyeOutlined$2;

var EyeOutlined = function EyeOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: EyeOutlinedSvg
      })
    })
  );
};
EyeOutlined.displayName = 'EyeOutlined';
const EyeOutlined$1 = /*#__PURE__*/react.exports.forwardRef(EyeOutlined);

/* eslint-disable no-nested-ternary */
function getOffset(node) {
  var box = node.getBoundingClientRect();
  var docElem = document.documentElement;

  // < ie8  win.pageXOffset,  docElem.scrollLeft
  return {
    left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
    top: box.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
  };
}

function getUseId() {
  // We need fully clone React function here to avoid webpack warning React 17 do not export `useId`
  var fullClone = _objectSpread2$1({}, React$1);
  return fullClone.useId;
}
var uuid$2 = 0;
function useId$1(id) {
  // Inner id for accessibility usage. Only work in client side
  var _React$useState = react.exports.useState('ssr-id'),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    innerId = _React$useState2[0],
    setInnerId = _React$useState2[1];
  var useOriginId = getUseId();
  var reactNativeId = useOriginId === null || useOriginId === void 0 ? void 0 : useOriginId();
  react.exports.useEffect(function () {
    if (!useOriginId) {
      var nextId = uuid$2;
      uuid$2 += 1;
      setInnerId("rc_unique_".concat(nextId));
    }
  }, []);
  // Developer passed id is single source of truth
  if (id) {
    return id;
  }
  // Return react native id or inner id
  return reactNativeId || innerId;
}

function Mask(props) {
  var prefixCls = props.prefixCls,
    style = props.style,
    visible = props.visible,
    maskProps = props.maskProps,
    motionName = props.motionName;
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(CSSMotion, {
      visible: visible,
      motionName: motionName,
      leavedClassName: "".concat(prefixCls, "-mask-hidden"),
      children: function (_ref, ref) {
        var motionClassName = _ref.className,
          motionStyle = _ref.style;
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("div", {
            ref: ref,
            style: _objectSpread2$1(_objectSpread2$1({}, motionStyle), style),
            className: classNames$1("".concat(prefixCls, "-mask"), motionClassName),
            ...maskProps
          })
        );
      }
    }, "mask")
  );
}

// =============================== Motion ===============================
function getMotionName(prefixCls, transitionName, animationName) {
  var motionName = transitionName;
  if (!motionName && animationName) {
    motionName = "".concat(prefixCls, "-").concat(animationName);
  }
  return motionName;
}
// =============================== Offset ===============================
function getScroll(w, top) {
  var ret = w["page".concat(top ? 'Y' : 'X', "Offset")];
  var method = "scroll".concat(top ? 'Top' : 'Left');
  if (typeof ret !== 'number') {
    var d = w.document;
    ret = d.documentElement[method];
    if (typeof ret !== 'number') {
      ret = d.body[method];
    }
  }
  return ret;
}
function offset$1(el) {
  var rect = el.getBoundingClientRect();
  var pos = {
    left: rect.left,
    top: rect.top
  };
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += getScroll(w);
  pos.top += getScroll(w, true);
  return pos;
}

const MemoChildren = /*#__PURE__*/react.exports.memo(function (_ref) {
  var children = _ref.children;
  return children;
}, function (_, _ref2) {
  var shouldUpdate = _ref2.shouldUpdate;
  return !shouldUpdate;
});

var sentinelStyle = {
  width: 0,
  height: 0,
  overflow: 'hidden',
  outline: 'none'
};
var Panel$1 = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var prefixCls = props.prefixCls,
    className = props.className,
    style = props.style,
    title = props.title,
    ariaId = props.ariaId,
    footer = props.footer,
    closable = props.closable,
    closeIcon = props.closeIcon,
    onClose = props.onClose,
    children = props.children,
    bodyStyle = props.bodyStyle,
    bodyProps = props.bodyProps,
    modalRender = props.modalRender,
    onMouseDown = props.onMouseDown,
    onMouseUp = props.onMouseUp,
    holderRef = props.holderRef,
    visible = props.visible,
    forceRender = props.forceRender,
    width = props.width,
    height = props.height;
  // ================================= Refs =================================
  var sentinelStartRef = react.exports.useRef();
  var sentinelEndRef = react.exports.useRef();
  React.useImperativeHandle(ref, function () {
    return {
      focus: function focus() {
        var _sentinelStartRef$cur;
        (_sentinelStartRef$cur = sentinelStartRef.current) === null || _sentinelStartRef$cur === void 0 ? void 0 : _sentinelStartRef$cur.focus();
      },
      changeActive: function changeActive(next) {
        var _document = document,
          activeElement = _document.activeElement;
        if (next && activeElement === sentinelEndRef.current) {
          sentinelStartRef.current.focus();
        } else if (!next && activeElement === sentinelStartRef.current) {
          sentinelEndRef.current.focus();
        }
      }
    };
  });
  // ================================ Style =================================
  var contentStyle = {};
  if (width !== undefined) {
    contentStyle.width = width;
  }
  if (height !== undefined) {
    contentStyle.height = height;
  }
  // ================================ Render ================================
  var footerNode;
  if (footer) {
    footerNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      className: "".concat(prefixCls, "-footer"),
      children: footer
    });
  }
  var headerNode;
  if (title) {
    headerNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      className: "".concat(prefixCls, "-header"),
      children: /*#__PURE__*/jsx$1("div", {
        className: "".concat(prefixCls, "-title"),
        id: ariaId,
        children: title
      })
    });
  }
  var closer;
  if (closable) {
    closer =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("button", {
      type: "button",
      onClick: onClose,
      "aria-label": "Close",
      className: "".concat(prefixCls, "-close"),
      children: closeIcon ||
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        className: "".concat(prefixCls, "-close-x")
      })
    });
  }
  var content =
  /*#__PURE__*/
  /*#__PURE__*/
  jsxs("div", {
    className: "".concat(prefixCls, "-content"),
    children: [closer, headerNode, /*#__PURE__*/jsx$1("div", {
      className: "".concat(prefixCls, "-body"),
      style: bodyStyle,
      ...bodyProps,
      children: children
    }), footerNode]
  });
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("div", {
      role: "dialog",
      "aria-labelledby": title ? ariaId : null,
      "aria-modal": "true",
      ref: holderRef,
      style: _objectSpread2$1(_objectSpread2$1({}, style), contentStyle),
      className: classNames$1(prefixCls, className),
      onMouseDown: onMouseDown,
      onMouseUp: onMouseUp,
      children: [/*#__PURE__*/jsx$1("div", {
        tabIndex: 0,
        ref: sentinelStartRef,
        style: sentinelStyle,
        "aria-hidden": "true"
      }), /*#__PURE__*/jsx$1(MemoChildren, {
        shouldUpdate: visible || forceRender,
        children: modalRender ? modalRender(content) : content
      }), /*#__PURE__*/jsx$1("div", {
        tabIndex: 0,
        ref: sentinelEndRef,
        style: sentinelStyle,
        "aria-hidden": "true"
      })]
    }, "dialog-element")
  );
});
const Panel$2 = Panel$1;

var Content = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var prefixCls = props.prefixCls,
    title = props.title,
    style = props.style,
    className = props.className,
    visible = props.visible,
    forceRender = props.forceRender,
    destroyOnClose = props.destroyOnClose,
    motionName = props.motionName,
    ariaId = props.ariaId,
    onVisibleChanged = props.onVisibleChanged,
    mousePosition = props.mousePosition;
  var dialogRef = react.exports.useRef();
  // ============================= Style ==============================
  var _React$useState = react.exports.useState(),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    transformOrigin = _React$useState2[0],
    setTransformOrigin = _React$useState2[1];
  var contentStyle = {};
  if (transformOrigin) {
    contentStyle.transformOrigin = transformOrigin;
  }
  function onPrepare() {
    var elementOffset = offset$1(dialogRef.current);
    setTransformOrigin(mousePosition ? "".concat(mousePosition.x - elementOffset.left, "px ").concat(mousePosition.y - elementOffset.top, "px") : '');
  }
  // ============================= Render =============================
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(CSSMotion, {
      visible: visible,
      onVisibleChanged: onVisibleChanged,
      onAppearPrepare: onPrepare,
      onEnterPrepare: onPrepare,
      forceRender: forceRender,
      motionName: motionName,
      removeOnLeave: destroyOnClose,
      ref: dialogRef,
      children: function (_ref, motionRef) {
        var motionClassName = _ref.className,
          motionStyle = _ref.style;
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(Panel$2, {
            ...props,
            ref: ref,
            title: title,
            ariaId: ariaId,
            prefixCls: prefixCls,
            holderRef: motionRef,
            style: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, motionStyle), style), contentStyle),
            className: classNames$1(className, motionClassName)
          })
        );
      }
    })
  );
});
Content.displayName = 'Content';

function Dialog(props) {
  var _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-dialog' : _props$prefixCls,
    zIndex = props.zIndex,
    _props$visible = props.visible,
    visible = _props$visible === void 0 ? false : _props$visible,
    _props$keyboard = props.keyboard,
    keyboard = _props$keyboard === void 0 ? true : _props$keyboard,
    _props$focusTriggerAf = props.focusTriggerAfterClose,
    focusTriggerAfterClose = _props$focusTriggerAf === void 0 ? true : _props$focusTriggerAf,
    wrapStyle = props.wrapStyle,
    wrapClassName = props.wrapClassName,
    wrapProps = props.wrapProps,
    onClose = props.onClose,
    afterClose = props.afterClose,
    transitionName = props.transitionName,
    animation = props.animation,
    _props$closable = props.closable,
    closable = _props$closable === void 0 ? true : _props$closable,
    _props$mask = props.mask,
    mask = _props$mask === void 0 ? true : _props$mask,
    maskTransitionName = props.maskTransitionName,
    maskAnimation = props.maskAnimation,
    _props$maskClosable = props.maskClosable,
    maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable,
    maskStyle = props.maskStyle,
    maskProps = props.maskProps,
    rootClassName = props.rootClassName;
  var lastOutSideActiveElementRef = react.exports.useRef();
  var wrapperRef = react.exports.useRef();
  var contentRef = react.exports.useRef();
  var _React$useState = react.exports.useState(visible),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    animatedVisible = _React$useState2[0],
    setAnimatedVisible = _React$useState2[1];
  // ========================== Init ==========================
  var ariaId = useId$1();
  function saveLastOutSideActiveElementRef() {
    if (!contains(wrapperRef.current, document.activeElement)) {
      lastOutSideActiveElementRef.current = document.activeElement;
    }
  }
  function focusDialogContent() {
    if (!contains(wrapperRef.current, document.activeElement)) {
      var _contentRef$current;
      (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 ? void 0 : _contentRef$current.focus();
    }
  }
  // ========================= Events =========================
  function onDialogVisibleChanged(newVisible) {
    // Try to focus
    if (newVisible) {
      focusDialogContent();
    } else {
      // Clean up scroll bar & focus back
      setAnimatedVisible(false);
      if (mask && lastOutSideActiveElementRef.current && focusTriggerAfterClose) {
        try {
          lastOutSideActiveElementRef.current.focus({
            preventScroll: true
          });
        } catch (e) {
          // Do nothing
        }
        lastOutSideActiveElementRef.current = null;
      }
      // Trigger afterClose only when change visible from true to false
      if (animatedVisible) {
        afterClose === null || afterClose === void 0 ? void 0 : afterClose();
      }
    }
  }
  function onInternalClose(e) {
    onClose === null || onClose === void 0 ? void 0 : onClose(e);
  }
  // >>> Content
  var contentClickRef = react.exports.useRef(false);
  var contentTimeoutRef = react.exports.useRef();
  // We need record content click incase content popup out of dialog
  var onContentMouseDown = function onContentMouseDown() {
    clearTimeout(contentTimeoutRef.current);
    contentClickRef.current = true;
  };
  var onContentMouseUp = function onContentMouseUp() {
    contentTimeoutRef.current = setTimeout(function () {
      contentClickRef.current = false;
    });
  };
  // >>> Wrapper
  // Close only when element not on dialog
  var onWrapperClick = null;
  if (maskClosable) {
    onWrapperClick = function onWrapperClick(e) {
      if (contentClickRef.current) {
        contentClickRef.current = false;
      } else if (wrapperRef.current === e.target) {
        onInternalClose(e);
      }
    };
  }
  function onWrapperKeyDown(e) {
    if (keyboard && e.keyCode === KeyCode$1.ESC) {
      e.stopPropagation();
      onInternalClose(e);
      return;
    }
    // keep focus inside dialog
    if (visible) {
      if (e.keyCode === KeyCode$1.TAB) {
        contentRef.current.changeActive(!e.shiftKey);
      }
    }
  }
  // ========================= Effect =========================
  react.exports.useEffect(function () {
    if (visible) {
      setAnimatedVisible(true);
      saveLastOutSideActiveElementRef();
    }
  }, [visible]);
  // Remove direct should also check the scroll bar update
  react.exports.useEffect(function () {
    return function () {
      clearTimeout(contentTimeoutRef.current);
    };
  }, []);
  // ========================= Render =========================
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("div", {
      className: classNames$1("".concat(prefixCls, "-root"), rootClassName),
      ...pickAttrs(props, {
        data: true
      }),
      children: [/*#__PURE__*/jsx$1(Mask, {
        prefixCls: prefixCls,
        visible: mask && visible,
        motionName: getMotionName(prefixCls, maskTransitionName, maskAnimation),
        style: _objectSpread2$1({
          zIndex: zIndex
        }, maskStyle),
        maskProps: maskProps
      }), /*#__PURE__*/jsx$1("div", {
        tabIndex: -1,
        onKeyDown: onWrapperKeyDown,
        className: classNames$1("".concat(prefixCls, "-wrap"), wrapClassName),
        ref: wrapperRef,
        onClick: onWrapperClick,
        style: _objectSpread2$1(_objectSpread2$1({
          zIndex: zIndex
        }, wrapStyle), {}, {
          display: !animatedVisible ? 'none' : null
        }),
        ...wrapProps,
        children: /*#__PURE__*/jsx$1(Content, {
          ...props,
          onMouseDown: onContentMouseDown,
          onMouseUp: onContentMouseUp,
          ref: contentRef,
          closable: closable,
          ariaId: ariaId,
          prefixCls: prefixCls,
          visible: visible && animatedVisible,
          onClose: onInternalClose,
          onVisibleChanged: onDialogVisibleChanged,
          motionName: getMotionName(prefixCls, transitionName, animation)
        })
      })]
    })
  );
}

var DialogWrap = function DialogWrap(props) {
  var visible = props.visible,
    getContainer = props.getContainer,
    forceRender = props.forceRender,
    _props$destroyOnClose = props.destroyOnClose,
    destroyOnClose = _props$destroyOnClose === void 0 ? false : _props$destroyOnClose,
    _afterClose = props.afterClose;
  var _React$useState = react.exports.useState(visible),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    animatedVisible = _React$useState2[0],
    setAnimatedVisible = _React$useState2[1];
  react.exports.useEffect(function () {
    if (visible) {
      setAnimatedVisible(true);
    }
  }, [visible]);
  // //  dom 
  // if (getContainer === false) {
  //   return (
  //     <Dialog
  //       {...props}
  //       getOpenCount={() => 2} //  body 
  //     />
  //   );
  // }
  // Destroy on close will remove wrapped div
  if (!forceRender && destroyOnClose && !animatedVisible) {
    return null;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Portal, {
      open: visible || forceRender || animatedVisible,
      autoDestroy: false,
      getContainer: getContainer,
      autoLock: visible || animatedVisible,
      children: /*#__PURE__*/jsx$1(Dialog, {
        ...props,
        destroyOnClose: destroyOnClose,
        afterClose: function afterClose() {
          _afterClose === null || _afterClose === void 0 ? void 0 : _afterClose();
          setAnimatedVisible(false);
        }
      })
    })
  );
};
DialogWrap.displayName = 'Dialog';

function box(position) {
  return {
    position: position,
    top: 0,
    insetInlineEnd: 0,
    bottom: 0,
    insetInlineStart: 0
  };
}
var genModalMaskStyle = function genModalMaskStyle(token) {
  var _ref;
  var componentCls = token.componentCls;
  return [_defineProperty$1({}, componentCls + "-root", (_ref = {}, _defineProperty$1(_ref, "" + componentCls + token.antCls + "-zoom-enter, " + componentCls + token.antCls + "-zoom-appear", {
    // reset scale avoid mousePosition bug
    transform: 'none',
    opacity: 0,
    animationDuration: token.motionDurationSlow,
    // https://github.com/ant-design/ant-design/issues/11777
    userSelect: 'none'
  }), _defineProperty$1(_ref, componentCls + "-mask", _extends$2(_extends$2({}, box('fixed')), _defineProperty$1({
    zIndex: token.zIndexPopupBase,
    height: '100%',
    backgroundColor: token.colorBgMask
  }, componentCls + "-hidden", {
    display: 'none'
  }))), _defineProperty$1(_ref, componentCls + "-wrap", _extends$2(_extends$2({}, box('fixed')), {
    overflow: 'auto',
    outline: 0,
    WebkitOverflowScrolling: 'touch'
  })), _ref)), _defineProperty$1({}, componentCls + "-root", initFadeMotion(token))];
};
var genModalStyle = function genModalStyle(token) {
  var _ref6, _ref7, _extends3, _ref11;
  var componentCls = token.componentCls;
  return [// ======================== Root =========================
  _defineProperty$1({}, componentCls + "-root", (_ref7 = {}, _defineProperty$1(_ref7, componentCls + "-wrap", {
    zIndex: token.zIndexPopupBase,
    position: 'fixed',
    inset: 0,
    overflow: 'auto',
    outline: 0,
    WebkitOverflowScrolling: 'touch'
  }), _defineProperty$1(_ref7, componentCls + "-wrap-rtl", {
    direction: 'rtl'
  }), _defineProperty$1(_ref7, componentCls + "-centered", _defineProperty$1({
    textAlign: 'center',
    '&::before': {
      display: 'inline-block',
      width: 0,
      height: '100%',
      verticalAlign: 'middle',
      content: '""'
    }
  }, componentCls, {
    top: 0,
    display: 'inline-block',
    paddingBottom: 0,
    textAlign: 'start',
    verticalAlign: 'middle'
  })), _defineProperty$1(_ref7, "@media (max-width: " + token.screenSMMax + ")", (_ref6 = {}, _defineProperty$1(_ref6, componentCls, {
    maxWidth: 'calc(100vw - 16px)',
    margin: token.marginXS + " auto"
  }), _defineProperty$1(_ref6, componentCls + "-centered", _defineProperty$1({}, componentCls, {
    flex: 1
  })), _ref6)), _ref7)), // ======================== Modal ========================
  _defineProperty$1({}, componentCls, _extends$2(_extends$2({}, resetComponent(token)), (_extends3 = {
    pointerEvents: 'none',
    position: 'relative',
    top: 100,
    width: 'auto',
    maxWidth: "calc(100vw - " + token.margin * 2 + "px)",
    margin: '0 auto',
    paddingBottom: token.paddingLG
  }, _defineProperty$1(_extends3, componentCls + "-title", {
    margin: 0,
    color: token.modalHeadingColor,
    fontWeight: token.fontWeightStrong,
    fontSize: token.modalHeaderTitleFontSize,
    lineHeight: token.modalHeaderTitleLineHeight,
    wordWrap: 'break-word'
  }), _defineProperty$1(_extends3, componentCls + "-content", {
    position: 'relative',
    backgroundColor: token.modalContentBg,
    backgroundClip: 'padding-box',
    border: 0,
    borderRadius: token.borderRadiusLG,
    boxShadow: token.boxShadowSecondary,
    pointerEvents: 'auto',
    padding: token.paddingMD + "px " + token.paddingContentHorizontalLG + "px"
  }), _defineProperty$1(_extends3, componentCls + "-close", _extends$2({
    position: 'absolute',
    top: (token.modalHeaderCloseSize - token.modalCloseBtnSize) / 2,
    insetInlineEnd: (token.modalHeaderCloseSize - token.modalCloseBtnSize) / 2,
    zIndex: token.zIndexPopupBase + 10,
    padding: 0,
    color: token.modalCloseColor,
    fontWeight: token.fontWeightStrong,
    lineHeight: 1,
    textDecoration: 'none',
    background: 'transparent',
    borderRadius: token.borderRadiusSM,
    width: token.modalConfirmIconSize,
    height: token.modalConfirmIconSize,
    border: 0,
    outline: 0,
    cursor: 'pointer',
    transition: "color " + token.motionDurationMid + ", background-color " + token.motionDurationMid,
    '&-x': {
      display: 'block',
      fontSize: token.fontSizeLG,
      fontStyle: 'normal',
      lineHeight: token.modalCloseBtnSize + "px",
      textAlign: 'center',
      textTransform: 'none',
      textRendering: 'auto'
    },
    '&:hover': {
      color: token.modalIconHoverColor,
      backgroundColor: token.wireframe ? 'transparent' : token.colorFillContent,
      textDecoration: 'none'
    },
    '&:active': {
      backgroundColor: token.wireframe ? 'transparent' : token.colorFillContentHover
    }
  }, genFocusStyle(token))), _defineProperty$1(_extends3, componentCls + "-header", {
    color: token.colorText,
    background: token.modalHeaderBg,
    borderRadius: token.borderRadiusLG + "px " + token.borderRadiusLG + "px 0 0",
    marginBottom: token.marginXS
  }), _defineProperty$1(_extends3, componentCls + "-body", {
    fontSize: token.fontSize,
    lineHeight: token.lineHeight,
    wordWrap: 'break-word'
  }), _defineProperty$1(_extends3, componentCls + "-footer", _defineProperty$1({
    textAlign: 'end',
    background: token.modalFooterBg,
    marginTop: token.marginSM
  }, token.antCls + "-btn + " + token.antCls + "-btn:not(" + token.antCls + "-dropdown-trigger)", {
    marginBottom: 0,
    marginInlineStart: token.marginXS
  })), _defineProperty$1(_extends3, componentCls + "-open", {
    overflow: 'hidden'
  }), _extends3))), // ======================== Pure =========================
  _defineProperty$1({}, componentCls + "-pure-panel", (_ref11 = {
    top: 'auto',
    padding: 0,
    display: 'flex',
    flexDirection: 'column'
  }, _defineProperty$1(_ref11, componentCls + "-content,\n          " + componentCls + "-body,\n          " + componentCls + "-confirm-body-wrapper", {
    display: 'flex',
    flexDirection: 'column',
    flex: 'auto'
  }), _defineProperty$1(_ref11, componentCls + "-confirm-body", {
    marginBottom: 'auto'
  }), _ref11))];
};
var genModalConfirmStyle = function genModalConfirmStyle(token) {
  var _ref14, _ref15, _confirmComponentCls, _ref17;
  var componentCls = token.componentCls;
  var confirmComponentCls = componentCls + "-confirm";
  return _ref17 = {}, _defineProperty$1(_ref17, confirmComponentCls, (_confirmComponentCls = {
    '&-rtl': {
      direction: 'rtl'
    }
  }, _defineProperty$1(_confirmComponentCls, token.antCls + "-modal-header", {
    display: 'none'
  }), _defineProperty$1(_confirmComponentCls, confirmComponentCls + "-body-wrapper", _extends$2({}, clearFix())), _defineProperty$1(_confirmComponentCls, confirmComponentCls + "-body", (_ref15 = {
    display: 'flex',
    flexWrap: 'wrap',
    alignItems: 'center'
  }, _defineProperty$1(_ref15, confirmComponentCls + "-title", _defineProperty$1({
    flex: '0 0 100%',
    display: 'block',
    // create BFC to avoid
    // https://user-images.githubusercontent.com/507615/37702510-ba844e06-2d2d-11e8-9b67-8e19be57f445.png
    overflow: 'hidden',
    color: token.colorTextHeading,
    fontWeight: token.fontWeightStrong,
    fontSize: token.modalHeaderTitleFontSize,
    lineHeight: token.modalHeaderTitleLineHeight
  }, "+ " + confirmComponentCls + "-content", {
    marginBlockStart: token.marginXS,
    flexBasis: '100%',
    maxWidth: "calc(100% - " + (token.modalConfirmIconSize + token.marginSM) + "px)"
  })), _defineProperty$1(_ref15, confirmComponentCls + "-content", {
    color: token.colorText,
    fontSize: token.fontSize
  }), _defineProperty$1(_ref15, "> " + token.iconCls, (_ref14 = {
    flex: 'none',
    marginInlineEnd: token.marginSM,
    fontSize: token.modalConfirmIconSize
  }, _defineProperty$1(_ref14, "+ " + confirmComponentCls + "-title", {
    flex: 1
  }), _defineProperty$1(_ref14, "+ " + confirmComponentCls + "-title + " + confirmComponentCls + "-content", {
    marginInlineStart: token.modalConfirmIconSize + token.marginSM
  }), _ref14)), _ref15)), _defineProperty$1(_confirmComponentCls, confirmComponentCls + "-btns", _defineProperty$1({
    textAlign: 'end',
    marginTop: token.marginSM
  }, token.antCls + "-btn + " + token.antCls + "-btn", {
    marginBottom: 0,
    marginInlineStart: token.marginXS
  })), _confirmComponentCls)), _defineProperty$1(_ref17, confirmComponentCls + "-error " + confirmComponentCls + "-body > " + token.iconCls, {
    color: token.colorError
  }), _defineProperty$1(_ref17, confirmComponentCls + "-warning " + confirmComponentCls + "-body > " + token.iconCls + ",\n        " + confirmComponentCls + "-confirm " + confirmComponentCls + "-body > " + token.iconCls, {
    color: token.colorWarning
  }), _defineProperty$1(_ref17, confirmComponentCls + "-info " + confirmComponentCls + "-body > " + token.iconCls, {
    color: token.colorInfo
  }), _defineProperty$1(_ref17, confirmComponentCls + "-success " + confirmComponentCls + "-body > " + token.iconCls, {
    color: token.colorSuccess
  }), _defineProperty$1(_ref17, componentCls + "-zoom-leave " + componentCls + "-btns", {
    pointerEvents: 'none'
  }), _ref17;
};
var genRTLStyle = function genRTLStyle(token) {
  var componentCls = token.componentCls;
  return _defineProperty$1({}, componentCls + "-root", _defineProperty$1({}, componentCls + "-wrap-rtl", _defineProperty$1({
    direction: 'rtl'
  }, componentCls + "-confirm-body", {
    direction: 'rtl'
  })));
};
var genWireframeStyle = function genWireframeStyle(token) {
  var _componentCls, _confirmComponentCls2, _ref23;
  var componentCls = token.componentCls,
    antCls = token.antCls;
  var confirmComponentCls = componentCls + "-confirm";
  return _ref23 = {}, _defineProperty$1(_ref23, componentCls, (_componentCls = {}, _defineProperty$1(_componentCls, componentCls + "-content", {
    padding: 0
  }), _defineProperty$1(_componentCls, componentCls + "-header", {
    padding: token.modalHeaderPadding,
    borderBottom: token.modalHeaderBorderWidth + "px " + token.modalHeaderBorderStyle + " " + token.modalHeaderBorderColorSplit,
    marginBottom: 0
  }), _defineProperty$1(_componentCls, componentCls + "-body", {
    padding: token.modalBodyPadding
  }), _defineProperty$1(_componentCls, componentCls + "-footer", {
    padding: token.modalFooterPaddingVertical + "px " + token.modalFooterPaddingHorizontal + "px",
    borderTop: token.modalFooterBorderWidth + "px " + token.modalFooterBorderStyle + " " + token.modalFooterBorderColorSplit,
    borderRadius: "0 0 " + token.borderRadiusLG + "px " + token.borderRadiusLG + "px",
    marginTop: 0
  }), _componentCls)), _defineProperty$1(_ref23, confirmComponentCls, (_confirmComponentCls2 = {}, _defineProperty$1(_confirmComponentCls2, antCls + "-modal-body", {
    padding: token.padding * 2 + "px " + token.padding * 2 + "px " + token.paddingLG + "px"
  }), _defineProperty$1(_confirmComponentCls2, confirmComponentCls + "-body", _defineProperty$1({}, "> " + token.iconCls, _defineProperty$1({
    marginInlineEnd: token.margin
  }, "+ " + confirmComponentCls + "-title + " + confirmComponentCls + "-content", {
    marginInlineStart: token.modalConfirmIconSize + token.margin
  }))), _defineProperty$1(_confirmComponentCls2, confirmComponentCls + "-btns", {
    marginTop: token.marginLG
  }), _confirmComponentCls2)), _ref23;
};
// ============================== Export ==============================
const useStyle$9 = genComponentStyleHook('Modal', function (token) {
  var headerPaddingVertical = token.padding;
  var headerFontSize = token.fontSizeHeading5;
  var headerLineHeight = token.lineHeightHeading5;
  var modalToken = merge$2(token, {
    modalBodyPadding: token.paddingLG,
    modalHeaderBg: token.colorBgElevated,
    modalHeaderPadding: headerPaddingVertical + "px " + token.paddingLG + "px",
    modalHeaderBorderWidth: token.lineWidth,
    modalHeaderBorderStyle: token.lineType,
    modalHeaderTitleLineHeight: headerLineHeight,
    modalHeaderTitleFontSize: headerFontSize,
    modalHeaderBorderColorSplit: token.colorSplit,
    modalHeaderCloseSize: headerLineHeight * headerFontSize + headerPaddingVertical * 2,
    modalContentBg: token.colorBgElevated,
    modalHeadingColor: token.colorTextHeading,
    modalCloseColor: token.colorTextDescription,
    modalFooterBg: 'transparent',
    modalFooterBorderColorSplit: token.colorSplit,
    modalFooterBorderStyle: token.lineType,
    modalFooterPaddingVertical: token.paddingXS,
    modalFooterPaddingHorizontal: token.padding,
    modalFooterBorderWidth: token.lineWidth,
    modalConfirmTitleFontSize: token.fontSizeLG,
    modalIconHoverColor: token.colorIconHover,
    modalConfirmIconSize: token.fontSize * token.lineHeight,
    modalCloseBtnSize: token.controlHeightLG * 0.55
  });
  return [genModalStyle(modalToken), genModalConfirmStyle(modalToken), genRTLStyle(modalToken), genModalMaskStyle(modalToken), token.wireframe && genWireframeStyle(modalToken), initZoomMotion(modalToken, 'zoom')];
});

var Group$1 = function Group(props) {
  var _classNames;
  var _useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _useContext.getPrefixCls,
    direction = _useContext.direction;
  var customizePrefixCls = props.prefixCls,
    _props$className = props.className,
    className = _props$className === void 0 ? '' : _props$className;
  var prefixCls = getPrefixCls('input-group', customizePrefixCls);
  var inputPrefixCls = getPrefixCls('input');
  var _useStyle = useStyle$f(inputPrefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var cls = classNames$1(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-lg", props.size === 'large'), _defineProperty$1(_classNames, prefixCls + "-sm", props.size === 'small'), _defineProperty$1(_classNames, prefixCls + "-compact", props.compact), _defineProperty$1(_classNames, prefixCls + "-rtl", direction === 'rtl'), _classNames), hashId, className);
  var formItemContext = react.exports.useContext(FormItemInputContext);
  var groupFormItemContext = react.exports.useMemo(function () {
    return _extends$2(_extends$2({}, formItemContext), {
      isFormItemInput: false
    });
  }, [formItemContext]);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("span", {
    className: cls,
    style: props.style,
    onMouseEnter: props.onMouseEnter,
    onMouseLeave: props.onMouseLeave,
    onFocus: props.onFocus,
    onBlur: props.onBlur,
    children: /*#__PURE__*/jsx$1(FormItemInputContext.Provider, {
      value: groupFormItemContext,
      children: props.children
    })
  }));
};
const Group$2 = Group$1;

function hasAddon$1(props) {
  return !!(props.addonBefore || props.addonAfter);
}
function hasPrefixSuffix$1(props) {
  return !!(props.prefix || props.suffix || props.allowClear);
}
function resolveOnChange$1(target, e, onChange, targetValue) {
  if (!onChange) {
    return;
  }

  var event = e;

  if (e.type === 'click') {
    // Clone a new target for event.
    // Avoid the following usage, the setQuery method gets the original value.
    //
    // const [query, setQuery] = React.useState('');
    // <Input
    //   allowClear
    //   value={query}
    //   onChange={(e)=> {
    //     setQuery((prevStatus) => e.target.value);
    //   }}
    // />
    var currentTarget = target.cloneNode(true); // click clear icon

    event = Object.create(e, {
      target: {
        value: currentTarget
      },
      currentTarget: {
        value: currentTarget
      }
    });
    currentTarget.value = '';
    onChange(event);
    return;
  } // Trigger by composition event, this means we need force change the input value


  if (targetValue !== undefined) {
    event = Object.create(e, {
      target: {
        value: target
      },
      currentTarget: {
        value: target
      }
    });
    target.value = targetValue;
    onChange(event);
    return;
  }

  onChange(event);
}
function triggerFocus$1(element, option) {
  if (!element) return;
  element.focus(option); // Selection content

  var _ref = option || {},
      cursor = _ref.cursor;

  if (cursor) {
    var len = element.value.length;

    switch (cursor) {
      case 'start':
        element.setSelectionRange(0, 0);
        break;

      case 'end':
        element.setSelectionRange(len, len);
        break;

      default:
        element.setSelectionRange(0, len);
    }
  }
}
function fixControlledValue$1(value) {
  if (typeof value === 'undefined' || value === null) {
    return '';
  }

  return String(value);
}

var BaseInput = function BaseInput(props) {
  var inputElement = props.inputElement,
    prefixCls = props.prefixCls,
    prefix = props.prefix,
    suffix = props.suffix,
    addonBefore = props.addonBefore,
    addonAfter = props.addonAfter,
    className = props.className,
    style = props.style,
    affixWrapperClassName = props.affixWrapperClassName,
    groupClassName = props.groupClassName,
    wrapperClassName = props.wrapperClassName,
    disabled = props.disabled,
    readOnly = props.readOnly,
    focused = props.focused,
    triggerFocus = props.triggerFocus,
    allowClear = props.allowClear,
    value = props.value,
    handleReset = props.handleReset,
    hidden = props.hidden;
  var containerRef = react.exports.useRef(null);
  var onInputClick = function onInputClick(e) {
    var _containerRef$current;
    if ((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(e.target)) {
      triggerFocus === null || triggerFocus === void 0 ? void 0 : triggerFocus();
    }
  }; // ================== Clear Icon ================== //

  var getClearIcon = function getClearIcon() {
    var _classNames;
    if (!allowClear) {
      return null;
    }
    var needClear = !disabled && !readOnly && value;
    var clearIconCls = "".concat(prefixCls, "-clear-icon");
    var iconNode = _typeof$1(allowClear) === 'object' && allowClear !== null && allowClear !== void 0 && allowClear.clearIcon ? allowClear.clearIcon : '';
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        onClick: handleReset,
        onMouseDown: function onMouseDown(e) {
          return e.preventDefault();
        },
        className: classNames$1(clearIconCls, (_classNames = {}, _defineProperty$1(_classNames, "".concat(clearIconCls, "-hidden"), !needClear), _defineProperty$1(_classNames, "".concat(clearIconCls, "-has-suffix"), !!suffix), _classNames)),
        role: "button",
        tabIndex: -1,
        children: iconNode
      })
    );
  };
  var element = /*#__PURE__*/react.exports.cloneElement(inputElement, {
    value: value,
    hidden: hidden
  }); // ================== Prefix & Suffix ================== //

  if (hasPrefixSuffix$1(props)) {
    var _classNames2;
    var affixWrapperPrefixCls = "".concat(prefixCls, "-affix-wrapper");
    var affixWrapperCls = classNames$1(affixWrapperPrefixCls, (_classNames2 = {}, _defineProperty$1(_classNames2, "".concat(affixWrapperPrefixCls, "-disabled"), disabled), _defineProperty$1(_classNames2, "".concat(affixWrapperPrefixCls, "-focused"), focused), _defineProperty$1(_classNames2, "".concat(affixWrapperPrefixCls, "-readonly"), readOnly), _defineProperty$1(_classNames2, "".concat(affixWrapperPrefixCls, "-input-with-clear-btn"), suffix && allowClear && value), _classNames2), !hasAddon$1(props) && className, affixWrapperClassName);
    var suffixNode = (suffix || allowClear) &&
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("span", {
      className: "".concat(prefixCls, "-suffix"),
      children: [getClearIcon(), suffix]
    });
    element =
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("span", {
      className: affixWrapperCls,
      style: style,
      hidden: !hasAddon$1(props) && hidden,
      onClick: onInputClick,
      ref: containerRef,
      children: [prefix &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        className: "".concat(prefixCls, "-prefix"),
        children: prefix
      }), /*#__PURE__*/react.exports.cloneElement(inputElement, {
        style: null,
        value: value,
        hidden: null
      }), suffixNode]
    });
  } // ================== Addon ================== //

  if (hasAddon$1(props)) {
    var wrapperCls = "".concat(prefixCls, "-group");
    var addonCls = "".concat(wrapperCls, "-addon");
    var mergedWrapperClassName = classNames$1("".concat(prefixCls, "-wrapper"), wrapperCls, wrapperClassName);
    var mergedGroupClassName = classNames$1("".concat(prefixCls, "-group-wrapper"), className, groupClassName); // Need another wrapper for changing display:table to display:inline-block
    // and put style prop in wrapper

    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        className: mergedGroupClassName,
        style: style,
        hidden: hidden,
        children: /*#__PURE__*/jsxs("span", {
          className: mergedWrapperClassName,
          children: [addonBefore &&
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("span", {
            className: addonCls,
            children: addonBefore
          }), /*#__PURE__*/react.exports.cloneElement(element, {
            style: null,
            hidden: null
          }), addonAfter &&
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("span", {
            className: addonCls,
            children: addonAfter
          })]
        })
      })
    );
  }
  return element;
};

var _excluded$l = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "type", "inputClassName"];
var Input$4 = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var autoComplete = props.autoComplete,
    onChange = props.onChange,
    onFocus = props.onFocus,
    onBlur = props.onBlur,
    onPressEnter = props.onPressEnter,
    onKeyDown = props.onKeyDown,
    _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-input' : _props$prefixCls,
    disabled = props.disabled,
    htmlSize = props.htmlSize,
    className = props.className,
    maxLength = props.maxLength,
    suffix = props.suffix,
    showCount = props.showCount,
    _props$type = props.type,
    type = _props$type === void 0 ? 'text' : _props$type,
    inputClassName = props.inputClassName,
    rest = _objectWithoutProperties(props, _excluded$l);
  var _useMergedState = useMergedState$1(props.defaultValue, {
      value: props.value
    }),
    _useMergedState2 = _slicedToArray(_useMergedState, 2),
    value = _useMergedState2[0],
    setValue = _useMergedState2[1];
  var _useState = react.exports.useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    focused = _useState2[0],
    setFocused = _useState2[1];
  var inputRef = react.exports.useRef(null);
  var focus = function focus(option) {
    if (inputRef.current) {
      triggerFocus$1(inputRef.current, option);
    }
  };
  react.exports.useImperativeHandle(ref, function () {
    return {
      focus: focus,
      blur: function blur() {
        var _inputRef$current;
        (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.blur();
      },
      setSelectionRange: function setSelectionRange(start, end, direction) {
        var _inputRef$current2;
        (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.setSelectionRange(start, end, direction);
      },
      select: function select() {
        var _inputRef$current3;
        (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.select();
      },
      input: inputRef.current
    };
  });
  react.exports.useEffect(function () {
    setFocused(function (prev) {
      return prev && disabled ? false : prev;
    });
  }, [disabled]);
  var handleChange = function handleChange(e) {
    if (props.value === undefined) {
      setValue(e.target.value);
    }
    if (inputRef.current) {
      resolveOnChange$1(inputRef.current, e, onChange);
    }
  };
  var handleKeyDown = function handleKeyDown(e) {
    if (onPressEnter && e.key === 'Enter') {
      onPressEnter(e);
    }
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e);
  };
  var handleFocus = function handleFocus(e) {
    setFocused(true);
    onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
  };
  var handleBlur = function handleBlur(e) {
    setFocused(false);
    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
  };
  var handleReset = function handleReset(e) {
    setValue('');
    focus();
    if (inputRef.current) {
      resolveOnChange$1(inputRef.current, e, onChange);
    }
  };
  var getInputElement = function getInputElement() {
    // Fix https://fb.me/react-unknown-prop
    var otherProps = omit(props, ['prefixCls', 'onPressEnter', 'addonBefore', 'addonAfter', 'prefix', 'suffix', 'allowClear',
    // Input elements must be either controlled or uncontrolled,
    // specify either the value prop, or the defaultValue prop, but not both.
    'defaultValue', 'showCount', 'affixWrapperClassName', 'groupClassName', 'inputClassName', 'wrapperClassName', 'htmlSize']);
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("input", {
        autoComplete: autoComplete,
        ...otherProps,
        onChange: handleChange,
        onFocus: handleFocus,
        onBlur: handleBlur,
        onKeyDown: handleKeyDown,
        className: classNames$1(prefixCls, _defineProperty$1({}, "".concat(prefixCls, "-disabled"), disabled), inputClassName, !hasAddon$1(props) && !hasPrefixSuffix$1(props) && className),
        ref: inputRef,
        size: htmlSize,
        type: type
      })
    );
  };
  var getSuffix = function getSuffix() {
    // Max length value
    var hasMaxLength = Number(maxLength) > 0;
    if (suffix || showCount) {
      var val = fixControlledValue$1(value);
      var valueLength = _toConsumableArray(val).length;
      var dataCount = _typeof$1(showCount) === 'object' ? showCount.formatter({
        value: val,
        count: valueLength,
        maxLength: maxLength
      }) : "".concat(valueLength).concat(hasMaxLength ? " / ".concat(maxLength) : '');
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsxs(Fragment, {
          children: [!!showCount &&
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("span", {
            className: classNames$1("".concat(prefixCls, "-show-count-suffix"), _defineProperty$1({}, "".concat(prefixCls, "-show-count-has-suffix"), !!suffix)),
            children: dataCount
          }), suffix]
        })
      );
    }
    return null;
  };
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(BaseInput, {
      ...rest,
      prefixCls: prefixCls,
      className: className,
      inputElement: getInputElement(),
      handleReset: handleReset,
      value: fixControlledValue$1(value),
      focused: focused,
      triggerFocus: focus,
      suffix: getSuffix(),
      disabled: disabled
    })
  );
});

function useRemovePasswordTimeout(inputRef, triggerOnMount) {
  var removePasswordTimeoutRef = react.exports.useRef([]);
  var removePasswordTimeout = function removePasswordTimeout() {
    removePasswordTimeoutRef.current.push(setTimeout(function () {
      var _a, _b, _c, _d;
      if (((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) && ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.input.getAttribute('type')) === 'password' && ((_c = inputRef.current) === null || _c === void 0 ? void 0 : _c.input.hasAttribute('value'))) {
        (_d = inputRef.current) === null || _d === void 0 ? void 0 : _d.input.removeAttribute('value');
      }
    }));
  };
  react.exports.useEffect(function () {
    if (triggerOnMount) {
      removePasswordTimeout();
    }
    return function () {
      return removePasswordTimeoutRef.current.forEach(function (timer) {
        if (timer) {
          clearTimeout(timer);
        }
      });
    };
  }, []);
  return removePasswordTimeout;
}

// eslint-disable-next-line import/prefer-default-export
function hasPrefixSuffix(props) {
  return !!(props.prefix || props.suffix || props.allowClear);
}

var __rest$n = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function fixControlledValue(value) {
  if (typeof value === 'undefined' || value === null) {
    return '';
  }
  return String(value);
}
function resolveOnChange(target, e, onChange, targetValue) {
  if (!onChange) {
    return;
  }
  var event = e;
  if (e.type === 'click') {
    // Clone a new target for event.
    // Avoid the following usage, the setQuery method gets the original value.
    //
    // const [query, setQuery] = React.useState('');
    // <Input
    //   allowClear
    //   value={query}
    //   onChange={(e)=> {
    //     setQuery((prevStatus) => e.target.value);
    //   }}
    // />
    var currentTarget = target.cloneNode(true);
    // click clear icon
    event = Object.create(e, {
      target: {
        value: currentTarget
      },
      currentTarget: {
        value: currentTarget
      }
    });
    currentTarget.value = '';
    onChange(event);
    return;
  }
  // Trigger by composition event, this means we need force change the input value
  if (targetValue !== undefined) {
    event = Object.create(e, {
      target: {
        value: target
      },
      currentTarget: {
        value: target
      }
    });
    target.value = targetValue;
    onChange(event);
    return;
  }
  onChange(event);
}
function triggerFocus(element, option) {
  if (!element) {
    return;
  }
  element.focus(option);
  // Selection content
  var _ref = option || {},
    cursor = _ref.cursor;
  if (cursor) {
    var len = element.value.length;
    switch (cursor) {
      case 'start':
        element.setSelectionRange(0, 0);
        break;
      case 'end':
        element.setSelectionRange(len, len);
        break;
      default:
        element.setSelectionRange(0, len);
        break;
    }
  }
}
var Input$3 = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _classNames, _classNames2, _classNames4;
  var customizePrefixCls = props.prefixCls,
    _props$bordered = props.bordered,
    bordered = _props$bordered === void 0 ? true : _props$bordered,
    customStatus = props.status,
    customSize = props.size,
    customDisabled = props.disabled,
    onBlur = props.onBlur,
    onFocus = props.onFocus,
    suffix = props.suffix,
    allowClear = props.allowClear,
    addonAfter = props.addonAfter,
    addonBefore = props.addonBefore,
    className = props.className,
    onChange = props.onChange,
    rest = __rest$n(props, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "className", "onChange"]);
  var _React$useContext = React.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction,
    input = _React$useContext.input;
  var prefixCls = getPrefixCls('input', customizePrefixCls);
  var inputRef = react.exports.useRef(null);
  // Style
  var _useStyle = useStyle$f(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  // ===================== Compact Item =====================
  var _useCompactItemContex = useCompactItemContext(prefixCls, direction),
    compactSize = _useCompactItemContex.compactSize,
    compactItemClassnames = _useCompactItemContex.compactItemClassnames;
  // ===================== Size =====================
  var size = React.useContext(SizeContext);
  var mergedSize = compactSize || customSize || size;
  // ===================== Disabled =====================
  var disabled = React.useContext(DisabledContext);
  var mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
  // ===================== Status =====================
  var _useContext = react.exports.useContext(FormItemInputContext),
    contextStatus = _useContext.status,
    hasFeedback = _useContext.hasFeedback,
    feedbackIcon = _useContext.feedbackIcon;
  var mergedStatus = getMergedStatus(contextStatus, customStatus);
  // ===================== Focus warning =====================
  var inputHasPrefixSuffix = hasPrefixSuffix(props) || !!hasFeedback;
  var prevHasPrefixSuffix = react.exports.useRef(inputHasPrefixSuffix);
  react.exports.useEffect(function () {
    if (inputHasPrefixSuffix && !prevHasPrefixSuffix.current) ;
    prevHasPrefixSuffix.current = inputHasPrefixSuffix;
  }, [inputHasPrefixSuffix]);
  // ===================== Remove Password value =====================
  var removePasswordTimeout = useRemovePasswordTimeout(inputRef, true);
  var handleBlur = function handleBlur(e) {
    removePasswordTimeout();
    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
  };
  var handleFocus = function handleFocus(e) {
    removePasswordTimeout();
    onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
  };
  var handleChange = function handleChange(e) {
    removePasswordTimeout();
    onChange === null || onChange === void 0 ? void 0 : onChange(e);
  };
  var suffixNode = (hasFeedback || suffix) &&
  /*#__PURE__*/
  /*#__PURE__*/
  jsxs(Fragment, {
    children: [suffix, hasFeedback && feedbackIcon]
  });
  // Allow clear
  var mergedAllowClear;
  if (_typeof$1(allowClear) === 'object' && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
    mergedAllowClear = allowClear;
  } else if (allowClear) {
    mergedAllowClear = {
      clearIcon:
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(CloseCircleFilled$1, {})
    };
  }
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(Input$4, {
    ref: composeRef(ref, inputRef),
    prefixCls: prefixCls,
    autoComplete: input === null || input === void 0 ? void 0 : input.autoComplete,
    ...rest,
    disabled: mergedDisabled || undefined,
    onBlur: handleBlur,
    onFocus: handleFocus,
    suffix: suffixNode,
    allowClear: mergedAllowClear,
    className: classNames$1(className, compactItemClassnames),
    onChange: handleChange,
    addonAfter: addonAfter &&
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(NoCompactStyle, {
      children: /*#__PURE__*/jsx$1(NoFormStyle, {
        override: true,
        status: true,
        children: addonAfter
      })
    }),
    addonBefore: addonBefore &&
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(NoCompactStyle, {
      children: /*#__PURE__*/jsx$1(NoFormStyle, {
        override: true,
        status: true,
        children: addonBefore
      })
    }),
    inputClassName: classNames$1((_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-sm", mergedSize === 'small'), _defineProperty$1(_classNames, prefixCls + "-lg", mergedSize === 'large'), _defineProperty$1(_classNames, prefixCls + "-rtl", direction === 'rtl'), _defineProperty$1(_classNames, prefixCls + "-borderless", !bordered), _classNames), !inputHasPrefixSuffix && getStatusClassNames(prefixCls, mergedStatus), hashId),
    affixWrapperClassName: classNames$1((_classNames2 = {}, _defineProperty$1(_classNames2, prefixCls + "-affix-wrapper-sm", mergedSize === 'small'), _defineProperty$1(_classNames2, prefixCls + "-affix-wrapper-lg", mergedSize === 'large'), _defineProperty$1(_classNames2, prefixCls + "-affix-wrapper-rtl", direction === 'rtl'), _defineProperty$1(_classNames2, prefixCls + "-affix-wrapper-borderless", !bordered), _classNames2), getStatusClassNames(prefixCls + "-affix-wrapper", mergedStatus, hasFeedback), hashId),
    wrapperClassName: classNames$1(_defineProperty$1({}, prefixCls + "-group-rtl", direction === 'rtl'), hashId),
    groupClassName: classNames$1((_classNames4 = {}, _defineProperty$1(_classNames4, prefixCls + "-group-wrapper-sm", mergedSize === 'small'), _defineProperty$1(_classNames4, prefixCls + "-group-wrapper-lg", mergedSize === 'large'), _defineProperty$1(_classNames4, prefixCls + "-group-wrapper-rtl", direction === 'rtl'), _classNames4), getStatusClassNames(prefixCls + "-group-wrapper", mergedStatus, hasFeedback), hashId)
  }));
});
const InternalInput = Input$3;

// This icon file is generated automatically.
var EyeInvisibleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };
const EyeInvisibleOutlinedSvg = EyeInvisibleOutlined$2;

var EyeInvisibleOutlined = function EyeInvisibleOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: EyeInvisibleOutlinedSvg
      })
    })
  );
};
EyeInvisibleOutlined.displayName = 'EyeInvisibleOutlined';
const EyeInvisibleOutlined$1 = /*#__PURE__*/react.exports.forwardRef(EyeInvisibleOutlined);

var __rest$m = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var defaultIconRender = function defaultIconRender(visible) {
  return visible ?
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(EyeOutlined$1, {}) :
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(EyeInvisibleOutlined$1, {});
};
var ActionMap = {
  click: 'onClick',
  hover: 'onMouseOver'
};
var Password = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _props$visibilityTogg = props.visibilityToggle,
    visibilityToggle = _props$visibilityTogg === void 0 ? true : _props$visibilityTogg;
  var visibilityControlled = _typeof$1(visibilityToggle) === 'object' && visibilityToggle.visible !== undefined;
  var _useState = react.exports.useState(function () {
      return visibilityControlled ? visibilityToggle.visible : false;
    }),
    _useState2 = _slicedToArray(_useState, 2),
    visible = _useState2[0],
    setVisible = _useState2[1];
  var inputRef = react.exports.useRef(null);
  react.exports.useEffect(function () {
    if (visibilityControlled) {
      setVisible(visibilityToggle.visible);
    }
  }, [visibilityControlled, visibilityToggle]);
  // Remove Password value
  var removePasswordTimeout = useRemovePasswordTimeout(inputRef);
  var onVisibleChange = function onVisibleChange() {
    var disabled = props.disabled;
    if (disabled) {
      return;
    }
    if (visible) {
      removePasswordTimeout();
    }
    setVisible(function (prevState) {
      var _a;
      var newState = !prevState;
      if (_typeof$1(visibilityToggle) === 'object') {
        (_a = visibilityToggle.onVisibleChange) === null || _a === void 0 ? void 0 : _a.call(visibilityToggle, newState);
      }
      return newState;
    });
  };
  var getIcon = function getIcon(prefixCls) {
    var _iconProps;
    var _props$action = props.action,
      action = _props$action === void 0 ? 'click' : _props$action,
      _props$iconRender = props.iconRender,
      iconRender = _props$iconRender === void 0 ? defaultIconRender : _props$iconRender;
    var iconTrigger = ActionMap[action] || '';
    var icon = iconRender(visible);
    var iconProps = (_iconProps = {}, _defineProperty$1(_iconProps, iconTrigger, onVisibleChange), _defineProperty$1(_iconProps, "className", prefixCls + "-icon"), _defineProperty$1(_iconProps, "key", 'passwordIcon'), _defineProperty$1(_iconProps, "onMouseDown", function onMouseDown(e) {
      // Prevent focused state lost
      // https://github.com/ant-design/ant-design/issues/15173
      e.preventDefault();
    }), _defineProperty$1(_iconProps, "onMouseUp", function onMouseUp(e) {
      // Prevent caret position change
      // https://github.com/ant-design/ant-design/issues/23524
      e.preventDefault();
    }), _iconProps);
    return /*#__PURE__*/react.exports.cloneElement( /*#__PURE__*/react.exports.isValidElement(icon) ? icon :
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      children: icon
    }), iconProps);
  };
  var renderPassword = function renderPassword(_ref) {
    var getPrefixCls = _ref.getPrefixCls;
    var className = props.className,
      customizePrefixCls = props.prefixCls,
      customizeInputPrefixCls = props.inputPrefixCls,
      size = props.size,
      restProps = __rest$m(props, ["className", "prefixCls", "inputPrefixCls", "size"]);
    var inputPrefixCls = getPrefixCls('input', customizeInputPrefixCls);
    var prefixCls = getPrefixCls('input-password', customizePrefixCls);
    var suffixIcon = visibilityToggle && getIcon(prefixCls);
    var inputClassName = classNames$1(prefixCls, className, _defineProperty$1({}, prefixCls + "-" + size, !!size));
    var omittedProps = _extends$2(_extends$2({}, omit$1(restProps, ['suffix', 'iconRender', 'visibilityToggle'])), {
      type: visible ? 'text' : 'password',
      className: inputClassName,
      prefixCls: inputPrefixCls,
      suffix: suffixIcon
    });
    if (size) {
      omittedProps.size = size;
    }
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(InternalInput, {
        ref: composeRef(ref, inputRef),
        ...omittedProps
      })
    );
  };
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(ConfigConsumer, {
      children: renderPassword
    })
  );
});
const Password$1 = Password;

var __rest$l = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var Search = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _classNames;
  var customizePrefixCls = props.prefixCls,
    customizeInputPrefixCls = props.inputPrefixCls,
    className = props.className,
    customizeSize = props.size,
    suffix = props.suffix,
    _props$enterButton = props.enterButton,
    enterButton = _props$enterButton === void 0 ? false : _props$enterButton,
    addonAfter = props.addonAfter,
    loading = props.loading,
    disabled = props.disabled,
    customOnSearch = props.onSearch,
    customOnChange = props.onChange,
    onCompositionStart = props.onCompositionStart,
    onCompositionEnd = props.onCompositionEnd,
    restProps = __rest$l(props, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"]);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var contextSize = react.exports.useContext(SizeContext);
  var composedRef = react.exports.useRef(false);
  var prefixCls = getPrefixCls('input-search', customizePrefixCls);
  var inputPrefixCls = getPrefixCls('input', customizeInputPrefixCls);
  var _useCompactItemContex = useCompactItemContext(prefixCls, direction),
    compactSize = _useCompactItemContex.compactSize;
  var size = compactSize || customizeSize || contextSize;
  var inputRef = react.exports.useRef(null);
  var onChange = function onChange(e) {
    if (e && e.target && e.type === 'click' && customOnSearch) {
      customOnSearch(e.target.value, e);
    }
    if (customOnChange) {
      customOnChange(e);
    }
  };
  var onMouseDown = function onMouseDown(e) {
    var _a;
    if (document.activeElement === ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input)) {
      e.preventDefault();
    }
  };
  var onSearch = function onSearch(e) {
    var _a, _b;
    if (customOnSearch) {
      customOnSearch((_b = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) === null || _b === void 0 ? void 0 : _b.value, e);
    }
  };
  var onPressEnter = function onPressEnter(e) {
    if (composedRef.current || loading) {
      return;
    }
    onSearch(e);
  };
  var searchIcon = typeof enterButton === 'boolean' ?
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(SearchOutlined$1, {}) : null;
  var btnClassName = prefixCls + "-button";
  var button;
  var enterButtonAsElement = enterButton || {};
  var isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
  if (isAntdButton || enterButtonAsElement.type === 'button') {
    button = cloneElement(enterButtonAsElement, _extends$2({
      onMouseDown: onMouseDown,
      onClick: function onClick(e) {
        var _a, _b;
        (_b = (_a = enterButtonAsElement === null || enterButtonAsElement === void 0 ? void 0 : enterButtonAsElement.props) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
        onSearch(e);
      },
      key: 'enterButton'
    }, isAntdButton ? {
      className: btnClassName,
      size: size
    } : {}));
  } else {
    button =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Button$2, {
      className: btnClassName,
      type: enterButton ? 'primary' : undefined,
      size: size,
      disabled: disabled,
      onMouseDown: onMouseDown,
      onClick: onSearch,
      loading: loading,
      icon: searchIcon,
      children: enterButton
    }, "enterButton");
  }
  if (addonAfter) {
    button = [button, cloneElement(addonAfter, {
      key: 'addonAfter'
    })];
  }
  var cls = classNames$1(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-rtl", direction === 'rtl'), _defineProperty$1(_classNames, prefixCls + "-" + size, !!size), _defineProperty$1(_classNames, prefixCls + "-with-button", !!enterButton), _classNames), className);
  var handleOnCompositionStart = function handleOnCompositionStart(e) {
    composedRef.current = true;
    onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e);
  };
  var handleOnCompositionEnd = function handleOnCompositionEnd(e) {
    composedRef.current = false;
    onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e);
  };
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(InternalInput, {
      ref: composeRef(inputRef, ref),
      onPressEnter: onPressEnter,
      ...restProps,
      size: size,
      onCompositionStart: handleOnCompositionStart,
      onCompositionEnd: handleOnCompositionEnd,
      prefixCls: inputPrefixCls,
      addonAfter: button,
      suffix: suffix,
      onChange: onChange,
      className: cls,
      disabled: disabled
    })
  );
});
const Search$1 = Search;

// Thanks to https://github.com/andreypopp/react-textarea-autosize/
/**
 * calculateNodeHeight(uiTextNode, useCache = false)
 */
var HIDDEN_TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n  pointer-events: none !important;\n";
var SIZING_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'font-variant', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing', 'word-break'];
var computedStyleCache = {};
var hiddenTextarea;
function calculateNodeStyling(node) {
  var useCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var nodeRef = node.getAttribute('id') || node.getAttribute('data-reactid') || node.getAttribute('name');
  if (useCache && computedStyleCache[nodeRef]) {
    return computedStyleCache[nodeRef];
  }
  var style = window.getComputedStyle(node);
  var boxSizing = style.getPropertyValue('box-sizing') || style.getPropertyValue('-moz-box-sizing') || style.getPropertyValue('-webkit-box-sizing');
  var paddingSize = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));
  var borderSize = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));
  var sizingStyle = SIZING_STYLE.map(function (name) {
    return "".concat(name, ":").concat(style.getPropertyValue(name));
  }).join(';');
  var nodeInfo = {
    sizingStyle: sizingStyle,
    paddingSize: paddingSize,
    borderSize: borderSize,
    boxSizing: boxSizing
  };
  if (useCache && nodeRef) {
    computedStyleCache[nodeRef] = nodeInfo;
  }
  return nodeInfo;
}
function calculateAutoSizeStyle(uiTextNode) {
  var useCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var minRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var maxRows = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement('textarea');
    hiddenTextarea.setAttribute('tab-index', '-1');
    hiddenTextarea.setAttribute('aria-hidden', 'true');
    document.body.appendChild(hiddenTextarea);
  }
  // Fix wrap="off" issue
  // https://github.com/ant-design/ant-design/issues/6577
  if (uiTextNode.getAttribute('wrap')) {
    hiddenTextarea.setAttribute('wrap', uiTextNode.getAttribute('wrap'));
  } else {
    hiddenTextarea.removeAttribute('wrap');
  }
  // Copy all CSS properties that have an impact on the height of the content in
  // the textbox
  var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache),
    paddingSize = _calculateNodeStyling.paddingSize,
    borderSize = _calculateNodeStyling.borderSize,
    boxSizing = _calculateNodeStyling.boxSizing,
    sizingStyle = _calculateNodeStyling.sizingStyle;
  // Need to have the overflow attribute to hide the scrollbar otherwise
  // text-lines will not calculated properly as the shadow will technically be
  // narrower for content
  hiddenTextarea.setAttribute('style', "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
  hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || '';
  var minHeight = undefined;
  var maxHeight = undefined;
  var overflowY;
  var height = hiddenTextarea.scrollHeight;
  if (boxSizing === 'border-box') {
    // border-box: add border, since height = content + padding + border
    height += borderSize;
  } else if (boxSizing === 'content-box') {
    // remove padding, since height = content
    height -= paddingSize;
  }
  if (minRows !== null || maxRows !== null) {
    // measure height of a textarea with a single row
    hiddenTextarea.value = ' ';
    var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
    if (minRows !== null) {
      minHeight = singleRowHeight * minRows;
      if (boxSizing === 'border-box') {
        minHeight = minHeight + paddingSize + borderSize;
      }
      height = Math.max(minHeight, height);
    }
    if (maxRows !== null) {
      maxHeight = singleRowHeight * maxRows;
      if (boxSizing === 'border-box') {
        maxHeight = maxHeight + paddingSize + borderSize;
      }
      overflowY = height > maxHeight ? '' : 'hidden';
      height = Math.min(maxHeight, height);
    }
  }
  var style = {
    height: height,
    overflowY: overflowY,
    resize: 'none'
  };
  if (minHeight) {
    style.minHeight = minHeight;
  }
  if (maxHeight) {
    style.maxHeight = maxHeight;
  }
  return style;
}

var _excluded$k = ["prefixCls", "onPressEnter", "defaultValue", "value", "autoSize", "onResize", "className", "style", "disabled", "onChange", "onInternalAutoSize"];
var RESIZE_START = 0;
var RESIZE_MEASURING = 1;
var RESIZE_STABLE = 2;
var ResizableTextArea = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-textarea' : _props$prefixCls;
    props.onPressEnter;
    var defaultValue = props.defaultValue,
    value = props.value,
    autoSize = props.autoSize,
    onResize = props.onResize,
    className = props.className,
    style = props.style,
    disabled = props.disabled,
    onChange = props.onChange;
    props.onInternalAutoSize;
    var restProps = _objectWithoutProperties(props, _excluded$k);
  // =============================== Value ================================
  var _useMergedState = useMergedState$1(defaultValue, {
      value: value,
      postState: function postState(val) {
        return val !== null && val !== void 0 ? val : '';
      }
    }),
    _useMergedState2 = _slicedToArray(_useMergedState, 2),
    mergedValue = _useMergedState2[0],
    setMergedValue = _useMergedState2[1];
  var onInternalChange = function onInternalChange(event) {
    setMergedValue(event.target.value);
    onChange === null || onChange === void 0 ? void 0 : onChange(event);
  };
  // ================================ Ref =================================
  var textareaRef = react.exports.useRef();
  react.exports.useImperativeHandle(ref, function () {
    return {
      textArea: textareaRef.current
    };
  });
  // ============================== AutoSize ==============================
  var _React$useMemo = react.exports.useMemo(function () {
      if (autoSize && _typeof$1(autoSize) === 'object') {
        return [autoSize.minRows, autoSize.maxRows];
      }
      return [];
    }, [autoSize]),
    _React$useMemo2 = _slicedToArray(_React$useMemo, 2),
    minRows = _React$useMemo2[0],
    maxRows = _React$useMemo2[1];
  var needAutoSize = !!autoSize;
  // =============================== Scroll ===============================
  // https://github.com/ant-design/ant-design/issues/21870
  var fixFirefoxAutoScroll = function fixFirefoxAutoScroll() {
    try {
      // FF has bug with jump of scroll to top. We force back here.
      if (document.activeElement === textareaRef.current) {
        var _textareaRef$current = textareaRef.current,
          selectionStart = _textareaRef$current.selectionStart,
          selectionEnd = _textareaRef$current.selectionEnd,
          scrollTop = _textareaRef$current.scrollTop;
        // Fix Safari bug which not rollback when break line
        // This makes Chinese IME can't input. Do not fix this
        // const { value: tmpValue } = textareaRef.current;
        // textareaRef.current.value = '';
        // textareaRef.current.value = tmpValue;
        textareaRef.current.setSelectionRange(selectionStart, selectionEnd);
        textareaRef.current.scrollTop = scrollTop;
      }
    } catch (e) {
      // Fix error in Chrome:
      // Failed to read the 'selectionStart' property from 'HTMLInputElement'
      // http://stackoverflow.com/q/21177489/3040605
    }
  };
  // =============================== Resize ===============================
  var _React$useState = react.exports.useState(RESIZE_STABLE),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    resizeState = _React$useState2[0],
    setResizeState = _React$useState2[1];
  var _React$useState3 = react.exports.useState(),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    autoSizeStyle = _React$useState4[0],
    setAutoSizeStyle = _React$useState4[1];
  var startResize = function startResize() {
    setResizeState(RESIZE_START);
  };
  // Change to trigger resize measure
  useLayoutEffect$3(function () {
    if (needAutoSize) {
      startResize();
    }
  }, [value, minRows, maxRows, needAutoSize]);
  useLayoutEffect$3(function () {
    if (resizeState === RESIZE_START) {
      setResizeState(RESIZE_MEASURING);
    } else if (resizeState === RESIZE_MEASURING) {
      var textareaStyles = calculateAutoSizeStyle(textareaRef.current, false, minRows, maxRows);
      // Safari has bug that text will keep break line on text cut when it's prev is break line.
      // ZombieJ: This not often happen. So we just skip it.
      // const { selectionStart, selectionEnd, scrollTop } = textareaRef.current;
      // const { value: tmpValue } = textareaRef.current;
      // textareaRef.current.value = '';
      // textareaRef.current.value = tmpValue;
      // if (document.activeElement === textareaRef.current) {
      //   textareaRef.current.scrollTop = scrollTop;
      //   textareaRef.current.setSelectionRange(selectionStart, selectionEnd);
      // }
      setResizeState(RESIZE_STABLE);
      setAutoSizeStyle(textareaStyles);
    } else {
      fixFirefoxAutoScroll();
    }
  }, [resizeState]);
  // We lock resize trigger by raf to avoid Safari warning
  var resizeRafRef = react.exports.useRef();
  var cleanRaf = function cleanRaf() {
    wrapperRaf$1.cancel(resizeRafRef.current);
  };
  var onInternalResize = function onInternalResize(size) {
    if (resizeState === RESIZE_STABLE) {
      onResize === null || onResize === void 0 ? void 0 : onResize(size);
      if (autoSize) {
        cleanRaf();
        resizeRafRef.current = wrapperRaf$1(function () {
          startResize();
        });
      }
    }
  };
  react.exports.useEffect(function () {
    return cleanRaf;
  }, []);
  // =============================== Render ===============================
  var mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null;
  var mergedStyle = _objectSpread2$1(_objectSpread2$1({}, style), mergedAutoSizeStyle);
  if (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) {
    mergedStyle.overflowY = 'hidden';
    mergedStyle.overflowX = 'hidden';
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(ResizeObserver$1, {
      onResize: onInternalResize,
      disabled: !(autoSize || onResize),
      children: /*#__PURE__*/jsx$1("textarea", {
        ...restProps,
        ref: textareaRef,
        style: mergedStyle,
        className: classNames$1(prefixCls, className, _defineProperty$1({}, "".concat(prefixCls, "-disabled"), disabled)),
        disabled: disabled,
        value: mergedValue,
        onChange: onInternalChange
      })
    })
  );
});

var TextArea$2 = /*#__PURE__*/function (_React$Component) {
  _inherits(TextArea, _React$Component);
  var _super = _createSuper(TextArea);
  function TextArea(props) {
    var _this;
    _classCallCheck(this, TextArea);
    _this = _super.call(this, props);
    _this.resizableTextArea = void 0;
    _this.focus = function () {
      _this.resizableTextArea.textArea.focus();
    };
    _this.saveTextArea = function (resizableTextArea) {
      _this.resizableTextArea = resizableTextArea;
    };
    _this.handleChange = function (e) {
      var onChange = _this.props.onChange;
      _this.setValue(e.target.value);
      if (onChange) {
        onChange(e);
      }
    };
    _this.handleKeyDown = function (e) {
      var _this$props = _this.props,
        onPressEnter = _this$props.onPressEnter,
        onKeyDown = _this$props.onKeyDown;
      if (e.keyCode === 13 && onPressEnter) {
        onPressEnter(e);
      }
      if (onKeyDown) {
        onKeyDown(e);
      }
    };
    var value = typeof props.value === 'undefined' || props.value === null ? props.defaultValue : props.value;
    _this.state = {
      value: value
    };
    return _this;
  }
  _createClass(TextArea, [{
    key: "setValue",
    value: function setValue(value, callback) {
      if (!('value' in this.props)) {
        this.setState({
          value: value
        }, callback);
      }
    }
  }, {
    key: "blur",
    value: function blur() {
      this.resizableTextArea.textArea.blur();
    }
  }, {
    key: "render",
    value: function render() {
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(ResizableTextArea, {
          ...this.props,
          value: this.state.value,
          onKeyDown: this.handleKeyDown,
          onChange: this.handleChange,
          ref: this.saveTextArea
        })
      );
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps) {
      if ('value' in nextProps) {
        return {
          value: nextProps.value
        };
      }
      return null;
    }
  }]);
  return TextArea;
}(react.exports.Component);

var ClearableInputType = ['text', 'input'];
function hasAddon(props) {
  return !!(props.addonBefore || props.addonAfter);
}
var ClearableLabeledInput = /*#__PURE__*/function (_React$Component) {
  _inherits(ClearableLabeledInput, _React$Component);
  var _super = _createSuper(ClearableLabeledInput);
  function ClearableLabeledInput() {
    _classCallCheck(this, ClearableLabeledInput);
    return _super.apply(this, arguments);
  }
  _createClass(ClearableLabeledInput, [{
    key: "renderClearIcon",
    value: function renderClearIcon(prefixCls) {
      var _classNames;
      var _this$props = this.props,
        value = _this$props.value,
        disabled = _this$props.disabled,
        readOnly = _this$props.readOnly,
        handleReset = _this$props.handleReset,
        suffix = _this$props.suffix;
      var needClear = !disabled && !readOnly && value;
      var className = prefixCls + "-clear-icon";
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(CloseCircleFilled$1, {
          onClick: handleReset,
          onMouseDown: function onMouseDown(e) {
            return e.preventDefault();
          },
          className: classNames$1((_classNames = {}, _defineProperty$1(_classNames, className + "-hidden", !needClear), _defineProperty$1(_classNames, className + "-has-suffix", !!suffix), _classNames), className),
          role: "button"
        })
      );
    }
  }, {
    key: "renderTextAreaWithClearIcon",
    value: function renderTextAreaWithClearIcon(prefixCls, element, statusContext) {
      var _classNames2;
      var _this$props2 = this.props,
        value = _this$props2.value,
        allowClear = _this$props2.allowClear,
        className = _this$props2.className,
        style = _this$props2.style,
        direction = _this$props2.direction,
        bordered = _this$props2.bordered,
        hidden = _this$props2.hidden,
        customStatus = _this$props2.status,
        hashId = _this$props2.hashId;
      var contextStatus = statusContext.status,
        hasFeedback = statusContext.hasFeedback;
      if (!allowClear) {
        return cloneElement(element, {
          value: value
        });
      }
      var affixWrapperCls = classNames$1(prefixCls + "-affix-wrapper", prefixCls + "-affix-wrapper-textarea-with-clear-btn", getStatusClassNames(prefixCls + "-affix-wrapper", getMergedStatus(contextStatus, customStatus), hasFeedback), (_classNames2 = {}, _defineProperty$1(_classNames2, prefixCls + "-affix-wrapper-rtl", direction === 'rtl'), _defineProperty$1(_classNames2, prefixCls + "-affix-wrapper-borderless", !bordered), _defineProperty$1(_classNames2, "" + className, !hasAddon(this.props) && className), _classNames2), hashId);
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsxs("span", {
          className: affixWrapperCls,
          style: style,
          hidden: hidden,
          children: [cloneElement(element, {
            style: null,
            value: value
          }), this.renderClearIcon(prefixCls)]
        })
      );
    }
  }, {
    key: "render",
    value: function render() {
      var _this = this;
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(FormItemInputContext.Consumer, {
          children: function (statusContext) {
            var _this$props3 = _this.props,
              prefixCls = _this$props3.prefixCls,
              inputType = _this$props3.inputType,
              element = _this$props3.element;
            if (inputType === ClearableInputType[0]) {
              return _this.renderTextAreaWithClearIcon(prefixCls, element, statusContext);
            }
          }
        })
      );
    }
  }]);
  return ClearableLabeledInput;
}(react.exports.Component);
const ClearableLabeledInput$1 = ClearableLabeledInput;

var __rest$k = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function fixEmojiLength(value, maxLength) {
  return _toConsumableArray(value || '').slice(0, maxLength).join('');
}
function setTriggerValue(isCursorInEnd, preValue, triggerValue, maxLength) {
  var newTriggerValue = triggerValue;
  if (isCursorInEnd) {
    // 
    newTriggerValue = fixEmojiLength(triggerValue, maxLength);
  } else if (_toConsumableArray(preValue || '').length < triggerValue.length && _toConsumableArray(triggerValue || '').length > maxLength) {
    // 
    newTriggerValue = preValue;
  }
  return newTriggerValue;
}
var TextArea = /*#__PURE__*/react.exports.forwardRef(function (_a, ref) {
  var _classNames;
  var customizePrefixCls = _a.prefixCls,
    _a$bordered = _a.bordered,
    bordered = _a$bordered === void 0 ? true : _a$bordered,
    _a$showCount = _a.showCount,
    showCount = _a$showCount === void 0 ? false : _a$showCount,
    maxLength = _a.maxLength,
    className = _a.className,
    style = _a.style,
    customizeSize = _a.size,
    customDisabled = _a.disabled,
    onCompositionStart = _a.onCompositionStart,
    onCompositionEnd = _a.onCompositionEnd,
    onChange = _a.onChange,
    customStatus = _a.status,
    props = __rest$k(_a, ["prefixCls", "bordered", "showCount", "maxLength", "className", "style", "size", "disabled", "onCompositionStart", "onCompositionEnd", "onChange", "status"]);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var size = react.exports.useContext(SizeContext);
  // ===================== Disabled =====================
  var disabled = react.exports.useContext(DisabledContext);
  var mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
  var _React$useContext2 = react.exports.useContext(FormItemInputContext),
    contextStatus = _React$useContext2.status,
    hasFeedback = _React$useContext2.hasFeedback,
    feedbackIcon = _React$useContext2.feedbackIcon;
  var mergedStatus = getMergedStatus(contextStatus, customStatus);
  var innerRef = react.exports.useRef(null);
  var clearableInputRef = react.exports.useRef(null);
  var _React$useState = react.exports.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    compositing = _React$useState2[0],
    setCompositing = _React$useState2[1];
  var oldCompositionValueRef = react.exports.useRef();
  var oldSelectionStartRef = react.exports.useRef(0);
  var _useMergedState = useMergedState(props.defaultValue, {
      value: props.value
    }),
    _useMergedState2 = _slicedToArray(_useMergedState, 2),
    value = _useMergedState2[0],
    setValue = _useMergedState2[1];
  var hidden = props.hidden;
  var handleSetValue = function handleSetValue(val, callback) {
    if (props.value === undefined) {
      setValue(val);
      callback === null || callback === void 0 ? void 0 : callback();
    }
  };
  // =========================== Value Update ===========================
  // Max length value
  var hasMaxLength = Number(maxLength) > 0;
  var onInternalCompositionStart = function onInternalCompositionStart(e) {
    setCompositing(true);
    // 
    oldCompositionValueRef.current = value;
    // 
    oldSelectionStartRef.current = e.currentTarget.selectionStart;
    onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e);
  };
  var onInternalCompositionEnd = function onInternalCompositionEnd(e) {
    var _a;
    setCompositing(false);
    var triggerValue = e.currentTarget.value;
    if (hasMaxLength) {
      var isCursorInEnd = oldSelectionStartRef.current >= maxLength + 1 || oldSelectionStartRef.current === ((_a = oldCompositionValueRef.current) === null || _a === void 0 ? void 0 : _a.length);
      triggerValue = setTriggerValue(isCursorInEnd, oldCompositionValueRef.current, triggerValue, maxLength);
    }
    // Patch composition onChange when value changed
    if (triggerValue !== value) {
      handleSetValue(triggerValue);
      resolveOnChange(e.currentTarget, e, onChange, triggerValue);
    }
    onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e);
  };
  var handleChange = function handleChange(e) {
    var triggerValue = e.target.value;
    if (!compositing && hasMaxLength) {
      // 1. maxlength 2.maxlength
      var isCursorInEnd = e.target.selectionStart >= maxLength + 1 || e.target.selectionStart === triggerValue.length || !e.target.selectionStart;
      triggerValue = setTriggerValue(isCursorInEnd, value, triggerValue, maxLength);
    }
    handleSetValue(triggerValue);
    resolveOnChange(e.currentTarget, e, onChange, triggerValue);
  };
  // ============================== Reset ===============================
  var handleReset = function handleReset(e) {
    var _a, _b, _c;
    handleSetValue('');
    (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    resolveOnChange((_c = (_b = innerRef.current) === null || _b === void 0 ? void 0 : _b.resizableTextArea) === null || _c === void 0 ? void 0 : _c.textArea, e, onChange);
  };
  var prefixCls = getPrefixCls('input', customizePrefixCls);
  // Style
  var _useStyle = useStyle$f(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  react.exports.useImperativeHandle(ref, function () {
    var _a;
    return {
      resizableTextArea: (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.resizableTextArea,
      focus: function focus(option) {
        var _a, _b;
        triggerFocus((_b = (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.resizableTextArea) === null || _b === void 0 ? void 0 : _b.textArea, option);
      },
      blur: function blur() {
        var _a;
        return (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.blur();
      }
    };
  });
  var textArea =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(TextArea$2, {
    ...omit$1(props, ['allowClear']),
    disabled: mergedDisabled,
    className: classNames$1((_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-borderless", !bordered), _defineProperty$1(_classNames, className, className && !showCount), _defineProperty$1(_classNames, prefixCls + "-sm", size === 'small' || customizeSize === 'small'), _defineProperty$1(_classNames, prefixCls + "-lg", size === 'large' || customizeSize === 'large'), _classNames), getStatusClassNames(prefixCls, mergedStatus), hashId),
    style: showCount ? {
      resize: style === null || style === void 0 ? void 0 : style.resize
    } : style,
    prefixCls: prefixCls,
    onCompositionStart: onInternalCompositionStart,
    onChange: handleChange,
    onCompositionEnd: onInternalCompositionEnd,
    ref: innerRef
  });
  var val = fixControlledValue(value);
  if (!compositing && hasMaxLength && (props.value === null || props.value === undefined)) {
    // fix #27612 value ''.length === 2 emoji
    val = fixEmojiLength(val, maxLength);
  }
  // TextArea
  var textareaNode =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(ClearableLabeledInput$1, {
    disabled: mergedDisabled,
    ...props,
    prefixCls: prefixCls,
    direction: direction,
    inputType: "text",
    value: val,
    element: textArea,
    handleReset: handleReset,
    ref: clearableInputRef,
    bordered: bordered,
    status: customStatus,
    style: showCount ? undefined : style,
    hashId: hashId
  });
  // Only show text area wrapper when needed
  if (showCount || hasFeedback) {
    var _classNames2;
    var valueLength = _toConsumableArray(val).length;
    var dataCount = '';
    if (_typeof$1(showCount) === 'object') {
      dataCount = showCount.formatter({
        value: val,
        count: valueLength,
        maxLength: maxLength
      });
    } else {
      dataCount = "" + valueLength + (hasMaxLength ? " / " + maxLength : '');
    }
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsxs("div", {
        hidden: hidden,
        className: classNames$1(prefixCls + "-textarea", (_classNames2 = {}, _defineProperty$1(_classNames2, prefixCls + "-textarea-rtl", direction === 'rtl'), _defineProperty$1(_classNames2, prefixCls + "-textarea-show-count", showCount), _classNames2), getStatusClassNames(prefixCls + "-textarea", mergedStatus, hasFeedback), className, hashId),
        style: style,
        "data-count": dataCount,
        children: [textareaNode, hasFeedback &&
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("span", {
          className: prefixCls + "-textarea-suffix",
          children: feedbackIcon
        })]
      })
    );
  }
  return wrapSSR(textareaNode);
});
const TextArea$1 = TextArea;

var Input$1 = InternalInput;
Input$1.Group = Group$2;
Input$1.Search = Search$1;
Input$1.TextArea = TextArea$1;
Input$1.Password = Password$1;
const Input$2 = Input$1;

// This icon file is generated automatically.
var DoubleLeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, "name": "double-left", "theme": "outlined" };
const DoubleLeftOutlinedSvg = DoubleLeftOutlined$2;

var DoubleLeftOutlined = function DoubleLeftOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: DoubleLeftOutlinedSvg
      })
    })
  );
};
DoubleLeftOutlined.displayName = 'DoubleLeftOutlined';
const DoubleLeftOutlined$1 = /*#__PURE__*/react.exports.forwardRef(DoubleLeftOutlined);

// This icon file is generated automatically.
var DoubleRightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, "name": "double-right", "theme": "outlined" };
const DoubleRightOutlinedSvg = DoubleRightOutlined$2;

var DoubleRightOutlined = function DoubleRightOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: DoubleRightOutlinedSvg
      })
    })
  );
};
DoubleRightOutlined.displayName = 'DoubleRightOutlined';
const DoubleRightOutlined$1 = /*#__PURE__*/react.exports.forwardRef(DoubleRightOutlined);

var Pager = function Pager(props) {
  var _classNames;
  var prefixCls = "".concat(props.rootPrefixCls, "-item");
  var cls = classNames$1(prefixCls, "".concat(prefixCls, "-").concat(props.page), (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-active"), props.active), _defineProperty$1(_classNames, "".concat(prefixCls, "-disabled"), !props.page), _defineProperty$1(_classNames, props.className, !!props.className), _classNames));
  var handleClick = function handleClick() {
    props.onClick(props.page);
  };
  var handleKeyPress = function handleKeyPress(e) {
    props.onKeyPress(e, props.onClick, props.page);
  };
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("li", {
      title: props.showTitle ? props.page : null,
      className: cls,
      onClick: handleClick,
      onKeyPress: handleKeyPress,
      tabIndex: "0",
      children: props.itemRender(props.page, 'page',
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("a", {
        rel: "nofollow",
        children: props.page
      }))
    })
  );
};

const KEYCODE = {
  ZERO: 48,
  NINE: 57,
  NUMPAD_ZERO: 96,
  NUMPAD_NINE: 105,
  BACKSPACE: 8,
  DELETE: 46,
  ENTER: 13,
  ARROW_UP: 38,
  ARROW_DOWN: 40
};

var Options = /*#__PURE__*/function (_React$Component) {
  _inherits(Options, _React$Component);
  var _super = _createSuper(Options);
  function Options() {
    var _this;
    _classCallCheck(this, Options);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      goInputText: ''
    };
    _this.buildOptionText = function (value) {
      return "".concat(value, " ").concat(_this.props.locale.items_per_page);
    };
    _this.changeSize = function (value) {
      _this.props.changeSize(Number(value));
    };
    _this.handleChange = function (e) {
      _this.setState({
        goInputText: e.target.value
      });
    };
    _this.handleBlur = function (e) {
      var _this$props = _this.props,
        goButton = _this$props.goButton,
        quickGo = _this$props.quickGo,
        rootPrefixCls = _this$props.rootPrefixCls;
      var goInputText = _this.state.goInputText;
      if (goButton || goInputText === '') {
        return;
      }
      _this.setState({
        goInputText: ''
      });
      if (e.relatedTarget && (e.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item-link")) >= 0 || e.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item")) >= 0)) {
        return;
      }
      quickGo(_this.getValidValue());
    };
    _this.go = function (e) {
      var goInputText = _this.state.goInputText;
      if (goInputText === '') {
        return;
      }
      if (e.keyCode === KEYCODE.ENTER || e.type === 'click') {
        _this.setState({
          goInputText: ''
        });
        _this.props.quickGo(_this.getValidValue());
      }
    };
    return _this;
  }
  _createClass(Options, [{
    key: "getValidValue",
    value: function getValidValue() {
      var goInputText = this.state.goInputText;
      // eslint-disable-next-line no-restricted-globals
      return !goInputText || isNaN(goInputText) ? undefined : Number(goInputText);
    }
  }, {
    key: "getPageSizeOptions",
    value: function getPageSizeOptions() {
      var _this$props2 = this.props,
        pageSize = _this$props2.pageSize,
        pageSizeOptions = _this$props2.pageSizeOptions;
      if (pageSizeOptions.some(function (option) {
        return option.toString() === pageSize.toString();
      })) {
        return pageSizeOptions;
      }
      return pageSizeOptions.concat([pageSize.toString()]).sort(function (a, b) {
        // eslint-disable-next-line no-restricted-globals
        var numberA = isNaN(Number(a)) ? 0 : Number(a);
        // eslint-disable-next-line no-restricted-globals
        var numberB = isNaN(Number(b)) ? 0 : Number(b);
        return numberA - numberB;
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props3 = this.props,
        pageSize = _this$props3.pageSize,
        locale = _this$props3.locale,
        rootPrefixCls = _this$props3.rootPrefixCls,
        changeSize = _this$props3.changeSize,
        quickGo = _this$props3.quickGo,
        goButton = _this$props3.goButton,
        selectComponentClass = _this$props3.selectComponentClass,
        buildOptionText = _this$props3.buildOptionText,
        selectPrefixCls = _this$props3.selectPrefixCls,
        disabled = _this$props3.disabled;
      var goInputText = this.state.goInputText;
      var prefixCls = "".concat(rootPrefixCls, "-options");
      var Select = selectComponentClass;
      var changeSelect = null;
      var goInput = null;
      var gotoButton = null;
      if (!changeSize && !quickGo) {
        return null;
      }
      var pageSizeOptions = this.getPageSizeOptions();
      if (changeSize && Select) {
        var options = pageSizeOptions.map(function (opt, i) {
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1(Select.Option, {
              value: opt.toString(),
              children: (buildOptionText || _this2.buildOptionText)(opt)
            }, i)
          );
        });
        changeSelect =
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(Select, {
          disabled: disabled,
          prefixCls: selectPrefixCls,
          showSearch: false,
          className: "".concat(prefixCls, "-size-changer"),
          optionLabelProp: "children",
          dropdownMatchSelectWidth: false,
          value: (pageSize || pageSizeOptions[0]).toString(),
          onChange: this.changeSize,
          getPopupContainer: function getPopupContainer(triggerNode) {
            return triggerNode.parentNode;
          },
          "aria-label": locale.page_size,
          defaultOpen: false,
          children: options
        });
      }
      if (quickGo) {
        if (goButton) {
          gotoButton = typeof goButton === 'boolean' ?
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("button", {
            type: "button",
            onClick: this.go,
            onKeyUp: this.go,
            disabled: disabled,
            className: "".concat(prefixCls, "-quick-jumper-button"),
            children: locale.jump_to_confirm
          }) :
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("span", {
            onClick: this.go,
            onKeyUp: this.go,
            children: goButton
          });
        }
        goInput =
        /*#__PURE__*/
        /*#__PURE__*/
        jsxs("div", {
          className: "".concat(prefixCls, "-quick-jumper"),
          children: [locale.jump_to, /*#__PURE__*/jsx$1("input", {
            disabled: disabled,
            type: "text",
            value: goInputText,
            onChange: this.handleChange,
            onKeyUp: this.go,
            onBlur: this.handleBlur,
            "aria-label": locale.page
          }), locale.page, gotoButton]
        });
      }
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsxs("li", {
          className: "".concat(prefixCls),
          children: [changeSelect, goInput]
        })
      );
    }
  }]);
  return Options;
}(React.Component);
Options.defaultProps = {
  pageSizeOptions: ['10', '20', '50', '100']
};

const LOCALE = {
  // Options.jsx
  items_per_page: '/',
  jump_to: '',
  jump_to_confirm: '',
  page: '',
  // Pagination.jsx
  prev_page: '',
  next_page: '',
  prev_5: ' 5 ',
  next_5: ' 5 ',
  prev_3: ' 3 ',
  next_3: ' 3 ',
  page_size: ''
};

function noop$3() {}
function isInteger(v) {
  var value = Number(v);
  return (
    // eslint-disable-next-line no-restricted-globals
    typeof value === 'number' && !isNaN(value) && isFinite(value) && Math.floor(value) === value
  );
}
function defaultItemRender(page, type, element) {
  return element;
}
function calculatePage(p, state, props) {
  var pageSize = typeof p === 'undefined' ? state.pageSize : p;
  return Math.floor((props.total - 1) / pageSize) + 1;
}
var Pagination$2 = /*#__PURE__*/function (_React$Component) {
  _inherits(Pagination, _React$Component);
  var _super = _createSuper(Pagination);
  function Pagination(props) {
    var _this;
    _classCallCheck(this, Pagination);
    _this = _super.call(this, props);
    _this.getJumpPrevPage = function () {
      return Math.max(1, _this.state.current - (_this.props.showLessItems ? 3 : 5));
    };
    _this.getJumpNextPage = function () {
      return Math.min(calculatePage(undefined, _this.state, _this.props), _this.state.current + (_this.props.showLessItems ? 3 : 5));
    };
    _this.getItemIcon = function (icon, label) {
      var prefixCls = _this.props.prefixCls;
      var iconNode = icon ||
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("button", {
        type: "button",
        "aria-label": label,
        className: "".concat(prefixCls, "-item-link")
      });
      if (typeof icon === 'function') {
        iconNode = /*#__PURE__*/React.createElement(icon, _objectSpread2$1({}, _this.props));
      }
      return iconNode;
    };
    _this.savePaginationNode = function (node) {
      _this.paginationNode = node;
    };
    _this.isValid = function (page) {
      var total = _this.props.total;
      return isInteger(page) && page !== _this.state.current && isInteger(total) && total > 0;
    };
    _this.shouldDisplayQuickJumper = function () {
      var _this$props = _this.props,
        showQuickJumper = _this$props.showQuickJumper,
        total = _this$props.total;
      var pageSize = _this.state.pageSize;
      if (total <= pageSize) {
        return false;
      }
      return showQuickJumper;
    };
    _this.handleKeyDown = function (e) {
      if (e.keyCode === KEYCODE.ARROW_UP || e.keyCode === KEYCODE.ARROW_DOWN) {
        e.preventDefault();
      }
    };
    _this.handleKeyUp = function (e) {
      var value = _this.getValidValue(e);
      var currentInputValue = _this.state.currentInputValue;
      if (value !== currentInputValue) {
        _this.setState({
          currentInputValue: value
        });
      }
      if (e.keyCode === KEYCODE.ENTER) {
        _this.handleChange(value);
      } else if (e.keyCode === KEYCODE.ARROW_UP) {
        _this.handleChange(value - 1);
      } else if (e.keyCode === KEYCODE.ARROW_DOWN) {
        _this.handleChange(value + 1);
      }
    };
    _this.handleBlur = function (e) {
      var value = _this.getValidValue(e);
      _this.handleChange(value);
    };
    _this.changePageSize = function (size) {
      var current = _this.state.current;
      var newCurrent = calculatePage(size, _this.state, _this.props);
      current = current > newCurrent ? newCurrent : current;
      // fix the issue:
      // Once 'total' is 0, 'current' in 'onShowSizeChange' is 0, which is not correct.
      if (newCurrent === 0) {
        // eslint-disable-next-line prefer-destructuring
        current = _this.state.current;
      }
      if (typeof size === 'number') {
        if (!('pageSize' in _this.props)) {
          _this.setState({
            pageSize: size
          });
        }
        if (!('current' in _this.props)) {
          _this.setState({
            current: current,
            currentInputValue: current
          });
        }
      }
      _this.props.onShowSizeChange(current, size);
      if ('onChange' in _this.props && _this.props.onChange) {
        _this.props.onChange(current, size);
      }
    };
    _this.handleChange = function (page) {
      var _this$props2 = _this.props,
        disabled = _this$props2.disabled,
        onChange = _this$props2.onChange;
      var _this$state = _this.state,
        pageSize = _this$state.pageSize,
        current = _this$state.current,
        currentInputValue = _this$state.currentInputValue;
      if (_this.isValid(page) && !disabled) {
        var currentPage = calculatePage(undefined, _this.state, _this.props);
        var newPage = page;
        if (page > currentPage) {
          newPage = currentPage;
        } else if (page < 1) {
          newPage = 1;
        }
        if (!('current' in _this.props)) {
          _this.setState({
            current: newPage
          });
        }
        if (newPage !== currentInputValue) {
          _this.setState({
            currentInputValue: newPage
          });
        }
        onChange(newPage, pageSize);
        return newPage;
      }
      return current;
    };
    _this.prev = function () {
      if (_this.hasPrev()) {
        _this.handleChange(_this.state.current - 1);
      }
    };
    _this.next = function () {
      if (_this.hasNext()) {
        _this.handleChange(_this.state.current + 1);
      }
    };
    _this.jumpPrev = function () {
      _this.handleChange(_this.getJumpPrevPage());
    };
    _this.jumpNext = function () {
      _this.handleChange(_this.getJumpNextPage());
    };
    _this.hasPrev = function () {
      return _this.state.current > 1;
    };
    _this.hasNext = function () {
      return _this.state.current < calculatePage(undefined, _this.state, _this.props);
    };
    _this.runIfEnter = function (event, callback) {
      if (event.key === 'Enter' || event.charCode === 13) {
        for (var _len = arguments.length, restParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          restParams[_key - 2] = arguments[_key];
        }
        callback.apply(void 0, restParams);
      }
    };
    _this.runIfEnterPrev = function (e) {
      _this.runIfEnter(e, _this.prev);
    };
    _this.runIfEnterNext = function (e) {
      _this.runIfEnter(e, _this.next);
    };
    _this.runIfEnterJumpPrev = function (e) {
      _this.runIfEnter(e, _this.jumpPrev);
    };
    _this.runIfEnterJumpNext = function (e) {
      _this.runIfEnter(e, _this.jumpNext);
    };
    _this.handleGoTO = function (e) {
      if (e.keyCode === KEYCODE.ENTER || e.type === 'click') {
        _this.handleChange(_this.state.currentInputValue);
      }
    };
    var hasOnChange = props.onChange !== noop$3;
    var hasCurrent = ('current' in props);
    if (hasCurrent && !hasOnChange) {
      // eslint-disable-next-line no-console
      console.warn('Warning: You provided a `current` prop to a Pagination component without an `onChange` handler. This will render a read-only component.');
    }
    var _current = props.defaultCurrent;
    if ('current' in props) {
      // eslint-disable-next-line prefer-destructuring
      _current = props.current;
    }
    var _pageSize = props.defaultPageSize;
    if ('pageSize' in props) {
      // eslint-disable-next-line prefer-destructuring
      _pageSize = props.pageSize;
    }
    _current = Math.min(_current, calculatePage(_pageSize, undefined, props));
    _this.state = {
      current: _current,
      currentInputValue: _current,
      pageSize: _pageSize
    };
    return _this;
  }
  _createClass(Pagination, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      // When current page change, fix focused style of prev item
      // A hacky solution of https://github.com/ant-design/ant-design/issues/8948
      var prefixCls = this.props.prefixCls;
      if (prevState.current !== this.state.current && this.paginationNode) {
        var lastCurrentNode = this.paginationNode.querySelector(".".concat(prefixCls, "-item-").concat(prevState.current));
        if (lastCurrentNode && document.activeElement === lastCurrentNode) {
          lastCurrentNode.blur();
        }
      }
    }
  }, {
    key: "getValidValue",
    value: function getValidValue(e) {
      var inputValue = e.target.value;
      var allPages = calculatePage(undefined, this.state, this.props);
      var currentInputValue = this.state.currentInputValue;
      var value;
      if (inputValue === '') {
        value = inputValue;
        // eslint-disable-next-line no-restricted-globals
      } else if (isNaN(Number(inputValue))) {
        value = currentInputValue;
      } else if (inputValue >= allPages) {
        value = allPages;
      } else {
        value = Number(inputValue);
      }
      return value;
    }
  }, {
    key: "getShowSizeChanger",
    value: function getShowSizeChanger() {
      var _this$props3 = this.props,
        showSizeChanger = _this$props3.showSizeChanger,
        total = _this$props3.total,
        totalBoundaryShowSizeChanger = _this$props3.totalBoundaryShowSizeChanger;
      if (typeof showSizeChanger !== 'undefined') {
        return showSizeChanger;
      }
      return total > totalBoundaryShowSizeChanger;
    }
  }, {
    key: "renderPrev",
    value: function renderPrev(prevPage) {
      var _this$props4 = this.props,
        prevIcon = _this$props4.prevIcon,
        itemRender = _this$props4.itemRender;
      var prevButton = itemRender(prevPage, 'prev', this.getItemIcon(prevIcon, 'prev page'));
      var disabled = !this.hasPrev();
      return /*#__PURE__*/react.exports.isValidElement(prevButton) ? /*#__PURE__*/react.exports.cloneElement(prevButton, {
        disabled: disabled
      }) : prevButton;
    }
  }, {
    key: "renderNext",
    value: function renderNext(nextPage) {
      var _this$props5 = this.props,
        nextIcon = _this$props5.nextIcon,
        itemRender = _this$props5.itemRender;
      var nextButton = itemRender(nextPage, 'next', this.getItemIcon(nextIcon, 'next page'));
      var disabled = !this.hasNext();
      return /*#__PURE__*/react.exports.isValidElement(nextButton) ? /*#__PURE__*/react.exports.cloneElement(nextButton, {
        disabled: disabled
      }) : nextButton;
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props6 = this.props,
        prefixCls = _this$props6.prefixCls,
        className = _this$props6.className,
        style = _this$props6.style,
        disabled = _this$props6.disabled,
        hideOnSinglePage = _this$props6.hideOnSinglePage,
        total = _this$props6.total,
        locale = _this$props6.locale,
        showQuickJumper = _this$props6.showQuickJumper,
        showLessItems = _this$props6.showLessItems,
        showTitle = _this$props6.showTitle,
        showTotal = _this$props6.showTotal,
        simple = _this$props6.simple,
        itemRender = _this$props6.itemRender,
        showPrevNextJumpers = _this$props6.showPrevNextJumpers,
        jumpPrevIcon = _this$props6.jumpPrevIcon,
        jumpNextIcon = _this$props6.jumpNextIcon,
        selectComponentClass = _this$props6.selectComponentClass,
        selectPrefixCls = _this$props6.selectPrefixCls,
        pageSizeOptions = _this$props6.pageSizeOptions;
      var _this$state2 = this.state,
        current = _this$state2.current,
        pageSize = _this$state2.pageSize,
        currentInputValue = _this$state2.currentInputValue;

      // When hideOnSinglePage is true and there is only 1 page, hide the pager
      if (hideOnSinglePage === true && total <= pageSize) {
        return null;
      }
      var allPages = calculatePage(undefined, this.state, this.props);
      var pagerList = [];
      var jumpPrev = null;
      var jumpNext = null;
      var firstPager = null;
      var lastPager = null;
      var gotoButton = null;
      var goButton = showQuickJumper && showQuickJumper.goButton;
      var pageBufferSize = showLessItems ? 1 : 2;
      var prevPage = current - 1 > 0 ? current - 1 : 0;
      var nextPage = current + 1 < allPages ? current + 1 : allPages;
      var dataOrAriaAttributeProps = Object.keys(this.props).reduce(function (prev, key) {
        if (key.substr(0, 5) === 'data-' || key.substr(0, 5) === 'aria-' || key === 'role') {
          // eslint-disable-next-line no-param-reassign
          prev[key] = _this2.props[key];
        }
        return prev;
      }, {});
      var totalText = showTotal &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("li", {
        className: "".concat(prefixCls, "-total-text"),
        children: showTotal(total, [total === 0 ? 0 : (current - 1) * pageSize + 1, current * pageSize > total ? total : current * pageSize])
      });
      if (simple) {
        if (goButton) {
          if (typeof goButton === 'boolean') {
            gotoButton =
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1("button", {
              type: "button",
              onClick: this.handleGoTO,
              onKeyUp: this.handleGoTO,
              children: locale.jump_to_confirm
            });
          } else {
            gotoButton =
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1("span", {
              onClick: this.handleGoTO,
              onKeyUp: this.handleGoTO,
              children: goButton
            });
          }
          gotoButton =
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("li", {
            title: showTitle ? "".concat(locale.jump_to).concat(current, "/").concat(allPages) : null,
            className: "".concat(prefixCls, "-simple-pager"),
            children: gotoButton
          });
        }
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsxs("ul", {
            className: classNames$1(prefixCls, "".concat(prefixCls, "-simple"), _defineProperty$1({}, "".concat(prefixCls, "-disabled"), disabled), className),
            style: style,
            ref: this.savePaginationNode,
            ...dataOrAriaAttributeProps,
            children: [totalText, /*#__PURE__*/jsx$1("li", {
              title: showTitle ? locale.prev_page : null,
              onClick: this.prev,
              tabIndex: this.hasPrev() ? 0 : null,
              onKeyPress: this.runIfEnterPrev,
              className: classNames$1("".concat(prefixCls, "-prev"), _defineProperty$1({}, "".concat(prefixCls, "-disabled"), !this.hasPrev())),
              "aria-disabled": !this.hasPrev(),
              children: this.renderPrev(prevPage)
            }), /*#__PURE__*/jsxs("li", {
              title: showTitle ? "".concat(current, "/").concat(allPages) : null,
              className: "".concat(prefixCls, "-simple-pager"),
              children: [/*#__PURE__*/jsx$1("input", {
                type: "text",
                value: currentInputValue,
                disabled: disabled,
                onKeyDown: this.handleKeyDown,
                onKeyUp: this.handleKeyUp,
                onChange: this.handleKeyUp,
                onBlur: this.handleBlur,
                size: "3"
              }), /*#__PURE__*/jsx$1("span", {
                className: "".concat(prefixCls, "-slash"),
                children: "/"
              }), allPages]
            }), /*#__PURE__*/jsx$1("li", {
              title: showTitle ? locale.next_page : null,
              onClick: this.next,
              tabIndex: this.hasPrev() ? 0 : null,
              onKeyPress: this.runIfEnterNext,
              className: classNames$1("".concat(prefixCls, "-next"), _defineProperty$1({}, "".concat(prefixCls, "-disabled"), !this.hasNext())),
              "aria-disabled": !this.hasNext(),
              children: this.renderNext(nextPage)
            }), gotoButton]
          })
        );
      }
      if (allPages <= 3 + pageBufferSize * 2) {
        var pagerProps = {
          locale: locale,
          rootPrefixCls: prefixCls,
          onClick: this.handleChange,
          onKeyPress: this.runIfEnter,
          showTitle: showTitle,
          itemRender: itemRender
        };
        if (!allPages) {
          pagerList.push(
          /*#__PURE__*/
          /*#__PURE__*/
          react.exports.createElement(Pager, {
            ...pagerProps,
            key: "noPager",
            page: 1,
            className: "".concat(prefixCls, "-item-disabled")
          }));
        }
        for (var i = 1; i <= allPages; i += 1) {
          var active = current === i;
          pagerList.push(
          /*#__PURE__*/
          /*#__PURE__*/
          react.exports.createElement(Pager, {
            ...pagerProps,
            key: i,
            page: i,
            active: active
          }));
        }
      } else {
        var prevItemTitle = showLessItems ? locale.prev_3 : locale.prev_5;
        var nextItemTitle = showLessItems ? locale.next_3 : locale.next_5;
        if (showPrevNextJumpers) {
          jumpPrev =
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("li", {
            title: showTitle ? prevItemTitle : null,
            onClick: this.jumpPrev,
            tabIndex: "0",
            onKeyPress: this.runIfEnterJumpPrev,
            className: classNames$1("".concat(prefixCls, "-jump-prev"), _defineProperty$1({}, "".concat(prefixCls, "-jump-prev-custom-icon"), !!jumpPrevIcon)),
            children: itemRender(this.getJumpPrevPage(), 'jump-prev', this.getItemIcon(jumpPrevIcon, 'prev page'))
          }, "prev");
          jumpNext =
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("li", {
            title: showTitle ? nextItemTitle : null,
            tabIndex: "0",
            onClick: this.jumpNext,
            onKeyPress: this.runIfEnterJumpNext,
            className: classNames$1("".concat(prefixCls, "-jump-next"), _defineProperty$1({}, "".concat(prefixCls, "-jump-next-custom-icon"), !!jumpNextIcon)),
            children: itemRender(this.getJumpNextPage(), 'jump-next', this.getItemIcon(jumpNextIcon, 'next page'))
          }, "next");
        }
        lastPager =
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(Pager, {
          locale: locale,
          last: true,
          rootPrefixCls: prefixCls,
          onClick: this.handleChange,
          onKeyPress: this.runIfEnter,
          page: allPages,
          active: false,
          showTitle: showTitle,
          itemRender: itemRender
        }, allPages);
        firstPager =
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(Pager, {
          locale: locale,
          rootPrefixCls: prefixCls,
          onClick: this.handleChange,
          onKeyPress: this.runIfEnter,
          page: 1,
          active: false,
          showTitle: showTitle,
          itemRender: itemRender
        }, 1);
        var left = Math.max(1, current - pageBufferSize);
        var right = Math.min(current + pageBufferSize, allPages);
        if (current - 1 <= pageBufferSize) {
          right = 1 + pageBufferSize * 2;
        }
        if (allPages - current <= pageBufferSize) {
          left = allPages - pageBufferSize * 2;
        }
        for (var _i = left; _i <= right; _i += 1) {
          var _active = current === _i;
          pagerList.push(
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(Pager, {
            locale: locale,
            rootPrefixCls: prefixCls,
            onClick: this.handleChange,
            onKeyPress: this.runIfEnter,
            page: _i,
            active: _active,
            showTitle: showTitle,
            itemRender: itemRender
          }, _i));
        }
        if (current - 1 >= pageBufferSize * 2 && current !== 1 + 2) {
          pagerList[0] = /*#__PURE__*/react.exports.cloneElement(pagerList[0], {
            className: "".concat(prefixCls, "-item-after-jump-prev")
          });
          pagerList.unshift(jumpPrev);
        }
        if (allPages - current >= pageBufferSize * 2 && current !== allPages - 2) {
          pagerList[pagerList.length - 1] = /*#__PURE__*/react.exports.cloneElement(pagerList[pagerList.length - 1], {
            className: "".concat(prefixCls, "-item-before-jump-next")
          });
          pagerList.push(jumpNext);
        }
        if (left !== 1) {
          pagerList.unshift(firstPager);
        }
        if (right !== allPages) {
          pagerList.push(lastPager);
        }
      }
      var prevDisabled = !this.hasPrev() || !allPages;
      var nextDisabled = !this.hasNext() || !allPages;
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsxs("ul", {
          className: classNames$1(prefixCls, className, _defineProperty$1({}, "".concat(prefixCls, "-disabled"), disabled)),
          style: style,
          ref: this.savePaginationNode,
          ...dataOrAriaAttributeProps,
          children: [totalText, /*#__PURE__*/jsx$1("li", {
            title: showTitle ? locale.prev_page : null,
            onClick: this.prev,
            tabIndex: prevDisabled ? null : 0,
            onKeyPress: this.runIfEnterPrev,
            className: classNames$1("".concat(prefixCls, "-prev"), _defineProperty$1({}, "".concat(prefixCls, "-disabled"), prevDisabled)),
            "aria-disabled": prevDisabled,
            children: this.renderPrev(prevPage)
          }), pagerList, /*#__PURE__*/jsx$1("li", {
            title: showTitle ? locale.next_page : null,
            onClick: this.next,
            tabIndex: nextDisabled ? null : 0,
            onKeyPress: this.runIfEnterNext,
            className: classNames$1("".concat(prefixCls, "-next"), _defineProperty$1({}, "".concat(prefixCls, "-disabled"), nextDisabled)),
            "aria-disabled": nextDisabled,
            children: this.renderNext(nextPage)
          }), /*#__PURE__*/jsx$1(Options, {
            disabled: disabled,
            locale: locale,
            rootPrefixCls: prefixCls,
            selectComponentClass: selectComponentClass,
            selectPrefixCls: selectPrefixCls,
            changeSize: this.getShowSizeChanger() ? this.changePageSize : null,
            current: current,
            pageSize: pageSize,
            pageSizeOptions: pageSizeOptions,
            quickGo: this.shouldDisplayQuickJumper() ? this.handleChange : null,
            goButton: goButton
          })]
        })
      );
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, prevState) {
      var newState = {};
      if ('current' in props) {
        newState.current = props.current;
        if (props.current !== prevState.current) {
          newState.currentInputValue = newState.current;
        }
      }
      if ('pageSize' in props && props.pageSize !== prevState.pageSize) {
        var current = prevState.current;
        var newCurrent = calculatePage(props.pageSize, prevState, props);
        current = current > newCurrent ? newCurrent : current;
        if (!('current' in props)) {
          newState.current = current;
          newState.currentInputValue = current;
        }
        newState.pageSize = props.pageSize;
      }
      return newState;
    }
  }]);
  return Pagination;
}(React.Component);
Pagination$2.defaultProps = {
  defaultCurrent: 1,
  total: 0,
  defaultPageSize: 10,
  onChange: noop$3,
  className: '',
  selectPrefixCls: 'rc-select',
  prefixCls: 'rc-pagination',
  selectComponentClass: null,
  hideOnSinglePage: false,
  showPrevNextJumpers: true,
  showQuickJumper: false,
  showLessItems: false,
  showTitle: true,
  onShowSizeChange: noop$3,
  locale: LOCALE,
  style: {},
  itemRender: defaultItemRender,
  totalBoundaryShowSizeChanger: 50
};

var MiniSelect = function MiniSelect(props) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Select$3, {
      ...props,
      size: "small"
    })
  );
};
var MiddleSelect = function MiddleSelect(props) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Select$3, {
      ...props,
      size: "middle"
    })
  );
};
MiniSelect.Option = Select$3.Option;
MiddleSelect.Option = Select$3.Option;

var genPaginationDisabledStyle = function genPaginationDisabledStyle(token) {
  var _ref2, _ref3;
  var componentCls = token.componentCls;
  return _ref3 = {}, _defineProperty$1(_ref3, componentCls + "-disabled", {
    '&, &:hover': _defineProperty$1({
      cursor: 'not-allowed'
    }, componentCls + "-item-link", {
      color: token.colorTextDisabled,
      cursor: 'not-allowed'
    }),
    '&:focus-visible': _defineProperty$1({
      cursor: 'not-allowed'
    }, componentCls + "-item-link", {
      color: token.colorTextDisabled,
      cursor: 'not-allowed'
    })
  }), _defineProperty$1(_ref3, "&" + componentCls + "-disabled", (_ref2 = {
    cursor: 'not-allowed'
  }, _defineProperty$1(_ref2, componentCls + "-item", {
    cursor: 'not-allowed',
    '&:hover, &:active': {
      backgroundColor: 'transparent'
    },
    a: {
      color: token.colorTextDisabled,
      backgroundColor: 'transparent',
      border: 'none',
      cursor: 'not-allowed'
    },
    '&-active': {
      borderColor: token.colorBorder,
      backgroundColor: token.paginationItemDisabledBgActive,
      '&:hover, &:active': {
        backgroundColor: token.paginationItemDisabledBgActive
      },
      a: {
        color: token.paginationItemDisabledColorActive
      }
    }
  }), _defineProperty$1(_ref2, componentCls + "-item-link", _defineProperty$1({
    color: token.colorTextDisabled,
    cursor: 'not-allowed',
    '&:hover, &:active': {
      backgroundColor: 'transparent'
    }
  }, componentCls + "-simple&", {
    backgroundColor: 'transparent'
  })), _defineProperty$1(_ref2, componentCls + "-item-link-icon", {
    opacity: 0
  }), _defineProperty$1(_ref2, componentCls + "-item-ellipsis", {
    opacity: 1
  }), _defineProperty$1(_ref2, componentCls + "-simple-pager", {
    color: token.colorTextDisabled
  }), _ref2)), _ref3;
};
var genPaginationMiniStyle = function genPaginationMiniStyle(token) {
  var _ref4, _ref5;
  var componentCls = token.componentCls;
  return _ref5 = {}, _defineProperty$1(_ref5, "&&-mini " + componentCls + "-total-text, &&-mini " + componentCls + "-simple-pager", {
    height: token.paginationItemSizeSM,
    lineHeight: token.paginationItemSizeSM + "px"
  }), _defineProperty$1(_ref5, "&&-mini " + componentCls + "-item", {
    minWidth: token.paginationItemSizeSM,
    height: token.paginationItemSizeSM,
    margin: 0,
    lineHeight: token.paginationItemSizeSM - 2 + "px"
  }), _defineProperty$1(_ref5, "&&-mini " + componentCls + "-item:not(" + componentCls + "-item-active)", {
    backgroundColor: 'transparent',
    borderColor: 'transparent'
  }), _defineProperty$1(_ref5, "&&-mini " + componentCls + "-prev, &&-mini " + componentCls + "-next", {
    minWidth: token.paginationItemSizeSM,
    height: token.paginationItemSizeSM,
    margin: 0,
    lineHeight: token.paginationItemSizeSM + "px"
  }), _defineProperty$1(_ref5, "\n    &&-mini " + componentCls + "-prev " + componentCls + "-item-link,\n    &&-mini " + componentCls + "-next " + componentCls + "-item-link\n    ", {
    backgroundColor: 'transparent',
    borderColor: 'transparent',
    '&::after': {
      height: token.paginationItemSizeSM,
      lineHeight: token.paginationItemSizeSM + "px"
    }
  }), _defineProperty$1(_ref5, "&&-mini " + componentCls + "-jump-prev, &&-mini " + componentCls + "-jump-next", {
    height: token.paginationItemSizeSM,
    marginInlineEnd: 0,
    lineHeight: token.paginationItemSizeSM + "px"
  }), _defineProperty$1(_ref5, "&&-mini " + componentCls + "-options", (_ref4 = {
    marginInlineStart: token.paginationMiniOptionsMarginInlineStart
  }, _defineProperty$1(_ref4, "&-size-changer", {
    top: token.paginationMiniOptionsSizeChangerTop
  }), _defineProperty$1(_ref4, "&-quick-jumper", {
    height: token.paginationItemSizeSM,
    lineHeight: token.paginationItemSizeSM + "px",
    input: _extends$2(_extends$2({}, genInputSmallStyle(token)), {
      width: token.paginationMiniQuickJumperInputWidth,
      height: token.controlHeightSM
    })
  }), _ref4)), _ref5;
};
var genPaginationSimpleStyle = function genPaginationSimpleStyle(token) {
  var _ref7;
  var componentCls = token.componentCls;
  return _ref7 = {}, _defineProperty$1(_ref7, "\n    &" + componentCls + "-simple " + componentCls + "-prev,\n    &" + componentCls + "-simple " + componentCls + "-next\n    ", _defineProperty$1({
    height: token.paginationItemSizeSM,
    lineHeight: token.paginationItemSizeSM + "px",
    verticalAlign: 'top'
  }, componentCls + "-item-link", {
    height: token.paginationItemSizeSM,
    backgroundColor: 'transparent',
    border: 0,
    '&::after': {
      height: token.paginationItemSizeSM,
      lineHeight: token.paginationItemSizeSM + "px"
    }
  })), _defineProperty$1(_ref7, "&" + componentCls + "-simple " + componentCls + "-simple-pager", {
    display: 'inline-block',
    height: token.paginationItemSizeSM,
    marginInlineEnd: token.marginXS,
    input: {
      boxSizing: 'border-box',
      height: '100%',
      marginInlineEnd: token.marginXS,
      padding: "0 " + token.paginationItemPaddingInline + "px",
      textAlign: 'center',
      backgroundColor: token.paginationItemInputBg,
      border: token.lineWidth + "px " + token.lineType + " " + token.colorBorder,
      borderRadius: token.borderRadius,
      outline: 'none',
      transition: "border-color " + token.motionDurationMid,
      color: 'inherit',
      '&:hover': {
        borderColor: token.colorPrimary
      },
      '&:focus': {
        borderColor: token.colorPrimaryHover,
        boxShadow: token.inputOutlineOffset + "px 0 " + token.controlOutlineWidth + "px " + token.controlOutline
      },
      '&[disabled]': {
        color: token.colorTextDisabled,
        backgroundColor: token.colorBgContainerDisabled,
        borderColor: token.colorBorder,
        cursor: 'not-allowed'
      }
    }
  }), _ref7;
};
var genPaginationJumpStyle = function genPaginationJumpStyle(token) {
  var _ref8, _hover2, _extends2, _ref9, _ref11, _ref12;
  var componentCls = token.componentCls;
  return _ref12 = {}, _defineProperty$1(_ref12, componentCls + "-jump-prev, " + componentCls + "-jump-next", (_ref9 = {
    outline: 0
  }, _defineProperty$1(_ref9, componentCls + "-item-container", (_ref8 = {
    position: 'relative'
  }, _defineProperty$1(_ref8, componentCls + "-item-link-icon", {
    color: token.colorPrimary,
    fontSize: token.fontSizeSM,
    opacity: 0,
    transition: "all " + token.motionDurationMid,
    '&-svg': {
      top: 0,
      insetInlineEnd: 0,
      bottom: 0,
      insetInlineStart: 0,
      margin: 'auto'
    }
  }), _defineProperty$1(_ref8, componentCls + "-item-ellipsis", {
    position: 'absolute',
    top: 0,
    insetInlineEnd: 0,
    bottom: 0,
    insetInlineStart: 0,
    display: 'block',
    margin: 'auto',
    color: token.colorTextDisabled,
    fontFamily: 'Arial, Helvetica, sans-serif',
    letterSpacing: token.paginationEllipsisLetterSpacing,
    textAlign: 'center',
    textIndent: token.paginationEllipsisTextIndent,
    opacity: 1,
    transition: "all " + token.motionDurationMid
  }), _ref8)), _defineProperty$1(_ref9, '&:hover', (_hover2 = {}, _defineProperty$1(_hover2, componentCls + "-item-link-icon", {
    opacity: 1
  }), _defineProperty$1(_hover2, componentCls + "-item-ellipsis", {
    opacity: 0
  }), _hover2)), _defineProperty$1(_ref9, '&:focus-visible', _extends$2((_extends2 = {}, _defineProperty$1(_extends2, componentCls + "-item-link-icon", {
    opacity: 1
  }), _defineProperty$1(_extends2, componentCls + "-item-ellipsis", {
    opacity: 0
  }), _extends2), genFocusOutline(token))), _ref9)), _defineProperty$1(_ref12, "\n    " + componentCls + "-prev,\n    " + componentCls + "-jump-prev,\n    " + componentCls + "-jump-next\n    ", {
    marginInlineEnd: token.marginXS
  }), _defineProperty$1(_ref12, "\n    " + componentCls + "-prev,\n    " + componentCls + "-next,\n    " + componentCls + "-jump-prev,\n    " + componentCls + "-jump-next\n    ", {
    display: 'inline-block',
    minWidth: token.paginationItemSize,
    height: token.paginationItemSize,
    color: token.colorText,
    fontFamily: token.paginationFontFamily,
    lineHeight: token.paginationItemSize + "px",
    textAlign: 'center',
    verticalAlign: 'middle',
    listStyle: 'none',
    borderRadius: token.borderRadius,
    cursor: 'pointer',
    transition: "all " + token.motionDurationMid
  }), _defineProperty$1(_ref12, componentCls + "-prev, " + componentCls + "-next", (_ref11 = {
    fontFamily: 'Arial, Helvetica, sans-serif',
    outline: 0,
    button: {
      color: token.colorText,
      cursor: 'pointer',
      userSelect: 'none'
    }
  }, _defineProperty$1(_ref11, componentCls + "-item-link", {
    display: 'block',
    width: '100%',
    height: '100%',
    padding: 0,
    fontSize: token.fontSizeSM,
    textAlign: 'center',
    backgroundColor: 'transparent',
    border: token.lineWidth + "px " + token.lineType + " transparent",
    borderRadius: token.borderRadius,
    outline: 'none',
    transition: "border " + token.motionDurationMid
  }), _defineProperty$1(_ref11, "&:focus-visible " + componentCls + "-item-link", _extends$2({}, genFocusOutline(token))), _defineProperty$1(_ref11, "&:hover " + componentCls + "-item-link", {
    backgroundColor: token.colorBgTextHover
  }), _defineProperty$1(_ref11, "&:active " + componentCls + "-item-link", {
    backgroundColor: token.colorBgTextActive
  }), _defineProperty$1(_ref11, "&" + componentCls + "-disabled:hover", _defineProperty$1({}, componentCls + "-item-link", {
    backgroundColor: 'transparent'
  })), _ref11)), _defineProperty$1(_ref12, componentCls + "-slash", {
    marginInlineEnd: token.paginationSlashMarginInlineEnd,
    marginInlineStart: token.paginationSlashMarginInlineStart
  }), _defineProperty$1(_ref12, componentCls + "-options", {
    display: 'inline-block',
    marginInlineStart: token.margin,
    verticalAlign: 'middle',
    '&-size-changer.-select': {
      display: 'inline-block',
      width: 'auto'
    },
    '&-quick-jumper': {
      display: 'inline-block',
      height: token.controlHeight,
      marginInlineStart: token.marginXS,
      lineHeight: token.controlHeight + "px",
      verticalAlign: 'top',
      input: _extends$2(_extends$2({}, genBasicInputStyle(token)), {
        width: token.controlHeightLG * 1.25,
        height: token.controlHeight,
        boxSizing: 'border-box',
        margin: 0,
        marginInlineStart: token.marginXS,
        marginInlineEnd: token.marginXS
      })
    }
  }), _ref12;
};
var genPaginationItemStyle = function genPaginationItemStyle(token) {
  var componentCls = token.componentCls;
  return _defineProperty$1({}, componentCls + "-item", _extends$2(_extends$2(_defineProperty$1({
    display: 'inline-block',
    minWidth: token.paginationItemSize,
    height: token.paginationItemSize,
    marginInlineEnd: token.marginXS,
    fontFamily: token.paginationFontFamily,
    lineHeight: token.paginationItemSize - 2 + "px",
    textAlign: 'center',
    verticalAlign: 'middle',
    listStyle: 'none',
    backgroundColor: 'transparent',
    border: token.lineWidth + "px " + token.lineType + " transparent",
    borderRadius: token.borderRadius,
    outline: 0,
    cursor: 'pointer',
    userSelect: 'none',
    a: {
      display: 'block',
      padding: "0 " + token.paginationItemPaddingInline + "px",
      color: token.colorText,
      transition: 'none',
      '&:hover': {
        textDecoration: 'none'
      }
    }
  }, "&:not(" + componentCls + "-item-active)", {
    '&:hover': {
      transition: "all " + token.motionDurationMid,
      backgroundColor: token.colorBgTextHover
    },
    '&:active': {
      backgroundColor: token.colorBgTextActive
    }
  }), genFocusStyle(token)), {
    '&-active': {
      fontWeight: token.paginationFontWeightActive,
      backgroundColor: token.paginationItemBgActive,
      borderColor: token.colorPrimary,
      a: {
        color: token.colorPrimary
      },
      '&:hover': {
        borderColor: token.colorPrimaryHover
      },
      '&:hover a': {
        color: token.colorPrimaryHover
      }
    }
  }));
};
var genPaginationStyle$2 = function genPaginationStyle(token) {
  var _extends5, _ref16;
  var componentCls = token.componentCls;
  return _ref16 = {}, _defineProperty$1(_ref16, componentCls, _extends$2(_extends$2(_extends$2(_extends$2(_extends$2(_extends$2(_extends$2(_extends$2({}, resetComponent(token)), _defineProperty$1({
    'ul, ol': {
      margin: 0,
      padding: 0,
      listStyle: 'none'
    },
    '&::after': {
      display: 'block',
      clear: 'both',
      height: 0,
      overflow: 'hidden',
      visibility: 'hidden',
      content: '""'
    }
  }, componentCls + "-total-text", {
    display: 'inline-block',
    height: token.paginationItemSize,
    marginInlineEnd: token.marginXS,
    lineHeight: token.paginationItemSize - 2 + "px",
    verticalAlign: 'middle'
  })), genPaginationItemStyle(token)), genPaginationJumpStyle(token)), genPaginationSimpleStyle(token)), genPaginationMiniStyle(token)), genPaginationDisabledStyle(token)), (_extends5 = {}, _defineProperty$1(_extends5, "@media only screen and (max-width: " + token.screenLG + "px)", _defineProperty$1({}, componentCls + "-item", {
    '&-after-jump-prev, &-before-jump-next': {
      display: 'none'
    }
  })), _defineProperty$1(_extends5, "@media only screen and (max-width: " + token.screenSM + "px)", _defineProperty$1({}, componentCls + "-options", {
    display: 'none'
  })), _extends5))), _defineProperty$1(_ref16, "&" + token.componentCls + "-rtl", {
    direction: 'rtl'
  }), _ref16;
};
var genBorderedStyle$2 = function genBorderedStyle(token) {
  var _ref17, _ref19, _ref21, _ref22, _componentCls, _ref23;
  var componentCls = token.componentCls;
  return _ref23 = {}, _defineProperty$1(_ref23, "" + componentCls + componentCls + "-disabled", (_ref19 = {
    '&, &:hover': _defineProperty$1({}, componentCls + "-item-link", {
      borderColor: token.colorBorder
    }),
    '&:focus-visible': _defineProperty$1({}, componentCls + "-item-link", {
      borderColor: token.colorBorder
    })
  }, _defineProperty$1(_ref19, componentCls + "-item, " + componentCls + "-item-link", (_ref17 = {
    backgroundColor: token.colorBgContainerDisabled,
    borderColor: token.colorBorder
  }, _defineProperty$1(_ref17, "&:hover:not(" + componentCls + "-item-active)", {
    backgroundColor: token.colorBgContainerDisabled,
    borderColor: token.colorBorder,
    a: {
      color: token.colorTextDisabled
    }
  }), _defineProperty$1(_ref17, "&" + componentCls + "-item-active", {
    backgroundColor: token.paginationItemDisabledBgActive
  }), _ref17)), _defineProperty$1(_ref19, componentCls + "-prev, " + componentCls + "-next", _defineProperty$1({
    '&:hover button': {
      backgroundColor: token.colorBgContainerDisabled,
      borderColor: token.colorBorder,
      color: token.colorTextDisabled
    }
  }, componentCls + "-item-link", {
    backgroundColor: token.colorBgContainerDisabled,
    borderColor: token.colorBorder
  })), _ref19)), _defineProperty$1(_ref23, componentCls, (_componentCls = {}, _defineProperty$1(_componentCls, componentCls + "-prev, " + componentCls + "-next", (_ref21 = {
    '&:hover button': {
      borderColor: token.colorPrimaryHover,
      backgroundColor: token.paginationItemBg
    }
  }, _defineProperty$1(_ref21, componentCls + "-item-link", {
    backgroundColor: token.paginationItemLinkBg,
    borderColor: token.colorBorder
  }), _defineProperty$1(_ref21, "&:hover " + componentCls + "-item-link", {
    borderColor: token.colorPrimary,
    backgroundColor: token.paginationItemBg,
    color: token.colorPrimary
  }), _defineProperty$1(_ref21, "&" + componentCls + "-disabled", _defineProperty$1({}, componentCls + "-item-link", {
    borderColor: token.colorBorder,
    color: token.colorTextDisabled
  })), _ref21)), _defineProperty$1(_componentCls, componentCls + "-item", (_ref22 = {
    backgroundColor: token.paginationItemBg,
    border: token.lineWidth + "px " + token.lineType + " " + token.colorBorder
  }, _defineProperty$1(_ref22, "&:hover:not(" + componentCls + "-item-active)", {
    borderColor: token.colorPrimary,
    backgroundColor: token.paginationItemBg,
    a: {
      color: token.colorPrimary
    }
  }), _defineProperty$1(_ref22, '&-active', {
    borderColor: token.colorPrimary
  }), _ref22)), _componentCls)), _ref23;
};
// ============================== Export ==============================
const useStyle$8 = genComponentStyleHook('Pagination', function (token) {
  var paginationToken = merge$2(token, {
    paginationItemSize: token.controlHeight,
    paginationFontFamily: token.fontFamily,
    paginationItemBg: token.colorBgContainer,
    paginationItemBgActive: token.colorBgContainer,
    paginationFontWeightActive: token.fontWeightStrong,
    paginationItemSizeSM: token.controlHeightSM,
    paginationItemInputBg: token.colorBgContainer,
    paginationMiniOptionsSizeChangerTop: 0,
    paginationItemDisabledBgActive: token.controlItemBgActiveDisabled,
    paginationItemDisabledColorActive: token.colorTextDisabled,
    paginationItemLinkBg: token.colorBgContainer,
    inputOutlineOffset: '0 0',
    paginationMiniOptionsMarginInlineStart: token.marginXXS / 2,
    paginationMiniQuickJumperInputWidth: token.controlHeightLG * 1.1,
    paginationItemPaddingInline: token.marginXXS * 1.5,
    paginationEllipsisLetterSpacing: token.marginXXS / 2,
    paginationSlashMarginInlineStart: token.marginXXS,
    paginationSlashMarginInlineEnd: token.marginSM,
    paginationEllipsisTextIndent: '0.13em' // magic for ui experience
  }, initInputToken(token));
  return [genPaginationStyle$2(paginationToken), token.wireframe && genBorderedStyle$2(paginationToken)];
});

var __rest$j = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var Pagination = function Pagination(_a) {
  var customizePrefixCls = _a.prefixCls,
    customizeSelectPrefixCls = _a.selectPrefixCls,
    className = _a.className,
    size = _a.size,
    customLocale = _a.locale,
    selectComponentClass = _a.selectComponentClass,
    responsive = _a.responsive,
    showSizeChanger = _a.showSizeChanger,
    restProps = __rest$j(_a, ["prefixCls", "selectPrefixCls", "className", "size", "locale", "selectComponentClass", "responsive", "showSizeChanger"]);
  var _useBreakpoint = useBreakpoint(responsive),
    xs = _useBreakpoint.xs;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction,
    _React$useContext$pag = _React$useContext.pagination,
    pagination = _React$useContext$pag === void 0 ? {} : _React$useContext$pag;
  var prefixCls = getPrefixCls('pagination', customizePrefixCls);
  // Style
  var _useStyle = useStyle$8(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var mergedShowSizeChanger = showSizeChanger !== null && showSizeChanger !== void 0 ? showSizeChanger : pagination.showSizeChanger;
  var getIconsProps = function getIconsProps() {
    var ellipsis =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      className: prefixCls + "-item-ellipsis",
      children: "\u2022\u2022\u2022"
    });
    var prevIcon =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("button", {
      className: prefixCls + "-item-link",
      type: "button",
      tabIndex: -1,
      children: /*#__PURE__*/jsx$1(LeftOutlined$1, {})
    });
    var nextIcon =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("button", {
      className: prefixCls + "-item-link",
      type: "button",
      tabIndex: -1,
      children: /*#__PURE__*/jsx$1(RightOutlined$1, {})
    });
    var jumpPrevIcon =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("a", {
      className: prefixCls + "-item-link",
      children: /*#__PURE__*/jsxs("div", {
        className: prefixCls + "-item-container",
        children: [/*#__PURE__*/jsx$1(DoubleLeftOutlined$1, {
          className: prefixCls + "-item-link-icon"
        }), ellipsis]
      })
    });
    var jumpNextIcon =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("a", {
      className: prefixCls + "-item-link",
      children: /*#__PURE__*/jsxs("div", {
        className: prefixCls + "-item-container",
        children: [/*#__PURE__*/jsx$1(DoubleRightOutlined$1, {
          className: prefixCls + "-item-link-icon"
        }), ellipsis]
      })
    });
    // change arrows direction in right-to-left direction
    if (direction === 'rtl') {
      var _ref = [nextIcon, prevIcon];
      prevIcon = _ref[0];
      nextIcon = _ref[1];
      var _ref2 = [jumpNextIcon, jumpPrevIcon];
      jumpPrevIcon = _ref2[0];
      jumpNextIcon = _ref2[1];
    }
    return {
      prevIcon: prevIcon,
      nextIcon: nextIcon,
      jumpPrevIcon: jumpPrevIcon,
      jumpNextIcon: jumpNextIcon
    };
  };
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(LocaleReceiver, {
      componentName: "Pagination",
      defaultLocale: enUS,
      children: function (contextLocale) {
        var _classNames;
        var locale = _extends$2(_extends$2({}, contextLocale), customLocale);
        var isSmall = size === 'small' || !!(xs && !size && responsive);
        var selectPrefixCls = getPrefixCls('select', customizeSelectPrefixCls);
        var extendedClassName = classNames$1((_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-mini", isSmall), _defineProperty$1(_classNames, prefixCls + "-rtl", direction === 'rtl'), _classNames), className, hashId);
        return wrapSSR(
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(Pagination$2, {
          ...getIconsProps(),
          ...restProps,
          prefixCls: prefixCls,
          selectPrefixCls: selectPrefixCls,
          className: extendedClassName,
          selectComponentClass: selectComponentClass || (isSmall ? MiniSelect : MiddleSelect),
          locale: locale,
          showSizeChanger: mergedShowSizeChanger
        }));
      }
    })
  );
};
const Pagination$1 = Pagination;

var antSpinMove = new Keyframe('antSpinMove', {
  to: {
    opacity: 1
  }
});
var antRotate = new Keyframe('antRotate', {
  to: {
    transform: 'rotate(405deg)'
  }
});
var genSpinStyle = function genSpinStyle(token) {
  var _sm, _lg, _ref, _nestedLoading, _extends2;
  return _defineProperty$1({}, "" + token.componentCls, _extends$2(_extends$2({}, resetComponent(token)), (_extends2 = {
    position: 'absolute',
    display: 'none',
    color: token.colorPrimary,
    textAlign: 'center',
    verticalAlign: 'middle',
    opacity: 0,
    transition: "transform " + token.motionDurationSlow + " " + token.motionEaseInOutCirc,
    '&-spinning': {
      position: 'static',
      display: 'inline-block',
      opacity: 1
    },
    '&-nested-loading': (_nestedLoading = {
      position: 'relative'
    }, _defineProperty$1(_nestedLoading, "> div > " + token.componentCls, (_ref = {
      position: 'absolute',
      top: 0,
      insetInlineStart: 0,
      zIndex: 4,
      display: 'block',
      width: '100%',
      height: '100%',
      maxHeight: token.contentHeight
    }, _defineProperty$1(_ref, token.componentCls + "-dot", {
      position: 'absolute',
      top: '50%',
      insetInlineStart: '50%',
      margin: -token.spinDotSize / 2
    }), _defineProperty$1(_ref, token.componentCls + "-text", {
      position: 'absolute',
      top: '50%',
      width: '100%',
      paddingTop: (token.spinDotSize - token.fontSize) / 2 + 2,
      textShadow: "0 1px 2px " + token.colorBgContainer // FIXME: shadow
    }), _defineProperty$1(_ref, "&" + token.componentCls + "-show-text " + token.componentCls + "-dot", {
      marginTop: -(token.spinDotSize / 2) - 10
    }), _defineProperty$1(_ref, '&-sm', (_sm = {}, _defineProperty$1(_sm, token.componentCls + "-dot", {
      margin: -token.spinDotSizeSM / 2
    }), _defineProperty$1(_sm, token.componentCls + "-text", {
      paddingTop: (token.spinDotSizeSM - token.fontSize) / 2 + 2
    }), _defineProperty$1(_sm, "&" + token.componentCls + "-show-text " + token.componentCls + "-dot", {
      marginTop: -(token.spinDotSizeSM / 2) - 10
    }), _sm)), _defineProperty$1(_ref, '&-lg', (_lg = {}, _defineProperty$1(_lg, token.componentCls + "-dot", {
      margin: -(token.spinDotSizeLG / 2)
    }), _defineProperty$1(_lg, token.componentCls + "-text", {
      paddingTop: (token.spinDotSizeLG - token.fontSize) / 2 + 2
    }), _defineProperty$1(_lg, "&" + token.componentCls + "-show-text " + token.componentCls + "-dot", {
      marginTop: -(token.spinDotSizeLG / 2) - 10
    }), _lg)), _ref)), _defineProperty$1(_nestedLoading, token.componentCls + "-container", {
      position: 'relative',
      transition: "opacity " + token.motionDurationSlow,
      '&::after': {
        position: 'absolute',
        top: 0,
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 10,
        width: '100%',
        height: '100%',
        background: token.colorBgContainer,
        opacity: 0,
        transition: "all " + token.motionDurationSlow,
        content: '""',
        pointerEvents: 'none'
      }
    }), _defineProperty$1(_nestedLoading, token.componentCls + "-blur", _defineProperty$1({
      clear: 'both',
      opacity: 0.5,
      userSelect: 'none',
      pointerEvents: 'none'
    }, "&::after", {
      opacity: 0.4,
      pointerEvents: 'auto'
    })), _nestedLoading)
  }, _defineProperty$1(_extends2, "&-tip", {
    color: token.spinDotDefault
  }), _defineProperty$1(_extends2, token.componentCls + "-dot", {
    position: 'relative',
    display: 'inline-block',
    fontSize: token.spinDotSize,
    width: '1em',
    height: '1em',
    '&-item': {
      position: 'absolute',
      display: 'block',
      width: (token.spinDotSize - token.marginXXS / 2) / 2,
      height: (token.spinDotSize - token.marginXXS / 2) / 2,
      backgroundColor: token.colorPrimary,
      borderRadius: '100%',
      transform: 'scale(0.75)',
      transformOrigin: '50% 50%',
      opacity: 0.3,
      animationName: antSpinMove,
      animationDuration: '1s',
      animationIterationCount: 'infinite',
      animationTimingFunction: 'linear',
      animationDirection: 'alternate',
      '&:nth-child(1)': {
        top: 0,
        insetInlineStart: 0
      },
      '&:nth-child(2)': {
        top: 0,
        insetInlineEnd: 0,
        animationDelay: '0.4s'
      },
      '&:nth-child(3)': {
        insetInlineEnd: 0,
        bottom: 0,
        animationDelay: '0.8s'
      },
      '&:nth-child(4)': {
        bottom: 0,
        insetInlineStart: 0,
        animationDelay: '1.2s'
      }
    },
    '&-spin': {
      transform: 'rotate(45deg)',
      animationName: antRotate,
      animationDuration: '1.2s',
      animationIterationCount: 'infinite',
      animationTimingFunction: 'linear'
    }
  }), _defineProperty$1(_extends2, "&-sm " + token.componentCls + "-dot", {
    fontSize: token.spinDotSizeSM,
    i: {
      width: (token.spinDotSizeSM - token.marginXXS / 2) / 2,
      height: (token.spinDotSizeSM - token.marginXXS / 2) / 2
    }
  }), _defineProperty$1(_extends2, "&-lg " + token.componentCls + "-dot", {
    fontSize: token.spinDotSizeLG,
    i: {
      width: (token.spinDotSizeLG - token.marginXXS) / 2,
      height: (token.spinDotSizeLG - token.marginXXS) / 2
    }
  }), _defineProperty$1(_extends2, "&" + token.componentCls + "-show-text " + token.componentCls + "-text", {
    display: 'block'
  }), _extends2)));
};
// ============================== Export ==============================
const useStyle$7 = genComponentStyleHook('Spin', function (token) {
  var spinToken = merge$2(token, {
    spinDotDefault: token.colorTextDescription,
    spinDotSize: token.controlHeightLG / 2,
    spinDotSizeSM: token.controlHeightLG * 0.35,
    spinDotSizeLG: token.controlHeight
  });
  return [genSpinStyle(spinToken)];
}, {
  contentHeight: 400
});

var __rest$i = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
// Render indicator
var defaultIndicator = null;
function renderIndicator(prefixCls, props) {
  var indicator = props.indicator;
  var dotClassName = prefixCls + "-dot";
  // should not be render default indicator when indicator value is null
  if (indicator === null) {
    return null;
  }
  if (isValidElement(indicator)) {
    return cloneElement(indicator, {
      className: classNames$1(indicator.props.className, dotClassName)
    });
  }
  if (isValidElement(defaultIndicator)) {
    return cloneElement(defaultIndicator, {
      className: classNames$1(defaultIndicator.props.className, dotClassName)
    });
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("span", {
      className: classNames$1(dotClassName, prefixCls + "-dot-spin"),
      children: [/*#__PURE__*/jsx$1("i", {
        className: prefixCls + "-dot-item"
      }), /*#__PURE__*/jsx$1("i", {
        className: prefixCls + "-dot-item"
      }), /*#__PURE__*/jsx$1("i", {
        className: prefixCls + "-dot-item"
      }), /*#__PURE__*/jsx$1("i", {
        className: prefixCls + "-dot-item"
      })]
    })
  );
}
function shouldDelay(spinning, delay) {
  return !!spinning && !!delay && !isNaN(Number(delay));
}
var Spin = function Spin(props) {
  var prefixCls = props.spinPrefixCls,
    _props$spinning = props.spinning,
    customSpinning = _props$spinning === void 0 ? true : _props$spinning,
    _props$delay = props.delay,
    delay = _props$delay === void 0 ? 0 : _props$delay,
    className = props.className,
    _props$size = props.size,
    size = _props$size === void 0 ? 'default' : _props$size,
    tip = props.tip,
    wrapperClassName = props.wrapperClassName,
    style = props.style,
    children = props.children,
    hashId = props.hashId,
    restProps = __rest$i(props, ["spinPrefixCls", "spinning", "delay", "className", "size", "tip", "wrapperClassName", "style", "children", "hashId"]);
  var _React$useState = react.exports.useState(function () {
      return customSpinning && !shouldDelay(customSpinning, delay);
    }),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    spinning = _React$useState2[0],
    setSpinning = _React$useState2[1];
  react.exports.useEffect(function () {
    var updateSpinning = debounce$1(delay, function () {
      setSpinning(customSpinning);
    });
    updateSpinning();
    return function () {
      var _a;
      (_a = updateSpinning === null || updateSpinning === void 0 ? void 0 : updateSpinning.cancel) === null || _a === void 0 ? void 0 : _a.call(updateSpinning);
    };
  }, [delay, customSpinning]);
  var isNestedPattern = function isNestedPattern() {
    return typeof children !== 'undefined';
  };
  var renderSpin = function renderSpin(_ref) {
    var _classNames;
    var direction = _ref.direction;
    var spinClassName = classNames$1(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-sm", size === 'small'), _defineProperty$1(_classNames, prefixCls + "-lg", size === 'large'), _defineProperty$1(_classNames, prefixCls + "-spinning", spinning), _defineProperty$1(_classNames, prefixCls + "-show-text", !!tip), _defineProperty$1(_classNames, prefixCls + "-rtl", direction === 'rtl'), _classNames), className, hashId);
    // fix https://fb.me/react-unknown-prop
    var divProps = omit$1(restProps, ['indicator', 'prefixCls']);
    var spinElement =
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("div", {
      ...divProps,
      style: style,
      className: spinClassName,
      "aria-live": "polite",
      "aria-busy": spinning,
      children: [renderIndicator(prefixCls, props), tip ?
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("div", {
        className: prefixCls + "-text",
        children: tip
      }) : null]
    });
    if (isNestedPattern()) {
      var containerClassName = classNames$1(prefixCls + "-container", _defineProperty$1({}, prefixCls + "-blur", spinning));
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsxs("div", {
          ...divProps,
          className: classNames$1(prefixCls + "-nested-loading", wrapperClassName, hashId),
          children: [spinning &&
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("div", {
            children: spinElement
          }, "loading"), /*#__PURE__*/jsx$1("div", {
            className: containerClassName,
            children: children
          }, "container")]
        })
      );
    }
    return spinElement;
  };
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(ConfigConsumer, {
      children: renderSpin
    })
  );
};
var SpinFC = function SpinFC(props) {
  var customizePrefixCls = props.prefixCls;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls;
  var spinPrefixCls = getPrefixCls('spin', customizePrefixCls);
  var _useStyle = useStyle$7(spinPrefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var spinClassProps = _extends$2(_extends$2({}, props), {
    spinPrefixCls: spinPrefixCls,
    hashId: hashId
  });
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(Spin, {
    ...spinClassProps
  }));
};
SpinFC.setDefaultIndicator = function (indicator) {
  defaultIndicator = indicator;
};
const Spin$1 = SpinFC;

// Let compiler not to search module usage
var fullClone = _objectSpread2$1({}, ReactDOM$1);
var version$2 = fullClone.version,
  reactRender = fullClone.render,
  unmountComponentAtNode = fullClone.unmountComponentAtNode;
var createRoot;
try {
  var mainVersion = Number((version$2 || '').split('.')[0]);
  if (mainVersion >= 18) {
    createRoot = fullClone.createRoot;
  }
} catch (e) {
  // Do nothing;
}
function toggleWarning(skip) {
  var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && _typeof$1(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === 'object') {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
  }
}
var MARK = '__rc_react_root__';
function modernRender(node, container) {
  toggleWarning(true);
  var root = container[MARK] || createRoot(container);
  toggleWarning(false);
  root.render(node);
  container[MARK] = root;
}
function legacyRender(node, container) {
  reactRender(node, container);
}
function render(node, container) {
  if (createRoot) {
    modernRender(node, container);
    return;
  }
  legacyRender(node, container);
}
// ========================= Unmount ==========================
function modernUnmount(_x) {
  return _modernUnmount.apply(this, arguments);
}
function _modernUnmount() {
  _modernUnmount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(container) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", Promise.resolve().then(function () {
              var _container$MARK;
              (_container$MARK = container[MARK]) === null || _container$MARK === void 0 ? void 0 : _container$MARK.unmount();
              delete container[MARK];
            }));
          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _modernUnmount.apply(this, arguments);
}
function legacyUnmount(container) {
  unmountComponentAtNode(container);
}
function unmount(_x2) {
  return _unmount.apply(this, arguments);
}
function _unmount() {
  _unmount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(container) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(createRoot !== undefined)) {
              _context2.next = 2;
              break;
            }
            return _context2.abrupt("return", modernUnmount(container));
          case 2:
            legacyUnmount(container);
          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _unmount.apply(this, arguments);
}

var Notify = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var prefixCls = props.prefixCls,
    style = props.style,
    className = props.className,
    _props$duration = props.duration,
    duration = _props$duration === void 0 ? 4.5 : _props$duration,
    eventKey = props.eventKey,
    content = props.content,
    closable = props.closable,
    _props$closeIcon = props.closeIcon,
    closeIcon = _props$closeIcon === void 0 ? 'x' : _props$closeIcon,
    divProps = props.props,
    onClick = props.onClick,
    onNoticeClose = props.onNoticeClose;
  var _React$useState = react.exports.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    hovering = _React$useState2[0],
    setHovering = _React$useState2[1]; // ======================== Close =========================

  var onInternalClose = function onInternalClose() {
    onNoticeClose(eventKey);
  }; // ======================== Effect ========================

  react.exports.useEffect(function () {
    if (!hovering && duration > 0) {
      var timeout = setTimeout(function () {
        onInternalClose();
      }, duration * 1000);
      return function () {
        clearTimeout(timeout);
      };
    }
  }, [duration, hovering]); // ======================== Render ========================

  var noticePrefixCls = "".concat(prefixCls, "-notice");
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("div", {
      ...divProps,
      ref: ref,
      className: classNames$1(noticePrefixCls, className, _defineProperty$1({}, "".concat(noticePrefixCls, "-closable"), closable)),
      style: style,
      onMouseEnter: function onMouseEnter() {
        setHovering(true);
      },
      onMouseLeave: function onMouseLeave() {
        setHovering(false);
      },
      onClick: onClick,
      children: [/*#__PURE__*/jsx$1("div", {
        className: "".concat(noticePrefixCls, "-content"),
        children: content
      }), closable &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("a", {
        tabIndex: 0,
        className: "".concat(noticePrefixCls, "-close"),
        onClick: function onClick(e) {
          e.preventDefault();
          e.stopPropagation();
          onInternalClose();
        },
        children: closeIcon
      })]
    })
  );
});
const Notice = Notify;

var Notifications = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-notification' : _props$prefixCls,
    container = props.container,
    motion = props.motion,
    maxCount = props.maxCount,
    className = props.className,
    style = props.style,
    onAllRemoved = props.onAllRemoved;
  var _React$useState = react.exports.useState([]),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    configList = _React$useState2[0],
    setConfigList = _React$useState2[1]; // ======================== Close =========================

  var onNoticeClose = function onNoticeClose(key) {
    var _config$onClose;

    // Trigger close event
    var config = configList.find(function (item) {
      return item.key === key;
    });
    config === null || config === void 0 ? void 0 : (_config$onClose = config.onClose) === null || _config$onClose === void 0 ? void 0 : _config$onClose.call(config);
    setConfigList(function (list) {
      return list.filter(function (item) {
        return item.key !== key;
      });
    });
  }; // ========================= Refs =========================

  react.exports.useImperativeHandle(ref, function () {
    return {
      open: function open(config) {
        setConfigList(function (list) {
          var clone = _toConsumableArray(list); // Replace if exist

          var index = clone.findIndex(function (item) {
            return item.key === config.key;
          });
          if (index >= 0) {
            clone[index] = config;
          } else {
            clone.push(config);
          }
          if (maxCount > 0 && clone.length > maxCount) {
            clone = clone.slice(-maxCount);
          }
          return clone;
        });
      },
      close: function close(key) {
        onNoticeClose(key);
      },
      destroy: function destroy() {
        setConfigList([]);
      }
    };
  }); // ====================== Placements ======================

  var _React$useState3 = react.exports.useState({}),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    placements = _React$useState4[0],
    setPlacements = _React$useState4[1];
  react.exports.useEffect(function () {
    var nextPlacements = {};
    configList.forEach(function (config) {
      var _config$placement = config.placement,
        placement = _config$placement === void 0 ? 'topRight' : _config$placement;
      if (placement) {
        nextPlacements[placement] = nextPlacements[placement] || [];
        nextPlacements[placement].push(config);
      }
    }); // Fill exist placements to avoid empty list causing remove without motion

    Object.keys(placements).forEach(function (placement) {
      nextPlacements[placement] = nextPlacements[placement] || [];
    });
    setPlacements(nextPlacements);
  }, [configList]); // Clean up container if all notices fade out

  var onAllNoticeRemoved = function onAllNoticeRemoved(placement) {
    setPlacements(function (originPlacements) {
      var clone = _objectSpread2$1({}, originPlacements);
      var list = clone[placement] || [];
      if (!list.length) {
        delete clone[placement];
      }
      return clone;
    });
  }; // Effect tell that placements is empty now

  var emptyRef = react.exports.useRef(false);
  react.exports.useEffect(function () {
    if (Object.keys(placements).length > 0) {
      emptyRef.current = true;
    } else if (emptyRef.current) {
      // Trigger only when from exist to empty
      onAllRemoved === null || onAllRemoved === void 0 ? void 0 : onAllRemoved();
      emptyRef.current = false;
    }
  }, [placements]); // ======================== Render ========================

  if (!container) {
    return null;
  }
  var placementList = Object.keys(placements);
  return /*#__PURE__*/reactDom.exports.createPortal(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(Fragment, {
    children: placementList.map(function (placement) {
      var placementConfigList = placements[placement];
      var keys = placementConfigList.map(function (config) {
        return {
          config: config,
          key: config.key
        };
      });
      var placementMotion = typeof motion === 'function' ? motion(placement) : motion;
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(CSSMotionList, {
          className: classNames$1(prefixCls, "".concat(prefixCls, "-").concat(placement), className === null || className === void 0 ? void 0 : className(placement)),
          style: style === null || style === void 0 ? void 0 : style(placement),
          keys: keys,
          motionAppear: true,
          ...placementMotion,
          onAllRemoved: function onAllRemoved() {
            onAllNoticeRemoved(placement);
          },
          children: function (_ref, nodeRef) {
            var config = _ref.config,
              motionClassName = _ref.className,
              motionStyle = _ref.style;
            var key = config.key;
            var configClassName = config.className,
              configStyle = config.style;
            return (
              /*#__PURE__*/
              /*#__PURE__*/
              react.exports.createElement(Notice, {
                ...config,
                ref: nodeRef,
                prefixCls: prefixCls,
                className: classNames$1(motionClassName, configClassName),
                style: _objectSpread2$1(_objectSpread2$1({}, motionStyle), configStyle),
                key: key,
                eventKey: key,
                onNoticeClose: onNoticeClose
              })
            );
          }
        }, placement)
      );
    })
  }), container);
});

var _excluded$j = ["getContainer", "motion", "prefixCls", "maxCount", "className", "style", "onAllRemoved"];
var defaultGetContainer = function defaultGetContainer() {
  return document.body;
};
var uniqueKey = 0;
function mergeConfig$1() {
  var clone = {};
  for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) {
    objList[_key] = arguments[_key];
  }
  objList.forEach(function (obj) {
    if (obj) {
      Object.keys(obj).forEach(function (key) {
        var val = obj[key];
        if (val !== undefined) {
          clone[key] = val;
        }
      });
    }
  });
  return clone;
}
function useNotification$1() {
  var rootConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _rootConfig$getContai = rootConfig.getContainer,
    getContainer = _rootConfig$getContai === void 0 ? defaultGetContainer : _rootConfig$getContai,
    motion = rootConfig.motion,
    prefixCls = rootConfig.prefixCls,
    maxCount = rootConfig.maxCount,
    className = rootConfig.className,
    style = rootConfig.style,
    onAllRemoved = rootConfig.onAllRemoved,
    shareConfig = _objectWithoutProperties(rootConfig, _excluded$j);
  var _React$useState = react.exports.useState(),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    container = _React$useState2[0],
    setContainer = _React$useState2[1];
  var notificationsRef = react.exports.useRef();
  var contextHolder =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(Notifications, {
    container: container,
    ref: notificationsRef,
    prefixCls: prefixCls,
    motion: motion,
    maxCount: maxCount,
    className: className,
    style: style,
    onAllRemoved: onAllRemoved
  });
  var _React$useState3 = react.exports.useState([]),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    taskQueue = _React$useState4[0],
    setTaskQueue = _React$useState4[1]; // ========================= Refs =========================

  var api = react.exports.useMemo(function () {
    return {
      open: function open(config) {
        var mergedConfig = mergeConfig$1(shareConfig, config);
        if (mergedConfig.key === null || mergedConfig.key === undefined) {
          mergedConfig.key = "rc-notification-".concat(uniqueKey);
          uniqueKey += 1;
        }
        setTaskQueue(function (queue) {
          return [].concat(_toConsumableArray(queue), [{
            type: 'open',
            config: mergedConfig
          }]);
        });
      },
      close: function close(key) {
        setTaskQueue(function (queue) {
          return [].concat(_toConsumableArray(queue), [{
            type: 'close',
            key: key
          }]);
        });
      },
      destroy: function destroy() {
        setTaskQueue(function (queue) {
          return [].concat(_toConsumableArray(queue), [{
            type: 'destroy'
          }]);
        });
      }
    };
  }, []); // ======================= Container ======================
  // React 18 should all in effect that we will check container in each render
  // Which means getContainer should be stable.

  react.exports.useEffect(function () {
    setContainer(getContainer());
  }); // ======================== Effect ========================

  react.exports.useEffect(function () {
    // Flush task when node ready
    if (notificationsRef.current && taskQueue.length) {
      taskQueue.forEach(function (task) {
        switch (task.type) {
          case 'open':
            notificationsRef.current.open(task.config);
            break;
          case 'close':
            notificationsRef.current.close(task.key);
            break;
          case 'destroy':
            notificationsRef.current.destroy();
            break;
        }
      });
      setTaskQueue([]);
    }
  }, [taskQueue]); // ======================== Return ========================

  return [api, contextHolder];
}

function isThenable(thing) {
  return !!(thing && !!thing.then);
}
var ActionButton = function ActionButton(props) {
  var clickedRef = react.exports.useRef(false);
  var ref = react.exports.useRef(null);
  var _useState = useSafeState(false),
    _useState2 = _slicedToArray(_useState, 2),
    loading = _useState2[0],
    setLoading = _useState2[1];
  var close = props.close;
  var onInternalClose = function onInternalClose() {
    close === null || close === void 0 ? void 0 : close.apply(void 0, arguments);
  };
  react.exports.useEffect(function () {
    var timeoutId = null;
    if (props.autoFocus) {
      timeoutId = setTimeout(function () {
        var _a;
        (_a = ref.current) === null || _a === void 0 ? void 0 : _a.focus();
      });
    }
    return function () {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, []);
  var handlePromiseOnOk = function handlePromiseOnOk(returnValueOfOnOk) {
    if (!isThenable(returnValueOfOnOk)) {
      return;
    }
    setLoading(true);
    returnValueOfOnOk.then(function () {
      setLoading(false, true);
      onInternalClose.apply(void 0, arguments);
      clickedRef.current = false;
    }, function (e) {
      // Emit error when catch promise reject
      // eslint-disable-next-line no-console
      console.error(e);
      // See: https://github.com/ant-design/ant-design/issues/6183
      setLoading(false, true);
      clickedRef.current = false;
    });
  };
  var onClick = function onClick(e) {
    var actionFn = props.actionFn;
    if (clickedRef.current) {
      return;
    }
    clickedRef.current = true;
    if (!actionFn) {
      onInternalClose();
      return;
    }
    var returnValueOfOnOk;
    if (props.emitEvent) {
      returnValueOfOnOk = actionFn(e);
      if (props.quitOnNullishReturnValue && !isThenable(returnValueOfOnOk)) {
        clickedRef.current = false;
        onInternalClose(e);
        return;
      }
    } else if (actionFn.length) {
      returnValueOfOnOk = actionFn(close);
      // https://github.com/ant-design/ant-design/issues/23358
      clickedRef.current = false;
    } else {
      returnValueOfOnOk = actionFn();
      if (!returnValueOfOnOk) {
        onInternalClose();
        return;
      }
    }
    handlePromiseOnOk(returnValueOfOnOk);
  };
  var type = props.type,
    children = props.children,
    prefixCls = props.prefixCls,
    buttonProps = props.buttonProps;
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Button$2, {
      ...convertLegacyProps(type),
      onClick: onClick,
      loading: loading,
      prefixCls: prefixCls,
      ...buttonProps,
      ref: ref,
      children: children
    })
  );
};
const ActionButton$1 = ActionButton;

var __rest$h = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function renderCloseIcon(prefixCls, closeIcon) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      className: prefixCls + "-close-x",
      children: closeIcon ||
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(CloseOutlined$1, {
        className: prefixCls + "-close-icon"
      })
    })
  );
}
function renderFooter(props) {
  var okText = props.okText,
    _props$okType = props.okType,
    okType = _props$okType === void 0 ? 'primary' : _props$okType,
    cancelText = props.cancelText,
    confirmLoading = props.confirmLoading,
    onOk = props.onOk,
    onCancel = props.onCancel,
    okButtonProps = props.okButtonProps,
    cancelButtonProps = props.cancelButtonProps,
    footer = props.footer;
  return footer === undefined ?
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(LocaleReceiver, {
    componentName: "Modal",
    defaultLocale: getConfirmLocale(),
    children: function (locale) {
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsxs(Fragment, {
          children: [/*#__PURE__*/jsx$1(Button$2, {
            onClick: onCancel,
            ...cancelButtonProps,
            children: cancelText || locale.cancelText
          }), /*#__PURE__*/jsx$1(Button$2, {
            ...convertLegacyProps(okType),
            loading: confirmLoading,
            onClick: onOk,
            ...okButtonProps,
            children: okText || locale.okText
          })]
        })
      );
    }
  }) : footer;
}
function PurePanel$1(props) {
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    closeIcon = props.closeIcon,
    closable = props.closable,
    type = props.type,
    title = props.title,
    children = props.children,
    restProps = __rest$h(props, ["prefixCls", "className", "closeIcon", "closable", "type", "title", "children"]);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls;
  var rootPrefixCls = getPrefixCls();
  var prefixCls = customizePrefixCls || getPrefixCls('modal');
  var _useStyle = useStyle$9(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    hashId = _useStyle2[1];
  var confirmPrefixCls = prefixCls + "-confirm";
  // Choose target props by confirm mark
  var additionalProps = {};
  if (type) {
    additionalProps = {
      closable: closable !== null && closable !== void 0 ? closable : false,
      title: '',
      footer: '',
      children:
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(ConfirmContent, {
        ...props,
        confirmPrefixCls: confirmPrefixCls,
        rootPrefixCls: rootPrefixCls,
        content: children
      })
    };
  } else {
    additionalProps = {
      closable: closable !== null && closable !== void 0 ? closable : true,
      title: title,
      footer: renderFooter(props),
      children: children
    };
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Panel$2, {
      prefixCls: prefixCls,
      className: classNames$1(hashId, prefixCls + "-pure-panel", type && confirmPrefixCls, type && confirmPrefixCls + "-" + type, className),
      ...restProps,
      closeIcon: renderCloseIcon(prefixCls, closeIcon),
      closable: closable,
      ...additionalProps
    })
  );
}

var __rest$g = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var mousePosition;
// ref: https://github.com/ant-design/ant-design/issues/15795
var getClickPosition = function getClickPosition(e) {
  mousePosition = {
    x: e.pageX,
    y: e.pageY
  };
  // 100ms 
  //  zoom 
  // 
  setTimeout(function () {
    mousePosition = null;
  }, 100);
};
// 
if (canUseDocElement()) {
  document.documentElement.addEventListener('click', getClickPosition, true);
}
var Modal$2 = function Modal(props) {
  var _classNames;
  var _a;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getContextPopupContainer = _React$useContext.getPopupContainer,
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var handleCancel = function handleCancel(e) {
    var onCancel = props.onCancel;
    onCancel === null || onCancel === void 0 ? void 0 : onCancel(e);
  };
  var handleOk = function handleOk(e) {
    var onOk = props.onOk;
    onOk === null || onOk === void 0 ? void 0 : onOk(e);
  };
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    open = props.open,
    wrapClassName = props.wrapClassName,
    centered = props.centered,
    getContainer = props.getContainer,
    closeIcon = props.closeIcon,
    _props$focusTriggerAf = props.focusTriggerAfterClose,
    focusTriggerAfterClose = _props$focusTriggerAf === void 0 ? true : _props$focusTriggerAf,
    visible = props.visible,
    _props$width = props.width,
    width = _props$width === void 0 ? 520 : _props$width,
    restProps = __rest$g(props, ["prefixCls", "className", "open", "wrapClassName", "centered", "getContainer", "closeIcon", "focusTriggerAfterClose", "visible", "width"]);
  var prefixCls = getPrefixCls('modal', customizePrefixCls);
  var rootPrefixCls = getPrefixCls();
  // Style
  var _useStyle = useStyle$9(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var wrapClassNameExtended = classNames$1(wrapClassName, (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-centered", !!centered), _defineProperty$1(_classNames, prefixCls + "-wrap-rtl", direction === 'rtl'), _classNames));
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(NoCompactStyle, {
    children: /*#__PURE__*/jsx$1(NoFormStyle, {
      status: true,
      override: true,
      children: /*#__PURE__*/jsx$1(DialogWrap, {
        width: width,
        ...restProps,
        getContainer: getContainer === undefined ? getContextPopupContainer : getContainer,
        prefixCls: prefixCls,
        rootClassName: hashId,
        wrapClassName: wrapClassNameExtended,
        footer: renderFooter(_extends$2(_extends$2({}, props), {
          onOk: handleOk,
          onCancel: handleCancel
        })),
        visible: open !== null && open !== void 0 ? open : visible,
        mousePosition: (_a = restProps.mousePosition) !== null && _a !== void 0 ? _a : mousePosition,
        onClose: handleCancel,
        closeIcon: renderCloseIcon(prefixCls, closeIcon),
        focusTriggerAfterClose: focusTriggerAfterClose,
        transitionName: getTransitionName(rootPrefixCls, 'zoom', props.transitionName),
        maskTransitionName: getTransitionName(rootPrefixCls, 'fade', props.maskTransitionName),
        className: classNames$1(hashId, className)
      })
    })
  }));
};
const OriginModal = Modal$2;

function ConfirmContent(props) {
  var icon = props.icon,
    onCancel = props.onCancel,
    onOk = props.onOk,
    close = props.close,
    okText = props.okText,
    okButtonProps = props.okButtonProps,
    cancelText = props.cancelText,
    cancelButtonProps = props.cancelButtonProps,
    confirmPrefixCls = props.confirmPrefixCls,
    rootPrefixCls = props.rootPrefixCls,
    type = props.type,
    okCancel = props.okCancel,
    footer = props.footer,
    staticLocale = props.locale;
  // Icon
  var mergedIcon = icon;
  // { icon: null }`Modal.confirm`Icon
  if (!icon && icon !== null) {
    switch (type) {
      case 'info':
        mergedIcon =
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(InfoCircleFilled$1, {});
        break;
      case 'success':
        mergedIcon =
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(CheckCircleFilled$1, {});
        break;
      case 'error':
        mergedIcon =
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(CloseCircleFilled$1, {});
        break;
      default:
        mergedIcon =
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(ExclamationCircleFilled$1, {});
    }
  }
  var okType = props.okType || 'primary';
  //  true
  var mergedOkCancel = okCancel !== null && okCancel !== void 0 ? okCancel : type === 'confirm';
  var autoFocusButton = props.autoFocusButton === null ? false : props.autoFocusButton || 'ok';
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(LocaleReceiver, {
      componentName: "Modal",
      children: function (locale) {
        var mergedLocale = staticLocale || locale;
        var cancelButton = mergedOkCancel &&
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(ActionButton$1, {
          actionFn: onCancel,
          close: close,
          autoFocus: autoFocusButton === 'cancel',
          buttonProps: cancelButtonProps,
          prefixCls: rootPrefixCls + "-btn",
          children: cancelText || (mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.cancelText)
        });
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsxs("div", {
            className: confirmPrefixCls + "-body-wrapper",
            children: [/*#__PURE__*/jsxs("div", {
              className: confirmPrefixCls + "-body",
              children: [mergedIcon, props.title === undefined ? null :
              /*#__PURE__*/
              /*#__PURE__*/
              jsx$1("span", {
                className: confirmPrefixCls + "-title",
                children: props.title
              }), /*#__PURE__*/jsx$1("div", {
                className: confirmPrefixCls + "-content",
                children: props.content
              })]
            }), footer !== undefined ? footer :
            /*#__PURE__*/
            /*#__PURE__*/
            jsxs("div", {
              className: confirmPrefixCls + "-btns",
              children: [cancelButton, /*#__PURE__*/jsx$1(ActionButton$1, {
                type: okType,
                actionFn: onOk,
                close: close,
                autoFocus: autoFocusButton === 'ok',
                buttonProps: okButtonProps,
                prefixCls: rootPrefixCls + "-btn",
                children: okText || (mergedOkCancel ? mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.okText : mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.justOkText)
              })]
            })]
          })
        );
      }
    })
  );
}
var ConfirmDialog = function ConfirmDialog(props) {
  var close = props.close,
    zIndex = props.zIndex,
    afterClose = props.afterClose;
    props.visible;
    var open = props.open,
    keyboard = props.keyboard,
    centered = props.centered,
    getContainer = props.getContainer,
    maskStyle = props.maskStyle,
    direction = props.direction,
    prefixCls = props.prefixCls,
    wrapClassName = props.wrapClassName,
    rootPrefixCls = props.rootPrefixCls,
    iconPrefixCls = props.iconPrefixCls,
    bodyStyle = props.bodyStyle,
    _props$closable = props.closable,
    closable = _props$closable === void 0 ? false : _props$closable,
    closeIcon = props.closeIcon,
    modalRender = props.modalRender,
    focusTriggerAfterClose = props.focusTriggerAfterClose;
  var confirmPrefixCls = prefixCls + "-confirm";
  var width = props.width || 416;
  var style = props.style || {};
  var mask = props.mask === undefined ? true : props.mask;
  //  false
  var maskClosable = props.maskClosable === undefined ? false : props.maskClosable;
  var classString = classNames$1(confirmPrefixCls, confirmPrefixCls + "-" + props.type, _defineProperty$1({}, confirmPrefixCls + "-rtl", direction === 'rtl'), props.className);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(ConfigProvider, {
      prefixCls: rootPrefixCls,
      iconPrefixCls: iconPrefixCls,
      direction: direction,
      children: /*#__PURE__*/jsx$1(OriginModal, {
        prefixCls: prefixCls,
        className: classString,
        wrapClassName: classNames$1(_defineProperty$1({}, confirmPrefixCls + "-centered", !!props.centered), wrapClassName),
        onCancel: function onCancel() {
          return close === null || close === void 0 ? void 0 : close({
            triggerCancel: true
          });
        },
        open: open,
        title: "",
        footer: "",
        transitionName: getTransitionName(rootPrefixCls, 'zoom', props.transitionName),
        maskTransitionName: getTransitionName(rootPrefixCls, 'fade', props.maskTransitionName),
        mask: mask,
        maskClosable: maskClosable,
        maskStyle: maskStyle,
        style: style,
        bodyStyle: bodyStyle,
        width: width,
        zIndex: zIndex,
        afterClose: afterClose,
        keyboard: keyboard,
        centered: centered,
        getContainer: getContainer,
        closable: closable,
        closeIcon: closeIcon,
        modalRender: modalRender,
        focusTriggerAfterClose: focusTriggerAfterClose,
        children: /*#__PURE__*/jsx$1(ConfirmContent, {
          ...props,
          confirmPrefixCls: confirmPrefixCls
        })
      })
    })
  );
};

var destroyFns = [];
const destroyFns$1 = destroyFns;

var __rest$f = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var defaultRootPrefixCls = '';
function getRootPrefixCls() {
  return defaultRootPrefixCls;
}
function confirm(config) {
  var container = document.createDocumentFragment();
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  var currentConfig = _extends$2(_extends$2({}, config), {
    close: close,
    open: true
  });
  var timeoutId;
  function destroy() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var triggerCancel = args.some(function (param) {
      return param && param.triggerCancel;
    });
    if (config.onCancel && triggerCancel) {
      config.onCancel.apply(config, [function () {}].concat(_toConsumableArray(args.slice(1))));
    }
    for (var i = 0; i < destroyFns$1.length; i++) {
      var fn = destroyFns$1[i];
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      if (fn === close) {
        destroyFns$1.splice(i, 1);
        break;
      }
    }
    unmount(container);
  }
  function render$1(_a) {
    var okText = _a.okText,
      cancelText = _a.cancelText,
      customizePrefixCls = _a.prefixCls,
      props = __rest$f(_a, ["okText", "cancelText", "prefixCls"]);
    clearTimeout(timeoutId);
    /**
     * https://github.com/ant-design/ant-design/issues/23623
     *
     * Sync render blocks React event. Let's make this async.
     */
    timeoutId = setTimeout(function () {
      var runtimeLocale = getConfirmLocale();
      var _globalConfig = globalConfig(),
        getPrefixCls = _globalConfig.getPrefixCls,
        getIconPrefixCls = _globalConfig.getIconPrefixCls;
      // because Modal.config  set rootPrefixCls, which is different from other components
      var rootPrefixCls = getPrefixCls(undefined, getRootPrefixCls());
      var prefixCls = customizePrefixCls || rootPrefixCls + "-modal";
      var iconPrefixCls = getIconPrefixCls();
      render(
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(ConfirmDialog, {
        ...props,
        prefixCls: prefixCls,
        rootPrefixCls: rootPrefixCls,
        iconPrefixCls: iconPrefixCls,
        okText: okText,
        locale: runtimeLocale,
        cancelText: cancelText || runtimeLocale.cancelText
      }), container);
    });
  }
  function close() {
    var _this = this;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    currentConfig = _extends$2(_extends$2({}, currentConfig), {
      open: false,
      afterClose: function afterClose() {
        if (typeof config.afterClose === 'function') {
          config.afterClose();
        }
        destroy.apply(_this, args);
      }
    });
    // Legacy support
    if (currentConfig.visible) {
      delete currentConfig.visible;
    }
    render$1(currentConfig);
  }
  function update(configUpdate) {
    if (typeof configUpdate === 'function') {
      currentConfig = configUpdate(currentConfig);
    } else {
      currentConfig = _extends$2(_extends$2({}, currentConfig), configUpdate);
    }
    render$1(currentConfig);
  }
  render$1(currentConfig);
  destroyFns$1.push(close);
  return {
    destroy: close,
    update: update
  };
}
function withWarn(props) {
  return _extends$2(_extends$2({}, props), {
    type: 'warning'
  });
}
function withInfo(props) {
  return _extends$2(_extends$2({}, props), {
    type: 'info'
  });
}
function withSuccess(props) {
  return _extends$2(_extends$2({}, props), {
    type: 'success'
  });
}
function withError(props) {
  return _extends$2(_extends$2({}, props), {
    type: 'error'
  });
}
function withConfirm(props) {
  return _extends$2(_extends$2({}, props), {
    type: 'confirm'
  });
}
function modalGlobalConfig(_ref) {
  var rootPrefixCls = _ref.rootPrefixCls;
  defaultRootPrefixCls = rootPrefixCls;
}

function usePatchElement() {
  var _React$useState = react.exports.useState([]),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    elements = _React$useState2[0],
    setElements = _React$useState2[1];
  var patchElement = react.exports.useCallback(function (element) {
    // append a new element to elements (and create a new ref)
    setElements(function (originElements) {
      return [].concat(_toConsumableArray(originElements), [element]);
    });
    // return a function that removes the new element out of elements (and create a new ref)
    // it works a little like useEffect
    return function () {
      setElements(function (originElements) {
        return originElements.filter(function (ele) {
          return ele !== element;
        });
      });
    };
  }, []);
  return [elements, patchElement];
}

var HookModal = function HookModal(_ref, ref) {
  var afterClose = _ref.afterClose,
    config = _ref.config;
  var _React$useState = react.exports.useState(true),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    open = _React$useState2[0],
    setOpen = _React$useState2[1];
  var _React$useState3 = react.exports.useState(config),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    innerConfig = _React$useState4[0],
    setInnerConfig = _React$useState4[1];
  var _React$useContext = react.exports.useContext(ConfigContext),
    direction = _React$useContext.direction,
    getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls('modal');
  var rootPrefixCls = getPrefixCls();
  var close = function close() {
    setOpen(false);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var triggerCancel = args.some(function (param) {
      return param && param.triggerCancel;
    });
    if (innerConfig.onCancel && triggerCancel) {
      innerConfig.onCancel.apply(innerConfig, [function () {}].concat(_toConsumableArray(args.slice(1))));
    }
  };
  react.exports.useImperativeHandle(ref, function () {
    return {
      destroy: close,
      update: function update(newConfig) {
        setInnerConfig(function (originConfig) {
          return _extends$2(_extends$2({}, originConfig), newConfig);
        });
      }
    };
  });
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(LocaleReceiver, {
      componentName: "Modal",
      defaultLocale: defaultLocale.Modal,
      children: function (contextLocale) {
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(ConfirmDialog, {
            prefixCls: prefixCls,
            rootPrefixCls: rootPrefixCls,
            ...innerConfig,
            close: close,
            open: open,
            afterClose: afterClose,
            okText: innerConfig.okText || (innerConfig.okCancel ? contextLocale.okText : contextLocale.justOkText),
            direction: direction,
            cancelText: innerConfig.cancelText || contextLocale.cancelText
          })
        );
      }
    })
  );
};
const HookModal$1 = /*#__PURE__*/react.exports.forwardRef(HookModal);

var uuid$1 = 0;
var ElementsHolder = /*#__PURE__*/react.exports.memo( /*#__PURE__*/react.exports.forwardRef(function (_props, ref) {
  var _usePatchElement = usePatchElement(),
    _usePatchElement2 = _slicedToArray(_usePatchElement, 2),
    elements = _usePatchElement2[0],
    patchElement = _usePatchElement2[1];
  react.exports.useImperativeHandle(ref, function () {
    return {
      patchElement: patchElement
    };
  }, []);
  // eslint-disable-next-line react/jsx-no-useless-fragment
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Fragment, {
      children: elements
    })
  );
}));
function useModal() {
  var holderRef = react.exports.useRef(null);
  // ========================== Effect ==========================
  var _React$useState = react.exports.useState([]),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    actionQueue = _React$useState2[0],
    setActionQueue = _React$useState2[1];
  react.exports.useEffect(function () {
    if (actionQueue.length) {
      var cloneQueue = _toConsumableArray(actionQueue);
      cloneQueue.forEach(function (action) {
        action();
      });
      setActionQueue([]);
    }
  }, [actionQueue]);
  // =========================== Hook ===========================
  var getConfirmFunc = react.exports.useCallback(function (withFunc) {
    return function hookConfirm(config) {
      var _a;
      uuid$1 += 1;
      var modalRef = /*#__PURE__*/react.exports.createRef();
      var closeFunc;
      var modal =
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(HookModal$1, {
        config: withFunc(config),
        ref: modalRef,
        afterClose: function afterClose() {
          closeFunc === null || closeFunc === void 0 ? void 0 : closeFunc();
        }
      }, "modal-" + uuid$1);
      closeFunc = (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.patchElement(modal);
      return {
        destroy: function destroy() {
          function destroyAction() {
            var _a;
            (_a = modalRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
          }
          if (modalRef.current) {
            destroyAction();
          } else {
            setActionQueue(function (prev) {
              return [].concat(_toConsumableArray(prev), [destroyAction]);
            });
          }
        },
        update: function update(newConfig) {
          function updateAction() {
            var _a;
            (_a = modalRef.current) === null || _a === void 0 ? void 0 : _a.update(newConfig);
          }
          if (modalRef.current) {
            updateAction();
          } else {
            setActionQueue(function (prev) {
              return [].concat(_toConsumableArray(prev), [updateAction]);
            });
          }
        }
      };
    };
  }, []);
  var fns = react.exports.useMemo(function () {
    return {
      info: getConfirmFunc(withInfo),
      success: getConfirmFunc(withSuccess),
      error: getConfirmFunc(withError),
      warning: getConfirmFunc(withWarn),
      confirm: getConfirmFunc(withConfirm)
    };
  }, []);
  // eslint-disable-next-line react/jsx-key
  return [fns,
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(ElementsHolder, {
    ref: holderRef
  })];
}

function modalWarn(props) {
  return confirm(withWarn(props));
}
var Modal = OriginModal;
Modal.useModal = useModal;
Modal.info = function infoFn(props) {
  return confirm(withInfo(props));
};
Modal.success = function successFn(props) {
  return confirm(withSuccess(props));
};
Modal.error = function errorFn(props) {
  return confirm(withError(props));
};
Modal.warning = modalWarn;
Modal.warn = modalWarn;
Modal.confirm = function confirmFn(props) {
  return confirm(withConfirm(props));
};
Modal.destroyAll = function destroyAllFn() {
  while (destroyFns$1.length) {
    var close = destroyFns$1.pop();
    if (close) {
      close();
    }
  }
};
Modal.config = modalGlobalConfig;
Modal._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$1;
const Modal$1 = Modal;

var genNotificationPlacementStyle = function genNotificationPlacementStyle(token) {
  var _ref4;
  var componentCls = token.componentCls,
    width = token.width,
    notificationMarginEdge = token.notificationMarginEdge;
  var notificationTopFadeIn = new Keyframe('antNotificationTopFadeIn', {
    '0%': {
      marginTop: '-100%',
      opacity: 0
    },
    '100%': {
      marginTop: 0,
      opacity: 1
    }
  });
  var notificationBottomFadeIn = new Keyframe('antNotificationBottomFadeIn', {
    '0%': {
      marginBottom: '-100%',
      opacity: 0
    },
    '100%': {
      marginBottom: 0,
      opacity: 1
    }
  });
  var notificationLeftFadeIn = new Keyframe('antNotificationLeftFadeIn', {
    '0%': {
      right: {
        _skip_check_: true,
        value: width
      },
      opacity: 0
    },
    '100%': {
      right: {
        _skip_check_: true,
        value: 0
      },
      opacity: 1
    }
  });
  return _ref4 = {}, _defineProperty$1(_ref4, "&" + componentCls + "-top, &" + componentCls + "-bottom", {
    marginInline: 0
  }), _defineProperty$1(_ref4, "&" + componentCls + "-top", _defineProperty$1({}, componentCls + "-fade-enter" + componentCls + "-fade-enter-active, " + componentCls + "-fade-appear" + componentCls + "-fade-appear-active", {
    animationName: notificationTopFadeIn
  })), _defineProperty$1(_ref4, "&" + componentCls + "-bottom", _defineProperty$1({}, componentCls + "-fade-enter" + componentCls + "-fade-enter-active, " + componentCls + "-fade-appear" + componentCls + "-fade-appear-active", {
    animationName: notificationBottomFadeIn
  })), _defineProperty$1(_ref4, "&" + componentCls + "-topLeft, &" + componentCls + "-bottomLeft", _defineProperty$1({
    marginInlineEnd: 0,
    marginInlineStart: notificationMarginEdge
  }, componentCls + "-fade-enter" + componentCls + "-fade-enter-active, " + componentCls + "-fade-appear" + componentCls + "-fade-appear-active", {
    animationName: notificationLeftFadeIn
  })), _ref4;
};
const genNotificationPlacementStyle$1 = genNotificationPlacementStyle;

var genNotificationStyle = function genNotificationStyle(token) {
  var _extends2, _ref4, _noticeCls;
  var iconCls = token.iconCls,
    componentCls = token.componentCls,
    boxShadowSecondary = token.boxShadowSecondary,
    fontSizeLG = token.fontSizeLG,
    notificationMarginBottom = token.notificationMarginBottom,
    borderRadiusLG = token.borderRadiusLG,
    colorSuccess = token.colorSuccess,
    colorInfo = token.colorInfo,
    colorWarning = token.colorWarning,
    colorError = token.colorError,
    colorTextHeading = token.colorTextHeading,
    notificationBg = token.notificationBg,
    notificationPadding = token.notificationPadding,
    notificationMarginEdge = token.notificationMarginEdge,
    motionDurationMid = token.motionDurationMid,
    motionEaseInOut = token.motionEaseInOut,
    fontSize = token.fontSize,
    lineHeight = token.lineHeight,
    width = token.width,
    notificationIconSize = token.notificationIconSize;
  var noticeCls = componentCls + "-notice";
  var notificationFadeIn = new Keyframe('antNotificationFadeIn', {
    '0%': {
      left: {
        _skip_check_: true,
        value: width
      },
      opacity: 0
    },
    '100%': {
      left: {
        _skip_check_: true,
        value: 0
      },
      opacity: 1
    }
  });
  var notificationFadeOut = new Keyframe('antNotificationFadeOut', {
    '0%': {
      maxHeight: token.animationMaxHeight,
      marginBottom: notificationMarginBottom,
      opacity: 1
    },
    '100%': {
      maxHeight: 0,
      marginBottom: 0,
      paddingTop: 0,
      paddingBottom: 0,
      opacity: 0
    }
  });
  return [// ============================ Holder ============================
  _defineProperty$1({}, componentCls, _extends$2(_extends$2(_extends$2(_extends$2({}, resetComponent(token)), (_extends2 = {
    position: 'fixed',
    zIndex: token.zIndexPopup,
    marginInlineEnd: notificationMarginEdge
  }, _defineProperty$1(_extends2, componentCls + "-hook-holder", {
    position: 'relative'
  }), _defineProperty$1(_extends2, "&" + componentCls + "-top, &" + componentCls + "-bottom", _defineProperty$1({}, componentCls + "-notice", {
    marginInline: 'auto auto'
  })), _defineProperty$1(_extends2, "&" + componentCls + "-topLeft, &" + componentCls + "-bottomLeft", _defineProperty$1({}, componentCls + "-notice", {
    marginInlineEnd: 'auto',
    marginInlineStart: 0
  })), _defineProperty$1(_extends2, componentCls + "-fade-enter, " + componentCls + "-fade-appear", {
    animationDuration: token.motionDurationMid,
    animationTimingFunction: motionEaseInOut,
    animationFillMode: 'both',
    opacity: 0,
    animationPlayState: 'paused'
  }), _defineProperty$1(_extends2, componentCls + "-fade-leave", {
    animationTimingFunction: motionEaseInOut,
    animationFillMode: 'both',
    animationDuration: motionDurationMid,
    animationPlayState: 'paused'
  }), _defineProperty$1(_extends2, componentCls + "-fade-enter" + componentCls + "-fade-enter-active, " + componentCls + "-fade-appear" + componentCls + "-fade-appear-active", {
    animationName: notificationFadeIn,
    animationPlayState: 'running'
  }), _defineProperty$1(_extends2, componentCls + "-fade-leave" + componentCls + "-fade-leave-active", {
    animationName: notificationFadeOut,
    animationPlayState: 'running'
  }), _extends2)), genNotificationPlacementStyle$1(token)), {
    // RTL
    '&-rtl': _defineProperty$1({
      direction: 'rtl'
    }, componentCls + "-notice-btn", {
      "float": 'left'
    })
  })), // ============================ Notice ============================
  _defineProperty$1({}, noticeCls, (_noticeCls = {
    position: 'relative',
    width: width,
    maxWidth: "calc(100vw - " + notificationMarginEdge * 2 + "px)",
    marginBottom: notificationMarginBottom,
    marginInlineStart: 'auto',
    padding: notificationPadding,
    overflow: 'hidden',
    lineHeight: lineHeight,
    wordWrap: 'break-word',
    background: notificationBg,
    borderRadius: borderRadiusLG,
    boxShadow: boxShadowSecondary
  }, _defineProperty$1(_noticeCls, componentCls + "-close-icon", {
    fontSize: fontSize,
    cursor: 'pointer'
  }), _defineProperty$1(_noticeCls, noticeCls + "-message", {
    marginBottom: token.marginXS,
    color: colorTextHeading,
    fontSize: fontSizeLG,
    lineHeight: token.lineHeightLG
  }), _defineProperty$1(_noticeCls, noticeCls + "-description", {
    fontSize: fontSize
  }), _defineProperty$1(_noticeCls, "&" + noticeCls + "-closable " + noticeCls + "-message", {
    paddingInlineEnd: token.paddingLG
  }), _defineProperty$1(_noticeCls, noticeCls + "-with-icon " + noticeCls + "-message", {
    marginBottom: token.marginXS,
    marginInlineStart: token.marginSM + notificationIconSize,
    fontSize: fontSizeLG
  }), _defineProperty$1(_noticeCls, noticeCls + "-with-icon " + noticeCls + "-description", {
    marginInlineStart: token.marginSM + notificationIconSize,
    fontSize: fontSize
  }), _defineProperty$1(_noticeCls, noticeCls + "-icon", (_ref4 = {
    position: 'absolute',
    fontSize: notificationIconSize,
    lineHeight: 0
  }, _defineProperty$1(_ref4, "&-success" + iconCls, {
    color: colorSuccess
  }), _defineProperty$1(_ref4, "&-info" + iconCls, {
    color: colorInfo
  }), _defineProperty$1(_ref4, "&-warning" + iconCls, {
    color: colorWarning
  }), _defineProperty$1(_ref4, "&-error" + iconCls, {
    color: colorError
  }), _ref4)), _defineProperty$1(_noticeCls, noticeCls + "-close", {
    position: 'absolute',
    top: token.notificationPaddingVertical,
    insetInlineEnd: token.notificationPaddingHorizontal,
    color: token.colorIcon,
    outline: 'none',
    width: token.notificationCloseButtonSize,
    height: token.notificationCloseButtonSize,
    borderRadius: token.borderRadiusSM,
    transition: "background-color " + token.motionDurationMid + ", color " + token.motionDurationMid,
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    '&:hover': {
      color: token.colorIconHover,
      backgroundColor: token.wireframe ? 'transparent' : token.colorFillContent
    }
  }), _defineProperty$1(_noticeCls, noticeCls + "-btn", {
    "float": 'right',
    marginTop: token.marginSM
  }), _noticeCls)), // ============================= Pure =============================
  _defineProperty$1({}, noticeCls + "-pure-panel", {
    margin: 0
  })];
};
// ============================== Export ==============================
const useStyle$6 = genComponentStyleHook('Notification', function (token) {
  var notificationPaddingVertical = token.paddingMD;
  var notificationPaddingHorizontal = token.paddingLG;
  var notificationToken = merge$2(token, {
    // default.less variables
    notificationBg: token.colorBgElevated,
    notificationPaddingVertical: notificationPaddingVertical,
    notificationPaddingHorizontal: notificationPaddingHorizontal,
    // index.less variables
    notificationPadding: token.paddingMD + "px " + token.paddingContentHorizontalLG + "px",
    notificationMarginBottom: token.margin,
    notificationMarginEdge: token.marginLG,
    animationMaxHeight: 150,
    notificationIconSize: token.fontSizeLG * token.lineHeightLG,
    notificationCloseButtonSize: token.controlHeightLG * 0.55
  });
  return [genNotificationStyle(notificationToken)];
}, function (token) {
  return {
    zIndexPopup: token.zIndexPopupBase + 50,
    width: 384
  };
});

var __rest$e = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function getCloseIcon(prefixCls, closeIcon) {
  return closeIcon ||
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("span", {
    className: prefixCls + "-close-x",
    children: /*#__PURE__*/jsx$1(CloseOutlined$1, {
      className: prefixCls + "-close-icon"
    })
  });
}
var typeToIcon = {
  success: CheckCircleFilled$1,
  info: InfoCircleFilled$1,
  error: CloseCircleFilled$1,
  warning: ExclamationCircleFilled$1
};
function PureContent(_ref) {
  var prefixCls = _ref.prefixCls,
    icon = _ref.icon,
    type = _ref.type,
    message = _ref.message,
    description = _ref.description,
    btn = _ref.btn;
  var iconNode = null;
  if (icon) {
    iconNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      className: prefixCls + "-icon",
      children: icon
    });
  } else if (type) {
    iconNode = /*#__PURE__*/react.exports.createElement(typeToIcon[type] || null, {
      className: classNames$1(prefixCls + "-icon", prefixCls + "-icon-" + type)
    });
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("div", {
      className: classNames$1(_defineProperty$1({}, prefixCls + "-with-icon", iconNode)),
      role: "alert",
      children: [iconNode, /*#__PURE__*/jsx$1("div", {
        className: prefixCls + "-message",
        children: message
      }), /*#__PURE__*/jsx$1("div", {
        className: prefixCls + "-description",
        children: description
      }), btn &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("div", {
        className: prefixCls + "-btn",
        children: btn
      })]
    })
  );
}
/** @private Internal Component. Do not use in your production. */
function PurePanel(props) {
  var staticPrefixCls = props.prefixCls,
    className = props.className,
    icon = props.icon,
    type = props.type,
    message = props.message,
    description = props.description,
    btn = props.btn,
    _props$closable = props.closable,
    closable = _props$closable === void 0 ? true : _props$closable,
    closeIcon = props.closeIcon,
    restProps = __rest$e(props, ["prefixCls", "className", "icon", "type", "message", "description", "btn", "closable", "closeIcon"]);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = staticPrefixCls || getPrefixCls('notification');
  var noticePrefixCls = prefixCls + "-notice";
  var _useStyle = useStyle$6(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    hashId = _useStyle2[1];
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Notice, {
      ...restProps,
      prefixCls: prefixCls,
      className: classNames$1(className, hashId, noticePrefixCls + "-pure-panel"),
      eventKey: "pure",
      duration: null,
      closable: closable,
      closeIcon: getCloseIcon(prefixCls, closeIcon),
      content:
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(PureContent, {
        prefixCls: noticePrefixCls,
        icon: icon,
        type: type,
        message: message,
        description: description,
        btn: btn
      })
    })
  );
}

function getPlacementStyle(placement, top, bottom) {
  var style;
  switch (placement) {
    case 'top':
      style = {
        left: '50%',
        transform: 'translateX(-50%)',
        right: 'auto',
        top: top,
        bottom: 'auto'
      };
      break;
    case 'topLeft':
      style = {
        left: 0,
        top: top,
        bottom: 'auto'
      };
      break;
    case 'topRight':
      style = {
        right: 0,
        top: top,
        bottom: 'auto'
      };
      break;
    case 'bottom':
      style = {
        left: '50%',
        transform: 'translateX(-50%)',
        right: 'auto',
        top: 'auto',
        bottom: bottom
      };
      break;
    case 'bottomLeft':
      style = {
        left: 0,
        top: 'auto',
        bottom: bottom
      };
      break;
    default:
      style = {
        right: 0,
        top: 'auto',
        bottom: bottom
      };
      break;
  }
  return style;
}
function getMotion(prefixCls) {
  return {
    motionName: prefixCls + "-fade"
  };
}

var __rest$d = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var DEFAULT_OFFSET = 24;
var DEFAULT_DURATION = 4.5;
var Holder = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var top = props.top,
    bottom = props.bottom,
    staticPrefixCls = props.prefixCls,
    staticGetContainer = props.getContainer,
    maxCount = props.maxCount,
    rtl = props.rtl,
    onAllRemoved = props.onAllRemoved;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    getPopupContainer = _React$useContext.getPopupContainer;
  var prefixCls = staticPrefixCls || getPrefixCls('notification');
  // =============================== Style ===============================
  var getStyle = function getStyle(placement) {
    return getPlacementStyle(placement, top !== null && top !== void 0 ? top : DEFAULT_OFFSET, bottom !== null && bottom !== void 0 ? bottom : DEFAULT_OFFSET);
  };
  // Style
  var _useStyle = useStyle$6(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    hashId = _useStyle2[1];
  var getClassName = function getClassName() {
    return classNames$1(hashId, _defineProperty$1({}, prefixCls + "-rtl", rtl));
  };
  // ============================== Motion ===============================
  var getNotificationMotion = function getNotificationMotion() {
    return getMotion(prefixCls);
  };
  // ============================== Origin ===============================
  var _useRcNotification = useNotification$1({
      prefixCls: prefixCls,
      style: getStyle,
      className: getClassName,
      motion: getNotificationMotion,
      closable: true,
      closeIcon: getCloseIcon(prefixCls),
      duration: DEFAULT_DURATION,
      getContainer: function getContainer() {
        return (staticGetContainer === null || staticGetContainer === void 0 ? void 0 : staticGetContainer()) || (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer()) || document.body;
      },
      maxCount: maxCount,
      onAllRemoved: onAllRemoved
    }),
    _useRcNotification2 = _slicedToArray(_useRcNotification, 2),
    api = _useRcNotification2[0],
    holder = _useRcNotification2[1];
  // ================================ Ref ================================
  react.exports.useImperativeHandle(ref, function () {
    return _extends$2(_extends$2({}, api), {
      prefixCls: prefixCls,
      hashId: hashId
    });
  });
  return holder;
});
// ==============================================================================
// ==                                   Hook                                   ==
// ==============================================================================
function useInternalNotification(notificationConfig) {
  var holderRef = react.exports.useRef(null);
  // ================================ API ================================
  var wrapAPI = react.exports.useMemo(function () {
    // Wrap with notification content
    // >>> Open
    var open = function open(config) {
      if (!holderRef.current) {
        return;
      }
      var _holderRef$current = holderRef.current,
        originOpen = _holderRef$current.open,
        prefixCls = _holderRef$current.prefixCls,
        hashId = _holderRef$current.hashId;
      var noticePrefixCls = prefixCls + "-notice";
      var message = config.message,
        description = config.description,
        icon = config.icon,
        type = config.type,
        _config$placement = config.placement,
        placement = _config$placement === void 0 ? 'topRight' : _config$placement,
        btn = config.btn,
        className = config.className,
        restConfig = __rest$d(config, ["message", "description", "icon", "type", "placement", "btn", "className"]);
      return originOpen(_extends$2(_extends$2({}, restConfig), {
        content:
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(PureContent, {
          prefixCls: noticePrefixCls,
          icon: icon,
          type: type,
          message: message,
          description: description,
          btn: btn
        }),
        placement: placement,
        className: classNames$1(type && noticePrefixCls + "-" + type, hashId, className)
      }));
    };
    // >>> destroy
    var destroy = function destroy(key) {
      var _a, _b;
      if (key !== undefined) {
        (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.close(key);
      } else {
        (_b = holderRef.current) === null || _b === void 0 ? void 0 : _b.destroy();
      }
    };
    var clone = {
      open: open,
      destroy: destroy
    };
    var keys = ['success', 'info', 'warning', 'error'];
    keys.forEach(function (type) {
      clone[type] = function (config) {
        return open(_extends$2(_extends$2({}, config), {
          type: type
        }));
      };
    });
    return clone;
  }, []);
  // ============================== Return ===============================
  return [wrapAPI,
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(Holder, {
    ...notificationConfig,
    ref: holderRef
  }, "holder")];
}
function useNotification(notificationConfig) {
  return useInternalNotification(notificationConfig);
}

var notification = null;
var act = function act(callback) {
  return callback();
};
var taskQueue = [];
var defaultGlobalConfig = {};
function getGlobalContext() {
  var _defaultGlobalConfig = defaultGlobalConfig,
    globalPrefixCls = _defaultGlobalConfig.prefixCls,
    globalGetContainer = _defaultGlobalConfig.getContainer,
    rtl = _defaultGlobalConfig.rtl,
    maxCount = _defaultGlobalConfig.maxCount,
    top = _defaultGlobalConfig.top,
    bottom = _defaultGlobalConfig.bottom;
  var mergedPrefixCls = globalPrefixCls !== null && globalPrefixCls !== void 0 ? globalPrefixCls : globalConfig().getPrefixCls('notification');
  var mergedContainer = (globalGetContainer === null || globalGetContainer === void 0 ? void 0 : globalGetContainer()) || document.body;
  return {
    prefixCls: mergedPrefixCls,
    container: mergedContainer,
    rtl: rtl,
    maxCount: maxCount,
    top: top,
    bottom: bottom
  };
}
var GlobalHolder = /*#__PURE__*/react.exports.forwardRef(function (_, ref) {
  var _React$useState = react.exports.useState(),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    prefixCls = _React$useState2[0],
    setPrefixCls = _React$useState2[1];
  var _React$useState3 = react.exports.useState(),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    container = _React$useState4[0],
    setContainer = _React$useState4[1];
  var _React$useState5 = react.exports.useState(),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    maxCount = _React$useState6[0],
    setMaxCount = _React$useState6[1];
  var _React$useState7 = react.exports.useState(),
    _React$useState8 = _slicedToArray(_React$useState7, 2),
    rtl = _React$useState8[0],
    setRTL = _React$useState8[1];
  var _React$useState9 = react.exports.useState(),
    _React$useState10 = _slicedToArray(_React$useState9, 2),
    top = _React$useState10[0],
    setTop = _React$useState10[1];
  var _React$useState11 = react.exports.useState(),
    _React$useState12 = _slicedToArray(_React$useState11, 2),
    bottom = _React$useState12[0],
    setBottom = _React$useState12[1];
  var _useInternalNotificat = useInternalNotification({
      prefixCls: prefixCls,
      getContainer: function getContainer() {
        return container;
      },
      maxCount: maxCount,
      rtl: rtl,
      top: top,
      bottom: bottom
    }),
    _useInternalNotificat2 = _slicedToArray(_useInternalNotificat, 2),
    api = _useInternalNotificat2[0],
    holder = _useInternalNotificat2[1];
  var global = globalConfig();
  var rootPrefixCls = global.getRootPrefixCls();
  var rootIconPrefixCls = global.getIconPrefixCls();
  var sync = function sync() {
    var _getGlobalContext = getGlobalContext(),
      nextGlobalPrefixCls = _getGlobalContext.prefixCls,
      nextGlobalContainer = _getGlobalContext.container,
      nextGlobalMaxCount = _getGlobalContext.maxCount,
      nextGlobalRTL = _getGlobalContext.rtl,
      nextTop = _getGlobalContext.top,
      nextBottom = _getGlobalContext.bottom;
    setPrefixCls(nextGlobalPrefixCls);
    setContainer(nextGlobalContainer);
    setMaxCount(nextGlobalMaxCount);
    setRTL(nextGlobalRTL);
    setTop(nextTop);
    setBottom(nextBottom);
  };
  react.exports.useEffect(sync, []);
  react.exports.useImperativeHandle(ref, function () {
    var instance = _extends$2({}, api);
    Object.keys(instance).forEach(function (method) {
      instance[method] = function () {
        sync();
        return api[method].apply(api, arguments);
      };
    });
    return {
      instance: instance,
      sync: sync
    };
  });
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(ConfigProvider, {
      prefixCls: rootPrefixCls,
      iconPrefixCls: rootIconPrefixCls,
      children: holder
    })
  );
});
function flushNotice() {
  if (!notification) {
    var holderFragment = document.createDocumentFragment();
    var newNotification = {
      fragment: holderFragment
    };
    notification = newNotification;
    // Delay render to avoid sync issue
    act(function () {
      render(
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(GlobalHolder, {
        ref: function ref(node) {
          var _ref = node || {},
            instance = _ref.instance,
            sync = _ref.sync;
          Promise.resolve().then(function () {
            if (!newNotification.instance && instance) {
              newNotification.instance = instance;
              newNotification.sync = sync;
              flushNotice();
            }
          });
        }
      }), holderFragment);
    });
    return;
  }
  // Notification not ready
  if (!notification.instance) {
    return;
  }
  // >>> Execute task
  taskQueue.forEach(function (task) {
    // eslint-disable-next-line default-case
    switch (task.type) {
      case 'open':
        {
          act(function () {
            notification.instance.open(_extends$2(_extends$2({}, defaultGlobalConfig), task.config));
          });
          break;
        }
      case 'destroy':
        act(function () {
          notification === null || notification === void 0 ? void 0 : notification.instance.destroy(task.key);
        });
        break;
    }
  });
  // Clean up
  taskQueue = [];
}
// ==============================================================================
// ==                                  Export                                  ==
// ==============================================================================
var methods = ['success', 'info', 'warning', 'error'];
function setNotificationGlobalConfig(config) {
  defaultGlobalConfig = _extends$2(_extends$2({}, defaultGlobalConfig), config);
  // Trigger sync for it
  act(function () {
    var _a;
    (_a = notification === null || notification === void 0 ? void 0 : notification.sync) === null || _a === void 0 ? void 0 : _a.call(notification);
  });
}
function open$1(config) {
  taskQueue.push({
    type: 'open',
    config: config
  });
  flushNotice();
}
function destroy(key) {
  taskQueue.push({
    type: 'destroy',
    key: key
  });
  flushNotice();
}
var baseStaticMethods = {
  open: open$1,
  destroy: destroy,
  config: setNotificationGlobalConfig,
  useNotification: useNotification,
  _InternalPanelDoNotUseOrYouWillBeFired: PurePanel
};
var staticMethods = baseStaticMethods;
methods.forEach(function (type) {
  staticMethods[type] = function (config) {
    return open$1(_extends$2(_extends$2({}, config), {
      type: type
    }));
  };
});
const notification$1 = staticMethods;

/**
 * @ignore
 * some key-codes definition and utils from closure-library
 * @author yiminghe@gmail.com
 */
var KeyCode = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  /**
   * END
   */
  END: 35,
  /**
   * HOME
   */
  HOME: 36,
  /**
   * LEFT
   */
  LEFT: 37,
  /**
   * UP
   */
  UP: 38,
  /**
   * RIGHT
   */
  RIGHT: 39,
  /**
   * DOWN
   */
  DOWN: 40,
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  /**
   * DELETE
   */
  DELETE: 46,
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  /**
   * DASH
   */
  DASH: 189,
  /**
   * EQUALS
   */
  EQUALS: 187,
  /**
   * COMMA
   */
  COMMA: 188,
  /**
   * PERIOD
   */
  PERIOD: 190,
  /**
   * SLASH
   */
  SLASH: 191,
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e) {
    var keyCode = e.keyCode;
    if (e.altKey && !e.ctrlKey || e.metaKey ||
    // Function keys don't generate text
    keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    }
    // The following keys are quite harmless, even in combination with
    // CTRL, ALT or SHIFT.
    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  /**
   * whether character is entered.
   */
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }
    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    }
    // Safari sends zero key code for non-latin characters.
    if (window.navigator.userAgent.indexOf('WebKit') !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};

var defaultProps$1 = {
  className: '',
  percent: 0,
  prefixCls: 'rc-progress',
  strokeColor: '#2db7f5',
  strokeLinecap: 'round',
  strokeWidth: 1,
  style: {},
  trailColor: '#D9D9D9',
  trailWidth: 1,
  gapPosition: 'bottom'
};
var useTransitionDuration = function useTransitionDuration() {
  var pathsRef = react.exports.useRef([]);
  var prevTimeStamp = react.exports.useRef(null);
  react.exports.useEffect(function () {
    var now = Date.now();
    var updated = false;
    pathsRef.current.forEach(function (path) {
      if (!path) {
        return;
      }
      updated = true;
      var pathStyle = path.style;
      pathStyle.transitionDuration = '.3s, .3s, .3s, .06s';
      if (prevTimeStamp.current && now - prevTimeStamp.current < 100) {
        pathStyle.transitionDuration = '0s, 0s';
      }
    });
    if (updated) {
      prevTimeStamp.current = Date.now();
    }
  });
  return pathsRef.current;
};

var uuid = 0;
/** Is client side and not jsdom */
var isBrowserClient = canUseDom();
/** Get unique id for accessibility usage */
function getUUID() {
  var retId;
  // Test never reach
  /* istanbul ignore if */
  if (isBrowserClient) {
    retId = uuid;
    uuid += 1;
  } else {
    retId = 'TEST_OR_SSR';
  }
  return retId;
}
const useId = (function (id) {
  // Inner id for accessibility usage. Only work in client side
  var _React$useState = react.exports.useState(),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    innerId = _React$useState2[0],
    setInnerId = _React$useState2[1];
  react.exports.useEffect(function () {
    setInnerId("rc_progress_".concat(getUUID()));
  }, []);
  return id || innerId;
});

var _excluded$i = ["id", "prefixCls", "steps", "strokeWidth", "trailWidth", "gapDegree", "gapPosition", "trailColor", "strokeLinecap", "style", "className", "strokeColor", "percent"];
function stripPercentToNumber(percent) {
  return +percent.replace('%', '');
}
function toArray$2(value) {
  var mergedValue = value !== null && value !== void 0 ? value : [];
  return Array.isArray(mergedValue) ? mergedValue : [mergedValue];
}
var VIEW_BOX_SIZE = 100;
var getCircleStyle = function getCircleStyle(perimeter, perimeterWithoutGap, offset, percent, rotateDeg, gapDegree, gapPosition, strokeColor, strokeLinecap, strokeWidth) {
  var stepSpace = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;
  var offsetDeg = offset / 100 * 360 * ((360 - gapDegree) / 360);
  var positionDeg = gapDegree === 0 ? 0 : {
    bottom: 0,
    top: 180,
    left: 90,
    right: -90
  }[gapPosition];
  var strokeDashoffset = (100 - percent) / 100 * perimeterWithoutGap;
  // Fix percent accuracy when strokeLinecap is round
  // https://github.com/ant-design/ant-design/issues/35009
  if (strokeLinecap === 'round' && percent !== 100) {
    strokeDashoffset += strokeWidth / 2;
    // when percent is small enough (<= 1%), keep smallest value to avoid it's disappearance
    if (strokeDashoffset >= perimeterWithoutGap) {
      strokeDashoffset = perimeterWithoutGap - 0.01;
    }
  }
  return {
    stroke: typeof strokeColor === 'string' ? strokeColor : undefined,
    strokeDasharray: "".concat(perimeterWithoutGap, "px ").concat(perimeter),
    strokeDashoffset: strokeDashoffset + stepSpace,
    transform: "rotate(".concat(rotateDeg + offsetDeg + positionDeg, "deg)"),
    transformOrigin: '0 0',
    transition: 'stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s',
    fillOpacity: 0
  };
};
var Circle$2 = function Circle(_ref) {
  var id = _ref.id,
    prefixCls = _ref.prefixCls,
    steps = _ref.steps,
    strokeWidth = _ref.strokeWidth,
    trailWidth = _ref.trailWidth,
    _ref$gapDegree = _ref.gapDegree,
    gapDegree = _ref$gapDegree === void 0 ? 0 : _ref$gapDegree,
    gapPosition = _ref.gapPosition,
    trailColor = _ref.trailColor,
    strokeLinecap = _ref.strokeLinecap,
    style = _ref.style,
    className = _ref.className,
    strokeColor = _ref.strokeColor,
    percent = _ref.percent,
    restProps = _objectWithoutProperties(_ref, _excluded$i);
  var mergedId = useId(id);
  var gradientId = "".concat(mergedId, "-gradient");
  var radius = VIEW_BOX_SIZE / 2 - strokeWidth / 2;
  var perimeter = Math.PI * 2 * radius;
  var rotateDeg = gapDegree > 0 ? 90 + gapDegree / 2 : -90;
  var perimeterWithoutGap = perimeter * ((360 - gapDegree) / 360);
  var _ref2 = _typeof$1(steps) === 'object' ? steps : {
      count: steps,
      space: 2
    },
    stepCount = _ref2.count,
    stepSpace = _ref2.space;
  var circleStyle = getCircleStyle(perimeter, perimeterWithoutGap, 0, 100, rotateDeg, gapDegree, gapPosition, trailColor, strokeLinecap, strokeWidth);
  var percentList = toArray$2(percent);
  var strokeColorList = toArray$2(strokeColor);
  var gradient = strokeColorList.find(function (color) {
    return color && _typeof$1(color) === 'object';
  });
  var paths = useTransitionDuration();
  var getStokeList = function getStokeList() {
    var stackPtg = 0;
    return percentList.map(function (ptg, index) {
      var color = strokeColorList[index] || strokeColorList[strokeColorList.length - 1];
      var stroke = color && _typeof$1(color) === 'object' ? "url(#".concat(gradientId, ")") : undefined;
      var circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, ptg, rotateDeg, gapDegree, gapPosition, color, strokeLinecap, strokeWidth);
      stackPtg += ptg;
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("circle", {
          className: "".concat(prefixCls, "-circle-path"),
          r: radius,
          cx: 0,
          cy: 0,
          stroke: stroke,
          strokeLinecap: strokeLinecap,
          strokeWidth: strokeWidth,
          opacity: ptg === 0 ? 0 : 1,
          style: circleStyleForStack,
          ref: function ref(elem) {
            // https://reactjs.org/docs/refs-and-the-dom.html#callback-refs
            // React will call the ref callback with the DOM element when the component mounts,
            // and call it with `null` when it unmounts.
            // Refs are guaranteed to be up-to-date before componentDidMount or componentDidUpdate fires.
            paths[index] = elem;
          }
        }, index)
      );
    }).reverse();
  };
  var getStepStokeList = function getStepStokeList() {
    // only show the first percent when pass steps
    var current = Math.round(stepCount * (percentList[0] / 100));
    var stepPtg = 100 / stepCount;
    var stackPtg = 0;
    return new Array(stepCount).fill(null).map(function (_, index) {
      var color = index <= current - 1 ? strokeColorList[0] : trailColor;
      var stroke = color && _typeof$1(color) === 'object' ? "url(#".concat(gradientId, ")") : undefined;
      var circleStyleForStack = getCircleStyle(perimeter, perimeterWithoutGap, stackPtg, stepPtg, rotateDeg, gapDegree, gapPosition, color, 'butt', strokeWidth, stepSpace);
      stackPtg += (perimeterWithoutGap - circleStyleForStack.strokeDashoffset + stepSpace) * 100 / perimeterWithoutGap;
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("circle", {
          className: "".concat(prefixCls, "-circle-path"),
          r: radius,
          cx: 0,
          cy: 0,
          stroke: stroke,
          strokeWidth: strokeWidth,
          opacity: 1,
          style: circleStyleForStack,
          ref: function ref(elem) {
            paths[index] = elem;
          }
        }, index)
      );
    });
  };
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("svg", {
      className: classNames$1("".concat(prefixCls, "-circle"), className),
      viewBox: "".concat(-VIEW_BOX_SIZE / 2, " ").concat(-VIEW_BOX_SIZE / 2, " ").concat(VIEW_BOX_SIZE, " ").concat(VIEW_BOX_SIZE),
      style: style,
      id: id,
      role: "presentation",
      ...restProps,
      children: [gradient &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("defs", {
        children: /*#__PURE__*/jsx$1("linearGradient", {
          id: gradientId,
          x1: "100%",
          y1: "0%",
          x2: "0%",
          y2: "0%",
          children: Object.keys(gradient).sort(function (a, b) {
            return stripPercentToNumber(a) - stripPercentToNumber(b);
          }).map(function (key, index) {
            return (
              /*#__PURE__*/
              /*#__PURE__*/
              jsx$1("stop", {
                offset: key,
                stopColor: gradient[key]
              }, index)
            );
          })
        })
      }), !stepCount &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("circle", {
        className: "".concat(prefixCls, "-circle-trail"),
        r: radius,
        cx: 0,
        cy: 0,
        stroke: trailColor,
        strokeLinecap: strokeLinecap,
        strokeWidth: trailWidth || strokeWidth,
        style: circleStyle
      }), stepCount ? getStepStokeList() : getStokeList()]
    })
  );
};
Circle$2.defaultProps = defaultProps$1;
Circle$2.displayName = 'Circle';

function validProgress(progress) {
  if (!progress || progress < 0) {
    return 0;
  }
  if (progress > 100) {
    return 100;
  }
  return progress;
}
function getSuccessPercent(_ref) {
  var success = _ref.success,
    successPercent = _ref.successPercent;
  var percent = successPercent;
  /** @deprecated Use `percent` instead */
  if (success && 'progress' in success) {
    percent = success.progress;
  }
  if (success && 'percent' in success) {
    percent = success.percent;
  }
  return percent;
}
var getPercentage = function getPercentage(_ref2) {
  var percent = _ref2.percent,
    success = _ref2.success,
    successPercent = _ref2.successPercent;
  var realSuccessPercent = validProgress(getSuccessPercent({
    success: success,
    successPercent: successPercent
  }));
  return [realSuccessPercent, validProgress(validProgress(percent) - realSuccessPercent)];
};
var getStrokeColor = function getStrokeColor(_ref3) {
  var _ref3$success = _ref3.success,
    success = _ref3$success === void 0 ? {} : _ref3$success,
    strokeColor = _ref3.strokeColor;
  var successColor = success.strokeColor;
  return [successColor || presetPrimaryColors.green, strokeColor || null];
};

var CIRCLE_MIN_STROKE_WIDTH = 3;
var getMinPercent = function getMinPercent(width) {
  return CIRCLE_MIN_STROKE_WIDTH / width * 100;
};
var Circle = function Circle(props) {
  var prefixCls = props.prefixCls,
    _props$width = props.width,
    width = _props$width === void 0 ? 120 : _props$width,
    _props$strokeWidth = props.strokeWidth,
    strokeWidth = _props$strokeWidth === void 0 ? Math.max(getMinPercent(width), 6) : _props$strokeWidth,
    _props$trailColor = props.trailColor,
    trailColor = _props$trailColor === void 0 ? null : _props$trailColor,
    _props$strokeLinecap = props.strokeLinecap,
    strokeLinecap = _props$strokeLinecap === void 0 ? 'round' : _props$strokeLinecap,
    gapPosition = props.gapPosition,
    gapDegree = props.gapDegree,
    type = props.type,
    children = props.children,
    success = props.success;
  var circleStyle = {
    width: width,
    height: width,
    fontSize: width * 0.15 + 6
  };
  var realGapDegree = react.exports.useMemo(function () {
    // Support gapDeg = 0 when type = 'dashboard'
    if (gapDegree || gapDegree === 0) {
      return gapDegree;
    }
    if (type === 'dashboard') {
      return 75;
    }
    return undefined;
  }, [gapDegree, type]);
  var gapPos = gapPosition || type === 'dashboard' && 'bottom' || undefined;
  // using className to style stroke color
  var isGradient = Object.prototype.toString.call(props.strokeColor) === '[object Object]';
  var strokeColor = getStrokeColor({
    success: success,
    strokeColor: props.strokeColor
  });
  var wrapperClassName = classNames$1(prefixCls + "-inner", _defineProperty$1({}, prefixCls + "-circle-gradient", isGradient));
  var circleContent =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(Circle$2, {
    percent: getPercentage(props),
    strokeWidth: strokeWidth,
    trailWidth: strokeWidth,
    strokeColor: strokeColor,
    strokeLinecap: strokeLinecap,
    trailColor: trailColor,
    prefixCls: prefixCls,
    gapDegree: realGapDegree,
    gapPosition: gapPos
  });
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      className: wrapperClassName,
      style: circleStyle,
      children: width <= 20 ?
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(Tooltip$1, {
        title: children,
        children: circleContent
      }) :
      /*#__PURE__*/
      /*#__PURE__*/
      jsxs(Fragment, {
        children: [circleContent, children]
      })
    })
  );
};
const Circle$1 = Circle;

var __rest$c = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var sortGradient = function sortGradient(gradients) {
  var tempArr = [];
  Object.keys(gradients).forEach(function (key) {
    var formattedKey = parseFloat(key.replace(/%/g, ''));
    if (!isNaN(formattedKey)) {
      tempArr.push({
        key: formattedKey,
        value: gradients[key]
      });
    }
  });
  tempArr = tempArr.sort(function (a, b) {
    return a.key - b.key;
  });
  return tempArr.map(function (_ref) {
    var key = _ref.key,
      value = _ref.value;
    return value + " " + key + "%";
  }).join(', ');
};
/**
 * Then this man came to realize the truth: Besides six pence, there is the moon. Besides bread and
 * butter, there is the bug. And... Besides women, there is the code.
 *
 * @example
 *   {
 *     "0%": "#afc163",
 *     "25%": "#66FF00",
 *     "50%": "#00CC00", // ====>  linear-gradient(to right, #afc163 0%, #66FF00 25%,
 *     "75%": "#009900", //        #00CC00 50%, #009900 75%, #ffffff 100%)
 *     "100%": "#ffffff"
 *   }
 */
var handleGradient = function handleGradient(strokeColor, directionConfig) {
  var _strokeColor$from = strokeColor.from,
    from = _strokeColor$from === void 0 ? presetPrimaryColors.blue : _strokeColor$from,
    _strokeColor$to = strokeColor.to,
    to = _strokeColor$to === void 0 ? presetPrimaryColors.blue : _strokeColor$to,
    _strokeColor$directio = strokeColor.direction,
    direction = _strokeColor$directio === void 0 ? directionConfig === 'rtl' ? 'to left' : 'to right' : _strokeColor$directio,
    rest = __rest$c(strokeColor, ["from", "to", "direction"]);
  if (Object.keys(rest).length !== 0) {
    var sortedGradients = sortGradient(rest);
    return {
      backgroundImage: "linear-gradient(" + direction + ", " + sortedGradients + ")"
    };
  }
  return {
    backgroundImage: "linear-gradient(" + direction + ", " + from + ", " + to + ")"
  };
};
var Line = function Line(props) {
  var prefixCls = props.prefixCls,
    directionConfig = props.direction,
    percent = props.percent,
    strokeWidth = props.strokeWidth,
    size = props.size,
    strokeColor = props.strokeColor,
    _props$strokeLinecap = props.strokeLinecap,
    strokeLinecap = _props$strokeLinecap === void 0 ? 'round' : _props$strokeLinecap,
    children = props.children,
    _props$trailColor = props.trailColor,
    trailColor = _props$trailColor === void 0 ? null : _props$trailColor,
    success = props.success;
  var backgroundProps = strokeColor && typeof strokeColor !== 'string' ? handleGradient(strokeColor, directionConfig) : {
    backgroundColor: strokeColor
  };
  var borderRadius = strokeLinecap === 'square' || strokeLinecap === 'butt' ? 0 : undefined;
  var trailStyle = {
    backgroundColor: trailColor || undefined,
    borderRadius: borderRadius
  };
  var percentStyle = _extends$2({
    width: validProgress(percent) + "%",
    height: strokeWidth || (size === 'small' ? 6 : 8),
    borderRadius: borderRadius
  }, backgroundProps);
  var successPercent = getSuccessPercent(props);
  var successPercentStyle = {
    width: validProgress(successPercent) + "%",
    height: strokeWidth || (size === 'small' ? 6 : 8),
    borderRadius: borderRadius,
    backgroundColor: success === null || success === void 0 ? void 0 : success.strokeColor
  };
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs(Fragment, {
      children: [/*#__PURE__*/jsx$1("div", {
        className: prefixCls + "-outer",
        children: /*#__PURE__*/jsxs("div", {
          className: prefixCls + "-inner",
          style: trailStyle,
          children: [/*#__PURE__*/jsx$1("div", {
            className: prefixCls + "-bg",
            style: percentStyle
          }), successPercent !== undefined ?
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("div", {
            className: prefixCls + "-success-bg",
            style: successPercentStyle
          }) : null]
        })
      }), children]
    })
  );
};
const Line$1 = Line;

var Steps = function Steps(props) {
  var size = props.size,
    steps = props.steps,
    _props$percent = props.percent,
    percent = _props$percent === void 0 ? 0 : _props$percent,
    _props$strokeWidth = props.strokeWidth,
    strokeWidth = _props$strokeWidth === void 0 ? 8 : _props$strokeWidth,
    strokeColor = props.strokeColor,
    _props$trailColor = props.trailColor,
    trailColor = _props$trailColor === void 0 ? null : _props$trailColor,
    prefixCls = props.prefixCls,
    children = props.children;
  var current = Math.round(steps * (percent / 100));
  var stepWidth = size === 'small' ? 2 : 14;
  var styledSteps = new Array(steps);
  for (var i = 0; i < steps; i++) {
    var color = Array.isArray(strokeColor) ? strokeColor[i] : strokeColor;
    styledSteps[i] =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      className: classNames$1(prefixCls + "-steps-item", _defineProperty$1({}, prefixCls + "-steps-item-active", i <= current - 1)),
      style: {
        backgroundColor: i <= current - 1 ? color : trailColor,
        width: stepWidth,
        height: strokeWidth
      }
    }, i);
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("div", {
      className: prefixCls + "-steps-outer",
      children: [styledSteps, children]
    })
  );
};
const Steps$1 = Steps;

var antProgressActive = new Keyframe('antProgressActive', {
  '0%': {
    transform: 'translateX(-100%) scaleX(0)',
    opacity: 0.1
  },
  '20%': {
    transform: 'translateX(-100%) scaleX(0)',
    opacity: 0.5
  },
  to: {
    transform: 'translateX(0) scaleX(1)',
    opacity: 0
  }
});
var genBaseStyle$1 = function genBaseStyle(token) {
  var _ref5, _ref7, _extends2;
  var progressCls = token.componentCls,
    iconPrefixCls = token.iconCls;
  return _defineProperty$1({}, progressCls, _extends$2(_extends$2({}, resetComponent(token)), (_extends2 = {
    display: 'inline-block',
    '&-rtl': {
      direction: 'rtl'
    },
    '&-line': {
      position: 'relative',
      width: '100%',
      fontSize: token.fontSize,
      marginInlineEnd: token.marginXS,
      marginBottom: token.marginXS
    }
  }, _defineProperty$1(_extends2, progressCls + "-outer", {
    display: 'inline-block',
    width: '100%'
  }), _defineProperty$1(_extends2, "&" + progressCls + "-show-info", _defineProperty$1({}, progressCls + "-outer", {
    marginInlineEnd: "calc(-2em - " + token.marginXS + "px)",
    paddingInlineEnd: "calc(2em + " + token.paddingXS + "px)"
  })), _defineProperty$1(_extends2, progressCls + "-inner", {
    position: 'relative',
    display: 'inline-block',
    width: '100%',
    overflow: 'hidden',
    verticalAlign: 'middle',
    backgroundColor: token.progressRemainingColor,
    borderRadius: token.progressLineRadius
  }), _defineProperty$1(_extends2, progressCls + "-inner:not(" + progressCls + "-circle-gradient)", _defineProperty$1({}, progressCls + "-circle-path", {
    stroke: token.colorInfo
  })), _defineProperty$1(_extends2, "&" + progressCls + "-success-bg, " + progressCls + "-bg", {
    position: 'relative',
    backgroundColor: token.colorInfo,
    borderRadius: token.progressLineRadius,
    transition: "all " + token.motionDurationSlow + " " + token.motionEaseInOutCirc
  }), _defineProperty$1(_extends2, progressCls + "-success-bg", {
    position: 'absolute',
    insetBlockStart: 0,
    insetInlineStart: 0,
    backgroundColor: token.colorSuccess
  }), _defineProperty$1(_extends2, progressCls + "-text", _defineProperty$1({
    display: 'inline-block',
    width: '2em',
    marginInlineStart: token.marginXS,
    color: token.progressInfoTextColor,
    lineHeight: 1,
    whiteSpace: 'nowrap',
    textAlign: 'start',
    verticalAlign: 'middle',
    wordBreak: 'normal'
  }, iconPrefixCls, {
    fontSize: token.fontSize
  })), _defineProperty$1(_extends2, "&" + progressCls + "-status-active", _defineProperty$1({}, progressCls + "-bg::before", {
    position: 'absolute',
    inset: 0,
    backgroundColor: token.colorBgContainer,
    borderRadius: token.progressLineRadius,
    opacity: 0,
    animationName: antProgressActive,
    animationDuration: token.progressActiveMotionDuration,
    animationTimingFunction: token.motionEaseOutQuint,
    animationIterationCount: 'infinite',
    content: '""'
  })), _defineProperty$1(_extends2, "&" + progressCls + "-status-exception", (_ref5 = {}, _defineProperty$1(_ref5, progressCls + "-bg", {
    backgroundColor: token.colorError
  }), _defineProperty$1(_ref5, progressCls + "-text", {
    color: token.colorError
  }), _ref5)), _defineProperty$1(_extends2, "&" + progressCls + "-status-exception " + progressCls + "-inner:not(" + progressCls + "-circle-gradient)", _defineProperty$1({}, progressCls + "-circle-path", {
    stroke: token.colorError
  })), _defineProperty$1(_extends2, "&" + progressCls + "-status-success", (_ref7 = {}, _defineProperty$1(_ref7, progressCls + "-bg", {
    backgroundColor: token.colorSuccess
  }), _defineProperty$1(_ref7, progressCls + "-text", {
    color: token.colorSuccess
  }), _ref7)), _defineProperty$1(_extends2, "&" + progressCls + "-status-success " + progressCls + "-inner:not(" + progressCls + "-circle-gradient)", _defineProperty$1({}, progressCls + "-circle-path", {
    stroke: token.colorSuccess
  })), _extends2)));
};
var genCircleStyle = function genCircleStyle(token) {
  var _progressCls, _ref14;
  var progressCls = token.componentCls,
    iconPrefixCls = token.iconCls;
  return _ref14 = {}, _defineProperty$1(_ref14, progressCls, (_progressCls = {}, _defineProperty$1(_progressCls, progressCls + "-circle-trail", {
    stroke: token.progressRemainingColor
  }), _defineProperty$1(_progressCls, "&" + progressCls + "-circle " + progressCls + "-inner", {
    position: 'relative',
    lineHeight: 1,
    backgroundColor: 'transparent'
  }), _defineProperty$1(_progressCls, "&" + progressCls + "-circle " + progressCls + "-text", _defineProperty$1({
    position: 'absolute',
    insetBlockStart: '50%',
    insetInlineStart: '50%',
    width: '100%',
    margin: 0,
    padding: 0,
    color: token.colorText,
    lineHeight: 1,
    whiteSpace: 'normal',
    textAlign: 'center',
    transform: "translate(-50%, -50%)"
  }, iconPrefixCls, {
    fontSize: token.fontSize / token.fontSizeSM + "em"
  })), _defineProperty$1(_progressCls, progressCls + "-circle&-status-exception", _defineProperty$1({}, progressCls + "-text", {
    color: token.colorError
  })), _defineProperty$1(_progressCls, progressCls + "-circle&-status-success", _defineProperty$1({}, progressCls + "-text", {
    color: token.colorSuccess
  })), _progressCls)), _defineProperty$1(_ref14, progressCls + "-inline-circle", _defineProperty$1({
    lineHeight: 1
  }, progressCls + "-inner", {
    verticalAlign: 'bottom'
  })), _ref14;
};
var genStepStyle = function genStepStyle(token) {
  var progressCls = token.componentCls;
  return _defineProperty$1({}, progressCls, _defineProperty$1({}, progressCls + "-steps", {
    display: 'inline-block',
    '&-outer': {
      display: 'flex',
      flexDirection: 'row',
      alignItems: 'center'
    },
    '&-item': {
      flexShrink: 0,
      minWidth: token.progressStepMinWidth,
      marginInlineEnd: token.progressStepMarginInlineEnd,
      backgroundColor: token.progressRemainingColor,
      transition: "all " + token.motionDurationSlow,
      '&-active': {
        backgroundColor: token.colorInfo
      }
    }
  }));
};
var genSmallLine = function genSmallLine(token) {
  var progressCls = token.componentCls,
    iconPrefixCls = token.iconCls;
  return _defineProperty$1({}, progressCls, _defineProperty$1({}, progressCls + "-small&-line, " + progressCls + "-small&-line " + progressCls + "-text " + iconPrefixCls, {
    fontSize: token.fontSizeSM
  }));
};
const useStyle$5 = genComponentStyleHook('Progress', function (token) {
  var progressStepMarginInlineEnd = token.marginXXS / 2;
  var progressToken = merge$2(token, {
    progressLineRadius: 100,
    progressInfoTextColor: token.colorText,
    progressDefaultColor: token.colorInfo,
    progressRemainingColor: token.colorFillSecondary,
    progressStepMarginInlineEnd: progressStepMarginInlineEnd,
    progressStepMinWidth: progressStepMarginInlineEnd,
    progressActiveMotionDuration: '2.4s'
  });
  return [genBaseStyle$1(progressToken), genCircleStyle(progressToken), genStepStyle(progressToken), genSmallLine(progressToken)];
});

var __rest$b = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var ProgressStatuses = ['normal', 'exception', 'active', 'success'];
var Progress = function Progress(props) {
  var _classNames;
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    steps = props.steps,
    strokeColor = props.strokeColor,
    _props$percent = props.percent,
    percent = _props$percent === void 0 ? 0 : _props$percent,
    _props$size = props.size,
    size = _props$size === void 0 ? 'default' : _props$size,
    _props$showInfo = props.showInfo,
    showInfo = _props$showInfo === void 0 ? true : _props$showInfo,
    _props$type = props.type,
    type = _props$type === void 0 ? 'line' : _props$type,
    status = props.status,
    format = props.format,
    restProps = __rest$b(props, ["prefixCls", "className", "steps", "strokeColor", "percent", "size", "showInfo", "type", "status", "format"]);
  var percentNumber = react.exports.useMemo(function () {
    var successPercent = getSuccessPercent(props);
    return parseInt(successPercent !== undefined ? successPercent.toString() : percent.toString(), 10);
  }, [percent, props.success, props.successPercent]);
  var progressStatus = react.exports.useMemo(function () {
    if (!ProgressStatuses.includes(status) && percentNumber >= 100) {
      return 'success';
    }
    return status || 'normal';
  }, [status, percentNumber]);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var prefixCls = getPrefixCls('progress', customizePrefixCls);
  var _useStyle = useStyle$5(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var progressInfo = react.exports.useMemo(function () {
    if (!showInfo) {
      return null;
    }
    var successPercent = getSuccessPercent(props);
    var text;
    var textFormatter = format || function (number) {
      return number + "%";
    };
    var isLineType = type === 'line';
    if (format || progressStatus !== 'exception' && progressStatus !== 'success') {
      text = textFormatter(validProgress(percent), validProgress(successPercent));
    } else if (progressStatus === 'exception') {
      text = isLineType ?
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(CloseCircleFilled$1, {}) :
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(CloseOutlined$1, {});
    } else if (progressStatus === 'success') {
      text = isLineType ?
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(CheckCircleFilled$1, {}) :
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(CheckOutlined$1, {});
    }
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        className: prefixCls + "-text",
        title: typeof text === 'string' ? text : undefined,
        children: text
      })
    );
  }, [showInfo, percentNumber, progressStatus, type, prefixCls, format]);
  var strokeColorNotArray = Array.isArray(strokeColor) ? strokeColor[0] : strokeColor;
  var strokeColorNotGradient = typeof strokeColor === 'string' || Array.isArray(strokeColor) ? strokeColor : undefined;
  var progress;
  // Render progress shape
  if (type === 'line') {
    progress = steps ?
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Steps$1, {
      ...props,
      strokeColor: strokeColorNotGradient,
      prefixCls: prefixCls,
      steps: steps,
      children: progressInfo
    }) :
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Line$1, {
      ...props,
      strokeColor: strokeColorNotArray,
      prefixCls: prefixCls,
      direction: direction,
      children: progressInfo
    });
  } else if (type === 'circle' || type === 'dashboard') {
    progress =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Circle$1, {
      ...props,
      strokeColor: strokeColorNotArray,
      prefixCls: prefixCls,
      progressStatus: progressStatus,
      children: progressInfo
    });
  }
  var classString = classNames$1(prefixCls, (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-inline-circle", type === 'circle' && props.width <= 20), _defineProperty$1(_classNames, prefixCls + "-" + (type === 'dashboard' && 'circle' || steps && 'steps' || type), true), _defineProperty$1(_classNames, prefixCls + "-status-" + progressStatus, true), _defineProperty$1(_classNames, prefixCls + "-show-info", showInfo), _defineProperty$1(_classNames, prefixCls + "-" + size, size), _defineProperty$1(_classNames, prefixCls + "-rtl", direction === 'rtl'), _classNames), className, hashId);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    className: classString,
    role: "progressbar",
    ...omit$1(restProps, ['trailColor', 'strokeWidth', 'width', 'gapDegree', 'gapPosition', 'strokeLinecap', 'success', 'successPercent']),
    children: progress
  }));
};
const Progress$1 = Progress;

var calcThumbStyle = function calcThumbStyle(targetElement) {
  return targetElement ? {
    left: targetElement.offsetLeft,
    width: targetElement.clientWidth
  } : null;
};
var toPX = function toPX(value) {
  return value !== undefined ? "".concat(value, "px") : undefined;
};
function MotionThumb(props) {
  var prefixCls = props.prefixCls,
    containerRef = props.containerRef,
    value = props.value,
    getValueIndex = props.getValueIndex,
    motionName = props.motionName,
    onMotionStart = props.onMotionStart,
    onMotionEnd = props.onMotionEnd;
  var thumbRef = react.exports.useRef(null);
  var _React$useState = react.exports.useState(value),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    prevValue = _React$useState2[0],
    setPrevValue = _React$useState2[1]; // =========================== Effect ===========================

  var findValueElement = function findValueElement(val) {
    var _containerRef$current;
    var index = getValueIndex(val);
    var ele = (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.querySelectorAll(".".concat(prefixCls, "-item"))[index];
    return ele;
  };
  var _React$useState3 = react.exports.useState(null),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    prevStyle = _React$useState4[0],
    setPrevStyle = _React$useState4[1];
  var _React$useState5 = react.exports.useState(null),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    nextStyle = _React$useState6[0],
    setNextStyle = _React$useState6[1];
  useLayoutEffect$3(function () {
    if (prevValue !== value) {
      var prev = findValueElement(prevValue);
      var next = findValueElement(value);
      var calcPrevStyle = calcThumbStyle(prev);
      var calcNextStyle = calcThumbStyle(next);
      setPrevValue(value);
      setPrevStyle(calcPrevStyle);
      setNextStyle(calcNextStyle);
      if (prev && next) {
        onMotionStart();
      } else {
        onMotionEnd();
      }
    }
  }, [value]); // =========================== Motion ===========================

  var onAppearStart = function onAppearStart() {
    return {
      transform: "translateX(var(--thumb-start-left))",
      width: "var(--thumb-start-width)"
    };
  };
  var onAppearActive = function onAppearActive() {
    return {
      transform: "translateX(var(--thumb-active-left))",
      width: "var(--thumb-active-width)"
    };
  };
  var onAppearEnd = function onAppearEnd() {
    setPrevStyle(null);
    setNextStyle(null);
    onMotionEnd();
  }; // =========================== Render ===========================
  // No need motion when nothing exist in queue

  if (!prevStyle || !nextStyle) {
    return null;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(CSSMotion, {
      visible: true,
      motionName: motionName,
      motionAppear: true,
      onAppearStart: onAppearStart,
      onAppearActive: onAppearActive,
      onAppearEnd: onAppearEnd,
      children: function (_ref, ref) {
        var motionClassName = _ref.className,
          motionStyle = _ref.style;
        var mergedStyle = _objectSpread2$1(_objectSpread2$1({}, motionStyle), {}, {
          '--thumb-start-left': toPX(prevStyle === null || prevStyle === void 0 ? void 0 : prevStyle.left),
          '--thumb-start-width': toPX(prevStyle === null || prevStyle === void 0 ? void 0 : prevStyle.width),
          '--thumb-active-left': toPX(nextStyle === null || nextStyle === void 0 ? void 0 : nextStyle.left),
          '--thumb-active-width': toPX(nextStyle === null || nextStyle === void 0 ? void 0 : nextStyle.width)
        }); // It's little ugly which should be refactor when @umi/test update to latest jsdom

        var motionProps = {
          ref: composeRef$1(thumbRef, ref),
          style: mergedStyle,
          className: classNames$1("".concat(prefixCls, "-thumb"), motionClassName)
        };
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("div", {
            ..._objectSpread2$1({}, motionProps)
          })
        );
      }
    })
  );
}

var _excluded$h = ["prefixCls", "direction", "options", "disabled", "defaultValue", "value", "onChange", "className", "motionName"];
function getValidTitle(option) {
  if (typeof option.title !== 'undefined') {
    return option.title;
  } // read `label` when title is `undefined`

  if (_typeof$1(option.label) !== 'object') {
    var _option$label;
    return (_option$label = option.label) === null || _option$label === void 0 ? void 0 : _option$label.toString();
  }
}
function normalizeOptions(options) {
  return options.map(function (option) {
    if (_typeof$1(option) === 'object' && option !== null) {
      var validTitle = getValidTitle(option);
      return _objectSpread2$1(_objectSpread2$1({}, option), {}, {
        title: validTitle
      });
    }
    return {
      label: option === null || option === void 0 ? void 0 : option.toString(),
      title: option === null || option === void 0 ? void 0 : option.toString(),
      value: option
    };
  });
}
var InternalSegmentedOption = function InternalSegmentedOption(_ref) {
  var prefixCls = _ref.prefixCls,
    className = _ref.className,
    disabled = _ref.disabled,
    checked = _ref.checked,
    label = _ref.label,
    title = _ref.title,
    value = _ref.value,
    onChange = _ref.onChange;
  var handleChange = function handleChange(event) {
    if (disabled) {
      return;
    }
    onChange(event, value);
  };
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("label", {
      className: classNames$1(className, _defineProperty$1({}, "".concat(prefixCls, "-item-disabled"), disabled)),
      children: [/*#__PURE__*/jsx$1("input", {
        className: "".concat(prefixCls, "-item-input"),
        type: "radio",
        disabled: disabled,
        checked: checked,
        onChange: handleChange
      }), /*#__PURE__*/jsx$1("div", {
        className: "".concat(prefixCls, "-item-label"),
        title: title,
        children: label
      })]
    })
  );
};
var Segmented$2 = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _segmentedOptions$, _classNames2;
  var _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-segmented' : _props$prefixCls,
    direction = props.direction,
    options = props.options,
    disabled = props.disabled,
    defaultValue = props.defaultValue,
    value = props.value,
    onChange = props.onChange,
    _props$className = props.className,
    className = _props$className === void 0 ? '' : _props$className,
    _props$motionName = props.motionName,
    motionName = _props$motionName === void 0 ? 'thumb-motion' : _props$motionName,
    restProps = _objectWithoutProperties(props, _excluded$h);
  var containerRef = react.exports.useRef(null);
  var mergedRef = react.exports.useMemo(function () {
    return composeRef$1(containerRef, ref);
  }, [containerRef, ref]);
  var segmentedOptions = react.exports.useMemo(function () {
    return normalizeOptions(options);
  }, [options]); // Note: We should not auto switch value when value not exist in options
  // which may break single source of truth.

  var _useMergedState = useMergedState$1((_segmentedOptions$ = segmentedOptions[0]) === null || _segmentedOptions$ === void 0 ? void 0 : _segmentedOptions$.value, {
      value: value,
      defaultValue: defaultValue
    }),
    _useMergedState2 = _slicedToArray(_useMergedState, 2),
    rawValue = _useMergedState2[0],
    setRawValue = _useMergedState2[1]; // ======================= Change ========================

  var _React$useState = react.exports.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    thumbShow = _React$useState2[0],
    setThumbShow = _React$useState2[1];
  var handleChange = function handleChange(event, val) {
    if (disabled) {
      return;
    }
    setRawValue(val);
    onChange === null || onChange === void 0 ? void 0 : onChange(val);
  };
  var divProps = omit(restProps, ['children']);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      ..._objectSpread2$1(_objectSpread2$1({}, divProps), {}, {
        className: classNames$1(prefixCls, (_classNames2 = {}, _defineProperty$1(_classNames2, "".concat(prefixCls, "-rtl"), direction === 'rtl'), _defineProperty$1(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _classNames2), className),
        ref: mergedRef
      }),
      children: /*#__PURE__*/jsxs("div", {
        className: "".concat(prefixCls, "-group"),
        children: [/*#__PURE__*/jsx$1(MotionThumb, {
          prefixCls: prefixCls,
          value: rawValue,
          containerRef: containerRef,
          motionName: "".concat(prefixCls, "-").concat(motionName),
          getValueIndex: function getValueIndex(val) {
            return segmentedOptions.findIndex(function (n) {
              return n.value === val;
            });
          },
          onMotionStart: function onMotionStart() {
            setThumbShow(true);
          },
          onMotionEnd: function onMotionEnd() {
            setThumbShow(false);
          }
        }), segmentedOptions.map(function (segmentedOption) {
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1(InternalSegmentedOption, {
              ..._objectSpread2$1(_objectSpread2$1({
                key: segmentedOption.value,
                prefixCls: prefixCls,
                className: classNames$1(segmentedOption.className, "".concat(prefixCls, "-item"), _defineProperty$1({}, "".concat(prefixCls, "-item-selected"), segmentedOption.value === rawValue && !thumbShow)),
                checked: segmentedOption.value === rawValue,
                onChange: handleChange
              }, segmentedOption), {}, {
                disabled: !!disabled || !!segmentedOption.disabled
              })
            })
          );
        })]
      })
    })
  );
});
Segmented$2.displayName = 'Segmented';
Segmented$2.defaultProps = {
  options: []
};

// ============================== Mixins ==============================
function segmentedDisabledItem(cls, token) {
  return _defineProperty$1({}, cls + ", " + cls + ":hover, " + cls + ":focus", {
    color: token.colorTextDisabled,
    cursor: 'not-allowed'
  });
}
function getSegmentedItemSelectedStyle(token) {
  return {
    backgroundColor: token.bgColorSelected,
    boxShadow: token.boxShadow
  };
}
var segmentedTextEllipsisCss = _extends$2({
  overflow: 'hidden'
}, textEllipsis);
// ============================== Styles ==============================
var genSegmentedStyle = function genSegmentedStyle(token) {
  var _ref2, _lg, _sm, _extends2, _extends4;
  var componentCls = token.componentCls;
  return _defineProperty$1({}, componentCls, _extends$2(_extends$2(_extends$2(_extends$2(_extends$2({}, resetComponent(token)), (_extends2 = {
    display: 'inline-block',
    padding: token.segmentedContainerPadding,
    color: token.labelColor,
    backgroundColor: token.bgColor,
    borderRadius: token.borderRadius,
    transition: "all " + token.motionDurationMid + " " + token.motionEaseInOut
  }, _defineProperty$1(_extends2, componentCls + "-group", {
    position: 'relative',
    display: 'flex',
    alignItems: 'stretch',
    justifyItems: 'flex-start',
    width: '100%'
  }), _defineProperty$1(_extends2, '&&-rtl', {
    direction: 'rtl'
  }), _defineProperty$1(_extends2, '&&-block', {
    display: 'flex'
  }), _defineProperty$1(_extends2, "&&-block " + componentCls + "-item", {
    flex: 1,
    minWidth: 0
  }), _defineProperty$1(_extends2, componentCls + "-item", (_ref2 = {
    position: 'relative',
    textAlign: 'center',
    cursor: 'pointer',
    transition: "color " + token.motionDurationMid + " " + token.motionEaseInOut,
    borderRadius: token.borderRadiusSM,
    '&-selected': _extends$2(_extends$2({}, getSegmentedItemSelectedStyle(token)), {
      color: token.labelColorHover
    }),
    '&::after': {
      content: '""',
      position: 'absolute',
      width: '100%',
      height: '100%',
      top: 0,
      insetInlineStart: 0,
      borderRadius: token.borderRadiusSM,
      transition: "background-color " + token.motionDurationMid
    }
  }, _defineProperty$1(_ref2, "&:hover:not(" + componentCls + "-item-selected):not(" + componentCls + "-item-disabled)", {
    color: token.labelColorHover,
    '&::after': {
      backgroundColor: token.bgColorHover
    }
  }), _defineProperty$1(_ref2, '&-label', _extends$2({
    minHeight: token.controlHeight - token.segmentedContainerPadding * 2,
    lineHeight: token.controlHeight - token.segmentedContainerPadding * 2 + "px",
    padding: "0 " + token.segmentedPaddingHorizontal + "px"
  }, segmentedTextEllipsisCss)), _defineProperty$1(_ref2, '&-icon + *', {
    marginInlineStart: token.marginSM / 2
  }), _defineProperty$1(_ref2, '&-input', {
    position: 'absolute',
    insetBlockStart: 0,
    insetInlineStart: 0,
    width: 0,
    height: 0,
    opacity: 0,
    pointerEvents: 'none'
  }), _ref2)), _defineProperty$1(_extends2, '&&-lg', (_lg = {
    borderRadius: token.borderRadiusLG
  }, _defineProperty$1(_lg, componentCls + "-item-label", {
    minHeight: token.controlHeightLG - token.segmentedContainerPadding * 2,
    lineHeight: token.controlHeightLG - token.segmentedContainerPadding * 2 + "px",
    padding: "0 " + token.segmentedPaddingHorizontal + "px",
    fontSize: token.fontSizeLG
  }), _defineProperty$1(_lg, componentCls + "-item-selected", {
    borderRadius: token.borderRadius
  }), _lg)), _defineProperty$1(_extends2, '&&-sm', (_sm = {
    borderRadius: token.borderRadiusSM
  }, _defineProperty$1(_sm, componentCls + "-item-label", {
    minHeight: token.controlHeightSM - token.segmentedContainerPadding * 2,
    lineHeight: token.controlHeightSM - token.segmentedContainerPadding * 2 + "px",
    padding: "0 " + token.segmentedPaddingHorizontalSM + "px"
  }), _defineProperty$1(_sm, componentCls + "-item-selected", {
    borderRadius: token.borderRadiusXS
  }), _sm)), _extends2)), segmentedDisabledItem("&-disabled " + componentCls + "-item", token)), segmentedDisabledItem(componentCls + "-item-disabled", token)), (_extends4 = {}, _defineProperty$1(_extends4, componentCls + "-thumb", _extends$2(_extends$2({}, getSegmentedItemSelectedStyle(token)), _defineProperty$1({
    position: 'absolute',
    insetBlockStart: 0,
    insetInlineStart: 0,
    width: 0,
    height: '100%',
    padding: token.paddingXXS + "px 0",
    borderRadius: token.borderRadiusSM
  }, "& ~ " + componentCls + "-item:not(" + componentCls + "-item-selected):not(" + componentCls + "-item-disabled)::after", {
    backgroundColor: 'transparent'
  }))), _defineProperty$1(_extends4, componentCls + "-thumb-motion-appear-active", {
    transition: "transform " + token.motionDurationSlow + " " + token.motionEaseInOut + ", width " + token.motionDurationSlow + " " + token.motionEaseInOut,
    willChange: 'transform, width'
  }), _extends4)));
};
// ============================== Export ==============================
const useStyle$4 = genComponentStyleHook('Segmented', function (token) {
  var lineWidthBold = token.lineWidthBold,
    lineWidth = token.lineWidth,
    colorTextLabel = token.colorTextLabel,
    colorText = token.colorText,
    colorFillSecondary = token.colorFillSecondary,
    colorBgLayout = token.colorBgLayout,
    colorBgElevated = token.colorBgElevated;
  var segmentedToken = merge$2(token, {
    segmentedPaddingHorizontal: token.controlPaddingHorizontal - lineWidth,
    segmentedPaddingHorizontalSM: token.controlPaddingHorizontalSM - lineWidth,
    segmentedContainerPadding: lineWidthBold,
    labelColor: colorTextLabel,
    labelColorHover: colorText,
    bgColor: colorBgLayout,
    bgColorHover: colorFillSecondary,
    bgColorSelected: colorBgElevated
  });
  return [genSegmentedStyle(segmentedToken)];
});

var __rest$a = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function isSegmentedLabeledOptionWithIcon(option) {
  return _typeof$1(option) === 'object' && !!(option === null || option === void 0 ? void 0 : option.icon);
}
var Segmented = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _classNames;
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    block = props.block,
    _props$options = props.options,
    options = _props$options === void 0 ? [] : _props$options,
    _props$size = props.size,
    customSize = _props$size === void 0 ? 'middle' : _props$size,
    restProps = __rest$a(props, ["prefixCls", "className", "block", "options", "size"]);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var prefixCls = getPrefixCls('segmented', customizePrefixCls);
  // Style
  var _useStyle = useStyle$4(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  // ===================== Size =====================
  var size = react.exports.useContext(SizeContext);
  var mergedSize = customSize || size;
  // syntactic sugar to support `icon` for Segmented Item
  var extendedOptions = react.exports.useMemo(function () {
    return options.map(function (option) {
      if (isSegmentedLabeledOptionWithIcon(option)) {
        var icon = option.icon,
          label = option.label,
          restOption = __rest$a(option, ["icon", "label"]);
        return _extends$2(_extends$2({}, restOption), {
          label:
          /*#__PURE__*/
          /*#__PURE__*/
          jsxs(Fragment, {
            children: [/*#__PURE__*/jsx$1("span", {
              className: prefixCls + "-item-icon",
              children: icon
            }), label &&
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1("span", {
              children: label
            })]
          })
        });
      }
      return option;
    });
  }, [options, prefixCls]);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(Segmented$2, {
    ...restProps,
    className: classNames$1(className, (_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-block", block), _defineProperty$1(_classNames, prefixCls + "-sm", mergedSize === 'small'), _defineProperty$1(_classNames, prefixCls + "-lg", mergedSize === 'large'), _classNames), hashId),
    options: extendedOptions,
    ref: ref,
    prefixCls: prefixCls,
    direction: direction
  }));
});
const Segmented$1 = Segmented;

var _excluded$g = ["prefixCls", "className", "checked", "defaultChecked", "disabled", "loadingIcon", "checkedChildren", "unCheckedChildren", "onClick", "onChange", "onKeyDown"];
var Switch$2 = /*#__PURE__*/react.exports.forwardRef(function (_ref, ref) {
  var _classNames;
  var _ref$prefixCls = _ref.prefixCls,
    prefixCls = _ref$prefixCls === void 0 ? 'rc-switch' : _ref$prefixCls,
    className = _ref.className,
    checked = _ref.checked,
    defaultChecked = _ref.defaultChecked,
    disabled = _ref.disabled,
    loadingIcon = _ref.loadingIcon,
    checkedChildren = _ref.checkedChildren,
    unCheckedChildren = _ref.unCheckedChildren,
    onClick = _ref.onClick,
    onChange = _ref.onChange,
    onKeyDown = _ref.onKeyDown,
    restProps = _objectWithoutProperties(_ref, _excluded$g);
  var _useMergedState = useMergedState$1(false, {
      value: checked,
      defaultValue: defaultChecked
    }),
    _useMergedState2 = _slicedToArray(_useMergedState, 2),
    innerChecked = _useMergedState2[0],
    setInnerChecked = _useMergedState2[1];
  function triggerChange(newChecked, event) {
    var mergedChecked = innerChecked;
    if (!disabled) {
      mergedChecked = newChecked;
      setInnerChecked(mergedChecked);
      onChange === null || onChange === void 0 ? void 0 : onChange(mergedChecked, event);
    }
    return mergedChecked;
  }
  function onInternalKeyDown(e) {
    if (e.which === KeyCode$1.LEFT) {
      triggerChange(false, e);
    } else if (e.which === KeyCode$1.RIGHT) {
      triggerChange(true, e);
    }
    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(e);
  }
  function onInternalClick(e) {
    var ret = triggerChange(!innerChecked, e); // [Legacy] trigger onClick with value

    onClick === null || onClick === void 0 ? void 0 : onClick(ret, e);
  }
  var switchClassName = classNames$1(prefixCls, className, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-checked"), innerChecked), _defineProperty$1(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("button", {
      ...restProps,
      type: "button",
      role: "switch",
      "aria-checked": innerChecked,
      disabled: disabled,
      className: switchClassName,
      ref: ref,
      onKeyDown: onInternalKeyDown,
      onClick: onInternalClick,
      children: [loadingIcon, /*#__PURE__*/jsxs("span", {
        className: "".concat(prefixCls, "-inner"),
        children: [/*#__PURE__*/jsx$1("span", {
          className: "".concat(prefixCls, "-inner-checked"),
          children: checkedChildren
        }), /*#__PURE__*/jsx$1("span", {
          className: "".concat(prefixCls, "-inner-unchecked"),
          children: unCheckedChildren
        })]
      })]
    })
  );
});
Switch$2.displayName = 'Switch';

var genSwitchSmallStyle = function genSwitchSmallStyle(token) {
  var _ref, _ref2, _ref3, _ref6, _ref7;
  var componentCls = token.componentCls;
  var switchInnerCls = componentCls + "-inner";
  return _defineProperty$1({}, componentCls, _defineProperty$1({}, "&" + componentCls + "-small", (_ref7 = {
    minWidth: token.switchMinWidthSM,
    height: token.switchHeightSM,
    lineHeight: token.switchHeightSM + "px"
  }, _defineProperty$1(_ref7, componentCls + "-inner", (_ref = {}, _defineProperty$1(_ref, switchInnerCls + "-checked", {
    marginInlineStart: "calc(" + token.switchInnerMarginMinSM + "px - 100% + " + (token.switchPinSizeSM + token.switchPadding * 2) + "px)",
    marginInlineEnd: "calc(" + token.switchInnerMarginMaxSM + "px + 100% - " + (token.switchPinSizeSM + token.switchPadding * 2) + "px)"
  }), _defineProperty$1(_ref, switchInnerCls + "-unchecked", {
    marginTop: -token.switchHeightSM,
    marginInlineStart: token.switchInnerMarginMaxSM,
    marginInlineEnd: token.switchInnerMarginMinSM
  }), _ref)), _defineProperty$1(_ref7, componentCls + "-handle", {
    width: token.switchPinSizeSM,
    height: token.switchPinSizeSM
  }), _defineProperty$1(_ref7, componentCls + "-loading-icon", {
    top: (token.switchPinSizeSM - token.switchLoadingIconSize) / 2,
    fontSize: token.switchLoadingIconSize
  }), _defineProperty$1(_ref7, "&" + componentCls + "-checked", (_ref3 = {}, _defineProperty$1(_ref3, componentCls + "-inner", (_ref2 = {}, _defineProperty$1(_ref2, switchInnerCls + "-checked", {
    marginInlineStart: token.switchInnerMarginMinSM,
    marginInlineEnd: token.switchInnerMarginMaxSM
  }), _defineProperty$1(_ref2, switchInnerCls + "-unchecked", {
    marginInlineStart: "calc(" + token.switchInnerMarginMaxSM + "px + 100% - " + (token.switchPinSizeSM + token.switchPadding * 2) + "px)",
    marginInlineEnd: "calc(" + token.switchInnerMarginMinSM + "px - 100% + " + (token.switchPinSizeSM + token.switchPadding * 2) + "px)"
  }), _ref2)), _defineProperty$1(_ref3, componentCls + "-handle", {
    insetInlineStart: "calc(100% - " + (token.switchPinSizeSM + token.switchPadding) + "px)"
  }), _ref3)), _defineProperty$1(_ref7, "&:not(" + componentCls + "-disabled):active", (_ref6 = {}, _defineProperty$1(_ref6, "&:not(" + componentCls + "-checked) " + switchInnerCls, _defineProperty$1({}, switchInnerCls + "-unchecked", {
    marginInlineStart: token.switchInnerMarginMaxSM + token.marginXXS / 2,
    marginInlineEnd: token.switchInnerMarginMinSM - token.marginXXS / 2
  })), _defineProperty$1(_ref6, "&" + componentCls + "-checked " + switchInnerCls, _defineProperty$1({}, switchInnerCls + "-checked", {
    marginInlineStart: token.switchInnerMarginMinSM - token.marginXXS / 2,
    marginInlineEnd: token.switchInnerMarginMaxSM + token.marginXXS / 2
  })), _ref6)), _ref7)));
};
var genSwitchLoadingStyle = function genSwitchLoadingStyle(token) {
  var _componentCls2;
  var componentCls = token.componentCls;
  return _defineProperty$1({}, componentCls, (_componentCls2 = {}, _defineProperty$1(_componentCls2, componentCls + "-loading-icon" + token.iconCls, {
    position: 'relative',
    top: (token.switchPinSize - token.fontSize) / 2,
    color: token.switchLoadingIconColor,
    verticalAlign: 'top'
  }), _defineProperty$1(_componentCls2, "&" + componentCls + "-checked " + componentCls + "-loading-icon", {
    color: token.switchColor
  }), _componentCls2));
};
var genSwitchHandleStyle = function genSwitchHandleStyle(token) {
  var _ref10, _componentCls3;
  var componentCls = token.componentCls;
  var switchHandleCls = componentCls + "-handle";
  return _defineProperty$1({}, componentCls, (_componentCls3 = {}, _defineProperty$1(_componentCls3, switchHandleCls, {
    position: 'absolute',
    top: token.switchPadding,
    insetInlineStart: token.switchPadding,
    width: token.switchPinSize,
    height: token.switchPinSize,
    transition: "all " + token.switchDuration + " ease-in-out",
    '&::before': {
      position: 'absolute',
      top: 0,
      insetInlineEnd: 0,
      bottom: 0,
      insetInlineStart: 0,
      backgroundColor: token.colorWhite,
      borderRadius: token.switchPinSize / 2,
      boxShadow: token.switchHandleShadow,
      transition: "all " + token.switchDuration + " ease-in-out",
      content: '""'
    }
  }), _defineProperty$1(_componentCls3, "&" + componentCls + "-checked " + switchHandleCls, {
    insetInlineStart: "calc(100% - " + (token.switchPinSize + token.switchPadding) + "px)"
  }), _defineProperty$1(_componentCls3, "&:not(" + componentCls + "-disabled):active", (_ref10 = {}, _defineProperty$1(_ref10, switchHandleCls + "::before", {
    insetInlineEnd: token.switchHandleActiveInset,
    insetInlineStart: 0
  }), _defineProperty$1(_ref10, "&" + componentCls + "-checked " + switchHandleCls + "::before", {
    insetInlineEnd: 0,
    insetInlineStart: token.switchHandleActiveInset
  }), _ref10)), _componentCls3));
};
var genSwitchInnerStyle = function genSwitchInnerStyle(token) {
  var _switchInnerCls, _ref12, _ref15, _componentCls4;
  var componentCls = token.componentCls;
  var switchInnerCls = componentCls + "-inner";
  return _defineProperty$1({}, componentCls, (_componentCls4 = {}, _defineProperty$1(_componentCls4, switchInnerCls, (_switchInnerCls = {
    display: 'block',
    overflow: 'hidden',
    borderRadius: 100,
    height: '100%'
  }, _defineProperty$1(_switchInnerCls, switchInnerCls + "-checked, " + switchInnerCls + "-unchecked", {
    display: 'block',
    color: token.colorTextLightSolid,
    fontSize: token.fontSizeSM,
    transition: "margin-inline-start " + token.switchDuration + " ease-in-out, margin-inline-end " + token.switchDuration + " ease-in-out",
    pointerEvents: 'none'
  }), _defineProperty$1(_switchInnerCls, switchInnerCls + "-checked", {
    marginInlineStart: "calc(" + token.switchInnerMarginMin + "px - 100% + " + (token.switchPinSize + token.switchPadding * 2) + "px)",
    marginInlineEnd: "calc(" + token.switchInnerMarginMax + "px + 100% - " + (token.switchPinSize + token.switchPadding * 2) + "px)"
  }), _defineProperty$1(_switchInnerCls, switchInnerCls + "-unchecked", {
    marginTop: -token.switchHeight,
    marginInlineStart: token.switchInnerMarginMax,
    marginInlineEnd: token.switchInnerMarginMin
  }), _switchInnerCls)), _defineProperty$1(_componentCls4, "&" + componentCls + "-checked " + switchInnerCls, (_ref12 = {}, _defineProperty$1(_ref12, switchInnerCls + "-checked", {
    marginInlineStart: token.switchInnerMarginMin,
    marginInlineEnd: token.switchInnerMarginMax
  }), _defineProperty$1(_ref12, switchInnerCls + "-unchecked", {
    marginInlineStart: "calc(" + token.switchInnerMarginMax + "px + 100% - " + (token.switchPinSize + token.switchPadding * 2) + "px)",
    marginInlineEnd: "calc(" + token.switchInnerMarginMin + "px - 100% + " + (token.switchPinSize + token.switchPadding * 2) + "px)"
  }), _ref12)), _defineProperty$1(_componentCls4, "&:not(" + componentCls + "-disabled):active", (_ref15 = {}, _defineProperty$1(_ref15, "&:not(" + componentCls + "-checked) " + switchInnerCls, _defineProperty$1({}, switchInnerCls + "-unchecked", {
    marginInlineStart: token.switchInnerMarginMax + token.switchPadding * 2,
    marginInlineEnd: token.switchInnerMarginMin - token.switchPadding * 2
  })), _defineProperty$1(_ref15, "&" + componentCls + "-checked " + switchInnerCls, _defineProperty$1({}, switchInnerCls + "-checked", {
    marginInlineStart: token.switchInnerMarginMin - token.switchPadding * 2,
    marginInlineEnd: token.switchInnerMarginMax + token.switchPadding * 2
  })), _ref15)), _componentCls4));
};
var genSwitchStyle = function genSwitchStyle(token) {
  var _extends3;
  var componentCls = token.componentCls;
  return _defineProperty$1({}, componentCls, _extends$2(_extends$2(_extends$2(_extends$2({}, resetComponent(token)), _defineProperty$1({
    position: 'relative',
    display: 'inline-block',
    boxSizing: 'border-box',
    minWidth: token.switchMinWidth,
    height: token.switchHeight,
    lineHeight: token.switchHeight + "px",
    verticalAlign: 'middle',
    background: token.colorTextQuaternary,
    border: '0',
    borderRadius: 100,
    cursor: 'pointer',
    transition: "all " + token.motionDurationMid,
    userSelect: 'none'
  }, "&:hover:not(" + componentCls + "-disabled)", {
    background: token.colorTextTertiary
  })), genFocusStyle(token)), (_extends3 = {}, _defineProperty$1(_extends3, "&" + componentCls + "-checked", _defineProperty$1({
    background: token.switchColor
  }, "&:hover:not(" + componentCls + "-disabled)", {
    background: token.colorPrimaryHover
  })), _defineProperty$1(_extends3, "&" + componentCls + "-loading, &" + componentCls + "-disabled", {
    cursor: 'not-allowed',
    opacity: token.switchDisabledOpacity,
    '*': {
      boxShadow: 'none',
      cursor: 'not-allowed'
    }
  }), _defineProperty$1(_extends3, "&" + componentCls + "-rtl", {
    direction: 'rtl'
  }), _extends3)));
};
// ============================== Export ==============================
const useStyle$3 = genComponentStyleHook('Switch', function (token) {
  var switchHeight = token.fontSize * token.lineHeight;
  var switchHeightSM = token.controlHeight / 2;
  var switchPadding = 2; // This is magic
  var switchPinSize = switchHeight - switchPadding * 2;
  var switchPinSizeSM = switchHeightSM - switchPadding * 2;
  var switchToken = merge$2(token, {
    switchMinWidth: switchPinSize * 2 + switchPadding * 4,
    switchHeight: switchHeight,
    switchDuration: token.motionDurationMid,
    switchColor: token.colorPrimary,
    switchDisabledOpacity: token.opacityLoading,
    switchInnerMarginMin: switchPinSize / 2,
    switchInnerMarginMax: switchPinSize + switchPadding + switchPadding * 2,
    switchPadding: switchPadding,
    switchPinSize: switchPinSize,
    switchBg: token.colorBgContainer,
    switchMinWidthSM: switchPinSizeSM * 2 + switchPadding * 2,
    switchHeightSM: switchHeightSM,
    switchInnerMarginMinSM: switchPinSizeSM / 2,
    switchInnerMarginMaxSM: switchPinSizeSM + switchPadding + switchPadding * 2,
    switchPinSizeSM: switchPinSizeSM,
    switchHandleShadow: "0 2px 4px 0 " + new TinyColor('#00230b').setAlpha(0.2).toRgbString(),
    switchLoadingIconSize: token.fontSizeIcon * 0.75,
    switchLoadingIconColor: "rgba(0, 0, 0, " + token.opacityLoading + ")",
    switchHandleActiveInset: '-30%'
  });
  return [genSwitchStyle(switchToken),
  // inner style
  genSwitchInnerStyle(switchToken),
  // handle style
  genSwitchHandleStyle(switchToken),
  // loading style
  genSwitchLoadingStyle(switchToken),
  // small style
  genSwitchSmallStyle(switchToken)];
});

var __rest$9 = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var Switch = /*#__PURE__*/react.exports.forwardRef(function (_a, ref) {
  var _classNames;
  var customizePrefixCls = _a.prefixCls,
    customizeSize = _a.size,
    customDisabled = _a.disabled,
    loading = _a.loading,
    _a$className = _a.className,
    className = _a$className === void 0 ? '' : _a$className,
    props = __rest$9(_a, ["prefixCls", "size", "disabled", "loading", "className"]);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var size = react.exports.useContext(SizeContext);
  // ===================== Disabled =====================
  var disabled = react.exports.useContext(DisabledContext);
  var mergedDisabled = (customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled) || loading;
  var prefixCls = getPrefixCls('switch', customizePrefixCls);
  var loadingIcon =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    className: prefixCls + "-handle",
    children: loading &&
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(LoadingOutlined$1, {
      className: prefixCls + "-loading-icon"
    })
  });
  // Style
  var _useStyle = useStyle$3(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var classes = classNames$1((_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-small", (customizeSize || size) === 'small'), _defineProperty$1(_classNames, prefixCls + "-loading", loading), _defineProperty$1(_classNames, prefixCls + "-rtl", direction === 'rtl'), _classNames), className, hashId);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(Wave$1, {
    insertExtraNode: true,
    children: /*#__PURE__*/jsx$1(Switch$2, {
      ...props,
      prefixCls: prefixCls,
      className: classes,
      disabled: mergedDisabled,
      ref: ref,
      loadingIcon: loadingIcon
    })
  }));
});
Switch.__ANT_SWITCH = true;
const Switch$1 = Switch;

var isStyleNameSupport = function isStyleNameSupport(styleName) {
  if (canUseDom() && window.document.documentElement) {
    var styleNameList = Array.isArray(styleName) ? styleName : [styleName];
    var documentElement = window.document.documentElement;
    return styleNameList.some(function (name) {
      return name in documentElement.style;
    });
  }
  return false;
};
var isStyleValueSupport = function isStyleValueSupport(styleName, value) {
  if (!isStyleNameSupport(styleName)) {
    return false;
  }
  var ele = document.createElement('div');
  var origin = ele.style[styleName];
  ele.style[styleName] = value;
  return ele.style[styleName] !== origin;
};
function isStyleSupport(styleName, styleValue) {
  if (!Array.isArray(styleName) && styleValue !== undefined) {
    return isStyleValueSupport(styleName, styleValue);
  }
  return isStyleNameSupport(styleName);
}

function createContext(defaultContext) {
  var Context = /*#__PURE__*/react.exports.createContext(defaultContext);
  var Provider = function Provider(_ref) {
    var value = _ref.value,
      children = _ref.children;
    var valueRef = react.exports.useRef(value);
    valueRef.current = value;
    var _React$useState = react.exports.useState(function () {
        return {
          getValue: function getValue() {
            return valueRef.current;
          },
          listeners: new Set()
        };
      }),
      _React$useState2 = _slicedToArray(_React$useState, 1),
      context = _React$useState2[0];
    useLayoutEffect$3(function () {
      reactDom.exports.unstable_batchedUpdates(function () {
        context.listeners.forEach(function (listener) {
          listener(value);
        });
      });
    }, [value]);
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(Context.Provider, {
        value: context,
        children: children
      })
    );
  };
  return {
    Context: Context,
    Provider: Provider
  };
}
function useContextSelector(holder, selector) {
  var eventSelector = useEvent$1(typeof selector === 'function' ? selector : function (ctx) {
    if (!Array.isArray(selector)) {
      return ctx[selector];
    }
    var obj = {};
    selector.forEach(function (key) {
      obj[key] = ctx[key];
    });
    return obj;
  });
  var context = react.exports.useContext(holder === null || holder === void 0 ? void 0 : holder.Context);
  var _ref2 = context || {},
    listeners = _ref2.listeners,
    getValue = _ref2.getValue;
  var valueRef = react.exports.useRef();
  valueRef.current = eventSelector(context ? getValue() : null);
  var _React$useState3 = react.exports.useState({}),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    forceUpdate = _React$useState4[1];
  useLayoutEffect$3(function () {
    if (!context) {
      return;
    }
    function trigger(nextValue) {
      var nextSelectorValue = eventSelector(nextValue);
      if (!shallowequal(valueRef.current, nextSelectorValue)) {
        forceUpdate({});
      }
    }
    listeners.add(trigger);
    return function () {
      listeners.delete(trigger);
    };
  }, [context]);
  return valueRef.current;
}

// const BodyContext = React.createContext<BodyContextProps>(null);
var BodyContext = createContext();

var HoverContext = createContext();

var PerfContext = /*#__PURE__*/react.exports.createContext({
  renderWithProps: false
});

var ResizeContext = createContext();

var TableContext = createContext();

// recursion (flat tree structure)
function flatRecord(record, indent, childrenColumnName, expandedKeys, getRowKey, index) {
  var arr = [];
  arr.push({
    record: record,
    indent: indent,
    index: index
  });
  var key = getRowKey(record);
  var expanded = expandedKeys === null || expandedKeys === void 0 ? void 0 : expandedKeys.has(key);

  if (record && Array.isArray(record[childrenColumnName]) && expanded) {
    // expanded state, flat record
    for (var i = 0; i < record[childrenColumnName].length; i += 1) {
      var tempArr = flatRecord(record[childrenColumnName][i], indent + 1, childrenColumnName, expandedKeys, getRowKey, i);
      arr.push.apply(arr, _toConsumableArray(tempArr));
    }
  }

  return arr;
}
/**
 * flat tree data on expanded state
 *
 * @export
 * @template T
 * @param {*} data : table data
 * @param {string} childrenColumnName : 
 * @param {Set<Key>} expandedKeys : keys
 * @param {GetRowKey<T>} getRowKey  : rowKey
 * @returns flattened data
 */


function useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey) {
  var arr = react.exports.useMemo(function () {
    if (expandedKeys !== null && expandedKeys !== void 0 && expandedKeys.size) {
      var temp = []; // collect flattened record

      for (var i = 0; i < (data === null || data === void 0 ? void 0 : data.length); i += 1) {
        var record = data[i];
        temp.push.apply(temp, _toConsumableArray(flatRecord(record, 0, childrenColumnName, expandedKeys, getRowKey, i)));
      }

      return temp;
    }

    return data === null || data === void 0 ? void 0 : data.map(function (item, index) {
      return {
        record: item,
        indent: 0,
        index: index
      };
    });
  }, [data, childrenColumnName, expandedKeys, getRowKey]);
  return arr;
}

var INTERNAL_KEY_PREFIX = 'RC_TABLE_KEY';

function toArray$1(arr) {
  if (arr === undefined || arr === null) {
    return [];
  }

  return Array.isArray(arr) ? arr : [arr];
}

function getPathValue(record, path) {
  // Skip if path is empty
  if (!path && typeof path !== 'number') {
    return record;
  }

  var pathList = toArray$1(path);
  var current = record;

  for (var i = 0; i < pathList.length; i += 1) {
    if (!current) {
      return null;
    }

    var prop = pathList[i];
    current = current[prop];
  }

  return current;
}
function getColumnsKey(columns) {
  var columnKeys = [];
  var keys = {};
  columns.forEach(function (column) {
    var _ref = column || {},
        key = _ref.key,
        dataIndex = _ref.dataIndex;

    var mergedKey = key || toArray$1(dataIndex).join('-') || INTERNAL_KEY_PREFIX;

    while (keys[mergedKey]) {
      mergedKey = "".concat(mergedKey, "_next");
    }

    keys[mergedKey] = true;
    columnKeys.push(mergedKey);
  });
  return columnKeys;
}
function validateValue(val) {
  return val !== null && val !== undefined;
}

var StickyContext = /*#__PURE__*/react.exports.createContext(false);

var _excluded$f = ["colSpan", "rowSpan", "style", "className"];
function inHoverRange(cellStartRow, cellRowSpan, startRow, endRow) {
  var cellEndRow = cellStartRow + cellRowSpan - 1;
  return cellStartRow <= endRow && cellEndRow >= startRow;
}
function isRenderCell(data) {
  return data && _typeof$1(data) === 'object' && !Array.isArray(data) && ! /*#__PURE__*/react.exports.isValidElement(data);
}
function isRefComponent(component) {
  // String tag component also support ref
  if (typeof component === 'string') {
    return true;
  }
  return supportRef$1(component);
}
var getTitleFromCellRenderChildren = function getTitleFromCellRenderChildren(_ref) {
  var ellipsis = _ref.ellipsis,
    rowType = _ref.rowType,
    children = _ref.children;
  var title;
  var ellipsisConfig = ellipsis === true ? {
    showTitle: true
  } : ellipsis;
  if (ellipsisConfig && (ellipsisConfig.showTitle || rowType === 'header')) {
    if (typeof children === 'string' || typeof children === 'number') {
      title = children.toString();
    } else if ( /*#__PURE__*/react.exports.isValidElement(children) && typeof children.props.children === 'string') {
      title = children.props.children;
    }
  }
  return title;
};
function Cell(_ref2, ref) {
  var _ref4, _ref5, _classNames;
  var prefixCls = _ref2.prefixCls,
    className = _ref2.className,
    record = _ref2.record,
    index = _ref2.index,
    renderIndex = _ref2.renderIndex,
    dataIndex = _ref2.dataIndex,
    render = _ref2.render,
    children = _ref2.children,
    _ref2$component = _ref2.component,
    Component = _ref2$component === void 0 ? 'td' : _ref2$component,
    colSpan = _ref2.colSpan,
    rowSpan = _ref2.rowSpan,
    scope = _ref2.scope,
    fixLeft = _ref2.fixLeft,
    fixRight = _ref2.fixRight,
    firstFixLeft = _ref2.firstFixLeft,
    lastFixLeft = _ref2.lastFixLeft,
    firstFixRight = _ref2.firstFixRight,
    lastFixRight = _ref2.lastFixRight,
    appendNode = _ref2.appendNode,
    _ref2$additionalProps = _ref2.additionalProps,
    additionalProps = _ref2$additionalProps === void 0 ? {} : _ref2$additionalProps,
    ellipsis = _ref2.ellipsis,
    align = _ref2.align,
    rowType = _ref2.rowType,
    isSticky = _ref2.isSticky,
    hovering = _ref2.hovering,
    onHover = _ref2.onHover;
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var perfRecord = react.exports.useContext(PerfContext);
  var supportSticky = react.exports.useContext(StickyContext);
  var allColumnsFixedLeft = useContextSelector(BodyContext, 'allColumnsFixedLeft'); // ==================== Child Node ====================

  var _React$useMemo = react.exports.useMemo(function () {
      if (validateValue(children)) {
        return [children];
      }
      var value = getPathValue(record, dataIndex); // Customize render node

      var returnChildNode = value;
      var returnCellProps = undefined;
      if (render) {
        var renderData = render(value, record, renderIndex);
        if (isRenderCell(renderData)) {
          returnChildNode = renderData.children;
          returnCellProps = renderData.props;
          perfRecord.renderWithProps = true;
        } else {
          returnChildNode = renderData;
        }
      }
      return [returnChildNode, returnCellProps];
    }, [/* eslint-disable react-hooks/exhaustive-deps */
    // Always re-render if `renderWithProps`
    perfRecord.renderWithProps ? Math.random() : 0, /* eslint-enable */
    children, dataIndex, perfRecord, record, render, renderIndex]),
    _React$useMemo2 = _slicedToArray(_React$useMemo, 2),
    childNode = _React$useMemo2[0],
    legacyCellProps = _React$useMemo2[1];
  var mergedChildNode = childNode; // Not crash if final `childNode` is not validate ReactNode

  if (_typeof$1(mergedChildNode) === 'object' && !Array.isArray(mergedChildNode) && ! /*#__PURE__*/react.exports.isValidElement(mergedChildNode)) {
    mergedChildNode = null;
  }
  if (ellipsis && (lastFixLeft || firstFixRight)) {
    mergedChildNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      className: "".concat(cellPrefixCls, "-content"),
      children: mergedChildNode
    });
  }
  var _ref3 = legacyCellProps || {},
    cellColSpan = _ref3.colSpan,
    cellRowSpan = _ref3.rowSpan,
    cellStyle = _ref3.style,
    cellClassName = _ref3.className,
    restCellProps = _objectWithoutProperties(_ref3, _excluded$f);
  var mergedColSpan = (_ref4 = cellColSpan !== undefined ? cellColSpan : colSpan) !== null && _ref4 !== void 0 ? _ref4 : 1;
  var mergedRowSpan = (_ref5 = cellRowSpan !== undefined ? cellRowSpan : rowSpan) !== null && _ref5 !== void 0 ? _ref5 : 1;
  if (mergedColSpan === 0 || mergedRowSpan === 0) {
    return null;
  } // ====================== Fixed =======================

  var fixedStyle = {};
  var isFixLeft = typeof fixLeft === 'number' && supportSticky;
  var isFixRight = typeof fixRight === 'number' && supportSticky;
  if (isFixLeft) {
    fixedStyle.position = 'sticky';
    fixedStyle.left = fixLeft;
  }
  if (isFixRight) {
    fixedStyle.position = 'sticky';
    fixedStyle.right = fixRight;
  } // ====================== Align =======================

  var alignStyle = {};
  if (align) {
    alignStyle.textAlign = align;
  } // ====================== Hover =======================

  var onMouseEnter = function onMouseEnter(event) {
    var _additionalProps$onMo;
    if (record) {
      onHover(index, index + mergedRowSpan - 1);
    }
    additionalProps === null || additionalProps === void 0 ? void 0 : (_additionalProps$onMo = additionalProps.onMouseEnter) === null || _additionalProps$onMo === void 0 ? void 0 : _additionalProps$onMo.call(additionalProps, event);
  };
  var onMouseLeave = function onMouseLeave(event) {
    var _additionalProps$onMo2;
    if (record) {
      onHover(-1, -1);
    }
    additionalProps === null || additionalProps === void 0 ? void 0 : (_additionalProps$onMo2 = additionalProps.onMouseLeave) === null || _additionalProps$onMo2 === void 0 ? void 0 : _additionalProps$onMo2.call(additionalProps, event);
  }; // ====================== Render ======================

  var title = getTitleFromCellRenderChildren({
    rowType: rowType,
    ellipsis: ellipsis,
    children: childNode
  });
  var componentProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
    title: title
  }, restCellProps), additionalProps), {}, {
    colSpan: mergedColSpan !== 1 ? mergedColSpan : null,
    rowSpan: mergedRowSpan !== 1 ? mergedRowSpan : null,
    scope: scope,
    className: classNames$1(cellPrefixCls, className, (_classNames = {}, _defineProperty$1(_classNames, "".concat(cellPrefixCls, "-fix-left"), isFixLeft && supportSticky), _defineProperty$1(_classNames, "".concat(cellPrefixCls, "-fix-left-first"), firstFixLeft && supportSticky), _defineProperty$1(_classNames, "".concat(cellPrefixCls, "-fix-left-last"), lastFixLeft && supportSticky), _defineProperty$1(_classNames, "".concat(cellPrefixCls, "-fix-left-all"), lastFixLeft && allColumnsFixedLeft && supportSticky), _defineProperty$1(_classNames, "".concat(cellPrefixCls, "-fix-right"), isFixRight && supportSticky), _defineProperty$1(_classNames, "".concat(cellPrefixCls, "-fix-right-first"), firstFixRight && supportSticky), _defineProperty$1(_classNames, "".concat(cellPrefixCls, "-fix-right-last"), lastFixRight && supportSticky), _defineProperty$1(_classNames, "".concat(cellPrefixCls, "-ellipsis"), ellipsis), _defineProperty$1(_classNames, "".concat(cellPrefixCls, "-with-append"), appendNode), _defineProperty$1(_classNames, "".concat(cellPrefixCls, "-fix-sticky"), (isFixLeft || isFixRight) && isSticky && supportSticky), _defineProperty$1(_classNames, "".concat(cellPrefixCls, "-row-hover"), !legacyCellProps && hovering), _classNames), additionalProps.className, cellClassName),
    style: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, additionalProps.style), alignStyle), fixedStyle), cellStyle),
    onMouseEnter: onMouseEnter,
    onMouseLeave: onMouseLeave,
    ref: isRefComponent(Component) ? ref : null
  });
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs(Component, {
      ...componentProps,
      children: [appendNode, mergedChildNode]
    })
  );
}
var RefCell = /*#__PURE__*/react.exports.forwardRef(Cell);
RefCell.displayName = 'Cell';
var comparePropList = ['expanded', 'className', 'hovering'];
var MemoCell = /*#__PURE__*/react.exports.memo(RefCell, function (prev, next) {
  if (next.shouldCellUpdate) {
    return (
      // Additional handle of expanded logic
      comparePropList.every(function (propName) {
        return prev[propName] === next[propName];
      }) &&
      // User control update logic
      !next.shouldCellUpdate(next.record, prev.record)
    );
  }
  return shallowequal(prev, next);
});
/** Inject hover data here, we still wish MemoCell keep simple `shouldCellUpdate` logic */

var WrappedCell = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var index = props.index,
    _props$additionalProp = props.additionalProps,
    additionalProps = _props$additionalProp === void 0 ? {} : _props$additionalProp,
    colSpan = props.colSpan,
    rowSpan = props.rowSpan;
  var cellColSpan = additionalProps.colSpan,
    cellRowSpan = additionalProps.rowSpan;
  var mergedColSpan = colSpan !== null && colSpan !== void 0 ? colSpan : cellColSpan;
  var mergedRowSpan = rowSpan !== null && rowSpan !== void 0 ? rowSpan : cellRowSpan;
  var _useContextSelector = useContextSelector(HoverContext, function (cxt) {
      var isHovering = inHoverRange(index, mergedRowSpan || 1, cxt === null || cxt === void 0 ? void 0 : cxt.startRow, cxt === null || cxt === void 0 ? void 0 : cxt.endRow);
      return {
        onHover: cxt === null || cxt === void 0 ? void 0 : cxt.onHover,
        hovering: isHovering
      };
    }),
    onHover = _useContextSelector.onHover,
    hovering = _useContextSelector.hovering;
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(MemoCell, {
      ...props,
      colSpan: mergedColSpan,
      rowSpan: mergedRowSpan,
      hovering: hovering,
      ref: ref,
      onHover: onHover
    })
  );
});
WrappedCell.displayName = 'WrappedCell';

var ExpandedRowContext = createContext(null);

function ExpandedRow(_ref) {
  var prefixCls = _ref.prefixCls,
    children = _ref.children,
    Component = _ref.component,
    cellComponent = _ref.cellComponent,
    className = _ref.className,
    expanded = _ref.expanded,
    colSpan = _ref.colSpan,
    isEmpty = _ref.isEmpty;
  var scrollbarSize = useContextSelector(TableContext, 'scrollbarSize');
  var _useContextSelector = useContextSelector(ExpandedRowContext, ['fixHeader', 'fixColumn', 'componentWidth', 'horizonScroll']),
    fixHeader = _useContextSelector.fixHeader,
    fixColumn = _useContextSelector.fixColumn,
    componentWidth = _useContextSelector.componentWidth,
    horizonScroll = _useContextSelector.horizonScroll; // Cache render node

  return react.exports.useMemo(function () {
    var contentNode = children;
    if (isEmpty ? horizonScroll : fixColumn) {
      contentNode =
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("div", {
        style: {
          width: componentWidth - (fixHeader ? scrollbarSize : 0),
          position: 'sticky',
          left: 0,
          overflow: 'hidden'
        },
        className: "".concat(prefixCls, "-expanded-row-fixed"),
        children: componentWidth !== 0 && contentNode
      });
    }
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(Component, {
        className: className,
        style: {
          display: expanded ? null : 'none'
        },
        children: /*#__PURE__*/jsx$1(WrappedCell, {
          component: cellComponent,
          prefixCls: prefixCls,
          colSpan: colSpan,
          children: contentNode
        })
      })
    );
  }, [children, Component, className, expanded, colSpan, isEmpty, scrollbarSize, componentWidth, fixColumn, fixHeader, horizonScroll]);
}

function BodyRow(props) {
  var className = props.className,
    style = props.style,
    record = props.record,
    index = props.index,
    renderIndex = props.renderIndex,
    rowKey = props.rowKey,
    rowExpandable = props.rowExpandable,
    expandedKeys = props.expandedKeys,
    onRow = props.onRow,
    _props$indent = props.indent,
    indent = _props$indent === void 0 ? 0 : _props$indent,
    RowComponent = props.rowComponent,
    cellComponent = props.cellComponent,
    scopeCellComponent = props.scopeCellComponent,
    childrenColumnName = props.childrenColumnName;
  var _useContextSelector = useContextSelector(TableContext, ['prefixCls', 'fixedInfoList']),
    prefixCls = _useContextSelector.prefixCls,
    fixedInfoList = _useContextSelector.fixedInfoList;
  var _useContextSelector2 = useContextSelector(BodyContext, ['flattenColumns', 'expandableType', 'expandRowByClick', 'onTriggerExpand', 'rowClassName', 'expandedRowClassName', 'indentSize', 'expandIcon', 'expandedRowRender', 'expandIconColumnIndex']),
    flattenColumns = _useContextSelector2.flattenColumns,
    expandableType = _useContextSelector2.expandableType,
    expandRowByClick = _useContextSelector2.expandRowByClick,
    onTriggerExpand = _useContextSelector2.onTriggerExpand,
    rowClassName = _useContextSelector2.rowClassName,
    expandedRowClassName = _useContextSelector2.expandedRowClassName,
    indentSize = _useContextSelector2.indentSize,
    expandIcon = _useContextSelector2.expandIcon,
    expandedRowRender = _useContextSelector2.expandedRowRender,
    expandIconColumnIndex = _useContextSelector2.expandIconColumnIndex;
  var _React$useState = react.exports.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    expandRended = _React$useState2[0],
    setExpandRended = _React$useState2[1];
  var expanded = expandedKeys && expandedKeys.has(props.recordKey);
  react.exports.useEffect(function () {
    if (expanded) {
      setExpandRended(true);
    }
  }, [expanded]);
  var rowSupportExpand = expandableType === 'row' && (!rowExpandable || rowExpandable(record)); // Only when row is not expandable and `children` exist in record

  var nestExpandable = expandableType === 'nest';
  var hasNestChildren = childrenColumnName && record && record[childrenColumnName];
  var mergedExpandable = rowSupportExpand || nestExpandable; // ======================== Expandable =========================

  var onExpandRef = react.exports.useRef(onTriggerExpand);
  onExpandRef.current = onTriggerExpand;
  var onInternalTriggerExpand = function onInternalTriggerExpand() {
    onExpandRef.current.apply(onExpandRef, arguments);
  }; // =========================== onRow ===========================

  var additionalProps = onRow === null || onRow === void 0 ? void 0 : onRow(record, index);
  var onClick = function onClick(event) {
    var _additionalProps$onCl;
    if (expandRowByClick && mergedExpandable) {
      onInternalTriggerExpand(record, event);
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    additionalProps === null || additionalProps === void 0 ? void 0 : (_additionalProps$onCl = additionalProps.onClick) === null || _additionalProps$onCl === void 0 ? void 0 : _additionalProps$onCl.call.apply(_additionalProps$onCl, [additionalProps, event].concat(args));
  }; // ======================== Base tr row ========================

  var computeRowClassName;
  if (typeof rowClassName === 'string') {
    computeRowClassName = rowClassName;
  } else if (typeof rowClassName === 'function') {
    computeRowClassName = rowClassName(record, index, indent);
  }
  var columnsKey = getColumnsKey(flattenColumns);
  var baseRowNode =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(RowComponent, {
    ...additionalProps,
    "data-row-key": rowKey,
    className: classNames$1(className, "".concat(prefixCls, "-row"), "".concat(prefixCls, "-row-level-").concat(indent), computeRowClassName, additionalProps && additionalProps.className),
    style: _objectSpread2$1(_objectSpread2$1({}, style), additionalProps ? additionalProps.style : null),
    onClick: onClick,
    children: flattenColumns.map(function (column, colIndex) {
      var render = column.render,
        dataIndex = column.dataIndex,
        columnClassName = column.className;
      var key = columnsKey[colIndex];
      var fixedInfo = fixedInfoList[colIndex]; // ============= Used for nest expandable =============

      var appendCellNode;
      if (colIndex === (expandIconColumnIndex || 0) && nestExpandable) {
        appendCellNode =
        /*#__PURE__*/
        /*#__PURE__*/
        jsxs(Fragment, {
          children: [/*#__PURE__*/jsx$1("span", {
            style: {
              paddingLeft: "".concat(indentSize * indent, "px")
            },
            className: "".concat(prefixCls, "-row-indent indent-level-").concat(indent)
          }), expandIcon({
            prefixCls: prefixCls,
            expanded: expanded,
            expandable: hasNestChildren,
            record: record,
            onExpand: onInternalTriggerExpand
          })]
        });
      }
      var additionalCellProps;
      if (column.onCell) {
        additionalCellProps = column.onCell(record, index);
      }
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(WrappedCell, {
          className: columnClassName,
          ellipsis: column.ellipsis,
          align: column.align,
          scope: column.rowScope,
          component: column.rowScope ? scopeCellComponent : cellComponent,
          prefixCls: prefixCls,
          record: record,
          index: index,
          renderIndex: renderIndex,
          dataIndex: dataIndex,
          render: render,
          shouldCellUpdate: column.shouldCellUpdate,
          expanded: appendCellNode && expanded,
          ...fixedInfo,
          appendNode: appendCellNode,
          additionalProps: additionalCellProps
        }, key)
      );
    })
  }); // ======================== Expand Row =========================

  var expandRowNode;
  if (rowSupportExpand && (expandRended || expanded)) {
    var expandContent = expandedRowRender(record, index, indent + 1, expanded);
    var computedExpandedRowClassName = expandedRowClassName && expandedRowClassName(record, index, indent);
    expandRowNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(ExpandedRow, {
      expanded: expanded,
      className: classNames$1("".concat(prefixCls, "-expanded-row"), "".concat(prefixCls, "-expanded-row-level-").concat(indent + 1), computedExpandedRowClassName),
      prefixCls: prefixCls,
      component: RowComponent,
      cellComponent: cellComponent,
      colSpan: flattenColumns.length,
      isEmpty: false,
      children: expandContent
    });
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs(Fragment, {
      children: [baseRowNode, expandRowNode]
    })
  );
}
BodyRow.displayName = 'BodyRow';

function MeasureCell(_ref) {
  var columnKey = _ref.columnKey,
    onColumnResize = _ref.onColumnResize;
  var cellRef = react.exports.useRef();
  react.exports.useEffect(function () {
    if (cellRef.current) {
      onColumnResize(columnKey, cellRef.current.offsetWidth);
    }
  }, []);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(ResizeObserver$1, {
      data: columnKey,
      children: /*#__PURE__*/jsx$1("td", {
        ref: cellRef,
        style: {
          padding: 0,
          border: 0,
          height: 0
        },
        children: /*#__PURE__*/jsx$1("div", {
          style: {
            height: 0,
            overflow: 'hidden'
          },
          children: "\xA0"
        })
      })
    })
  );
}

function MeasureRow(_ref) {
  var prefixCls = _ref.prefixCls,
    columnsKey = _ref.columnsKey,
    onColumnResize = _ref.onColumnResize;
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("tr", {
      "aria-hidden": "true",
      className: "".concat(prefixCls, "-measure-row"),
      style: {
        height: 0,
        fontSize: 0
      },
      children: /*#__PURE__*/jsx$1(ResizeObserver$1.Collection, {
        onBatchResize: function onBatchResize(infoList) {
          infoList.forEach(function (_ref2) {
            var columnKey = _ref2.data,
              size = _ref2.size;
            onColumnResize(columnKey, size.offsetWidth);
          });
        },
        children: columnsKey.map(function (columnKey) {
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1(MeasureCell, {
              columnKey: columnKey,
              onColumnResize: onColumnResize
            }, columnKey)
          );
        })
      })
    })
  );
}

function Body(_ref) {
  var data = _ref.data,
    getRowKey = _ref.getRowKey,
    measureColumnWidth = _ref.measureColumnWidth,
    expandedKeys = _ref.expandedKeys,
    onRow = _ref.onRow,
    rowExpandable = _ref.rowExpandable,
    emptyNode = _ref.emptyNode,
    childrenColumnName = _ref.childrenColumnName;
  var onColumnResize = useContextSelector(ResizeContext, 'onColumnResize');
  var _useContextSelector = useContextSelector(TableContext, ['prefixCls', 'getComponent']),
    prefixCls = _useContextSelector.prefixCls,
    getComponent = _useContextSelector.getComponent;
  var flattenColumns = useContextSelector(BodyContext, 'flattenColumns');
  var flattenData = useFlattenRecords(data, childrenColumnName, expandedKeys, getRowKey); // =================== Performance ====================

  var perfRef = react.exports.useRef({
    renderWithProps: false
  }); // ====================== Hover =======================

  var _React$useState = react.exports.useState(-1),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    startRow = _React$useState2[0],
    setStartRow = _React$useState2[1];
  var _React$useState3 = react.exports.useState(-1),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    endRow = _React$useState4[0],
    setEndRow = _React$useState4[1];
  var onHover = react.exports.useCallback(function (start, end) {
    setStartRow(start);
    setEndRow(end);
  }, []); // ====================== Render ======================

  var bodyNode = react.exports.useMemo(function () {
    var WrapperComponent = getComponent(['body', 'wrapper'], 'tbody');
    var trComponent = getComponent(['body', 'row'], 'tr');
    var tdComponent = getComponent(['body', 'cell'], 'td');
    var thComponent = getComponent(['body', 'cell'], 'th');
    var rows;
    if (data.length) {
      rows = flattenData.map(function (item, idx) {
        var record = item.record,
          indent = item.indent,
          renderIndex = item.index;
        var key = getRowKey(record, idx);
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(BodyRow, {
            rowKey: key,
            record: record,
            recordKey: key,
            index: idx,
            renderIndex: renderIndex,
            rowComponent: trComponent,
            cellComponent: tdComponent,
            scopeCellComponent: thComponent,
            expandedKeys: expandedKeys,
            onRow: onRow,
            getRowKey: getRowKey,
            rowExpandable: rowExpandable,
            childrenColumnName: childrenColumnName,
            indent: indent
          }, key)
        );
      });
    } else {
      rows =
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(ExpandedRow, {
        expanded: true,
        className: "".concat(prefixCls, "-placeholder"),
        prefixCls: prefixCls,
        component: trComponent,
        cellComponent: tdComponent,
        colSpan: flattenColumns.length,
        isEmpty: true,
        children: emptyNode
      });
    }
    var columnsKey = getColumnsKey(flattenColumns);
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsxs(WrapperComponent, {
        className: "".concat(prefixCls, "-tbody"),
        children: [measureColumnWidth &&
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(MeasureRow, {
          prefixCls: prefixCls,
          columnsKey: columnsKey,
          onColumnResize: onColumnResize
        }), rows]
      })
    );
  }, [data, prefixCls, onRow, measureColumnWidth, expandedKeys, getRowKey, getComponent, emptyNode, flattenColumns, childrenColumnName, onColumnResize, rowExpandable, flattenData]);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(PerfContext.Provider, {
      value: perfRef.current,
      children: /*#__PURE__*/jsx$1(HoverContext.Provider, {
        value: {
          startRow: startRow,
          endRow: endRow,
          onHover: onHover
        },
        children: bodyNode
      })
    })
  );
}
var MemoBody = /*#__PURE__*/react.exports.memo(Body);
MemoBody.displayName = 'Body';

var _excluded$e = ["expandable"];
var INTERNAL_COL_DEFINE = 'RC_TABLE_INTERNAL_COL_DEFINE';
function getExpandableProps(props) {
  var expandable = props.expandable,
      legacyExpandableConfig = _objectWithoutProperties(props, _excluded$e);

  var config;

  if ('expandable' in props) {
    config = _objectSpread2$1(_objectSpread2$1({}, legacyExpandableConfig), expandable);
  } else {

    config = legacyExpandableConfig;
  }

  if (config.showExpandColumn === false) {
    config.expandIconColumnIndex = -1;
  }

  return config;
}

var _excluded$d = ["columnType"];
function ColGroup(_ref) {
  var colWidths = _ref.colWidths,
    columns = _ref.columns,
    columCount = _ref.columCount;
  var cols = [];
  var len = columCount || columns.length; // Only insert col with width & additional props
  // Skip if rest col do not have any useful info

  var mustInsert = false;
  for (var i = len - 1; i >= 0; i -= 1) {
    var width = colWidths[i];
    var column = columns && columns[i];
    var additionalProps = column && column[INTERNAL_COL_DEFINE];
    if (width || additionalProps || mustInsert) {
      var _ref2 = additionalProps || {};
        _ref2.columnType;
        var restAdditionalProps = _objectWithoutProperties(_ref2, _excluded$d);
      cols.unshift(
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("col", {
        style: {
          width: width
        },
        ...restAdditionalProps
      }, i));
      mustInsert = true;
    }
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("colgroup", {
      children: cols
    })
  );
}

var EXPAND_COLUMN = {};

var _excluded$c = ["className", "noData", "columns", "flattenColumns", "colWidths", "columCount", "stickyOffsets", "direction", "fixHeader", "stickyTopOffset", "stickyBottomOffset", "stickyClassName", "onScroll", "maxContentScroll", "children"];
function useColumnWidth(colWidths, columCount) {
  return react.exports.useMemo(function () {
    var cloneColumns = [];
    for (var i = 0; i < columCount; i += 1) {
      var val = colWidths[i];
      if (val !== undefined) {
        cloneColumns[i] = val;
      } else {
        return null;
      }
    }
    return cloneColumns;
  }, [colWidths.join('_'), columCount]);
}
var FixedHolder = /*#__PURE__*/react.exports.forwardRef(function (_ref, ref) {
  var className = _ref.className,
    noData = _ref.noData,
    columns = _ref.columns,
    flattenColumns = _ref.flattenColumns,
    colWidths = _ref.colWidths,
    columCount = _ref.columCount,
    stickyOffsets = _ref.stickyOffsets,
    direction = _ref.direction,
    fixHeader = _ref.fixHeader,
    stickyTopOffset = _ref.stickyTopOffset,
    stickyBottomOffset = _ref.stickyBottomOffset,
    stickyClassName = _ref.stickyClassName,
    onScroll = _ref.onScroll,
    maxContentScroll = _ref.maxContentScroll,
    children = _ref.children,
    props = _objectWithoutProperties(_ref, _excluded$c);
  var _useContextSelector = useContextSelector(TableContext, ['prefixCls', 'scrollbarSize', 'isSticky']),
    prefixCls = _useContextSelector.prefixCls,
    scrollbarSize = _useContextSelector.scrollbarSize,
    isSticky = _useContextSelector.isSticky;
  var combinationScrollBarSize = isSticky && !fixHeader ? 0 : scrollbarSize; // Pass wheel to scroll event

  var scrollRef = react.exports.useRef(null);
  var setScrollRef = react.exports.useCallback(function (element) {
    fillRef$1(ref, element);
    fillRef$1(scrollRef, element);
  }, []);
  react.exports.useEffect(function () {
    var _scrollRef$current;
    function onWheel(e) {
      var _ref2 = e,
        currentTarget = _ref2.currentTarget,
        deltaX = _ref2.deltaX;
      if (deltaX) {
        onScroll({
          currentTarget: currentTarget,
          scrollLeft: currentTarget.scrollLeft + deltaX
        });
        e.preventDefault();
      }
    }
    (_scrollRef$current = scrollRef.current) === null || _scrollRef$current === void 0 ? void 0 : _scrollRef$current.addEventListener('wheel', onWheel);
    return function () {
      var _scrollRef$current2;
      (_scrollRef$current2 = scrollRef.current) === null || _scrollRef$current2 === void 0 ? void 0 : _scrollRef$current2.removeEventListener('wheel', onWheel);
    };
  }, []); // Check if all flattenColumns has width

  var allFlattenColumnsWithWidth = react.exports.useMemo(function () {
    return flattenColumns.every(function (column) {
      return column.width >= 0;
    });
  }, [flattenColumns]); // Add scrollbar column

  var lastColumn = flattenColumns[flattenColumns.length - 1];
  var ScrollBarColumn = {
    fixed: lastColumn ? lastColumn.fixed : null,
    scrollbar: true,
    onHeaderCell: function onHeaderCell() {
      return {
        className: "".concat(prefixCls, "-cell-scrollbar")
      };
    }
  };
  var columnsWithScrollbar = react.exports.useMemo(function () {
    return combinationScrollBarSize ? [].concat(_toConsumableArray(columns), [ScrollBarColumn]) : columns;
  }, [combinationScrollBarSize, columns]);
  var flattenColumnsWithScrollbar = react.exports.useMemo(function () {
    return combinationScrollBarSize ? [].concat(_toConsumableArray(flattenColumns), [ScrollBarColumn]) : flattenColumns;
  }, [combinationScrollBarSize, flattenColumns]); // Calculate the sticky offsets

  var headerStickyOffsets = react.exports.useMemo(function () {
    var right = stickyOffsets.right,
      left = stickyOffsets.left;
    return _objectSpread2$1(_objectSpread2$1({}, stickyOffsets), {}, {
      left: direction === 'rtl' ? [].concat(_toConsumableArray(left.map(function (width) {
        return width + combinationScrollBarSize;
      })), [0]) : left,
      right: direction === 'rtl' ? right : [].concat(_toConsumableArray(right.map(function (width) {
        return width + combinationScrollBarSize;
      })), [0]),
      isSticky: isSticky
    });
  }, [combinationScrollBarSize, stickyOffsets, isSticky]);
  var mergedColumnWidth = useColumnWidth(colWidths, columCount);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      style: _objectSpread2$1({
        overflow: 'hidden'
      }, isSticky ? {
        top: stickyTopOffset,
        bottom: stickyBottomOffset
      } : {}),
      ref: setScrollRef,
      className: classNames$1(className, _defineProperty$1({}, stickyClassName, !!stickyClassName)),
      children: /*#__PURE__*/jsxs("table", {
        style: {
          tableLayout: 'fixed',
          visibility: noData || mergedColumnWidth ? null : 'hidden'
        },
        children: [(!noData || !maxContentScroll || allFlattenColumnsWithWidth) &&
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(ColGroup, {
          colWidths: mergedColumnWidth ? [].concat(_toConsumableArray(mergedColumnWidth), [combinationScrollBarSize]) : [],
          columCount: columCount + 1,
          columns: flattenColumnsWithScrollbar
        }), children(_objectSpread2$1(_objectSpread2$1({}, props), {}, {
          stickyOffsets: headerStickyOffsets,
          columns: columnsWithScrollbar,
          flattenColumns: flattenColumnsWithScrollbar
        }))]
      })
    })
  );
});
FixedHolder.displayName = 'FixedHolder';

function getCellFixedInfo(colStart, colEnd, columns, stickyOffsets, direction) {
  var startColumn = columns[colStart] || {};
  var endColumn = columns[colEnd] || {};
  var fixLeft;
  var fixRight;

  if (startColumn.fixed === 'left') {
    fixLeft = stickyOffsets.left[colStart];
  } else if (endColumn.fixed === 'right') {
    fixRight = stickyOffsets.right[colEnd];
  }

  var lastFixLeft = false;
  var firstFixRight = false;
  var lastFixRight = false;
  var firstFixLeft = false;
  var nextColumn = columns[colEnd + 1];
  var prevColumn = columns[colStart - 1];

  if (direction === 'rtl') {
    if (fixLeft !== undefined) {
      var prevFixLeft = prevColumn && prevColumn.fixed === 'left';
      firstFixLeft = !prevFixLeft;
    } else if (fixRight !== undefined) {
      var nextFixRight = nextColumn && nextColumn.fixed === 'right';
      lastFixRight = !nextFixRight;
    }
  } else if (fixLeft !== undefined) {
    var nextFixLeft = nextColumn && nextColumn.fixed === 'left';
    lastFixLeft = !nextFixLeft;
  } else if (fixRight !== undefined) {
    var prevFixRight = prevColumn && prevColumn.fixed === 'right';
    firstFixRight = !prevFixRight;
  }

  return {
    fixLeft: fixLeft,
    fixRight: fixRight,
    lastFixLeft: lastFixLeft,
    firstFixRight: firstFixRight,
    lastFixRight: lastFixRight,
    firstFixLeft: firstFixLeft,
    isSticky: stickyOffsets.isSticky
  };
}

var SummaryContext = /*#__PURE__*/react.exports.createContext({});

function SummaryCell(_ref) {
  var className = _ref.className,
    index = _ref.index,
    children = _ref.children,
    _ref$colSpan = _ref.colSpan,
    colSpan = _ref$colSpan === void 0 ? 1 : _ref$colSpan,
    rowSpan = _ref.rowSpan,
    align = _ref.align;
  var _useContextSelector = useContextSelector(TableContext, ['prefixCls', 'direction']),
    prefixCls = _useContextSelector.prefixCls,
    direction = _useContextSelector.direction;
  var _React$useContext = react.exports.useContext(SummaryContext),
    scrollColumnIndex = _React$useContext.scrollColumnIndex,
    stickyOffsets = _React$useContext.stickyOffsets,
    flattenColumns = _React$useContext.flattenColumns;
  var lastIndex = index + colSpan - 1;
  var mergedColSpan = lastIndex + 1 === scrollColumnIndex ? colSpan + 1 : colSpan;
  var fixedInfo = getCellFixedInfo(index, index + mergedColSpan - 1, flattenColumns, stickyOffsets, direction);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(WrappedCell, {
      className: className,
      index: index,
      component: "td",
      prefixCls: prefixCls,
      record: null,
      dataIndex: null,
      align: align,
      colSpan: mergedColSpan,
      rowSpan: rowSpan,
      render: function render() {
        return children;
      },
      ...fixedInfo
    })
  );
}

var _excluded$b = ["children"];
function FooterRow(_ref) {
  var children = _ref.children,
    props = _objectWithoutProperties(_ref, _excluded$b);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("tr", {
      ...props,
      children: children
    })
  );
}

/**
 * Syntactic sugar. Do not support HOC.
 */
function Summary(_ref) {
  var children = _ref.children;
  return children;
}

Summary.Row = FooterRow;
Summary.Cell = SummaryCell;

function Footer(_ref) {
  var children = _ref.children,
    stickyOffsets = _ref.stickyOffsets,
    flattenColumns = _ref.flattenColumns;
  var prefixCls = useContextSelector(TableContext, 'prefixCls');
  var lastColumnIndex = flattenColumns.length - 1;
  var scrollColumn = flattenColumns[lastColumnIndex];
  var summaryContext = react.exports.useMemo(function () {
    return {
      stickyOffsets: stickyOffsets,
      flattenColumns: flattenColumns,
      scrollColumnIndex: scrollColumn !== null && scrollColumn !== void 0 && scrollColumn.scrollbar ? lastColumnIndex : null
    };
  }, [scrollColumn, flattenColumns, lastColumnIndex, stickyOffsets]);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(SummaryContext.Provider, {
      value: summaryContext,
      children: /*#__PURE__*/jsx$1("tfoot", {
        className: "".concat(prefixCls, "-summary"),
        children: children
      })
    })
  );
}
var FooterComponents = Summary;

function HeaderRow(_ref) {
  var cells = _ref.cells,
    stickyOffsets = _ref.stickyOffsets,
    flattenColumns = _ref.flattenColumns,
    RowComponent = _ref.rowComponent,
    CellComponent = _ref.cellComponent,
    tdCellComponent = _ref.tdCellComponent,
    onHeaderRow = _ref.onHeaderRow,
    index = _ref.index;
  var _useContextSelector = useContextSelector(TableContext, ['prefixCls', 'direction']),
    prefixCls = _useContextSelector.prefixCls,
    direction = _useContextSelector.direction;
  var rowProps;
  if (onHeaderRow) {
    rowProps = onHeaderRow(cells.map(function (cell) {
      return cell.column;
    }), index);
  }
  var columnsKey = getColumnsKey(cells.map(function (cell) {
    return cell.column;
  }));
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(RowComponent, {
      ...rowProps,
      children: cells.map(function (cell, cellIndex) {
        var column = cell.column;
        var fixedInfo = getCellFixedInfo(cell.colStart, cell.colEnd, flattenColumns, stickyOffsets, direction);
        var additionalProps;
        if (column && column.onHeaderCell) {
          additionalProps = cell.column.onHeaderCell(column);
        }
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          react.exports.createElement(WrappedCell, {
            ...cell,
            scope: column.title ? cell.colSpan > 1 ? 'colgroup' : 'col' : null,
            ellipsis: column.ellipsis,
            align: column.align,
            component: column.title ? CellComponent : tdCellComponent,
            prefixCls: prefixCls,
            key: columnsKey[cellIndex],
            ...fixedInfo,
            additionalProps: additionalProps,
            rowType: "header"
          })
        );
      })
    })
  );
}
HeaderRow.displayName = 'HeaderRow';

function parseHeaderRows(rootColumns) {
  var rows = [];
  function fillRowCells(columns, colIndex) {
    var rowIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    // Init rows
    rows[rowIndex] = rows[rowIndex] || [];
    var currentColIndex = colIndex;
    var colSpans = columns.filter(Boolean).map(function (column) {
      var cell = {
        key: column.key,
        className: column.className || '',
        children: column.title,
        column: column,
        colStart: currentColIndex
      };
      var colSpan = 1;
      var subColumns = column.children;
      if (subColumns && subColumns.length > 0) {
        colSpan = fillRowCells(subColumns, currentColIndex, rowIndex + 1).reduce(function (total, count) {
          return total + count;
        }, 0);
        cell.hasSubColumns = true;
      }
      if ('colSpan' in column) {
        colSpan = column.colSpan;
      }
      if ('rowSpan' in column) {
        cell.rowSpan = column.rowSpan;
      }
      cell.colSpan = colSpan;
      cell.colEnd = cell.colStart + colSpan - 1;
      rows[rowIndex].push(cell);
      currentColIndex += colSpan;
      return colSpan;
    });
    return colSpans;
  } // Generate `rows` cell data

  fillRowCells(rootColumns, 0); // Handle `rowSpan`

  var rowCount = rows.length;
  var _loop = function _loop(rowIndex) {
    rows[rowIndex].forEach(function (cell) {
      if (!('rowSpan' in cell) && !cell.hasSubColumns) {
        // eslint-disable-next-line no-param-reassign
        cell.rowSpan = rowCount - rowIndex;
      }
    });
  };
  for (var rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
    _loop(rowIndex);
  }
  return rows;
}
function Header(_ref) {
  var stickyOffsets = _ref.stickyOffsets,
    columns = _ref.columns,
    flattenColumns = _ref.flattenColumns,
    onHeaderRow = _ref.onHeaderRow;
  var _useContextSelector = useContextSelector(TableContext, ['prefixCls', 'getComponent']),
    prefixCls = _useContextSelector.prefixCls,
    getComponent = _useContextSelector.getComponent;
  var rows = react.exports.useMemo(function () {
    return parseHeaderRows(columns);
  }, [columns]);
  var WrapperComponent = getComponent(['header', 'wrapper'], 'thead');
  var trComponent = getComponent(['header', 'row'], 'tr');
  var thComponent = getComponent(['header', 'cell'], 'th');
  var tdComponent = getComponent(['header', 'cell'], 'td');
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(WrapperComponent, {
      className: "".concat(prefixCls, "-thead"),
      children: rows.map(function (row, rowIndex) {
        var rowNode =
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(HeaderRow, {
          flattenColumns: flattenColumns,
          cells: row,
          stickyOffsets: stickyOffsets,
          rowComponent: trComponent,
          cellComponent: thComponent,
          tdCellComponent: tdComponent,
          onHeaderRow: onHeaderRow,
          index: rowIndex
        }, rowIndex);
        return rowNode;
      })
    })
  );
}

var _excluded$a = ["children"],
  _excluded2$1 = ["fixed"];
function convertChildrenToColumns(children) {
  return toArray$6(children).filter(function (node) {
    return /*#__PURE__*/react.exports.isValidElement(node);
  }).map(function (_ref) {
    var key = _ref.key,
      props = _ref.props;
    var nodeChildren = props.children,
      restProps = _objectWithoutProperties(props, _excluded$a);
    var column = _objectSpread2$1({
      key: key
    }, restProps);
    if (nodeChildren) {
      column.children = convertChildrenToColumns(nodeChildren);
    }
    return column;
  });
}
function flatColumns(columns) {
  return columns.reduce(function (list, column) {
    var fixed = column.fixed; // Convert `fixed='true'` to `fixed='left'` instead

    var parsedFixed = fixed === true ? 'left' : fixed;
    var subColumns = column.children;
    if (subColumns && subColumns.length > 0) {
      return [].concat(_toConsumableArray(list), _toConsumableArray(flatColumns(subColumns).map(function (subColum) {
        return _objectSpread2$1({
          fixed: parsedFixed
        }, subColum);
      })));
    }
    return [].concat(_toConsumableArray(list), [_objectSpread2$1(_objectSpread2$1({}, column), {}, {
      fixed: parsedFixed
    })]);
  }, []);
}
function revertForRtl(columns) {
  return columns.map(function (column) {
    var fixed = column.fixed,
      restProps = _objectWithoutProperties(column, _excluded2$1); // Convert `fixed='left'` to `fixed='right'` instead

    var parsedFixed = fixed;
    if (fixed === 'left') {
      parsedFixed = 'right';
    } else if (fixed === 'right') {
      parsedFixed = 'left';
    }
    return _objectSpread2$1({
      fixed: parsedFixed
    }, restProps);
  });
}
/**
 * Parse `columns` & `children` into `columns`.
 */

function useColumns(_ref2, transformColumns) {
  var prefixCls = _ref2.prefixCls,
    columns = _ref2.columns,
    children = _ref2.children,
    expandable = _ref2.expandable,
    expandedKeys = _ref2.expandedKeys,
    columnTitle = _ref2.columnTitle,
    getRowKey = _ref2.getRowKey,
    onTriggerExpand = _ref2.onTriggerExpand,
    expandIcon = _ref2.expandIcon,
    rowExpandable = _ref2.rowExpandable,
    expandIconColumnIndex = _ref2.expandIconColumnIndex,
    direction = _ref2.direction,
    expandRowByClick = _ref2.expandRowByClick,
    columnWidth = _ref2.columnWidth,
    fixed = _ref2.fixed;
  var baseColumns = react.exports.useMemo(function () {
    return columns || convertChildrenToColumns(children);
  }, [columns, children]); // ========================== Expand ==========================

  var withExpandColumns = react.exports.useMemo(function () {
    if (expandable) {
      var _expandColumn;
      var cloneColumns = baseColumns.slice(); // >>> Warning if use `expandIconColumnIndex`

      if (!cloneColumns.includes(EXPAND_COLUMN)) {
        var expandColIndex = expandIconColumnIndex || 0;
        if (expandColIndex >= 0) {
          cloneColumns.splice(expandColIndex, 0, EXPAND_COLUMN);
        }
      } // >>> Deduplicate additional expand column
      var expandColumnIndex = cloneColumns.indexOf(EXPAND_COLUMN);
      cloneColumns = cloneColumns.filter(function (column, index) {
        return column !== EXPAND_COLUMN || index === expandColumnIndex;
      }); // >>> Check if expand column need to fixed

      var prevColumn = baseColumns[expandColumnIndex];
      var fixedColumn;
      if ((fixed === 'left' || fixed) && !expandIconColumnIndex) {
        fixedColumn = 'left';
      } else if ((fixed === 'right' || fixed) && expandIconColumnIndex === baseColumns.length) {
        fixedColumn = 'right';
      } else {
        fixedColumn = prevColumn ? prevColumn.fixed : null;
      } // >>> Create expandable column

      var expandColumn = (_expandColumn = {}, _defineProperty$1(_expandColumn, INTERNAL_COL_DEFINE, {
        className: "".concat(prefixCls, "-expand-icon-col"),
        columnType: 'EXPAND_COLUMN'
      }), _defineProperty$1(_expandColumn, "title", columnTitle), _defineProperty$1(_expandColumn, "fixed", fixedColumn), _defineProperty$1(_expandColumn, "className", "".concat(prefixCls, "-row-expand-icon-cell")), _defineProperty$1(_expandColumn, "width", columnWidth), _defineProperty$1(_expandColumn, "render", function render(_, record, index) {
        var rowKey = getRowKey(record, index);
        var expanded = expandedKeys.has(rowKey);
        var recordExpandable = rowExpandable ? rowExpandable(record) : true;
        var icon = expandIcon({
          prefixCls: prefixCls,
          expanded: expanded,
          expandable: recordExpandable,
          record: record,
          onExpand: onTriggerExpand
        });
        if (expandRowByClick) {
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1("span", {
              onClick: function onClick(e) {
                return e.stopPropagation();
              },
              children: icon
            })
          );
        }
        return icon;
      }), _expandColumn);
      return cloneColumns.map(function (col) {
        return col === EXPAND_COLUMN ? expandColumn : col;
      });
    }
    return baseColumns.filter(function (col) {
      return col !== EXPAND_COLUMN;
    });
  }, [expandable, baseColumns, getRowKey, expandedKeys, expandIcon, direction]); // ========================= Transform ========================

  var mergedColumns = react.exports.useMemo(function () {
    var finalColumns = withExpandColumns;
    if (transformColumns) {
      finalColumns = transformColumns(finalColumns);
    } // Always provides at least one column for table display

    if (!finalColumns.length) {
      finalColumns = [{
        render: function render() {
          return null;
        }
      }];
    }
    return finalColumns;
  }, [transformColumns, withExpandColumns, direction]); // ========================== Flatten =========================

  var flattenColumns = react.exports.useMemo(function () {
    if (direction === 'rtl') {
      return revertForRtl(flatColumns(mergedColumns));
    }
    return flatColumns(mergedColumns);
  }, [mergedColumns, direction]); // Only check out of production since it's waste for each render
  return [mergedColumns, flattenColumns];
}

/**
 * Execute code before next frame but async
 */
function useLayoutState(defaultState) {
  var stateRef = react.exports.useRef(defaultState);

  var _useState = react.exports.useState({}),
      _useState2 = _slicedToArray(_useState, 2),
      forceUpdate = _useState2[1];

  var lastPromiseRef = react.exports.useRef(null);
  var updateBatchRef = react.exports.useRef([]);

  function setFrameState(updater) {
    updateBatchRef.current.push(updater);
    var promise = Promise.resolve();
    lastPromiseRef.current = promise;
    promise.then(function () {
      if (lastPromiseRef.current === promise) {
        var prevBatch = updateBatchRef.current;
        var prevState = stateRef.current;
        updateBatchRef.current = [];
        prevBatch.forEach(function (batchUpdater) {
          stateRef.current = batchUpdater(stateRef.current);
        });
        lastPromiseRef.current = null;

        if (prevState !== stateRef.current) {
          forceUpdate({});
        }
      }
    });
  }

  react.exports.useEffect(function () {
    return function () {
      lastPromiseRef.current = null;
    };
  }, []);
  return [stateRef.current, setFrameState];
}
/** Lock frame, when frame pass reset the lock. */

function useTimeoutLock(defaultState) {
  var frameRef = react.exports.useRef(defaultState || null);
  var timeoutRef = react.exports.useRef();

  function cleanUp() {
    window.clearTimeout(timeoutRef.current);
  }

  function setState(newState) {
    frameRef.current = newState;
    cleanUp();
    timeoutRef.current = window.setTimeout(function () {
      frameRef.current = null;
      timeoutRef.current = undefined;
    }, 100);
  }

  function getState() {
    return frameRef.current;
  }

  react.exports.useEffect(function () {
    return cleanUp;
  }, []);
  return [setState, getState];
}

// fix ssr render
var defaultContainer = canUseDom() ? window : null;
/** Sticky header hooks */

function useSticky(sticky, prefixCls) {
  var _ref = _typeof$1(sticky) === 'object' ? sticky : {},
      _ref$offsetHeader = _ref.offsetHeader,
      offsetHeader = _ref$offsetHeader === void 0 ? 0 : _ref$offsetHeader,
      _ref$offsetSummary = _ref.offsetSummary,
      offsetSummary = _ref$offsetSummary === void 0 ? 0 : _ref$offsetSummary,
      _ref$offsetScroll = _ref.offsetScroll,
      offsetScroll = _ref$offsetScroll === void 0 ? 0 : _ref$offsetScroll,
      _ref$getContainer = _ref.getContainer,
      getContainer = _ref$getContainer === void 0 ? function () {
    return defaultContainer;
  } : _ref$getContainer;

  var container = getContainer() || defaultContainer;
  return react.exports.useMemo(function () {
    var isSticky = !!sticky;
    return {
      isSticky: isSticky,
      stickyClassName: isSticky ? "".concat(prefixCls, "-sticky-holder") : '',
      offsetHeader: offsetHeader,
      offsetSummary: offsetSummary,
      offsetScroll: offsetScroll,
      container: container
    };
  }, [offsetScroll, offsetHeader, offsetSummary, prefixCls, container]);
}

/**
 * Get sticky column offset width
 */
function useStickyOffsets(colWidths, columnCount, direction) {
  var stickyOffsets = react.exports.useMemo(function () {
    var leftOffsets = [];
    var rightOffsets = [];
    var left = 0;
    var right = 0;

    for (var start = 0; start < columnCount; start += 1) {
      if (direction === 'rtl') {
        // Left offset
        rightOffsets[start] = right;
        right += colWidths[start] || 0; // Right offset

        var end = columnCount - start - 1;
        leftOffsets[end] = left;
        left += colWidths[end] || 0;
      } else {
        // Left offset
        leftOffsets[start] = left;
        left += colWidths[start] || 0; // Right offset

        var _end = columnCount - start - 1;

        rightOffsets[_end] = right;
        right += colWidths[_end] || 0;
      }
    }

    return {
      left: leftOffsets,
      right: rightOffsets
    };
  }, [colWidths, columnCount, direction]);
  return stickyOffsets;
}

function Panel(_ref) {
  var className = _ref.className,
    children = _ref.children;
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      className: className,
      children: children
    })
  );
}

var StickyScrollBar = function StickyScrollBar(_ref, ref) {
  var _scrollBodyRef$curren, _scrollBodyRef$curren2;
  var scrollBodyRef = _ref.scrollBodyRef,
    onScroll = _ref.onScroll,
    offsetScroll = _ref.offsetScroll,
    container = _ref.container;
  var prefixCls = useContextSelector(TableContext, 'prefixCls');
  var bodyScrollWidth = ((_scrollBodyRef$curren = scrollBodyRef.current) === null || _scrollBodyRef$curren === void 0 ? void 0 : _scrollBodyRef$curren.scrollWidth) || 0;
  var bodyWidth = ((_scrollBodyRef$curren2 = scrollBodyRef.current) === null || _scrollBodyRef$curren2 === void 0 ? void 0 : _scrollBodyRef$curren2.clientWidth) || 0;
  var scrollBarWidth = bodyScrollWidth && bodyWidth * (bodyWidth / bodyScrollWidth);
  var scrollBarRef = react.exports.useRef();
  var _useLayoutState = useLayoutState({
      scrollLeft: 0,
      isHiddenScrollBar: false
    }),
    _useLayoutState2 = _slicedToArray(_useLayoutState, 2),
    scrollState = _useLayoutState2[0],
    setScrollState = _useLayoutState2[1];
  var refState = react.exports.useRef({
    delta: 0,
    x: 0
  });
  var _React$useState = react.exports.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    isActive = _React$useState2[0],
    setActive = _React$useState2[1];
  var onMouseUp = function onMouseUp() {
    setActive(false);
  };
  var onMouseDown = function onMouseDown(event) {
    event.persist();
    refState.current.delta = event.pageX - scrollState.scrollLeft;
    refState.current.x = 0;
    setActive(true);
    event.preventDefault();
  };
  var onMouseMove = function onMouseMove(event) {
    var _window;

    // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
    var _ref2 = event || ((_window = window) === null || _window === void 0 ? void 0 : _window.event),
      buttons = _ref2.buttons;
    if (!isActive || buttons === 0) {
      // If out body mouse up, we can set isActive false when mouse move
      if (isActive) {
        setActive(false);
      }
      return;
    }
    var left = refState.current.x + event.pageX - refState.current.x - refState.current.delta;
    if (left <= 0) {
      left = 0;
    }
    if (left + scrollBarWidth >= bodyWidth) {
      left = bodyWidth - scrollBarWidth;
    }
    onScroll({
      scrollLeft: left / bodyWidth * (bodyScrollWidth + 2)
    });
    refState.current.x = event.pageX;
  };
  var onContainerScroll = function onContainerScroll() {
    if (!scrollBodyRef.current) {
      return;
    }
    var tableOffsetTop = getOffset(scrollBodyRef.current).top;
    var tableBottomOffset = tableOffsetTop + scrollBodyRef.current.offsetHeight;
    var currentClientOffset = container === window ? document.documentElement.scrollTop + window.innerHeight : getOffset(container).top + container.clientHeight;
    if (tableBottomOffset - getScrollBarSize() <= currentClientOffset || tableOffsetTop >= currentClientOffset - offsetScroll) {
      setScrollState(function (state) {
        return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
          isHiddenScrollBar: true
        });
      });
    } else {
      setScrollState(function (state) {
        return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
          isHiddenScrollBar: false
        });
      });
    }
  };
  var setScrollLeft = function setScrollLeft(left) {
    setScrollState(function (state) {
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        scrollLeft: left / bodyScrollWidth * bodyWidth || 0
      });
    });
  };
  react.exports.useImperativeHandle(ref, function () {
    return {
      setScrollLeft: setScrollLeft
    };
  });
  react.exports.useEffect(function () {
    var onMouseUpListener = addEventListenerWrap(document.body, 'mouseup', onMouseUp, false);
    var onMouseMoveListener = addEventListenerWrap(document.body, 'mousemove', onMouseMove, false);
    onContainerScroll();
    return function () {
      onMouseUpListener.remove();
      onMouseMoveListener.remove();
    };
  }, [scrollBarWidth, isActive]);
  react.exports.useEffect(function () {
    var onScrollListener = addEventListenerWrap(container, 'scroll', onContainerScroll, false);
    var onResizeListener = addEventListenerWrap(window, 'resize', onContainerScroll, false);
    return function () {
      onScrollListener.remove();
      onResizeListener.remove();
    };
  }, [container]);
  react.exports.useEffect(function () {
    if (!scrollState.isHiddenScrollBar) {
      setScrollState(function (state) {
        var bodyNode = scrollBodyRef.current;
        if (!bodyNode) {
          return state;
        }
        return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
          scrollLeft: bodyNode.scrollLeft / bodyNode.scrollWidth * bodyNode.clientWidth
        });
      });
    }
  }, [scrollState.isHiddenScrollBar]);
  if (bodyScrollWidth <= bodyWidth || !scrollBarWidth || scrollState.isHiddenScrollBar) {
    return null;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      style: {
        height: getScrollBarSize(),
        width: bodyWidth,
        bottom: offsetScroll
      },
      className: "".concat(prefixCls, "-sticky-scroll"),
      children: /*#__PURE__*/jsx$1("div", {
        onMouseDown: onMouseDown,
        ref: scrollBarRef,
        className: classNames$1("".concat(prefixCls, "-sticky-scroll-bar"), _defineProperty$1({}, "".concat(prefixCls, "-sticky-scroll-bar-active"), isActive)),
        style: {
          width: "".concat(scrollBarWidth, "px"),
          transform: "translate3d(".concat(scrollState.scrollLeft, "px, 0, 0)")
        }
      })
    })
  );
};
const StickyScrollBar$1 = /*#__PURE__*/react.exports.forwardRef(StickyScrollBar);

/* istanbul ignore next */

/**
 * This is a syntactic sugar for `columns` prop.
 * So HOC will not work on this.
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function Column$1(_) {
  return null;
}

/* istanbul ignore next */

/**
 * This is a syntactic sugar for `columns` prop.
 * So HOC will not work on this.
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function ColumnGroup$1(_) {
  return null;
}

function renderExpandIcon$1(_ref) {
  var _classNames;
  var prefixCls = _ref.prefixCls,
    record = _ref.record,
    onExpand = _ref.onExpand,
    expanded = _ref.expanded,
    expandable = _ref.expandable;
  var expandClassName = "".concat(prefixCls, "-row-expand-icon");
  if (!expandable) {
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        className: classNames$1(expandClassName, "".concat(prefixCls, "-row-spaced"))
      })
    );
  }
  var onClick = function onClick(event) {
    onExpand(record, event);
    event.stopPropagation();
  };
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      className: classNames$1(expandClassName, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-row-expanded"), expanded), _defineProperty$1(_classNames, "".concat(prefixCls, "-row-collapsed"), !expanded), _classNames)),
      onClick: onClick
    })
  );
}
function findAllChildrenKeys(data, getRowKey, childrenColumnName) {
  var keys = [];
  function dig(list) {
    (list || []).forEach(function (item, index) {
      keys.push(getRowKey(item, index));
      dig(item[childrenColumnName]);
    });
  }
  dig(data);
  return keys;
}

var EMPTY_DATA$1 = []; // Used for customize scroll

var EMPTY_SCROLL_TARGET = {};
var INTERNAL_HOOKS = 'rc-table-internal-hook';
var MemoTableContent = /*#__PURE__*/react.exports.memo(function (_ref) {
  var children = _ref.children;
  return children;
}, function (prev, next) {
  if (!shallowequal(prev.props, next.props)) {
    return false;
  } // No additional render when pinged status change.
  // This is not a bug.

  return prev.pingLeft !== next.pingLeft || prev.pingRight !== next.pingRight;
});
function Table$2(tableProps) {
  var _classNames;
  var props = _objectSpread2$1({
    rowKey: 'key',
    prefixCls: 'rc-table',
    emptyText: function emptyText() {
      return 'No Data';
    }
  }, tableProps);
  var prefixCls = props.prefixCls,
    className = props.className,
    rowClassName = props.rowClassName,
    style = props.style,
    data = props.data,
    rowKey = props.rowKey,
    scroll = props.scroll,
    tableLayout = props.tableLayout,
    direction = props.direction,
    title = props.title,
    footer = props.footer,
    summary = props.summary,
    caption = props.caption,
    id = props.id,
    showHeader = props.showHeader,
    components = props.components,
    emptyText = props.emptyText,
    onRow = props.onRow,
    onHeaderRow = props.onHeaderRow,
    internalHooks = props.internalHooks,
    transformColumns = props.transformColumns,
    internalRefs = props.internalRefs,
    sticky = props.sticky;
  var mergedData = data || EMPTY_DATA$1;
  var hasData = !!mergedData.length; // ===================== Warning ======================

  var getComponent = react.exports.useCallback(function (path, defaultComponent) {
    return getPathValue(components || {}, path) || defaultComponent;
  }, [components]);
  var getRowKey = react.exports.useMemo(function () {
    if (typeof rowKey === 'function') {
      return rowKey;
    }
    return function (record) {
      var key = record && record[rowKey];
      return key;
    };
  }, [rowKey]); // ====================== Expand ======================

  var expandableConfig = getExpandableProps(props);
  var expandIcon = expandableConfig.expandIcon,
    expandedRowKeys = expandableConfig.expandedRowKeys,
    defaultExpandedRowKeys = expandableConfig.defaultExpandedRowKeys,
    defaultExpandAllRows = expandableConfig.defaultExpandAllRows,
    expandedRowRender = expandableConfig.expandedRowRender,
    columnTitle = expandableConfig.columnTitle,
    onExpand = expandableConfig.onExpand,
    onExpandedRowsChange = expandableConfig.onExpandedRowsChange,
    expandRowByClick = expandableConfig.expandRowByClick,
    rowExpandable = expandableConfig.rowExpandable,
    expandIconColumnIndex = expandableConfig.expandIconColumnIndex,
    expandedRowClassName = expandableConfig.expandedRowClassName,
    childrenColumnName = expandableConfig.childrenColumnName,
    indentSize = expandableConfig.indentSize;
  var mergedExpandIcon = expandIcon || renderExpandIcon$1;
  var mergedChildrenColumnName = childrenColumnName || 'children';
  var expandableType = react.exports.useMemo(function () {
    if (expandedRowRender) {
      return 'row';
    }
    /* eslint-disable no-underscore-dangle */

    /**
     * Fix https://github.com/ant-design/ant-design/issues/21154
     * This is a workaround to not to break current behavior.
     * We can remove follow code after final release.
     *
     * To other developer:
     *  Do not use `__PARENT_RENDER_ICON__` in prod since we will remove this when refactor
     */

    if (props.expandable && internalHooks === INTERNAL_HOOKS && props.expandable.__PARENT_RENDER_ICON__ || mergedData.some(function (record) {
      return record && _typeof$1(record) === 'object' && record[mergedChildrenColumnName];
    })) {
      return 'nest';
    }
    /* eslint-enable */

    return false;
  }, [!!expandedRowRender, mergedData]);
  var _React$useState = react.exports.useState(function () {
      if (defaultExpandedRowKeys) {
        return defaultExpandedRowKeys;
      }
      if (defaultExpandAllRows) {
        return findAllChildrenKeys(mergedData, getRowKey, mergedChildrenColumnName);
      }
      return [];
    }),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    innerExpandedKeys = _React$useState2[0],
    setInnerExpandedKeys = _React$useState2[1];
  var mergedExpandedKeys = react.exports.useMemo(function () {
    return new Set(expandedRowKeys || innerExpandedKeys || []);
  }, [expandedRowKeys, innerExpandedKeys]);
  var onTriggerExpand = react.exports.useCallback(function (record) {
    var key = getRowKey(record, mergedData.indexOf(record));
    var newExpandedKeys;
    var hasKey = mergedExpandedKeys.has(key);
    if (hasKey) {
      mergedExpandedKeys.delete(key);
      newExpandedKeys = _toConsumableArray(mergedExpandedKeys);
    } else {
      newExpandedKeys = [].concat(_toConsumableArray(mergedExpandedKeys), [key]);
    }
    setInnerExpandedKeys(newExpandedKeys);
    if (onExpand) {
      onExpand(!hasKey, record);
    }
    if (onExpandedRowsChange) {
      onExpandedRowsChange(newExpandedKeys);
    }
  }, [getRowKey, mergedExpandedKeys, mergedData, onExpand, onExpandedRowsChange]); // Warning if use `expandedRowRender` and nest children in the same time

  var _React$useState3 = react.exports.useState(0),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    componentWidth = _React$useState4[0],
    setComponentWidth = _React$useState4[1];
  var _useColumns = useColumns(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, props), expandableConfig), {}, {
      expandable: !!expandedRowRender,
      columnTitle: columnTitle,
      expandedKeys: mergedExpandedKeys,
      getRowKey: getRowKey,
      // https://github.com/ant-design/ant-design/issues/23894
      onTriggerExpand: onTriggerExpand,
      expandIcon: mergedExpandIcon,
      expandIconColumnIndex: expandIconColumnIndex,
      direction: direction
    }), internalHooks === INTERNAL_HOOKS ? transformColumns : null),
    _useColumns2 = _slicedToArray(_useColumns, 2),
    columns = _useColumns2[0],
    flattenColumns = _useColumns2[1];
  var columnContext = react.exports.useMemo(function () {
    return {
      columns: columns,
      flattenColumns: flattenColumns
    };
  }, [columns, flattenColumns]); // ====================== Scroll ======================

  var fullTableRef = react.exports.useRef();
  var scrollHeaderRef = react.exports.useRef();
  var scrollBodyRef = react.exports.useRef();
  var scrollBodyContainerRef = react.exports.useRef();
  var scrollSummaryRef = react.exports.useRef();
  var _React$useState5 = react.exports.useState(false),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    pingedLeft = _React$useState6[0],
    setPingedLeft = _React$useState6[1];
  var _React$useState7 = react.exports.useState(false),
    _React$useState8 = _slicedToArray(_React$useState7, 2),
    pingedRight = _React$useState8[0],
    setPingedRight = _React$useState8[1];
  var _useLayoutState = useLayoutState(new Map()),
    _useLayoutState2 = _slicedToArray(_useLayoutState, 2),
    colsWidths = _useLayoutState2[0],
    updateColsWidths = _useLayoutState2[1]; // Convert map to number width

  var colsKeys = getColumnsKey(flattenColumns);
  var pureColWidths = colsKeys.map(function (columnKey) {
    return colsWidths.get(columnKey);
  });
  var colWidths = react.exports.useMemo(function () {
    return pureColWidths;
  }, [pureColWidths.join('_')]);
  var stickyOffsets = useStickyOffsets(colWidths, flattenColumns.length, direction);
  var fixHeader = scroll && validateValue(scroll.y);
  var horizonScroll = scroll && validateValue(scroll.x) || Boolean(expandableConfig.fixed);
  var fixColumn = horizonScroll && flattenColumns.some(function (_ref2) {
    var fixed = _ref2.fixed;
    return fixed;
  }); // Sticky

  var stickyRef = react.exports.useRef();
  var _useSticky = useSticky(sticky, prefixCls),
    isSticky = _useSticky.isSticky,
    offsetHeader = _useSticky.offsetHeader,
    offsetSummary = _useSticky.offsetSummary,
    offsetScroll = _useSticky.offsetScroll,
    stickyClassName = _useSticky.stickyClassName,
    container = _useSticky.container; // Footer (Fix footer must fixed header)

  var summaryNode = summary === null || summary === void 0 ? void 0 : summary(mergedData);
  var fixFooter = (fixHeader || isSticky) && /*#__PURE__*/react.exports.isValidElement(summaryNode) && summaryNode.type === Summary && summaryNode.props.fixed; // Scroll

  var scrollXStyle;
  var scrollYStyle;
  var scrollTableStyle;
  if (fixHeader) {
    scrollYStyle = {
      overflowY: 'scroll',
      maxHeight: scroll.y
    };
  }
  if (horizonScroll) {
    scrollXStyle = {
      overflowX: 'auto'
    }; // When no vertical scrollbar, should hide it
    // https://github.com/ant-design/ant-design/pull/20705
    // https://github.com/ant-design/ant-design/issues/21879

    if (!fixHeader) {
      scrollYStyle = {
        overflowY: 'hidden'
      };
    }
    scrollTableStyle = {
      width: (scroll === null || scroll === void 0 ? void 0 : scroll.x) === true ? 'auto' : scroll === null || scroll === void 0 ? void 0 : scroll.x,
      minWidth: '100%'
    };
  }
  var onColumnResize = react.exports.useCallback(function (columnKey, width) {
    if (isVisible(fullTableRef.current)) {
      updateColsWidths(function (widths) {
        if (widths.get(columnKey) !== width) {
          var newWidths = new Map(widths);
          newWidths.set(columnKey, width);
          return newWidths;
        }
        return widths;
      });
    }
  }, []);
  var _useTimeoutLock = useTimeoutLock(null),
    _useTimeoutLock2 = _slicedToArray(_useTimeoutLock, 2),
    setScrollTarget = _useTimeoutLock2[0],
    getScrollTarget = _useTimeoutLock2[1];
  function forceScroll(scrollLeft, target) {
    if (!target) {
      return;
    }
    if (typeof target === 'function') {
      target(scrollLeft);
    } else if (target.scrollLeft !== scrollLeft) {
      target.scrollLeft = scrollLeft; // Delay to force scroll position if not sync
      // ref: https://github.com/ant-design/ant-design/issues/37179

      if (target.scrollLeft !== scrollLeft) {
        setTimeout(function () {
          target.scrollLeft = scrollLeft;
        }, 0);
      }
    }
  }
  var onScroll = function onScroll(_ref3) {
    var currentTarget = _ref3.currentTarget,
      scrollLeft = _ref3.scrollLeft;
    var isRTL = direction === 'rtl';
    var mergedScrollLeft = typeof scrollLeft === 'number' ? scrollLeft : currentTarget.scrollLeft;
    var compareTarget = currentTarget || EMPTY_SCROLL_TARGET;
    if (!getScrollTarget() || getScrollTarget() === compareTarget) {
      var _stickyRef$current;
      setScrollTarget(compareTarget);
      forceScroll(mergedScrollLeft, scrollHeaderRef.current);
      forceScroll(mergedScrollLeft, scrollBodyRef.current);
      forceScroll(mergedScrollLeft, scrollSummaryRef.current);
      forceScroll(mergedScrollLeft, (_stickyRef$current = stickyRef.current) === null || _stickyRef$current === void 0 ? void 0 : _stickyRef$current.setScrollLeft);
    }
    if (currentTarget) {
      var scrollWidth = currentTarget.scrollWidth,
        clientWidth = currentTarget.clientWidth; // There is no space to scroll

      if (scrollWidth === clientWidth) {
        setPingedLeft(false);
        setPingedRight(false);
        return;
      }
      if (isRTL) {
        setPingedLeft(-mergedScrollLeft < scrollWidth - clientWidth);
        setPingedRight(-mergedScrollLeft > 0);
      } else {
        setPingedLeft(mergedScrollLeft > 0);
        setPingedRight(mergedScrollLeft < scrollWidth - clientWidth);
      }
    }
  };
  var triggerOnScroll = function triggerOnScroll() {
    if (horizonScroll && scrollBodyRef.current) {
      onScroll({
        currentTarget: scrollBodyRef.current
      });
    } else {
      setPingedLeft(false);
      setPingedRight(false);
    }
  };
  var onFullTableResize = function onFullTableResize(_ref4) {
    var width = _ref4.width;
    if (width !== componentWidth) {
      triggerOnScroll();
      setComponentWidth(fullTableRef.current ? fullTableRef.current.offsetWidth : width);
    }
  }; // Sync scroll bar when init or `horizonScroll`, `data` and `columns.length` changed

  var mounted = react.exports.useRef(false);
  react.exports.useEffect(function () {
    // onFullTableResize will be trigger once when ResizeObserver is mounted
    // This will reduce one duplicated triggerOnScroll time
    if (mounted.current) {
      triggerOnScroll();
    }
  }, [horizonScroll, data, columns.length]);
  react.exports.useEffect(function () {
    mounted.current = true;
  }, []); // ===================== Effects ======================

  var _React$useState9 = react.exports.useState(0),
    _React$useState10 = _slicedToArray(_React$useState9, 2),
    scrollbarSize = _React$useState10[0],
    setScrollbarSize = _React$useState10[1];
  var _React$useState11 = react.exports.useState(true),
    _React$useState12 = _slicedToArray(_React$useState11, 2),
    supportSticky = _React$useState12[0],
    setSupportSticky = _React$useState12[1]; // Only IE not support, we mark as support first

  react.exports.useEffect(function () {
    if (scrollBodyRef.current instanceof Element) {
      setScrollbarSize(getTargetScrollBarSize(scrollBodyRef.current).width);
    } else {
      setScrollbarSize(getTargetScrollBarSize(scrollBodyContainerRef.current).width);
    }
    setSupportSticky(isStyleSupport('position', 'sticky'));
  }, []); // ================== INTERNAL HOOKS ==================

  react.exports.useEffect(function () {
    if (internalHooks === INTERNAL_HOOKS && internalRefs) {
      internalRefs.body.current = scrollBodyRef.current;
    }
  }); // ====================== Render ======================

  var TableComponent = getComponent(['table'], 'table'); // Table layout

  var mergedTableLayout = react.exports.useMemo(function () {
    if (tableLayout) {
      return tableLayout;
    } // https://github.com/ant-design/ant-design/issues/25227
    // When scroll.x is max-content, no need to fix table layout
    // it's width should stretch out to fit content

    if (fixColumn) {
      return (scroll === null || scroll === void 0 ? void 0 : scroll.x) === 'max-content' ? 'auto' : 'fixed';
    }
    if (fixHeader || isSticky || flattenColumns.some(function (_ref5) {
      var ellipsis = _ref5.ellipsis;
      return ellipsis;
    })) {
      return 'fixed';
    }
    return 'auto';
  }, [fixHeader, fixColumn, flattenColumns, tableLayout, isSticky]);
  var groupTableNode; // Header props

  var headerProps = {
    colWidths: colWidths,
    columCount: flattenColumns.length,
    stickyOffsets: stickyOffsets,
    onHeaderRow: onHeaderRow,
    fixHeader: fixHeader,
    scroll: scroll
  }; // Empty

  var emptyNode = react.exports.useMemo(function () {
    if (hasData) {
      return null;
    }
    if (typeof emptyText === 'function') {
      return emptyText();
    }
    return emptyText;
  }, [hasData, emptyText]); // Body

  var bodyTable =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(MemoBody, {
    data: mergedData,
    measureColumnWidth: fixHeader || horizonScroll || isSticky,
    expandedKeys: mergedExpandedKeys,
    rowExpandable: rowExpandable,
    getRowKey: getRowKey,
    onRow: onRow,
    emptyNode: emptyNode,
    childrenColumnName: mergedChildrenColumnName
  });
  var bodyColGroup =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(ColGroup, {
    colWidths: flattenColumns.map(function (_ref6) {
      var width = _ref6.width;
      return width;
    }),
    columns: flattenColumns
  });
  var captionElement = caption !== null && caption !== undefined ?
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("caption", {
    className: "".concat(prefixCls, "-caption"),
    children: caption
  }) : undefined;
  var customizeScrollBody = getComponent(['body']);
  var dataProps = pickAttrs(props, {
    data: true
  });
  var ariaProps = pickAttrs(props, {
    aria: true
  });
  if (fixHeader || isSticky) {
    // >>>>>> Fixed Header
    var bodyContent;
    if (typeof customizeScrollBody === 'function') {
      bodyContent = customizeScrollBody(mergedData, {
        scrollbarSize: scrollbarSize,
        ref: scrollBodyRef,
        onScroll: onScroll
      });
      headerProps.colWidths = flattenColumns.map(function (_ref7, index) {
        var width = _ref7.width;
        var colWidth = index === columns.length - 1 ? width - scrollbarSize : width;
        if (typeof colWidth === 'number' && !Number.isNaN(colWidth)) {
          return colWidth;
        }
        warningOnce(false, 'When use `components.body` with render props. Each column should have a fixed `width` value.');
        return 0;
      });
    } else {
      bodyContent =
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("div", {
        style: _objectSpread2$1(_objectSpread2$1({}, scrollXStyle), scrollYStyle),
        onScroll: onScroll,
        ref: scrollBodyRef,
        className: classNames$1("".concat(prefixCls, "-body")),
        children: /*#__PURE__*/jsxs(TableComponent, {
          style: _objectSpread2$1(_objectSpread2$1({}, scrollTableStyle), {}, {
            tableLayout: mergedTableLayout
          }),
          ...ariaProps,
          children: [captionElement, bodyColGroup, bodyTable, !fixFooter && summaryNode &&
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(Footer, {
            stickyOffsets: stickyOffsets,
            flattenColumns: flattenColumns,
            children: summaryNode
          })]
        })
      });
    } // Fixed holder share the props

    var fixedHolderProps = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
      noData: !mergedData.length,
      maxContentScroll: horizonScroll && scroll.x === 'max-content'
    }, headerProps), columnContext), {}, {
      direction: direction,
      stickyClassName: stickyClassName,
      onScroll: onScroll
    });
    groupTableNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs(Fragment, {
      children: [showHeader !== false &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(FixedHolder, {
        ...fixedHolderProps,
        stickyTopOffset: offsetHeader,
        className: "".concat(prefixCls, "-header"),
        ref: scrollHeaderRef,
        children: function (fixedHolderPassProps) {
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            jsxs(Fragment, {
              children: [/*#__PURE__*/jsx$1(Header, {
                ...fixedHolderPassProps
              }), fixFooter === 'top' &&
              /*#__PURE__*/
              /*#__PURE__*/
              jsx$1(Footer, {
                ...fixedHolderPassProps,
                children: summaryNode
              })]
            })
          );
        }
      }), bodyContent, fixFooter && fixFooter !== 'top' &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(FixedHolder, {
        ...fixedHolderProps,
        stickyBottomOffset: offsetSummary,
        className: "".concat(prefixCls, "-summary"),
        ref: scrollSummaryRef,
        children: function (fixedHolderPassProps) {
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1(Footer, {
              ...fixedHolderPassProps,
              children: summaryNode
            })
          );
        }
      }), isSticky &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(StickyScrollBar$1, {
        ref: stickyRef,
        offsetScroll: offsetScroll,
        scrollBodyRef: scrollBodyRef,
        onScroll: onScroll,
        container: container
      })]
    });
  } else {
    // >>>>>> Unique table
    groupTableNode =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      style: _objectSpread2$1(_objectSpread2$1({}, scrollXStyle), scrollYStyle),
      className: classNames$1("".concat(prefixCls, "-content")),
      onScroll: onScroll,
      ref: scrollBodyRef,
      children: /*#__PURE__*/jsxs(TableComponent, {
        style: _objectSpread2$1(_objectSpread2$1({}, scrollTableStyle), {}, {
          tableLayout: mergedTableLayout
        }),
        ...ariaProps,
        children: [captionElement, bodyColGroup, showHeader !== false &&
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(Header, {
          ...headerProps,
          ...columnContext
        }), bodyTable, summaryNode &&
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(Footer, {
          stickyOffsets: stickyOffsets,
          flattenColumns: flattenColumns,
          children: summaryNode
        })]
      })
    });
  }
  var fullTable =
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    className: classNames$1(prefixCls, className, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-rtl"), direction === 'rtl'), _defineProperty$1(_classNames, "".concat(prefixCls, "-ping-left"), pingedLeft), _defineProperty$1(_classNames, "".concat(prefixCls, "-ping-right"), pingedRight), _defineProperty$1(_classNames, "".concat(prefixCls, "-layout-fixed"), tableLayout === 'fixed'), _defineProperty$1(_classNames, "".concat(prefixCls, "-fixed-header"), fixHeader), _defineProperty$1(_classNames, "".concat(prefixCls, "-fixed-column"), fixColumn), _defineProperty$1(_classNames, "".concat(prefixCls, "-scroll-horizontal"), horizonScroll), _defineProperty$1(_classNames, "".concat(prefixCls, "-has-fix-left"), flattenColumns[0] && flattenColumns[0].fixed), _defineProperty$1(_classNames, "".concat(prefixCls, "-has-fix-right"), flattenColumns[flattenColumns.length - 1] && flattenColumns[flattenColumns.length - 1].fixed === 'right'), _classNames)),
    style: style,
    id: id,
    ref: fullTableRef,
    ...dataProps,
    children: /*#__PURE__*/jsxs(MemoTableContent, {
      pingLeft: pingedLeft,
      pingRight: pingedRight,
      props: _objectSpread2$1(_objectSpread2$1({}, props), {}, {
        stickyOffsets: stickyOffsets,
        mergedExpandedKeys: mergedExpandedKeys
      }),
      children: [title &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(Panel, {
        className: "".concat(prefixCls, "-title"),
        children: title(mergedData)
      }), /*#__PURE__*/jsx$1("div", {
        ref: scrollBodyContainerRef,
        className: "".concat(prefixCls, "-container"),
        children: groupTableNode
      }), footer &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(Panel, {
        className: "".concat(prefixCls, "-footer"),
        children: footer(mergedData)
      })]
    })
  });
  if (horizonScroll) {
    fullTable =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(ResizeObserver$1, {
      onResize: onFullTableResize,
      children: fullTable
    });
  }
  var TableContextValue = react.exports.useMemo(function () {
    return {
      prefixCls: prefixCls,
      getComponent: getComponent,
      scrollbarSize: scrollbarSize,
      direction: direction,
      fixedInfoList: flattenColumns.map(function (_, colIndex) {
        return getCellFixedInfo(colIndex, colIndex, flattenColumns, stickyOffsets, direction);
      }),
      isSticky: isSticky
    };
  }, [prefixCls, getComponent, scrollbarSize, direction, flattenColumns, stickyOffsets, isSticky]);
  var BodyContextValue = react.exports.useMemo(function () {
    return _objectSpread2$1(_objectSpread2$1({}, columnContext), {}, {
      tableLayout: mergedTableLayout,
      rowClassName: rowClassName,
      expandedRowClassName: expandedRowClassName,
      expandIcon: mergedExpandIcon,
      expandableType: expandableType,
      expandRowByClick: expandRowByClick,
      expandedRowRender: expandedRowRender,
      onTriggerExpand: onTriggerExpand,
      expandIconColumnIndex: expandIconColumnIndex,
      indentSize: indentSize,
      allColumnsFixedLeft: columnContext.flattenColumns.every(function (col) {
        return col.fixed === 'left';
      })
    });
  }, [columnContext, mergedTableLayout, rowClassName, expandedRowClassName, mergedExpandIcon, expandableType, expandRowByClick, expandedRowRender, onTriggerExpand, expandIconColumnIndex, indentSize]);
  var ExpandedRowContextValue = react.exports.useMemo(function () {
    return {
      componentWidth: componentWidth,
      fixHeader: fixHeader,
      fixColumn: fixColumn,
      horizonScroll: horizonScroll
    };
  }, [componentWidth, fixHeader, fixColumn, horizonScroll]);
  var ResizeContextValue = react.exports.useMemo(function () {
    return {
      onColumnResize: onColumnResize
    };
  }, [onColumnResize]);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(StickyContext.Provider, {
      value: supportSticky,
      children: /*#__PURE__*/jsx$1(TableContext.Provider, {
        value: TableContextValue,
        children: /*#__PURE__*/jsx$1(BodyContext.Provider, {
          value: BodyContextValue,
          children: /*#__PURE__*/jsx$1(ExpandedRowContext.Provider, {
            value: ExpandedRowContextValue,
            children: /*#__PURE__*/jsx$1(ResizeContext.Provider, {
              value: ResizeContextValue,
              children: fullTable
            })
          })
        })
      })
    })
  );
}
Table$2.EXPAND_COLUMN = EXPAND_COLUMN;
Table$2.Column = Column$1;
Table$2.ColumnGroup = ColumnGroup$1;
Table$2.Summary = FooterComponents;

/* istanbul ignore next */
/** This is a syntactic sugar for `columns` prop. So HOC will not work on this. */
// eslint-disable-next-line no-unused-vars
function Column(_) {
  return null;
}

/* istanbul ignore next */
/** This is a syntactic sugar for `columns` prop. So HOC will not work on this. */
// eslint-disable-next-line no-unused-vars
function ColumnGroup(_) {
  return null;
}

function renderExpandIcon(locale) {
  return function expandIcon(_ref) {
    var _classNames;
    var prefixCls = _ref.prefixCls,
      onExpand = _ref.onExpand,
      record = _ref.record,
      expanded = _ref.expanded,
      expandable = _ref.expandable;
    var iconPrefix = prefixCls + "-row-expand-icon";
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("button", {
        type: "button",
        onClick: function onClick(e) {
          onExpand(record, e);
          e.stopPropagation();
        },
        className: classNames$1(iconPrefix, (_classNames = {}, _defineProperty$1(_classNames, iconPrefix + "-spaced", !expandable), _defineProperty$1(_classNames, iconPrefix + "-expanded", expandable && expanded), _defineProperty$1(_classNames, iconPrefix + "-collapsed", expandable && !expanded), _classNames)),
        "aria-label": expanded ? locale.collapse : locale.expand,
        "aria-expanded": expanded
      })
    );
  };
}

function getColumnKey(column, defaultKey) {
  if ('key' in column && column.key !== undefined && column.key !== null) {
    return column.key;
  }
  if (column.dataIndex) {
    return Array.isArray(column.dataIndex) ? column.dataIndex.join('.') : column.dataIndex;
  }
  return defaultKey;
}
function getColumnPos(index, pos) {
  return pos ? pos + "-" + index : "" + index;
}
function renderColumnTitle(title, props) {
  if (typeof title === 'function') {
    return title(props);
  }
  return title;
}
/**
 * Safe get column title
 *
 * Should filter [object Object]
 *
 * @param title
 * @returns
 */
function safeColumnTitle(title, props) {
  var res = renderColumnTitle(title, props);
  if (Object.prototype.toString.call(res) === '[object Object]') return '';
  return res;
}

// This icon file is generated automatically.
var FilterFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M349 838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V642H349v196zm531.1-684H143.9c-24.5 0-39.8 26.7-27.5 48l221.3 376h348.8l221.3-376c12.1-21.3-3.2-48-27.7-48z" } }] }, "name": "filter", "theme": "filled" };
const FilterFilledSvg = FilterFilled$2;

var FilterFilled = function FilterFilled(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: FilterFilledSvg
      })
    })
  );
};
FilterFilled.displayName = 'FilterFilled';
const FilterFilled$1 = /*#__PURE__*/react.exports.forwardRef(FilterFilled);

function _objectDestructuringEmpty(obj) {
  if (obj == null) throw new TypeError("Cannot destructure " + obj);
}

var Filler = /*#__PURE__*/react.exports.forwardRef(function (_ref, ref) {
  var height = _ref.height,
    offset = _ref.offset,
    children = _ref.children,
    prefixCls = _ref.prefixCls,
    onInnerResize = _ref.onInnerResize;
  var outerStyle = {};
  var innerStyle = {
    display: 'flex',
    flexDirection: 'column'
  };
  if (offset !== undefined) {
    outerStyle = {
      height: height,
      position: 'relative',
      overflow: 'hidden'
    };
    innerStyle = _objectSpread2$1(_objectSpread2$1({}, innerStyle), {}, {
      transform: "translateY(".concat(offset, "px)"),
      position: 'absolute',
      left: 0,
      right: 0,
      top: 0
    });
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      style: outerStyle,
      children: /*#__PURE__*/jsx$1(ResizeObserver$1, {
        onResize: function onResize(_ref2) {
          var offsetHeight = _ref2.offsetHeight;
          if (offsetHeight && onInnerResize) {
            onInnerResize();
          }
        },
        children: /*#__PURE__*/jsx$1("div", {
          style: innerStyle,
          className: classNames$1(_defineProperty$1({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
          ref: ref,
          children: children
        })
      })
    })
  );
});
Filler.displayName = 'Filler';

var MIN_SIZE = 20;
function getPageY(e) {
  return 'touches' in e ? e.touches[0].pageY : e.pageY;
}
var ScrollBar = /*#__PURE__*/function (_React$Component) {
  _inherits(ScrollBar, _React$Component);
  var _super = _createSuper(ScrollBar);
  function ScrollBar() {
    var _this;
    _classCallCheck(this, ScrollBar);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.moveRaf = null;
    _this.scrollbarRef = /*#__PURE__*/react.exports.createRef();
    _this.thumbRef = /*#__PURE__*/react.exports.createRef();
    _this.visibleTimeout = null;
    _this.state = {
      dragging: false,
      pageY: null,
      startTop: null,
      visible: false
    };
    _this.delayHidden = function () {
      clearTimeout(_this.visibleTimeout);
      _this.setState({
        visible: true
      });
      _this.visibleTimeout = setTimeout(function () {
        _this.setState({
          visible: false
        });
      }, 2000);
    };
    _this.onScrollbarTouchStart = function (e) {
      e.preventDefault();
    };
    _this.onContainerMouseDown = function (e) {
      e.stopPropagation();
      e.preventDefault();
    };
    _this.patchEvents = function () {
      window.addEventListener('mousemove', _this.onMouseMove);
      window.addEventListener('mouseup', _this.onMouseUp);
      _this.thumbRef.current.addEventListener('touchmove', _this.onMouseMove);
      _this.thumbRef.current.addEventListener('touchend', _this.onMouseUp);
    };
    _this.removeEvents = function () {
      var _this$scrollbarRef$cu;
      window.removeEventListener('mousemove', _this.onMouseMove);
      window.removeEventListener('mouseup', _this.onMouseUp);
      (_this$scrollbarRef$cu = _this.scrollbarRef.current) === null || _this$scrollbarRef$cu === void 0 ? void 0 : _this$scrollbarRef$cu.removeEventListener('touchstart', _this.onScrollbarTouchStart);
      if (_this.thumbRef.current) {
        _this.thumbRef.current.removeEventListener('touchstart', _this.onMouseDown);
        _this.thumbRef.current.removeEventListener('touchmove', _this.onMouseMove);
        _this.thumbRef.current.removeEventListener('touchend', _this.onMouseUp);
      }
      wrapperRaf$1.cancel(_this.moveRaf);
    };
    _this.onMouseDown = function (e) {
      var onStartMove = _this.props.onStartMove;
      _this.setState({
        dragging: true,
        pageY: getPageY(e),
        startTop: _this.getTop()
      });
      onStartMove();
      _this.patchEvents();
      e.stopPropagation();
      e.preventDefault();
    };
    _this.onMouseMove = function (e) {
      var _this$state = _this.state,
        dragging = _this$state.dragging,
        pageY = _this$state.pageY,
        startTop = _this$state.startTop;
      var onScroll = _this.props.onScroll;
      wrapperRaf$1.cancel(_this.moveRaf);
      if (dragging) {
        var offsetY = getPageY(e) - pageY;
        var newTop = startTop + offsetY;
        var enableScrollRange = _this.getEnableScrollRange();
        var enableHeightRange = _this.getEnableHeightRange();
        var ptg = enableHeightRange ? newTop / enableHeightRange : 0;
        var newScrollTop = Math.ceil(ptg * enableScrollRange);
        _this.moveRaf = wrapperRaf$1(function () {
          onScroll(newScrollTop);
        });
      }
    };
    _this.onMouseUp = function () {
      var onStopMove = _this.props.onStopMove;
      _this.setState({
        dragging: false
      });
      onStopMove();
      _this.removeEvents();
    };
    _this.getSpinHeight = function () {
      var _this$props = _this.props,
        height = _this$props.height,
        count = _this$props.count;
      var baseHeight = height / count * 10;
      baseHeight = Math.max(baseHeight, MIN_SIZE);
      baseHeight = Math.min(baseHeight, height / 2);
      return Math.floor(baseHeight);
    };
    _this.getEnableScrollRange = function () {
      var _this$props2 = _this.props,
        scrollHeight = _this$props2.scrollHeight,
        height = _this$props2.height;
      return scrollHeight - height || 0;
    };
    _this.getEnableHeightRange = function () {
      var height = _this.props.height;
      var spinHeight = _this.getSpinHeight();
      return height - spinHeight || 0;
    };
    _this.getTop = function () {
      var scrollTop = _this.props.scrollTop;
      var enableScrollRange = _this.getEnableScrollRange();
      var enableHeightRange = _this.getEnableHeightRange();
      if (scrollTop === 0 || enableScrollRange === 0) {
        return 0;
      }
      var ptg = scrollTop / enableScrollRange;
      return ptg * enableHeightRange;
    };
    _this.showScroll = function () {
      var _this$props3 = _this.props,
        height = _this$props3.height,
        scrollHeight = _this$props3.scrollHeight;
      return scrollHeight > height;
    };
    return _this;
  }
  _createClass(ScrollBar, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.scrollbarRef.current.addEventListener('touchstart', this.onScrollbarTouchStart);
      this.thumbRef.current.addEventListener('touchstart', this.onMouseDown);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.scrollTop !== this.props.scrollTop) {
        this.delayHidden();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.removeEvents();
      clearTimeout(this.visibleTimeout);
    }
  }, {
    key: "render",
    value:
    // ====================== Render =======================
    function render() {
      var _this$state2 = this.state,
        dragging = _this$state2.dragging,
        visible = _this$state2.visible;
      var prefixCls = this.props.prefixCls;
      var spinHeight = this.getSpinHeight();
      var top = this.getTop();
      var canScroll = this.showScroll();
      var mergedVisible = canScroll && visible;
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("div", {
          ref: this.scrollbarRef,
          className: classNames$1("".concat(prefixCls, "-scrollbar"), _defineProperty$1({}, "".concat(prefixCls, "-scrollbar-show"), canScroll)),
          style: {
            width: 8,
            top: 0,
            bottom: 0,
            right: 0,
            position: 'absolute',
            display: mergedVisible ? null : 'none'
          },
          onMouseDown: this.onContainerMouseDown,
          onMouseMove: this.delayHidden,
          children: /*#__PURE__*/jsx$1("div", {
            ref: this.thumbRef,
            className: classNames$1("".concat(prefixCls, "-scrollbar-thumb"), _defineProperty$1({}, "".concat(prefixCls, "-scrollbar-thumb-moving"), dragging)),
            style: {
              width: '100%',
              height: spinHeight,
              top: top,
              left: 0,
              position: 'absolute',
              background: 'rgba(0, 0, 0, 0.5)',
              borderRadius: 99,
              cursor: 'pointer',
              userSelect: 'none'
            },
            onMouseDown: this.onMouseDown
          })
        })
      );
    }
  }]);
  return ScrollBar;
}(react.exports.Component);

function Item(_ref) {
  var children = _ref.children,
    setRef = _ref.setRef;
  var refFunc = react.exports.useCallback(function (node) {
    setRef(node);
  }, []);
  return /*#__PURE__*/react.exports.cloneElement(children, {
    ref: refFunc
  });
}

function useChildren(list, startIndex, endIndex, setNodeRef, renderFunc, _ref) {
  var getKey = _ref.getKey;
  return list.slice(startIndex, endIndex + 1).map(function (item, index) {
    var eleIndex = startIndex + index;
    var node = renderFunc(item, eleIndex, {
      // style: status === 'MEASURE_START' ? { visibility: 'hidden' } : {},
    });
    var key = getKey(item);
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(Item, {
        setRef: function setRef(ele) {
          return setNodeRef(item, ele);
        },
        children: node
      }, key)
    );
  });
}

// Firefox has low performance of map.
var CacheMap = /*#__PURE__*/function () {
  function CacheMap() {
    _classCallCheck(this, CacheMap);
    this.maps = void 0;
    this.maps = Object.create(null);
  }
  _createClass(CacheMap, [{
    key: "set",
    value: function set(key, value) {
      this.maps[key] = value;
    }
  }, {
    key: "get",
    value: function get(key) {
      return this.maps[key];
    }
  }]);
  return CacheMap;
}();

function useHeights(getKey, onItemAdd, onItemRemove) {
  var _React$useState = react.exports.useState(0),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    updatedMark = _React$useState2[0],
    setUpdatedMark = _React$useState2[1];
  var instanceRef = react.exports.useRef(new Map());
  var heightsRef = react.exports.useRef(new CacheMap());
  var collectRafRef = react.exports.useRef();
  function cancelRaf() {
    wrapperRaf$1.cancel(collectRafRef.current);
  }
  function collectHeight() {
    cancelRaf();
    collectRafRef.current = wrapperRaf$1(function () {
      instanceRef.current.forEach(function (element, key) {
        if (element && element.offsetParent) {
          var htmlElement = findDOMNode(element);
          var offsetHeight = htmlElement.offsetHeight;
          if (heightsRef.current.get(key) !== offsetHeight) {
            heightsRef.current.set(key, htmlElement.offsetHeight);
          }
        }
      });
      // Always trigger update mark to tell parent that should re-calculate heights when resized
      setUpdatedMark(function (c) {
        return c + 1;
      });
    });
  }
  function setInstanceRef(item, instance) {
    var key = getKey(item);
    var origin = instanceRef.current.get(key);
    if (instance) {
      instanceRef.current.set(key, instance);
      collectHeight();
    } else {
      instanceRef.current.delete(key);
    }
    // Instance changed
    if (!origin !== !instance) {
      if (instance) {
        onItemAdd === null || onItemAdd === void 0 ? void 0 : onItemAdd(item);
      } else {
        onItemRemove === null || onItemRemove === void 0 ? void 0 : onItemRemove(item);
      }
    }
  }
  react.exports.useEffect(function () {
    return cancelRaf;
  }, []);
  return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
}

function useScrollTo(containerRef, data, heights, itemHeight, getKey, collectHeight, syncScrollTop, triggerFlash) {
  var scrollRef = react.exports.useRef();
  return function (arg) {
    // When not argument provided, we think dev may want to show the scrollbar
    if (arg === null || arg === undefined) {
      triggerFlash();
      return;
    }
    // Normal scroll logic
    wrapperRaf$1.cancel(scrollRef.current);
    if (typeof arg === 'number') {
      syncScrollTop(arg);
    } else if (arg && _typeof$1(arg) === 'object') {
      var index;
      var align = arg.align;
      if ('index' in arg) {
        index = arg.index;
      } else {
        index = data.findIndex(function (item) {
          return getKey(item) === arg.key;
        });
      }
      var _arg$offset = arg.offset,
        offset = _arg$offset === void 0 ? 0 : _arg$offset;
      // We will retry 3 times in case dynamic height shaking
      var syncScroll = function syncScroll(times, targetAlign) {
        if (times < 0 || !containerRef.current) return;
        var height = containerRef.current.clientHeight;
        var needCollectHeight = false;
        var newTargetAlign = targetAlign;
        // Go to next frame if height not exist
        if (height) {
          var mergedAlign = targetAlign || align;
          // Get top & bottom
          var stackTop = 0;
          var itemTop = 0;
          var itemBottom = 0;
          var maxLen = Math.min(data.length, index);
          for (var i = 0; i <= maxLen; i += 1) {
            var key = getKey(data[i]);
            itemTop = stackTop;
            var cacheHeight = heights.get(key);
            itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);
            stackTop = itemBottom;
            if (i === index && cacheHeight === undefined) {
              needCollectHeight = true;
            }
          }
          // Scroll to
          var targetTop = null;
          switch (mergedAlign) {
            case 'top':
              targetTop = itemTop - offset;
              break;
            case 'bottom':
              targetTop = itemBottom - height + offset;
              break;
            default:
              {
                var scrollTop = containerRef.current.scrollTop;
                var scrollBottom = scrollTop + height;
                if (itemTop < scrollTop) {
                  newTargetAlign = 'top';
                } else if (itemBottom > scrollBottom) {
                  newTargetAlign = 'bottom';
                }
              }
          }
          if (targetTop !== null && targetTop !== containerRef.current.scrollTop) {
            syncScrollTop(targetTop);
          }
        }
        // We will retry since element may not sync height as it described
        scrollRef.current = wrapperRaf$1(function () {
          if (needCollectHeight) {
            collectHeight();
          }
          syncScroll(times - 1, newTargetAlign);
        });
      };
      syncScroll(3);
    }
  };
}

/**
 * Get index with specific start index one by one. e.g.
 * min: 3, max: 9, start: 6
 *
 * Return index is:
 * [0]: 6
 * [1]: 7
 * [2]: 5
 * [3]: 8
 * [4]: 4
 * [5]: 9
 * [6]: 3
 */
/**
 * We assume that 2 list has only 1 item diff and others keeping the order.
 * So we can use dichotomy algorithm to find changed one.
 */
function findListDiffIndex(originList, targetList, getKey) {
  var originLen = originList.length;
  var targetLen = targetList.length;
  var shortList;
  var longList;
  if (originLen === 0 && targetLen === 0) {
    return null;
  }
  if (originLen < targetLen) {
    shortList = originList;
    longList = targetList;
  } else {
    shortList = targetList;
    longList = originList;
  }
  var notExistKey = {
    __EMPTY_ITEM__: true
  };
  function getItemKey(item) {
    if (item !== undefined) {
      return getKey(item);
    }
    return notExistKey;
  }
  // Loop to find diff one
  var diffIndex = null;
  var multiple = Math.abs(originLen - targetLen) !== 1;
  for (var i = 0; i < longList.length; i += 1) {
    var shortKey = getItemKey(shortList[i]);
    var longKey = getItemKey(longList[i]);
    if (shortKey !== longKey) {
      diffIndex = i;
      multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
      break;
    }
  }
  return diffIndex === null ? null : {
    index: diffIndex,
    multiple: multiple
  };
}

function useDiffItem(data, getKey, onDiff) {
  var _React$useState = react.exports.useState(data),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    prevData = _React$useState2[0],
    setPrevData = _React$useState2[1];
  var _React$useState3 = react.exports.useState(null),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    diffItem = _React$useState4[0],
    setDiffItem = _React$useState4[1];
  react.exports.useEffect(function () {
    var diff = findListDiffIndex(prevData || [], data || [], getKey);
    if ((diff === null || diff === void 0 ? void 0 : diff.index) !== undefined) {
      onDiff === null || onDiff === void 0 ? void 0 : onDiff(diff.index);
      setDiffItem(data[diff.index]);
    }
    setPrevData(data);
  }, [data]);
  return [diffItem];
}

var isFF = (typeof navigator === "undefined" ? "undefined" : _typeof$1(navigator)) === 'object' && /Firefox/i.test(navigator.userAgent);

const useOriginScroll = (function (isScrollAtTop, isScrollAtBottom) {
  // Do lock for a wheel when scrolling
  var lockRef = react.exports.useRef(false);
  var lockTimeoutRef = react.exports.useRef(null);
  function lockScroll() {
    clearTimeout(lockTimeoutRef.current);
    lockRef.current = true;
    lockTimeoutRef.current = setTimeout(function () {
      lockRef.current = false;
    }, 50);
  }
  // Pass to ref since global add is in closure
  var scrollPingRef = react.exports.useRef({
    top: isScrollAtTop,
    bottom: isScrollAtBottom
  });
  scrollPingRef.current.top = isScrollAtTop;
  scrollPingRef.current.bottom = isScrollAtBottom;
  return function (deltaY) {
    var smoothOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var originScroll =
    // Pass origin wheel when on the top
    deltaY < 0 && scrollPingRef.current.top ||
    // Pass origin wheel when on the bottom
    deltaY > 0 && scrollPingRef.current.bottom;
    if (smoothOffset && originScroll) {
      // No need lock anymore when it's smooth offset from touchMove interval
      clearTimeout(lockTimeoutRef.current);
      lockRef.current = false;
    } else if (!originScroll || lockRef.current) {
      lockScroll();
    }
    return !lockRef.current && originScroll;
  };
});

function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, onWheelDelta) {
  var offsetRef = react.exports.useRef(0);
  var nextFrameRef = react.exports.useRef(null);
  // Firefox patch
  var wheelValueRef = react.exports.useRef(null);
  var isMouseScrollRef = react.exports.useRef(false);
  // Scroll status sync
  var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
  function onWheel(event) {
    if (!inVirtual) return;
    wrapperRaf$1.cancel(nextFrameRef.current);
    var deltaY = event.deltaY;
    offsetRef.current += deltaY;
    wheelValueRef.current = deltaY;
    // Do nothing when scroll at the edge, Skip check when is in scroll
    if (originScroll(deltaY)) return;
    // Proxy of scroll events
    if (!isFF) {
      event.preventDefault();
    }
    nextFrameRef.current = wrapperRaf$1(function () {
      // Patch a multiple for Firefox to fix wheel number too small
      // ref: https://github.com/ant-design/ant-design/issues/26372#issuecomment-679460266
      var patchMultiple = isMouseScrollRef.current ? 10 : 1;
      onWheelDelta(offsetRef.current * patchMultiple);
      offsetRef.current = 0;
    });
  }
  // A patch for firefox
  function onFireFoxScroll(event) {
    if (!inVirtual) return;
    isMouseScrollRef.current = event.detail === wheelValueRef.current;
  }
  return [onWheel, onFireFoxScroll];
}

var SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
  var touchedRef = react.exports.useRef(false);
  var touchYRef = react.exports.useRef(0);
  var elementRef = react.exports.useRef(null);
  // Smooth scroll
  var intervalRef = react.exports.useRef(null);
  /* eslint-disable prefer-const */
  var cleanUpEvents;
  var onTouchMove = function onTouchMove(e) {
    if (touchedRef.current) {
      var currentY = Math.ceil(e.touches[0].pageY);
      var offsetY = touchYRef.current - currentY;
      touchYRef.current = currentY;
      if (callback(offsetY)) {
        e.preventDefault();
      }
      // Smooth interval
      clearInterval(intervalRef.current);
      intervalRef.current = setInterval(function () {
        offsetY *= SMOOTH_PTG;
        if (!callback(offsetY, true) || Math.abs(offsetY) <= 0.1) {
          clearInterval(intervalRef.current);
        }
      }, 16);
    }
  };
  var onTouchEnd = function onTouchEnd() {
    touchedRef.current = false;
    cleanUpEvents();
  };
  var onTouchStart = function onTouchStart(e) {
    cleanUpEvents();
    if (e.touches.length === 1 && !touchedRef.current) {
      touchedRef.current = true;
      touchYRef.current = Math.ceil(e.touches[0].pageY);
      elementRef.current = e.target;
      elementRef.current.addEventListener('touchmove', onTouchMove);
      elementRef.current.addEventListener('touchend', onTouchEnd);
    }
  };
  cleanUpEvents = function cleanUpEvents() {
    if (elementRef.current) {
      elementRef.current.removeEventListener('touchmove', onTouchMove);
      elementRef.current.removeEventListener('touchend', onTouchEnd);
    }
  };
  useLayoutEffect$3(function () {
    if (inVirtual) {
      listRef.current.addEventListener('touchstart', onTouchStart);
    }
    return function () {
      var _listRef$current;
      (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.removeEventListener('touchstart', onTouchStart);
      cleanUpEvents();
      clearInterval(intervalRef.current);
    };
  }, [inVirtual]);
}

var _excluded$9 = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "component", "onScroll", "onVisibleChange"];
var EMPTY_DATA = [];
var ScrollStyle = {
  overflowY: 'auto',
  overflowAnchor: 'none'
};
function RawList(props, ref) {
  var _props$prefixCls = props.prefixCls,
    prefixCls = _props$prefixCls === void 0 ? 'rc-virtual-list' : _props$prefixCls,
    className = props.className,
    height = props.height,
    itemHeight = props.itemHeight,
    _props$fullHeight = props.fullHeight,
    fullHeight = _props$fullHeight === void 0 ? true : _props$fullHeight,
    style = props.style,
    data = props.data,
    children = props.children,
    itemKey = props.itemKey,
    virtual = props.virtual,
    _props$component = props.component,
    Component = _props$component === void 0 ? 'div' : _props$component,
    onScroll = props.onScroll,
    onVisibleChange = props.onVisibleChange,
    restProps = _objectWithoutProperties(props, _excluded$9);
  // ================================= MISC =================================
  var useVirtual = !!(virtual !== false && height && itemHeight);
  var inVirtual = useVirtual && data && itemHeight * data.length > height;
  var _useState = react.exports.useState(0),
    _useState2 = _slicedToArray(_useState, 2),
    scrollTop = _useState2[0],
    setScrollTop = _useState2[1];
  var _useState3 = react.exports.useState(false),
    _useState4 = _slicedToArray(_useState3, 2),
    scrollMoving = _useState4[0],
    setScrollMoving = _useState4[1];
  var mergedClassName = classNames$1(prefixCls, className);
  var mergedData = data || EMPTY_DATA;
  var componentRef = react.exports.useRef();
  var fillerInnerRef = react.exports.useRef();
  var scrollBarRef = react.exports.useRef(); // Hack on scrollbar to enable flash call
  // =============================== Item Key ===============================
  var getKey = react.exports.useCallback(function (item) {
    if (typeof itemKey === 'function') {
      return itemKey(item);
    }
    return item === null || item === void 0 ? void 0 : item[itemKey];
  }, [itemKey]);
  var sharedConfig = {
    getKey: getKey
  };
  // ================================ Scroll ================================
  function syncScrollTop(newTop) {
    setScrollTop(function (origin) {
      var value;
      if (typeof newTop === 'function') {
        value = newTop(origin);
      } else {
        value = newTop;
      }
      var alignedTop = keepInRange(value);
      componentRef.current.scrollTop = alignedTop;
      return alignedTop;
    });
  }
  // ================================ Legacy ================================
  // Put ref here since the range is generate by follow
  var rangeRef = react.exports.useRef({
    start: 0,
    end: mergedData.length
  });
  var diffItemRef = react.exports.useRef();
  var _useDiffItem = useDiffItem(mergedData, getKey),
    _useDiffItem2 = _slicedToArray(_useDiffItem, 1),
    diffItem = _useDiffItem2[0];
  diffItemRef.current = diffItem;
  // ================================ Height ================================
  var _useHeights = useHeights(getKey, null, null),
    _useHeights2 = _slicedToArray(_useHeights, 4),
    setInstanceRef = _useHeights2[0],
    collectHeight = _useHeights2[1],
    heights = _useHeights2[2],
    heightUpdatedMark = _useHeights2[3];
  // ========================== Visible Calculation =========================
  var _React$useMemo = react.exports.useMemo(function () {
      if (!useVirtual) {
        return {
          scrollHeight: undefined,
          start: 0,
          end: mergedData.length - 1,
          offset: undefined
        };
      }
      // Always use virtual scroll bar in avoid shaking
      if (!inVirtual) {
        var _fillerInnerRef$curre;
        return {
          scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
          start: 0,
          end: mergedData.length - 1,
          offset: undefined
        };
      }
      var itemTop = 0;
      var startIndex;
      var startOffset;
      var endIndex;
      var dataLen = mergedData.length;
      for (var i = 0; i < dataLen; i += 1) {
        var item = mergedData[i];
        var key = getKey(item);
        var cacheHeight = heights.get(key);
        var currentItemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);
        // Check item top in the range
        if (currentItemBottom >= scrollTop && startIndex === undefined) {
          startIndex = i;
          startOffset = itemTop;
        }
        // Check item bottom in the range. We will render additional one item for motion usage
        if (currentItemBottom > scrollTop + height && endIndex === undefined) {
          endIndex = i;
        }
        itemTop = currentItemBottom;
      }
      // When scrollTop at the end but data cut to small count will reach this
      if (startIndex === undefined) {
        startIndex = 0;
        startOffset = 0;
        endIndex = Math.ceil(height / itemHeight);
      }
      if (endIndex === undefined) {
        endIndex = mergedData.length - 1;
      }
      // Give cache to improve scroll experience
      endIndex = Math.min(endIndex + 1, mergedData.length);
      return {
        scrollHeight: itemTop,
        start: startIndex,
        end: endIndex,
        offset: startOffset
      };
    }, [inVirtual, useVirtual, scrollTop, mergedData, heightUpdatedMark, height]),
    scrollHeight = _React$useMemo.scrollHeight,
    start = _React$useMemo.start,
    end = _React$useMemo.end,
    offset = _React$useMemo.offset;
  rangeRef.current.start = start;
  rangeRef.current.end = end;
  // =============================== In Range ===============================
  var maxScrollHeight = scrollHeight - height;
  var maxScrollHeightRef = react.exports.useRef(maxScrollHeight);
  maxScrollHeightRef.current = maxScrollHeight;
  function keepInRange(newScrollTop) {
    var newTop = newScrollTop;
    if (!Number.isNaN(maxScrollHeightRef.current)) {
      newTop = Math.min(newTop, maxScrollHeightRef.current);
    }
    newTop = Math.max(newTop, 0);
    return newTop;
  }
  var isScrollAtTop = scrollTop <= 0;
  var isScrollAtBottom = scrollTop >= maxScrollHeight;
  var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
  // ================================ Scroll ================================
  function onScrollBar(newScrollTop) {
    var newTop = newScrollTop;
    syncScrollTop(newTop);
  }
  // When data size reduce. It may trigger native scroll event back to fit scroll position
  function onFallbackScroll(e) {
    var newScrollTop = e.currentTarget.scrollTop;
    if (newScrollTop !== scrollTop) {
      syncScrollTop(newScrollTop);
    }
    // Trigger origin onScroll
    onScroll === null || onScroll === void 0 ? void 0 : onScroll(e);
  }
  // Since this added in global,should use ref to keep update
  var _useFrameWheel = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, function (offsetY) {
      syncScrollTop(function (top) {
        var newTop = top + offsetY;
        return newTop;
      });
    }),
    _useFrameWheel2 = _slicedToArray(_useFrameWheel, 2),
    onRawWheel = _useFrameWheel2[0],
    onFireFoxScroll = _useFrameWheel2[1];
  // Mobile touch move
  useMobileTouchMove(useVirtual, componentRef, function (deltaY, smoothOffset) {
    if (originScroll(deltaY, smoothOffset)) {
      return false;
    }
    onRawWheel({
      preventDefault: function preventDefault() {},
      deltaY: deltaY
    });
    return true;
  });
  useLayoutEffect$3(function () {
    // Firefox only
    function onMozMousePixelScroll(e) {
      if (useVirtual) {
        e.preventDefault();
      }
    }
    componentRef.current.addEventListener('wheel', onRawWheel);
    componentRef.current.addEventListener('DOMMouseScroll', onFireFoxScroll);
    componentRef.current.addEventListener('MozMousePixelScroll', onMozMousePixelScroll);
    return function () {
      if (componentRef.current) {
        componentRef.current.removeEventListener('wheel', onRawWheel);
        componentRef.current.removeEventListener('DOMMouseScroll', onFireFoxScroll);
        componentRef.current.removeEventListener('MozMousePixelScroll', onMozMousePixelScroll);
      }
    };
  }, [useVirtual]);
  // ================================= Ref ==================================
  var scrollTo = useScrollTo(componentRef, mergedData, heights, itemHeight, getKey, collectHeight, syncScrollTop, function () {
    var _scrollBarRef$current;
    (_scrollBarRef$current = scrollBarRef.current) === null || _scrollBarRef$current === void 0 ? void 0 : _scrollBarRef$current.delayHidden();
  });
  react.exports.useImperativeHandle(ref, function () {
    return {
      scrollTo: scrollTo
    };
  });
  // ================================ Effect ================================
  /** We need told outside that some list not rendered */
  useLayoutEffect$3(function () {
    if (onVisibleChange) {
      var renderList = mergedData.slice(start, end + 1);
      onVisibleChange(renderList, mergedData);
    }
  }, [start, end, mergedData]);
  // ================================ Render ================================
  var listChildren = useChildren(mergedData, start, end, setInstanceRef, children, sharedConfig);
  var componentStyle = null;
  if (height) {
    componentStyle = _objectSpread2$1(_defineProperty$1({}, fullHeight ? 'height' : 'maxHeight', height), ScrollStyle);
    if (useVirtual) {
      componentStyle.overflowY = 'hidden';
      if (scrollMoving) {
        componentStyle.pointerEvents = 'none';
      }
    }
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("div", {
      style: _objectSpread2$1(_objectSpread2$1({}, style), {}, {
        position: 'relative'
      }),
      className: mergedClassName,
      ...restProps,
      children: [/*#__PURE__*/jsx$1(Component, {
        className: "".concat(prefixCls, "-holder"),
        style: componentStyle,
        ref: componentRef,
        onScroll: onFallbackScroll,
        children: /*#__PURE__*/jsx$1(Filler, {
          prefixCls: prefixCls,
          height: scrollHeight,
          offset: offset,
          onInnerResize: collectHeight,
          ref: fillerInnerRef,
          children: listChildren
        })
      }), useVirtual &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(ScrollBar, {
        ref: scrollBarRef,
        prefixCls: prefixCls,
        scrollTop: scrollTop,
        height: height,
        scrollHeight: scrollHeight,
        count: mergedData.length,
        onScroll: onScrollBar,
        onStartMove: function onStartMove() {
          setScrollMoving(true);
        },
        onStopMove: function onStopMove() {
          setScrollMoving(false);
        }
      })]
    })
  );
}
var List = /*#__PURE__*/react.exports.forwardRef(RawList);
List.displayName = 'List';

var _excluded$8 = ["className", "style", "motion", "motionNodes", "motionType", "onMotionStart", "onMotionEnd", "active", "treeNodeRequiredProps"];
var MotionTreeNode = function MotionTreeNode(_ref, ref) {
  var className = _ref.className,
    style = _ref.style,
    motion = _ref.motion,
    motionNodes = _ref.motionNodes,
    motionType = _ref.motionType,
    onOriginMotionStart = _ref.onMotionStart,
    onOriginMotionEnd = _ref.onMotionEnd,
    active = _ref.active,
    treeNodeRequiredProps = _ref.treeNodeRequiredProps,
    props = _objectWithoutProperties(_ref, _excluded$8);
  var _React$useState = react.exports.useState(true),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    visible = _React$useState2[0],
    setVisible = _React$useState2[1];
  var _React$useContext = react.exports.useContext(TreeContext),
    prefixCls = _React$useContext.prefixCls;
  var motionedRef = react.exports.useRef(false);
  var onMotionEnd = function onMotionEnd() {
    if (!motionedRef.current) {
      onOriginMotionEnd();
    }
    motionedRef.current = true;
  };
  react.exports.useEffect(function () {
    if (motionNodes && motionType === 'hide' && visible) {
      setVisible(false);
    }
  }, [motionNodes]);
  react.exports.useEffect(function () {
    // Trigger motion only when patched
    if (motionNodes) {
      onOriginMotionStart();
    }
    return function () {
      if (motionNodes) {
        onMotionEnd();
      }
    };
  }, []);
  if (motionNodes) {
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(CSSMotion, {
        ref: ref,
        visible: visible,
        ...motion,
        motionAppear: motionType === 'show',
        onAppearEnd: onMotionEnd,
        onLeaveEnd: onMotionEnd,
        children: function (_ref2, motionRef) {
          var motionClassName = _ref2.className,
            motionStyle = _ref2.style;
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1("div", {
              ref: motionRef,
              className: classNames$1("".concat(prefixCls, "-treenode-motion"), motionClassName),
              style: motionStyle,
              children: motionNodes.map(function (treeNode) {
                var restProps = _extends$2({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)),
                  title = treeNode.title,
                  key = treeNode.key,
                  isStart = treeNode.isStart,
                  isEnd = treeNode.isEnd;
                delete restProps.children;
                var treeNodeProps = getTreeNodeProps(key, treeNodeRequiredProps);
                return (
                  /*#__PURE__*/
                  /*#__PURE__*/
                  react.exports.createElement(ContextTreeNode, {
                    ...restProps,
                    ...treeNodeProps,
                    title: title,
                    active: active,
                    data: treeNode.data,
                    key: key,
                    isStart: isStart,
                    isEnd: isEnd
                  })
                );
              })
            })
          );
        }
      })
    );
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(ContextTreeNode, {
      domRef: ref,
      className: className,
      style: style,
      ...props,
      active: active
    })
  );
};
MotionTreeNode.displayName = 'MotionTreeNode';
var RefMotionTreeNode = /*#__PURE__*/react.exports.forwardRef(MotionTreeNode);

function findExpandedKeys() {
  var prev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var prevLen = prev.length;
  var nextLen = next.length;
  if (Math.abs(prevLen - nextLen) !== 1) {
    return {
      add: false,
      key: null
    };
  }
  function find(shorter, longer) {
    var cache = new Map();
    shorter.forEach(function (key) {
      cache.set(key, true);
    });
    var keys = longer.filter(function (key) {
      return !cache.has(key);
    });
    return keys.length === 1 ? keys[0] : null;
  }
  if (prevLen < nextLen) {
    return {
      add: true,
      key: find(prev, next)
    };
  }
  return {
    add: false,
    key: find(next, prev)
  };
}
function getExpandRange(shorter, longer, key) {
  var shorterStartIndex = shorter.findIndex(function (data) {
    return data.key === key;
  });
  var shorterEndNode = shorter[shorterStartIndex + 1];
  var longerStartIndex = longer.findIndex(function (data) {
    return data.key === key;
  });
  if (shorterEndNode) {
    var longerEndIndex = longer.findIndex(function (data) {
      return data.key === shorterEndNode.key;
    });
    return longer.slice(longerStartIndex + 1, longerEndIndex);
  }
  return longer.slice(longerStartIndex + 1);
}

var _excluded$7 = ["prefixCls", "data", "selectable", "checkable", "expandedKeys", "selectedKeys", "checkedKeys", "loadedKeys", "loadingKeys", "halfCheckedKeys", "keyEntities", "disabled", "dragging", "dragOverNodeKey", "dropPosition", "motion", "height", "itemHeight", "virtual", "focusable", "activeItem", "focused", "tabIndex", "onKeyDown", "onFocus", "onBlur", "onActiveChange", "onListChangeStart", "onListChangeEnd"];
var HIDDEN_STYLE = {
  width: 0,
  height: 0,
  display: 'flex',
  overflow: 'hidden',
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
var noop$2 = function noop() {};
var MOTION_KEY = "RC_TREE_MOTION_".concat(Math.random());
var MotionNode = {
  key: MOTION_KEY
};
var MotionEntity = {
  key: MOTION_KEY,
  level: 0,
  index: 0,
  pos: '0',
  node: MotionNode,
  nodes: [MotionNode]
};
var MotionFlattenData = {
  parent: null,
  children: [],
  pos: MotionEntity.pos,
  data: MotionNode,
  title: null,
  key: MOTION_KEY,
  /** Hold empty list here since we do not use it */
  isStart: [],
  isEnd: []
};
/**
 * We only need get visible content items to play the animation.
 */
function getMinimumRangeTransitionRange(list, virtual, height, itemHeight) {
  if (virtual === false || !height) {
    return list;
  }
  return list.slice(0, Math.ceil(height / itemHeight) + 1);
}
function itemKey(item) {
  var key = item.key,
    pos = item.pos;
  return getKey(key, pos);
}
function getAccessibilityPath(item) {
  var path = String(item.data.key);
  var current = item;
  while (current.parent) {
    current = current.parent;
    path = "".concat(current.data.key, " > ").concat(path);
  }
  return path;
}
var NodeList = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var prefixCls = props.prefixCls,
    data = props.data;
    props.selectable;
    props.checkable;
    var expandedKeys = props.expandedKeys,
    selectedKeys = props.selectedKeys,
    checkedKeys = props.checkedKeys,
    loadedKeys = props.loadedKeys,
    loadingKeys = props.loadingKeys,
    halfCheckedKeys = props.halfCheckedKeys,
    keyEntities = props.keyEntities,
    disabled = props.disabled,
    dragging = props.dragging,
    dragOverNodeKey = props.dragOverNodeKey,
    dropPosition = props.dropPosition,
    motion = props.motion,
    height = props.height,
    itemHeight = props.itemHeight,
    virtual = props.virtual,
    focusable = props.focusable,
    activeItem = props.activeItem,
    focused = props.focused,
    tabIndex = props.tabIndex,
    onKeyDown = props.onKeyDown,
    onFocus = props.onFocus,
    onBlur = props.onBlur,
    onActiveChange = props.onActiveChange,
    onListChangeStart = props.onListChangeStart,
    onListChangeEnd = props.onListChangeEnd,
    domProps = _objectWithoutProperties(props, _excluded$7);
  // =============================== Ref ================================
  var listRef = react.exports.useRef(null);
  var indentMeasurerRef = react.exports.useRef(null);
  react.exports.useImperativeHandle(ref, function () {
    return {
      scrollTo: function scrollTo(scroll) {
        listRef.current.scrollTo(scroll);
      },
      getIndentWidth: function getIndentWidth() {
        return indentMeasurerRef.current.offsetWidth;
      }
    };
  });
  // ============================== Motion ==============================
  var _React$useState = react.exports.useState(expandedKeys),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    prevExpandedKeys = _React$useState2[0],
    setPrevExpandedKeys = _React$useState2[1];
  var _React$useState3 = react.exports.useState(data),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    prevData = _React$useState4[0],
    setPrevData = _React$useState4[1];
  var _React$useState5 = react.exports.useState(data),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    transitionData = _React$useState6[0],
    setTransitionData = _React$useState6[1];
  var _React$useState7 = react.exports.useState([]),
    _React$useState8 = _slicedToArray(_React$useState7, 2),
    transitionRange = _React$useState8[0],
    setTransitionRange = _React$useState8[1];
  var _React$useState9 = react.exports.useState(null),
    _React$useState10 = _slicedToArray(_React$useState9, 2),
    motionType = _React$useState10[0],
    setMotionType = _React$useState10[1];
  // When motion end but data change, this will makes data back to previous one
  var dataRef = react.exports.useRef(data);
  dataRef.current = data;
  function onMotionEnd() {
    var latestData = dataRef.current;
    setPrevData(latestData);
    setTransitionData(latestData);
    setTransitionRange([]);
    setMotionType(null);
    onListChangeEnd();
  }
  // Do animation if expanded keys changed
  react.exports.useEffect(function () {
    setPrevExpandedKeys(expandedKeys);
    var diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys);
    if (diffExpanded.key !== null) {
      if (diffExpanded.add) {
        var keyIndex = prevData.findIndex(function (_ref) {
          var key = _ref.key;
          return key === diffExpanded.key;
        });
        var rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data, diffExpanded.key), virtual, height, itemHeight);
        var newTransitionData = prevData.slice();
        newTransitionData.splice(keyIndex + 1, 0, MotionFlattenData);
        setTransitionData(newTransitionData);
        setTransitionRange(rangeNodes);
        setMotionType('show');
      } else {
        var _keyIndex = data.findIndex(function (_ref2) {
          var key = _ref2.key;
          return key === diffExpanded.key;
        });
        var _rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data, prevData, diffExpanded.key), virtual, height, itemHeight);
        var _newTransitionData = data.slice();
        _newTransitionData.splice(_keyIndex + 1, 0, MotionFlattenData);
        setTransitionData(_newTransitionData);
        setTransitionRange(_rangeNodes);
        setMotionType('hide');
      }
    } else if (prevData !== data) {
      // If whole data changed, we just refresh the list
      setPrevData(data);
      setTransitionData(data);
    }
  }, [expandedKeys, data]);
  // We should clean up motion if is changed by dragging
  react.exports.useEffect(function () {
    if (!dragging) {
      onMotionEnd();
    }
  }, [dragging]);
  var mergedData = motion ? transitionData : data;
  var treeNodeRequiredProps = {
    expandedKeys: expandedKeys,
    selectedKeys: selectedKeys,
    loadedKeys: loadedKeys,
    loadingKeys: loadingKeys,
    checkedKeys: checkedKeys,
    halfCheckedKeys: halfCheckedKeys,
    dragOverNodeKey: dragOverNodeKey,
    dropPosition: dropPosition,
    keyEntities: keyEntities
  };
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs(Fragment, {
      children: [focused && activeItem &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        style: HIDDEN_STYLE,
        "aria-live": "assertive",
        children: getAccessibilityPath(activeItem)
      }), /*#__PURE__*/jsx$1("div", {
        children: /*#__PURE__*/jsx$1("input", {
          style: HIDDEN_STYLE,
          disabled: focusable === false || disabled,
          tabIndex: focusable !== false ? tabIndex : null,
          onKeyDown: onKeyDown,
          onFocus: onFocus,
          onBlur: onBlur,
          value: "",
          onChange: noop$2,
          "aria-label": "for screen reader"
        })
      }), /*#__PURE__*/jsx$1("div", {
        className: "".concat(prefixCls, "-treenode"),
        "aria-hidden": true,
        style: {
          position: 'absolute',
          pointerEvents: 'none',
          visibility: 'hidden',
          height: 0,
          overflow: 'hidden'
        },
        children: /*#__PURE__*/jsx$1("div", {
          className: "".concat(prefixCls, "-indent"),
          children: /*#__PURE__*/jsx$1("div", {
            ref: indentMeasurerRef,
            className: "".concat(prefixCls, "-indent-unit")
          })
        })
      }), /*#__PURE__*/jsx$1(List, {
        ...domProps,
        data: mergedData,
        itemKey: itemKey,
        height: height,
        fullHeight: false,
        virtual: virtual,
        itemHeight: itemHeight,
        prefixCls: "".concat(prefixCls, "-list"),
        ref: listRef,
        onVisibleChange: function onVisibleChange(originList, fullList) {
          var originSet = new Set(originList);
          var restList = fullList.filter(function (item) {
            return !originSet.has(item);
          });
          // Motion node is not render. Skip motion
          if (restList.some(function (item) {
            return itemKey(item) === MOTION_KEY;
          })) {
            onMotionEnd();
          }
        },
        children: function (treeNode) {
          var pos = treeNode.pos,
            restProps = _extends$2({}, (_objectDestructuringEmpty(treeNode.data), treeNode.data)),
            title = treeNode.title,
            key = treeNode.key,
            isStart = treeNode.isStart,
            isEnd = treeNode.isEnd;
          var mergedKey = getKey(key, pos);
          delete restProps.key;
          delete restProps.children;
          var treeNodeProps = getTreeNodeProps(mergedKey, treeNodeRequiredProps);
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1(RefMotionTreeNode, {
              ...restProps,
              ...treeNodeProps,
              title: title,
              active: !!activeItem && key === activeItem.key,
              pos: pos,
              data: treeNode.data,
              isStart: isStart,
              isEnd: isEnd,
              motion: motion,
              motionNodes: key === MOTION_KEY ? transitionRange : null,
              motionType: motionType,
              onMotionStart: onListChangeStart,
              onMotionEnd: onMotionEnd,
              treeNodeRequiredProps: treeNodeRequiredProps,
              onMouseMove: function onMouseMove() {
                onActiveChange(null);
              }
            })
          );
        }
      })]
    })
  );
});
NodeList.displayName = 'NodeList';

function DropIndicator(_ref) {
  var dropPosition = _ref.dropPosition,
    dropLevelOffset = _ref.dropLevelOffset,
    indent = _ref.indent;
  var style = {
    pointerEvents: 'none',
    position: 'absolute',
    right: 0,
    backgroundColor: 'red',
    height: 2
  };
  switch (dropPosition) {
    case -1:
      style.top = 0;
      style.left = -dropLevelOffset * indent;
      break;
    case 1:
      style.bottom = 0;
      style.left = -dropLevelOffset * indent;
      break;
    case 0:
      style.bottom = 0;
      style.left = indent;
      break;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      style: style
    })
  );
}

var MAX_RETRY_TIMES = 10;
var Tree$3 = /*#__PURE__*/function (_React$Component) {
  _inherits(Tree, _React$Component);
  var _super = _createSuper(Tree);
  function Tree() {
    var _this;
    _classCallCheck(this, Tree);
    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(_args));
    _this.destroyed = false;
    _this.delayedDragEnterLogic = void 0;
    _this.loadingRetryTimes = {};
    _this.state = {
      keyEntities: {},
      indent: null,
      selectedKeys: [],
      checkedKeys: [],
      halfCheckedKeys: [],
      loadedKeys: [],
      loadingKeys: [],
      expandedKeys: [],
      draggingNodeKey: null,
      dragChildrenKeys: [],
      // dropTargetKey is the key of abstract-drop-node
      // the abstract-drop-node is the real drop node when drag and drop
      // not the DOM drag over node
      dropTargetKey: null,
      dropPosition: null,
      dropContainerKey: null,
      dropLevelOffset: null,
      dropTargetPos: null,
      dropAllowed: true,
      // the abstract-drag-over-node
      // if mouse is on the bottom of top dom node or no the top of the bottom dom node
      // abstract-drag-over-node is the top node
      dragOverNodeKey: null,
      treeData: [],
      flattenNodes: [],
      focused: false,
      activeKey: null,
      listChanging: false,
      prevProps: null,
      fieldNames: fillFieldNames()
    };
    _this.dragStartMousePosition = null;
    _this.dragNode = void 0;
    _this.currentMouseOverDroppableNodeKey = null;
    _this.listRef = /*#__PURE__*/react.exports.createRef();
    _this.onNodeDragStart = function (event, node) {
      var _this$state = _this.state,
        expandedKeys = _this$state.expandedKeys,
        keyEntities = _this$state.keyEntities;
      var onDragStart = _this.props.onDragStart;
      var eventKey = node.props.eventKey;
      _this.dragNode = node;
      _this.dragStartMousePosition = {
        x: event.clientX,
        y: event.clientY
      };
      var newExpandedKeys = arrDel(expandedKeys, eventKey);
      _this.setState({
        draggingNodeKey: eventKey,
        dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),
        indent: _this.listRef.current.getIndentWidth()
      });
      _this.setExpandedKeys(newExpandedKeys);
      window.addEventListener('dragend', _this.onWindowDragEnd);
      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart({
        event: event,
        node: convertNodePropsToEventData(node.props)
      });
    };
    _this.onNodeDragEnter = function (event, node) {
      var _this$state2 = _this.state,
        expandedKeys = _this$state2.expandedKeys,
        keyEntities = _this$state2.keyEntities,
        dragChildrenKeys = _this$state2.dragChildrenKeys,
        flattenNodes = _this$state2.flattenNodes,
        indent = _this$state2.indent;
      var _this$props = _this.props,
        onDragEnter = _this$props.onDragEnter,
        onExpand = _this$props.onExpand,
        allowDrop = _this$props.allowDrop,
        direction = _this$props.direction;
      var _node$props = node.props,
        pos = _node$props.pos,
        eventKey = _node$props.eventKey;
      var _assertThisInitialize = _assertThisInitialized(_this),
        dragNode = _assertThisInitialize.dragNode;
      // record the key of node which is latest entered, used in dragleave event.
      if (_this.currentMouseOverDroppableNodeKey !== eventKey) {
        _this.currentMouseOverDroppableNodeKey = eventKey;
      }
      if (!dragNode) {
        _this.resetDragState();
        return;
      }
      var _calcDropPosition = calcDropPosition(event, dragNode, node, indent, _this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction),
        dropPosition = _calcDropPosition.dropPosition,
        dropLevelOffset = _calcDropPosition.dropLevelOffset,
        dropTargetKey = _calcDropPosition.dropTargetKey,
        dropContainerKey = _calcDropPosition.dropContainerKey,
        dropTargetPos = _calcDropPosition.dropTargetPos,
        dropAllowed = _calcDropPosition.dropAllowed,
        dragOverNodeKey = _calcDropPosition.dragOverNodeKey;
      if (
      // don't allow drop inside its children
      dragChildrenKeys.indexOf(dropTargetKey) !== -1 ||
      // don't allow drop when drop is not allowed caculated by calcDropPosition
      !dropAllowed) {
        _this.resetDragState();
        return;
      }
      // Side effect for delay drag
      if (!_this.delayedDragEnterLogic) {
        _this.delayedDragEnterLogic = {};
      }
      Object.keys(_this.delayedDragEnterLogic).forEach(function (key) {
        clearTimeout(_this.delayedDragEnterLogic[key]);
      });
      if (dragNode.props.eventKey !== node.props.eventKey) {
        // hoist expand logic here
        // since if logic is on the bottom
        // it will be blocked by abstract dragover node check
        //   => if you dragenter from top, you mouse will still be consider as in the top node
        event.persist();
        _this.delayedDragEnterLogic[pos] = window.setTimeout(function () {
          if (_this.state.draggingNodeKey === null) return;
          var newExpandedKeys = _toConsumableArray(expandedKeys);
          var entity = keyEntities[node.props.eventKey];
          if (entity && (entity.children || []).length) {
            newExpandedKeys = arrAdd(expandedKeys, node.props.eventKey);
          }
          if (!('expandedKeys' in _this.props)) {
            _this.setExpandedKeys(newExpandedKeys);
          }
          onExpand === null || onExpand === void 0 ? void 0 : onExpand(newExpandedKeys, {
            node: convertNodePropsToEventData(node.props),
            expanded: true,
            nativeEvent: event.nativeEvent
          });
        }, 800);
      }
      // Skip if drag node is self
      if (dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0) {
        _this.resetDragState();
        return;
      }
      // Update drag over node and drag state
      _this.setState({
        dragOverNodeKey: dragOverNodeKey,
        dropPosition: dropPosition,
        dropLevelOffset: dropLevelOffset,
        dropTargetKey: dropTargetKey,
        dropContainerKey: dropContainerKey,
        dropTargetPos: dropTargetPos,
        dropAllowed: dropAllowed
      });
      onDragEnter === null || onDragEnter === void 0 ? void 0 : onDragEnter({
        event: event,
        node: convertNodePropsToEventData(node.props),
        expandedKeys: expandedKeys
      });
    };
    _this.onNodeDragOver = function (event, node) {
      var _this$state3 = _this.state,
        dragChildrenKeys = _this$state3.dragChildrenKeys,
        flattenNodes = _this$state3.flattenNodes,
        keyEntities = _this$state3.keyEntities,
        expandedKeys = _this$state3.expandedKeys,
        indent = _this$state3.indent;
      var _this$props2 = _this.props,
        onDragOver = _this$props2.onDragOver,
        allowDrop = _this$props2.allowDrop,
        direction = _this$props2.direction;
      var _assertThisInitialize2 = _assertThisInitialized(_this),
        dragNode = _assertThisInitialize2.dragNode;
      if (!dragNode) {
        return;
      }
      var _calcDropPosition2 = calcDropPosition(event, dragNode, node, indent, _this.dragStartMousePosition, allowDrop, flattenNodes, keyEntities, expandedKeys, direction),
        dropPosition = _calcDropPosition2.dropPosition,
        dropLevelOffset = _calcDropPosition2.dropLevelOffset,
        dropTargetKey = _calcDropPosition2.dropTargetKey,
        dropContainerKey = _calcDropPosition2.dropContainerKey,
        dropAllowed = _calcDropPosition2.dropAllowed,
        dropTargetPos = _calcDropPosition2.dropTargetPos,
        dragOverNodeKey = _calcDropPosition2.dragOverNodeKey;
      if (dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {
        // don't allow drop inside its children
        // don't allow drop when drop is not allowed caculated by calcDropPosition
        return;
      }
      // Update drag position
      if (dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0) {
        if (!(_this.state.dropPosition === null && _this.state.dropLevelOffset === null && _this.state.dropTargetKey === null && _this.state.dropContainerKey === null && _this.state.dropTargetPos === null && _this.state.dropAllowed === false && _this.state.dragOverNodeKey === null)) {
          _this.resetDragState();
        }
      } else if (!(dropPosition === _this.state.dropPosition && dropLevelOffset === _this.state.dropLevelOffset && dropTargetKey === _this.state.dropTargetKey && dropContainerKey === _this.state.dropContainerKey && dropTargetPos === _this.state.dropTargetPos && dropAllowed === _this.state.dropAllowed && dragOverNodeKey === _this.state.dragOverNodeKey)) {
        _this.setState({
          dropPosition: dropPosition,
          dropLevelOffset: dropLevelOffset,
          dropTargetKey: dropTargetKey,
          dropContainerKey: dropContainerKey,
          dropTargetPos: dropTargetPos,
          dropAllowed: dropAllowed,
          dragOverNodeKey: dragOverNodeKey
        });
      }
      onDragOver === null || onDragOver === void 0 ? void 0 : onDragOver({
        event: event,
        node: convertNodePropsToEventData(node.props)
      });
    };
    _this.onNodeDragLeave = function (event, node) {
      // if it is outside the droppable area
      // currentMouseOverDroppableNodeKey will be updated in dragenter event when into another droppable receiver.
      if (_this.currentMouseOverDroppableNodeKey === node.props.eventKey && !event.currentTarget.contains(event.relatedTarget)) {
        _this.resetDragState();
        _this.currentMouseOverDroppableNodeKey = null;
      }
      var onDragLeave = _this.props.onDragLeave;
      onDragLeave === null || onDragLeave === void 0 ? void 0 : onDragLeave({
        event: event,
        node: convertNodePropsToEventData(node.props)
      });
    };
    _this.onWindowDragEnd = function (event) {
      _this.onNodeDragEnd(event, null, true);
      window.removeEventListener('dragend', _this.onWindowDragEnd);
    };
    _this.onNodeDragEnd = function (event, node) {
      var onDragEnd = _this.props.onDragEnd;
      _this.setState({
        dragOverNodeKey: null
      });
      _this.cleanDragState();
      onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd({
        event: event,
        node: convertNodePropsToEventData(node.props)
      });
      _this.dragNode = null;
      window.removeEventListener('dragend', _this.onWindowDragEnd);
    };
    _this.onNodeDrop = function (event, node) {
      var _this$getActiveItem;
      var outsideTree = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var _this$state4 = _this.state,
        dragChildrenKeys = _this$state4.dragChildrenKeys,
        dropPosition = _this$state4.dropPosition,
        dropTargetKey = _this$state4.dropTargetKey,
        dropTargetPos = _this$state4.dropTargetPos,
        dropAllowed = _this$state4.dropAllowed;
      if (!dropAllowed) return;
      var onDrop = _this.props.onDrop;
      _this.setState({
        dragOverNodeKey: null
      });
      _this.cleanDragState();
      if (dropTargetKey === null) return;
      var abstractDropNodeProps = _objectSpread2$1(_objectSpread2$1({}, getTreeNodeProps(dropTargetKey, _this.getTreeNodeRequiredProps())), {}, {
        active: ((_this$getActiveItem = _this.getActiveItem()) === null || _this$getActiveItem === void 0 ? void 0 : _this$getActiveItem.key) === dropTargetKey,
        data: _this.state.keyEntities[dropTargetKey].node
      });
      var dropToChild = dragChildrenKeys.indexOf(dropTargetKey) !== -1;
      warningOnce(!dropToChild, "Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.");
      var posArr = posToArr(dropTargetPos);
      var dropResult = {
        event: event,
        node: convertNodePropsToEventData(abstractDropNodeProps),
        dragNode: _this.dragNode ? convertNodePropsToEventData(_this.dragNode.props) : null,
        dragNodesKeys: [_this.dragNode.props.eventKey].concat(dragChildrenKeys),
        dropToGap: dropPosition !== 0,
        dropPosition: dropPosition + Number(posArr[posArr.length - 1])
      };
      if (!outsideTree) {
        onDrop === null || onDrop === void 0 ? void 0 : onDrop(dropResult);
      }
      _this.dragNode = null;
    };
    _this.cleanDragState = function () {
      var draggingNodeKey = _this.state.draggingNodeKey;
      if (draggingNodeKey !== null) {
        _this.setState({
          draggingNodeKey: null,
          dropPosition: null,
          dropContainerKey: null,
          dropTargetKey: null,
          dropLevelOffset: null,
          dropAllowed: true,
          dragOverNodeKey: null
        });
      }
      _this.dragStartMousePosition = null;
      _this.currentMouseOverDroppableNodeKey = null;
    };
    _this.triggerExpandActionExpand = function (e, treeNode) {
      var _this$state5 = _this.state,
        expandedKeys = _this$state5.expandedKeys,
        flattenNodes = _this$state5.flattenNodes;
      var expanded = treeNode.expanded,
        key = treeNode.key,
        isLeaf = treeNode.isLeaf;
      if (isLeaf || e.shiftKey || e.metaKey || e.ctrlKey) {
        return;
      }
      var node = flattenNodes.filter(function (nodeItem) {
        return nodeItem.key === key;
      })[0];
      var eventNode = convertNodePropsToEventData(_objectSpread2$1(_objectSpread2$1({}, getTreeNodeProps(key, _this.getTreeNodeRequiredProps())), {}, {
        data: node.data
      }));
      _this.setExpandedKeys(expanded ? arrDel(expandedKeys, key) : arrAdd(expandedKeys, key));
      _this.onNodeExpand(e, eventNode);
    };
    _this.onNodeClick = function (e, treeNode) {
      var _this$props3 = _this.props,
        onClick = _this$props3.onClick,
        expandAction = _this$props3.expandAction;
      if (expandAction === 'click') {
        _this.triggerExpandActionExpand(e, treeNode);
      }
      onClick === null || onClick === void 0 ? void 0 : onClick(e, treeNode);
    };
    _this.onNodeDoubleClick = function (e, treeNode) {
      var _this$props4 = _this.props,
        onDoubleClick = _this$props4.onDoubleClick,
        expandAction = _this$props4.expandAction;
      if (expandAction === 'doubleClick') {
        _this.triggerExpandActionExpand(e, treeNode);
      }
      onDoubleClick === null || onDoubleClick === void 0 ? void 0 : onDoubleClick(e, treeNode);
    };
    _this.onNodeSelect = function (e, treeNode) {
      var selectedKeys = _this.state.selectedKeys;
      var _this$state6 = _this.state,
        keyEntities = _this$state6.keyEntities,
        fieldNames = _this$state6.fieldNames;
      var _this$props5 = _this.props,
        onSelect = _this$props5.onSelect,
        multiple = _this$props5.multiple;
      var selected = treeNode.selected;
      var key = treeNode[fieldNames.key];
      var targetSelected = !selected;
      // Update selected keys
      if (!targetSelected) {
        selectedKeys = arrDel(selectedKeys, key);
      } else if (!multiple) {
        selectedKeys = [key];
      } else {
        selectedKeys = arrAdd(selectedKeys, key);
      }
      // [Legacy] Not found related usage in doc or upper libs
      var selectedNodes = selectedKeys.map(function (selectedKey) {
        var entity = keyEntities[selectedKey];
        if (!entity) return null;
        return entity.node;
      }).filter(function (node) {
        return node;
      });
      _this.setUncontrolledState({
        selectedKeys: selectedKeys
      });
      onSelect === null || onSelect === void 0 ? void 0 : onSelect(selectedKeys, {
        event: 'select',
        selected: targetSelected,
        node: treeNode,
        selectedNodes: selectedNodes,
        nativeEvent: e.nativeEvent
      });
    };
    _this.onNodeCheck = function (e, treeNode, checked) {
      var _this$state7 = _this.state,
        keyEntities = _this$state7.keyEntities,
        oriCheckedKeys = _this$state7.checkedKeys,
        oriHalfCheckedKeys = _this$state7.halfCheckedKeys;
      var _this$props6 = _this.props,
        checkStrictly = _this$props6.checkStrictly,
        onCheck = _this$props6.onCheck;
      var key = treeNode.key;
      // Prepare trigger arguments
      var checkedObj;
      var eventObj = {
        event: 'check',
        node: treeNode,
        checked: checked,
        nativeEvent: e.nativeEvent
      };
      if (checkStrictly) {
        var checkedKeys = checked ? arrAdd(oriCheckedKeys, key) : arrDel(oriCheckedKeys, key);
        var halfCheckedKeys = arrDel(oriHalfCheckedKeys, key);
        checkedObj = {
          checked: checkedKeys,
          halfChecked: halfCheckedKeys
        };
        eventObj.checkedNodes = checkedKeys.map(function (checkedKey) {
          return keyEntities[checkedKey];
        }).filter(function (entity) {
          return entity;
        }).map(function (entity) {
          return entity.node;
        });
        _this.setUncontrolledState({
          checkedKeys: checkedKeys
        });
      } else {
        // Always fill first
        var _conductCheck = conductCheck([].concat(_toConsumableArray(oriCheckedKeys), [key]), true, keyEntities),
          _checkedKeys = _conductCheck.checkedKeys,
          _halfCheckedKeys = _conductCheck.halfCheckedKeys;
        // If remove, we do it again to correction
        if (!checked) {
          var keySet = new Set(_checkedKeys);
          keySet.delete(key);
          var _conductCheck2 = conductCheck(Array.from(keySet), {
            checked: false,
            halfCheckedKeys: _halfCheckedKeys
          }, keyEntities);
          _checkedKeys = _conductCheck2.checkedKeys;
          _halfCheckedKeys = _conductCheck2.halfCheckedKeys;
        }
        checkedObj = _checkedKeys;
        // [Legacy] This is used for `rc-tree-select`
        eventObj.checkedNodes = [];
        eventObj.checkedNodesPositions = [];
        eventObj.halfCheckedKeys = _halfCheckedKeys;
        _checkedKeys.forEach(function (checkedKey) {
          var entity = keyEntities[checkedKey];
          if (!entity) return;
          var node = entity.node,
            pos = entity.pos;
          eventObj.checkedNodes.push(node);
          eventObj.checkedNodesPositions.push({
            node: node,
            pos: pos
          });
        });
        _this.setUncontrolledState({
          checkedKeys: _checkedKeys
        }, false, {
          halfCheckedKeys: _halfCheckedKeys
        });
      }
      onCheck === null || onCheck === void 0 ? void 0 : onCheck(checkedObj, eventObj);
    };
    _this.onNodeLoad = function (treeNode) {
      var key = treeNode.key;
      var loadPromise = new Promise(function (resolve, reject) {
        // We need to get the latest state of loading/loaded keys
        _this.setState(function (_ref) {
          var _ref$loadedKeys = _ref.loadedKeys,
            loadedKeys = _ref$loadedKeys === void 0 ? [] : _ref$loadedKeys,
            _ref$loadingKeys = _ref.loadingKeys,
            loadingKeys = _ref$loadingKeys === void 0 ? [] : _ref$loadingKeys;
          var _this$props7 = _this.props,
            loadData = _this$props7.loadData,
            onLoad = _this$props7.onLoad;
          if (!loadData || loadedKeys.indexOf(key) !== -1 || loadingKeys.indexOf(key) !== -1) {
            return null;
          }
          // Process load data
          var promise = loadData(treeNode);
          promise.then(function () {
            var currentLoadedKeys = _this.state.loadedKeys;
            var newLoadedKeys = arrAdd(currentLoadedKeys, key);
            // onLoad should trigger before internal setState to avoid `loadData` trigger twice.
            // https://github.com/ant-design/ant-design/issues/12464
            onLoad === null || onLoad === void 0 ? void 0 : onLoad(newLoadedKeys, {
              event: 'load',
              node: treeNode
            });
            _this.setUncontrolledState({
              loadedKeys: newLoadedKeys
            });
            _this.setState(function (prevState) {
              return {
                loadingKeys: arrDel(prevState.loadingKeys, key)
              };
            });
            resolve();
          }).catch(function (e) {
            _this.setState(function (prevState) {
              return {
                loadingKeys: arrDel(prevState.loadingKeys, key)
              };
            });
            // If exceed max retry times, we give up retry
            _this.loadingRetryTimes[key] = (_this.loadingRetryTimes[key] || 0) + 1;
            if (_this.loadingRetryTimes[key] >= MAX_RETRY_TIMES) {
              var currentLoadedKeys = _this.state.loadedKeys;
              warningOnce(false, 'Retry for `loadData` many times but still failed. No more retry.');
              _this.setUncontrolledState({
                loadedKeys: arrAdd(currentLoadedKeys, key)
              });
              resolve();
            }
            reject(e);
          });
          return {
            loadingKeys: arrAdd(loadingKeys, key)
          };
        });
      });
      // Not care warning if we ignore this
      loadPromise.catch(function () {});
      return loadPromise;
    };
    _this.onNodeMouseEnter = function (event, node) {
      var onMouseEnter = _this.props.onMouseEnter;
      onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
        event: event,
        node: node
      });
    };
    _this.onNodeMouseLeave = function (event, node) {
      var onMouseLeave = _this.props.onMouseLeave;
      onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
        event: event,
        node: node
      });
    };
    _this.onNodeContextMenu = function (event, node) {
      var onRightClick = _this.props.onRightClick;
      if (onRightClick) {
        event.preventDefault();
        onRightClick({
          event: event,
          node: node
        });
      }
    };
    _this.onFocus = function () {
      var onFocus = _this.props.onFocus;
      _this.setState({
        focused: true
      });
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      onFocus === null || onFocus === void 0 ? void 0 : onFocus.apply(void 0, args);
    };
    _this.onBlur = function () {
      var onBlur = _this.props.onBlur;
      _this.setState({
        focused: false
      });
      _this.onActiveChange(null);
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      onBlur === null || onBlur === void 0 ? void 0 : onBlur.apply(void 0, args);
    };
    _this.getTreeNodeRequiredProps = function () {
      var _this$state8 = _this.state,
        expandedKeys = _this$state8.expandedKeys,
        selectedKeys = _this$state8.selectedKeys,
        loadedKeys = _this$state8.loadedKeys,
        loadingKeys = _this$state8.loadingKeys,
        checkedKeys = _this$state8.checkedKeys,
        halfCheckedKeys = _this$state8.halfCheckedKeys,
        dragOverNodeKey = _this$state8.dragOverNodeKey,
        dropPosition = _this$state8.dropPosition,
        keyEntities = _this$state8.keyEntities;
      return {
        expandedKeys: expandedKeys || [],
        selectedKeys: selectedKeys || [],
        loadedKeys: loadedKeys || [],
        loadingKeys: loadingKeys || [],
        checkedKeys: checkedKeys || [],
        halfCheckedKeys: halfCheckedKeys || [],
        dragOverNodeKey: dragOverNodeKey,
        dropPosition: dropPosition,
        keyEntities: keyEntities
      };
    };
    _this.setExpandedKeys = function (expandedKeys) {
      var _this$state9 = _this.state,
        treeData = _this$state9.treeData,
        fieldNames = _this$state9.fieldNames;
      var flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);
      _this.setUncontrolledState({
        expandedKeys: expandedKeys,
        flattenNodes: flattenNodes
      }, true);
    };
    _this.onNodeExpand = function (e, treeNode) {
      var expandedKeys = _this.state.expandedKeys;
      var _this$state10 = _this.state,
        listChanging = _this$state10.listChanging,
        fieldNames = _this$state10.fieldNames;
      var _this$props8 = _this.props,
        onExpand = _this$props8.onExpand,
        loadData = _this$props8.loadData;
      var expanded = treeNode.expanded;
      var key = treeNode[fieldNames.key];
      // Do nothing when motion is in progress
      if (listChanging) {
        return;
      }
      // Update selected keys
      var index = expandedKeys.indexOf(key);
      var targetExpanded = !expanded;
      warningOnce(expanded && index !== -1 || !expanded && index === -1, 'Expand state not sync with index check');
      if (targetExpanded) {
        expandedKeys = arrAdd(expandedKeys, key);
      } else {
        expandedKeys = arrDel(expandedKeys, key);
      }
      _this.setExpandedKeys(expandedKeys);
      onExpand === null || onExpand === void 0 ? void 0 : onExpand(expandedKeys, {
        node: treeNode,
        expanded: targetExpanded,
        nativeEvent: e.nativeEvent
      });
      // Async Load data
      if (targetExpanded && loadData) {
        var loadPromise = _this.onNodeLoad(treeNode);
        if (loadPromise) {
          loadPromise.then(function () {
            // [Legacy] Refresh logic
            var newFlattenTreeData = flattenTreeData(_this.state.treeData, expandedKeys, fieldNames);
            _this.setUncontrolledState({
              flattenNodes: newFlattenTreeData
            });
          }).catch(function () {
            var currentExpandedKeys = _this.state.expandedKeys;
            var expandedKeysToRestore = arrDel(currentExpandedKeys, key);
            _this.setExpandedKeys(expandedKeysToRestore);
          });
        }
      }
    };
    _this.onListChangeStart = function () {
      _this.setUncontrolledState({
        listChanging: true
      });
    };
    _this.onListChangeEnd = function () {
      setTimeout(function () {
        _this.setUncontrolledState({
          listChanging: false
        });
      });
    };
    _this.onActiveChange = function (newActiveKey) {
      var activeKey = _this.state.activeKey;
      var onActiveChange = _this.props.onActiveChange;
      if (activeKey === newActiveKey) {
        return;
      }
      _this.setState({
        activeKey: newActiveKey
      });
      if (newActiveKey !== null) {
        _this.scrollTo({
          key: newActiveKey
        });
      }
      onActiveChange === null || onActiveChange === void 0 ? void 0 : onActiveChange(newActiveKey);
    };
    _this.getActiveItem = function () {
      var _this$state11 = _this.state,
        activeKey = _this$state11.activeKey,
        flattenNodes = _this$state11.flattenNodes;
      if (activeKey === null) {
        return null;
      }
      return flattenNodes.find(function (_ref2) {
        var key = _ref2.key;
        return key === activeKey;
      }) || null;
    };
    _this.offsetActiveKey = function (offset) {
      var _this$state12 = _this.state,
        flattenNodes = _this$state12.flattenNodes,
        activeKey = _this$state12.activeKey;
      var index = flattenNodes.findIndex(function (_ref3) {
        var key = _ref3.key;
        return key === activeKey;
      });
      // Align with index
      if (index === -1 && offset < 0) {
        index = flattenNodes.length;
      }
      index = (index + offset + flattenNodes.length) % flattenNodes.length;
      var item = flattenNodes[index];
      if (item) {
        var key = item.key;
        _this.onActiveChange(key);
      } else {
        _this.onActiveChange(null);
      }
    };
    _this.onKeyDown = function (event) {
      var _this$state13 = _this.state,
        activeKey = _this$state13.activeKey,
        expandedKeys = _this$state13.expandedKeys,
        checkedKeys = _this$state13.checkedKeys,
        fieldNames = _this$state13.fieldNames;
      var _this$props9 = _this.props,
        onKeyDown = _this$props9.onKeyDown,
        checkable = _this$props9.checkable,
        selectable = _this$props9.selectable;
      // >>>>>>>>>> Direction
      switch (event.which) {
        case KeyCode$1.UP:
          {
            _this.offsetActiveKey(-1);
            event.preventDefault();
            break;
          }
        case KeyCode$1.DOWN:
          {
            _this.offsetActiveKey(1);
            event.preventDefault();
            break;
          }
      }
      // >>>>>>>>>> Expand & Selection
      var activeItem = _this.getActiveItem();
      if (activeItem && activeItem.data) {
        var treeNodeRequiredProps = _this.getTreeNodeRequiredProps();
        var expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;
        var eventNode = convertNodePropsToEventData(_objectSpread2$1(_objectSpread2$1({}, getTreeNodeProps(activeKey, treeNodeRequiredProps)), {}, {
          data: activeItem.data,
          active: true
        }));
        switch (event.which) {
          // >>> Expand
          case KeyCode$1.LEFT:
            {
              // Collapse if possible
              if (expandable && expandedKeys.includes(activeKey)) {
                _this.onNodeExpand({}, eventNode);
              } else if (activeItem.parent) {
                _this.onActiveChange(activeItem.parent.key);
              }
              event.preventDefault();
              break;
            }
          case KeyCode$1.RIGHT:
            {
              // Expand if possible
              if (expandable && !expandedKeys.includes(activeKey)) {
                _this.onNodeExpand({}, eventNode);
              } else if (activeItem.children && activeItem.children.length) {
                _this.onActiveChange(activeItem.children[0].key);
              }
              event.preventDefault();
              break;
            }
          // Selection
          case KeyCode$1.ENTER:
          case KeyCode$1.SPACE:
            {
              if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {
                _this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));
              } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {
                _this.onNodeSelect({}, eventNode);
              }
              break;
            }
        }
      }
      onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(event);
    };
    _this.setUncontrolledState = function (state) {
      var atomic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var forceState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      if (!_this.destroyed) {
        var needSync = false;
        var allPassed = true;
        var newState = {};
        Object.keys(state).forEach(function (name) {
          if (name in _this.props) {
            allPassed = false;
            return;
          }
          needSync = true;
          newState[name] = state[name];
        });
        if (needSync && (!atomic || allPassed)) {
          _this.setState(_objectSpread2$1(_objectSpread2$1({}, newState), forceState));
        }
      }
    };
    _this.scrollTo = function (scroll) {
      _this.listRef.current.scrollTo(scroll);
    };
    return _this;
  }
  _createClass(Tree, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.destroyed = false;
      this.onUpdated();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.onUpdated();
    }
  }, {
    key: "onUpdated",
    value: function onUpdated() {
      var activeKey = this.props.activeKey;
      if (activeKey !== undefined && activeKey !== this.state.activeKey) {
        this.setState({
          activeKey: activeKey
        });
        if (activeKey !== null) {
          this.scrollTo({
            key: activeKey
          });
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('dragend', this.onWindowDragEnd);
      this.destroyed = true;
    }
  }, {
    key: "resetDragState",
    value: function resetDragState() {
      this.setState({
        dragOverNodeKey: null,
        dropPosition: null,
        dropLevelOffset: null,
        dropTargetKey: null,
        dropContainerKey: null,
        dropTargetPos: null,
        dropAllowed: false
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _classNames;
      var _this$state14 = this.state,
        focused = _this$state14.focused,
        flattenNodes = _this$state14.flattenNodes,
        keyEntities = _this$state14.keyEntities,
        draggingNodeKey = _this$state14.draggingNodeKey,
        activeKey = _this$state14.activeKey,
        dropLevelOffset = _this$state14.dropLevelOffset,
        dropContainerKey = _this$state14.dropContainerKey,
        dropTargetKey = _this$state14.dropTargetKey,
        dropPosition = _this$state14.dropPosition,
        dragOverNodeKey = _this$state14.dragOverNodeKey,
        indent = _this$state14.indent;
      var _this$props10 = this.props,
        prefixCls = _this$props10.prefixCls,
        className = _this$props10.className,
        style = _this$props10.style,
        showLine = _this$props10.showLine,
        focusable = _this$props10.focusable,
        _this$props10$tabInde = _this$props10.tabIndex,
        tabIndex = _this$props10$tabInde === void 0 ? 0 : _this$props10$tabInde,
        selectable = _this$props10.selectable,
        showIcon = _this$props10.showIcon,
        icon = _this$props10.icon,
        switcherIcon = _this$props10.switcherIcon,
        draggable = _this$props10.draggable,
        checkable = _this$props10.checkable,
        checkStrictly = _this$props10.checkStrictly,
        disabled = _this$props10.disabled,
        motion = _this$props10.motion,
        loadData = _this$props10.loadData,
        filterTreeNode = _this$props10.filterTreeNode,
        height = _this$props10.height,
        itemHeight = _this$props10.itemHeight,
        virtual = _this$props10.virtual,
        titleRender = _this$props10.titleRender,
        dropIndicatorRender = _this$props10.dropIndicatorRender,
        onContextMenu = _this$props10.onContextMenu,
        onScroll = _this$props10.onScroll,
        direction = _this$props10.direction,
        rootClassName = _this$props10.rootClassName,
        rootStyle = _this$props10.rootStyle;
      var domProps = pickAttrs(this.props, {
        aria: true,
        data: true
      });
      // It's better move to hooks but we just simply keep here
      var draggableConfig;
      if (draggable) {
        if (_typeof$1(draggable) === 'object') {
          draggableConfig = draggable;
        } else if (typeof draggable === 'function') {
          draggableConfig = {
            nodeDraggable: draggable
          };
        } else {
          draggableConfig = {};
        }
      }
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(TreeContext.Provider, {
          value: {
            prefixCls: prefixCls,
            selectable: selectable,
            showIcon: showIcon,
            icon: icon,
            switcherIcon: switcherIcon,
            draggable: draggableConfig,
            draggingNodeKey: draggingNodeKey,
            checkable: checkable,
            checkStrictly: checkStrictly,
            disabled: disabled,
            keyEntities: keyEntities,
            dropLevelOffset: dropLevelOffset,
            dropContainerKey: dropContainerKey,
            dropTargetKey: dropTargetKey,
            dropPosition: dropPosition,
            dragOverNodeKey: dragOverNodeKey,
            indent: indent,
            direction: direction,
            dropIndicatorRender: dropIndicatorRender,
            loadData: loadData,
            filterTreeNode: filterTreeNode,
            titleRender: titleRender,
            onNodeClick: this.onNodeClick,
            onNodeDoubleClick: this.onNodeDoubleClick,
            onNodeExpand: this.onNodeExpand,
            onNodeSelect: this.onNodeSelect,
            onNodeCheck: this.onNodeCheck,
            onNodeLoad: this.onNodeLoad,
            onNodeMouseEnter: this.onNodeMouseEnter,
            onNodeMouseLeave: this.onNodeMouseLeave,
            onNodeContextMenu: this.onNodeContextMenu,
            onNodeDragStart: this.onNodeDragStart,
            onNodeDragEnter: this.onNodeDragEnter,
            onNodeDragOver: this.onNodeDragOver,
            onNodeDragLeave: this.onNodeDragLeave,
            onNodeDragEnd: this.onNodeDragEnd,
            onNodeDrop: this.onNodeDrop
          },
          children: /*#__PURE__*/jsx$1("div", {
            role: "tree",
            className: classNames$1(prefixCls, className, rootClassName, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-show-line"), showLine), _defineProperty$1(_classNames, "".concat(prefixCls, "-focused"), focused), _defineProperty$1(_classNames, "".concat(prefixCls, "-active-focused"), activeKey !== null), _classNames)),
            style: rootStyle,
            children: /*#__PURE__*/jsx$1(NodeList, {
              ref: this.listRef,
              prefixCls: prefixCls,
              style: style,
              data: flattenNodes,
              disabled: disabled,
              selectable: selectable,
              checkable: !!checkable,
              motion: motion,
              dragging: draggingNodeKey !== null,
              height: height,
              itemHeight: itemHeight,
              virtual: virtual,
              focusable: focusable,
              focused: focused,
              tabIndex: tabIndex,
              activeItem: this.getActiveItem(),
              onFocus: this.onFocus,
              onBlur: this.onBlur,
              onKeyDown: this.onKeyDown,
              onActiveChange: this.onActiveChange,
              onListChangeStart: this.onListChangeStart,
              onListChangeEnd: this.onListChangeEnd,
              onContextMenu: onContextMenu,
              onScroll: onScroll,
              ...this.getTreeNodeRequiredProps(),
              ...domProps
            })
          })
        })
      );
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, prevState) {
      var prevProps = prevState.prevProps;
      var newState = {
        prevProps: props
      };
      function needSync(name) {
        return !prevProps && name in props || prevProps && prevProps[name] !== props[name];
      }
      // ================== Tree Node ==================
      var treeData;
      // fieldNames
      var fieldNames = prevState.fieldNames;
      if (needSync('fieldNames')) {
        fieldNames = fillFieldNames(props.fieldNames);
        newState.fieldNames = fieldNames;
      }
      // Check if `treeData` or `children` changed and save into the state.
      if (needSync('treeData')) {
        treeData = props.treeData;
      } else if (needSync('children')) {
        warningOnce(false, '`children` of Tree is deprecated. Please use `treeData` instead.');
        treeData = convertTreeToData(props.children);
      }
      // Save flatten nodes info and convert `treeData` into keyEntities
      if (treeData) {
        newState.treeData = treeData;
        var entitiesMap = convertDataToEntities(treeData, {
          fieldNames: fieldNames
        });
        newState.keyEntities = _objectSpread2$1(_defineProperty$1({}, MOTION_KEY, MotionEntity), entitiesMap.keyEntities);
      }
      var keyEntities = newState.keyEntities || prevState.keyEntities;
      // ================ expandedKeys =================
      if (needSync('expandedKeys') || prevProps && needSync('autoExpandParent')) {
        newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;
      } else if (!prevProps && props.defaultExpandAll) {
        var cloneKeyEntities = _objectSpread2$1({}, keyEntities);
        delete cloneKeyEntities[MOTION_KEY];
        newState.expandedKeys = Object.keys(cloneKeyEntities).map(function (key) {
          return cloneKeyEntities[key].key;
        });
      } else if (!prevProps && props.defaultExpandedKeys) {
        newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;
      }
      if (!newState.expandedKeys) {
        delete newState.expandedKeys;
      }
      // ================ flattenNodes =================
      if (treeData || newState.expandedKeys) {
        var flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);
        newState.flattenNodes = flattenNodes;
      }
      // ================ selectedKeys =================
      if (props.selectable) {
        if (needSync('selectedKeys')) {
          newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);
        } else if (!prevProps && props.defaultSelectedKeys) {
          newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);
        }
      }
      // ================= checkedKeys =================
      if (props.checkable) {
        var checkedKeyEntity;
        if (needSync('checkedKeys')) {
          checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};
        } else if (!prevProps && props.defaultCheckedKeys) {
          checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};
        } else if (treeData) {
          // If `treeData` changed, we also need check it
          checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {
            checkedKeys: prevState.checkedKeys,
            halfCheckedKeys: prevState.halfCheckedKeys
          };
        }
        if (checkedKeyEntity) {
          var _checkedKeyEntity = checkedKeyEntity,
            _checkedKeyEntity$che = _checkedKeyEntity.checkedKeys,
            checkedKeys = _checkedKeyEntity$che === void 0 ? [] : _checkedKeyEntity$che,
            _checkedKeyEntity$hal = _checkedKeyEntity.halfCheckedKeys,
            halfCheckedKeys = _checkedKeyEntity$hal === void 0 ? [] : _checkedKeyEntity$hal;
          if (!props.checkStrictly) {
            var conductKeys = conductCheck(checkedKeys, true, keyEntities);
            checkedKeys = conductKeys.checkedKeys;
            halfCheckedKeys = conductKeys.halfCheckedKeys;
          }
          newState.checkedKeys = checkedKeys;
          newState.halfCheckedKeys = halfCheckedKeys;
        }
      }
      // ================= loadedKeys ==================
      if (needSync('loadedKeys')) {
        newState.loadedKeys = props.loadedKeys;
      }
      return newState;
    }
  }]);
  return Tree;
}(react.exports.Component);
Tree$3.defaultProps = {
  prefixCls: 'rc-tree',
  showLine: false,
  showIcon: true,
  selectable: true,
  multiple: false,
  checkable: false,
  disabled: false,
  checkStrictly: false,
  draggable: false,
  defaultExpandParent: true,
  autoExpandParent: false,
  defaultExpandAll: false,
  defaultExpandedKeys: [],
  defaultCheckedKeys: [],
  defaultSelectedKeys: [],
  dropIndicatorRender: DropIndicator,
  allowDrop: function allowDrop() {
    return true;
  },
  expandAction: false
};
Tree$3.TreeNode = ContextTreeNode;

// This icon file is generated automatically.
var HolderOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M300 276.5a56 56 0 1056-97 56 56 0 00-56 97zm0 284a56 56 0 1056-97 56 56 0 00-56 97zM640 228a56 56 0 10112 0 56 56 0 00-112 0zm0 284a56 56 0 10112 0 56 56 0 00-112 0zM300 844.5a56 56 0 1056-97 56 56 0 00-56 97zM640 796a56 56 0 10112 0 56 56 0 00-112 0z" } }] }, "name": "holder", "theme": "outlined" };
const HolderOutlinedSvg = HolderOutlined$2;

var HolderOutlined = function HolderOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: HolderOutlinedSvg
      })
    })
  );
};
HolderOutlined.displayName = 'HolderOutlined';
const HolderOutlined$1 = /*#__PURE__*/react.exports.forwardRef(HolderOutlined);

var offset = 4;
function dropIndicatorRender(props) {
  var _style;
  var dropPosition = props.dropPosition,
    dropLevelOffset = props.dropLevelOffset,
    prefixCls = props.prefixCls,
    indent = props.indent,
    _props$direction = props.direction,
    direction = _props$direction === void 0 ? 'ltr' : _props$direction;
  var startPosition = direction === 'ltr' ? 'left' : 'right';
  var endPosition = direction === 'ltr' ? 'right' : 'left';
  var style = (_style = {}, _defineProperty$1(_style, startPosition, -dropLevelOffset * indent + offset), _defineProperty$1(_style, endPosition, 0), _style);
  switch (dropPosition) {
    case -1:
      style.top = -3;
      break;
    case 1:
      style.bottom = -3;
      break;
    default:
      // dropPosition === 0
      style.bottom = -3;
      style[startPosition] = indent + offset;
      break;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      style: style,
      className: prefixCls + "-drop-indicator"
    })
  );
}

// This icon file is generated automatically.
var CaretDownFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "filled" };
const CaretDownFilledSvg = CaretDownFilled$2;

var CaretDownFilled = function CaretDownFilled(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: CaretDownFilledSvg
      })
    })
  );
};
CaretDownFilled.displayName = 'CaretDownFilled';
const CaretDownFilled$1 = /*#__PURE__*/react.exports.forwardRef(CaretDownFilled);

// This icon file is generated automatically.
var FileOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" } }] }, "name": "file", "theme": "outlined" };
const FileOutlinedSvg = FileOutlined$2;

var FileOutlined = function FileOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: FileOutlinedSvg
      })
    })
  );
};
FileOutlined.displayName = 'FileOutlined';
const FileOutlined$1 = /*#__PURE__*/react.exports.forwardRef(FileOutlined);

// This icon file is generated automatically.
var MinusSquareOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "minus-square", "theme": "outlined" };
const MinusSquareOutlinedSvg = MinusSquareOutlined$2;

var MinusSquareOutlined = function MinusSquareOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: MinusSquareOutlinedSvg
      })
    })
  );
};
MinusSquareOutlined.displayName = 'MinusSquareOutlined';
const MinusSquareOutlined$1 = /*#__PURE__*/react.exports.forwardRef(MinusSquareOutlined);

// This icon file is generated automatically.
var PlusSquareOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "plus-square", "theme": "outlined" };
const PlusSquareOutlinedSvg = PlusSquareOutlined$2;

var PlusSquareOutlined = function PlusSquareOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: PlusSquareOutlinedSvg
      })
    })
  );
};
PlusSquareOutlined.displayName = 'PlusSquareOutlined';
const PlusSquareOutlined$1 = /*#__PURE__*/react.exports.forwardRef(PlusSquareOutlined);

function renderSwitcherIcon(prefixCls, switcherIcon, showLine, treeNodeProps) {
  var isLeaf = treeNodeProps.isLeaf,
    expanded = treeNodeProps.expanded,
    loading = treeNodeProps.loading;
  if (loading) {
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(LoadingOutlined$1, {
        className: prefixCls + "-switcher-loading-icon"
      })
    );
  }
  var showLeafIcon;
  if (showLine && _typeof$1(showLine) === 'object') {
    showLeafIcon = showLine.showLeafIcon;
  }
  if (isLeaf) {
    if (!showLine) {
      return null;
    }
    if (typeof showLeafIcon !== 'boolean' && !!showLeafIcon) {
      var leafIcon = typeof showLeafIcon === 'function' ? showLeafIcon(treeNodeProps) : showLeafIcon;
      var leafCls = prefixCls + "-switcher-line-custom-icon";
      if (isValidElement(leafIcon)) {
        return cloneElement(leafIcon, {
          className: classNames$1(leafIcon.props.className || '', leafCls)
        });
      }
      return leafIcon;
    }
    return showLeafIcon ?
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(FileOutlined$1, {
      className: prefixCls + "-switcher-line-icon"
    }) :
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      className: prefixCls + "-switcher-leaf-line"
    });
  }
  var switcherCls = prefixCls + "-switcher-icon";
  var switcher = typeof switcherIcon === 'function' ? switcherIcon(treeNodeProps) : switcherIcon;
  if (isValidElement(switcher)) {
    return cloneElement(switcher, {
      className: classNames$1(switcher.props.className || '', switcherCls)
    });
  }
  if (switcher) {
    return switcher;
  }
  if (showLine) {
    return expanded ?
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(MinusSquareOutlined$1, {
      className: prefixCls + "-switcher-line-icon"
    }) :
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(PlusSquareOutlined$1, {
      className: prefixCls + "-switcher-line-icon"
    });
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(CaretDownFilled$1, {
      className: switcherCls
    })
  );
}

// ============================ Keyframes =============================
var treeNodeFX = new Keyframe('ant-tree-node-fx-do-not-use', {
  '0%': {
    opacity: 0
  },
  '100%': {
    opacity: 1
  }
});
// ============================== Switch ==============================
var getSwitchStyle = function getSwitchStyle(prefixCls, token) {
  return _defineProperty$1({}, "." + prefixCls + "-switcher-icon", {
    display: 'inline-block',
    fontSize: 10,
    verticalAlign: 'baseline',
    svg: {
      transition: "transform " + token.motionDurationSlow
    }
  });
};
// =============================== Drop ===============================
var getDropIndicatorStyle = function getDropIndicatorStyle(prefixCls, token) {
  return _defineProperty$1({}, "." + prefixCls + "-drop-indicator", {
    position: 'absolute',
    // it should displayed over the following node
    zIndex: 1,
    height: 2,
    backgroundColor: token.colorPrimary,
    borderRadius: 1,
    pointerEvents: 'none',
    '&:after': {
      position: 'absolute',
      top: -3,
      insetInlineStart: -6,
      width: 8,
      height: 8,
      backgroundColor: 'transparent',
      border: token.lineWidthBold + "px solid " + token.colorPrimary,
      borderRadius: '50%',
      content: '""'
    }
  });
};
var genBaseStyle = function genBaseStyle(prefixCls, token) {
  var _ref3, _draggable, _ref7, _ref8, _showLine, _extends2;
  var treeCls = token.treeCls,
    treeNodeCls = token.treeNodeCls,
    treeNodePadding = token.treeNodePadding,
    treeTitleHeight = token.treeTitleHeight;
  var treeCheckBoxMarginVertical = (treeTitleHeight - token.fontSizeLG) / 2;
  var treeCheckBoxMarginHorizontal = token.paddingXS;
  return _defineProperty$1({}, treeCls, _extends$2(_extends$2({}, resetComponent(token)), (_extends2 = {
    background: token.colorBgContainer,
    borderRadius: token.borderRadius,
    transition: "background-color " + token.motionDurationSlow,
    '&&-rtl': _defineProperty$1({}, treeCls + "-switcher", {
      '&_close': _defineProperty$1({}, treeCls + "-switcher-icon", {
        svg: {
          transform: 'rotate(90deg)'
        }
      })
    }),
    '&-focused:not(:hover):not(&-active-focused)': _extends$2({}, genFocusOutline(token))
  }, _defineProperty$1(_extends2, treeCls + "-list-holder-inner", {
    alignItems: 'flex-start'
  }), _defineProperty$1(_extends2, "&" + treeCls + "-block-node", _defineProperty$1({}, treeCls + "-list-holder-inner", (_ref3 = {
    alignItems: 'stretch'
  }, _defineProperty$1(_ref3, treeCls + "-node-content-wrapper", {
    flex: 'auto'
  }), _defineProperty$1(_ref3, treeNodeCls + ".dragging", {
    position: 'relative',
    '&:after': {
      position: 'absolute',
      top: 0,
      insetInlineEnd: 0,
      bottom: treeNodePadding,
      insetInlineStart: 0,
      border: "1px solid " + token.colorPrimary,
      opacity: 0,
      animationName: treeNodeFX,
      animationDuration: token.motionDurationSlow,
      animationPlayState: 'running',
      animationFillMode: 'forwards',
      content: '""',
      pointerEvents: 'none'
    }
  }), _ref3))), _defineProperty$1(_extends2, "" + treeNodeCls, (_ref7 = {
    display: 'flex',
    alignItems: 'flex-start',
    padding: "0 0 " + treeNodePadding + "px 0",
    outline: 'none',
    '&-rtl': {
      direction: 'rtl'
    },
    // Disabled
    '&-disabled': _defineProperty$1({}, treeCls + "-node-content-wrapper", {
      color: token.colorTextDisabled,
      cursor: 'not-allowed',
      '&:hover': {
        background: 'transparent'
      }
    })
  }, _defineProperty$1(_ref7, "&-active " + treeCls + "-node-content-wrapper", _extends$2({}, genFocusOutline(token))), _defineProperty$1(_ref7, "&:not(&-disabled).filter-node " + treeCls + "-title", {
    color: 'inherit',
    fontWeight: 500
  }), _defineProperty$1(_ref7, '&-draggable', (_draggable = {}, _defineProperty$1(_draggable, treeCls + "-draggable-icon", _defineProperty$1({
    width: treeTitleHeight,
    lineHeight: treeTitleHeight + "px",
    textAlign: 'center',
    visibility: 'visible',
    opacity: 0.2,
    transition: "opacity " + token.motionDurationSlow
  }, treeNodeCls + ":hover &", {
    opacity: 0.45
  })), _defineProperty$1(_draggable, "&" + treeNodeCls + "-disabled", _defineProperty$1({}, treeCls + "-draggable-icon", {
    visibility: 'hidden'
  })), _draggable)), _ref7)), _defineProperty$1(_extends2, treeCls + "-indent", {
    alignSelf: 'stretch',
    whiteSpace: 'nowrap',
    userSelect: 'none',
    '&-unit': {
      display: 'inline-block',
      width: treeTitleHeight
    }
  }), _defineProperty$1(_extends2, treeCls + "-draggable-icon", {
    visibility: 'hidden'
  }), _defineProperty$1(_extends2, treeCls + "-switcher", _extends$2(_extends$2({}, getSwitchStyle(prefixCls, token)), {
    position: 'relative',
    flex: 'none',
    alignSelf: 'stretch',
    width: treeTitleHeight,
    margin: 0,
    lineHeight: treeTitleHeight + "px",
    textAlign: 'center',
    cursor: 'pointer',
    userSelect: 'none',
    '&-noop': {
      cursor: 'default'
    },
    '&_close': _defineProperty$1({}, treeCls + "-switcher-icon", {
      svg: {
        transform: 'rotate(-90deg)'
      }
    }),
    '&-loading-icon': {
      color: token.colorPrimary
    },
    '&-leaf-line': {
      position: 'relative',
      zIndex: 1,
      display: 'inline-block',
      width: '100%',
      height: '100%',
      // https://github.com/ant-design/ant-design/issues/31884
      '&:before': {
        position: 'absolute',
        top: 0,
        insetInlineEnd: treeTitleHeight / 2,
        bottom: -treeNodePadding,
        marginInlineStart: -1,
        borderInlineEnd: "1px solid " + token.colorBorder,
        content: '""'
      },
      '&:after': {
        position: 'absolute',
        width: treeTitleHeight / 2 * 0.8,
        height: treeTitleHeight / 2,
        borderBottom: "1px solid " + token.colorBorder,
        content: '""'
      }
    }
  })), _defineProperty$1(_extends2, treeCls + "-checkbox", {
    top: 'initial',
    marginInlineEnd: treeCheckBoxMarginHorizontal,
    marginBlockStart: treeCheckBoxMarginVertical
  }), _defineProperty$1(_extends2, treeCls + "-node-content-wrapper, " + treeCls + "-checkbox + span", (_ref8 = {
    position: 'relative',
    zIndex: 'auto',
    minHeight: treeTitleHeight,
    margin: 0,
    padding: "0 " + token.paddingXS / 2 + "px",
    color: 'inherit',
    lineHeight: treeTitleHeight + "px",
    background: 'transparent',
    borderRadius: token.borderRadius,
    cursor: 'pointer',
    transition: "all " + token.motionDurationMid + ", border 0s, line-height 0s, box-shadow 0s",
    '&:hover': {
      backgroundColor: token.controlItemBgHover
    }
  }, _defineProperty$1(_ref8, "&" + treeCls + "-node-selected", {
    backgroundColor: token.controlOutline
  }), _defineProperty$1(_ref8, treeCls + "-iconEle", {
    display: 'inline-block',
    width: treeTitleHeight,
    height: treeTitleHeight,
    lineHeight: treeTitleHeight + "px",
    textAlign: 'center',
    verticalAlign: 'top',
    '&:empty': {
      display: 'none'
    }
  }), _ref8)), _defineProperty$1(_extends2, treeCls + "-unselectable " + treeCls + "-node-content-wrapper:hover", {
    backgroundColor: 'transparent'
  }), _defineProperty$1(_extends2, treeCls + "-node-content-wrapper", _extends$2({
    lineHeight: treeTitleHeight + "px",
    userSelect: 'none'
  }, getDropIndicatorStyle(prefixCls, token))), _defineProperty$1(_extends2, treeNodeCls + ".drop-container", {
    '> [draggable]': {
      boxShadow: "0 0 0 2px " + token.colorPrimary
    }
  }), _defineProperty$1(_extends2, '&-show-line', (_showLine = {}, _defineProperty$1(_showLine, treeCls + "-indent", {
    '&-unit': {
      position: 'relative',
      height: '100%',
      '&:before': {
        position: 'absolute',
        top: 0,
        insetInlineEnd: treeTitleHeight / 2,
        bottom: -treeNodePadding,
        borderInlineEnd: "1px solid " + token.colorBorder,
        content: '""'
      },
      '&-end': {
        '&:before': {
          display: 'none'
        }
      }
    }
  }), _defineProperty$1(_showLine, treeCls + "-switcher", {
    background: token.colorBgContainer,
    '&-line-icon': {
      // https://github.com/ant-design/ant-design/issues/32813
      verticalAlign: '-0.15em'
    }
  }), _showLine)), _defineProperty$1(_extends2, treeNodeCls + "-leaf-last", _defineProperty$1({}, treeCls + "-switcher", {
    '&-leaf-line': {
      '&:before': {
        top: 'auto !important',
        bottom: 'auto !important',
        height: treeTitleHeight / 2 + "px !important"
      }
    }
  })), _extends2)));
};
// ============================ Directory =============================
var genDirectoryStyle = function genDirectoryStyle(token) {
  var _selected, _treeNodeCls;
  var treeCls = token.treeCls,
    treeNodeCls = token.treeNodeCls,
    treeNodePadding = token.treeNodePadding;
  return _defineProperty$1({}, "" + treeCls + treeCls + "-directory", _defineProperty$1({}, treeNodeCls, (_treeNodeCls = {
    position: 'relative',
    // Hover color
    '&:before': {
      position: 'absolute',
      top: 0,
      insetInlineEnd: 0,
      bottom: treeNodePadding,
      insetInlineStart: 0,
      transition: "background-color " + token.motionDurationMid,
      content: '""',
      pointerEvents: 'none'
    },
    '&:hover': {
      '&:before': {
        background: token.controlItemBgHover
      }
    },
    // Elements
    '> *': {
      zIndex: 1
    }
  }, _defineProperty$1(_treeNodeCls, treeCls + "-switcher", {
    transition: "color " + token.motionDurationMid
  }), _defineProperty$1(_treeNodeCls, treeCls + "-node-content-wrapper", _defineProperty$1({
    borderRadius: 0,
    userSelect: 'none',
    '&:hover': {
      background: 'transparent'
    }
  }, "&" + treeCls + "-node-selected", {
    color: token.colorTextLightSolid,
    background: 'transparent'
  })), _defineProperty$1(_treeNodeCls, '&-selected', (_selected = {}, _defineProperty$1(_selected, "\n            &:hover::before,\n            &::before\n          ", {
    background: token.colorPrimary
  }), _defineProperty$1(_selected, treeCls + "-switcher", {
    color: token.colorTextLightSolid
  }), _defineProperty$1(_selected, treeCls + "-node-content-wrapper", {
    color: token.colorTextLightSolid,
    background: 'transparent'
  }), _selected)), _treeNodeCls)));
};
// ============================== Merged ==============================
var genTreeStyle = function genTreeStyle(prefixCls, token) {
  var treeCls = "." + prefixCls;
  var treeNodeCls = treeCls + "-treenode";
  var treeNodePadding = token.paddingXS / 2;
  var treeTitleHeight = token.controlHeightSM;
  var treeToken = merge$2(token, {
    treeCls: treeCls,
    treeNodeCls: treeNodeCls,
    treeNodePadding: treeNodePadding,
    treeTitleHeight: treeTitleHeight
  });
  return [
  // Basic
  genBaseStyle(prefixCls, treeToken),
  // Directory
  genDirectoryStyle(treeToken)];
};
// ============================== Export ==============================
const useStyle$2 = genComponentStyleHook('Tree', function (token, _ref14) {
  var prefixCls = _ref14.prefixCls;
  return [_defineProperty$1({}, token.componentCls, getStyle(prefixCls + "-checkbox", token)), genTreeStyle(prefixCls, token), genCollapseMotion$1(token)];
});

var Tree$2 = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _classNames;
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction,
    virtual = _React$useContext.virtual;
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    _props$showIcon = props.showIcon,
    showIcon = _props$showIcon === void 0 ? false : _props$showIcon,
    showLine = props.showLine,
    _switcherIcon = props.switcherIcon,
    _props$blockNode = props.blockNode,
    blockNode = _props$blockNode === void 0 ? false : _props$blockNode,
    children = props.children,
    _props$checkable = props.checkable,
    checkable = _props$checkable === void 0 ? false : _props$checkable,
    _props$selectable = props.selectable,
    selectable = _props$selectable === void 0 ? true : _props$selectable,
    draggable = props.draggable,
    customMotion = props.motion;
  var prefixCls = getPrefixCls('tree', customizePrefixCls);
  var rootPrefixCls = getPrefixCls();
  var motion = customMotion !== null && customMotion !== void 0 ? customMotion : _extends$2(_extends$2({}, initCollapseMotion$1(rootPrefixCls)), {
    motionAppear: false
  });
  var newProps = _extends$2(_extends$2({}, props), {
    checkable: checkable,
    selectable: selectable,
    showIcon: showIcon,
    motion: motion,
    blockNode: blockNode,
    showLine: Boolean(showLine),
    dropIndicatorRender: dropIndicatorRender
  });
  var _useStyle = useStyle$2(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var draggableConfig = react.exports.useMemo(function () {
    if (!draggable) {
      return false;
    }
    var mergedDraggable = {};
    switch (_typeof$1(draggable)) {
      case 'function':
        mergedDraggable.nodeDraggable = draggable;
        break;
      case 'object':
        mergedDraggable = _extends$2({}, draggable);
        break;
      // Do nothing
    }

    if (mergedDraggable.icon !== false) {
      mergedDraggable.icon = mergedDraggable.icon ||
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(HolderOutlined$1, {});
    }
    return mergedDraggable;
  }, [draggable]);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(Tree$3, {
    itemHeight: 20,
    ref: ref,
    virtual: virtual,
    ...newProps,
    prefixCls: prefixCls,
    className: classNames$1((_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-icon-hide", !showIcon), _defineProperty$1(_classNames, prefixCls + "-block-node", blockNode), _defineProperty$1(_classNames, prefixCls + "-unselectable", !selectable), _defineProperty$1(_classNames, prefixCls + "-rtl", direction === 'rtl'), _classNames), className, hashId),
    direction: direction,
    checkable: checkable ?
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      className: prefixCls + "-checkbox-inner"
    }) : checkable,
    selectable: selectable,
    switcherIcon: function switcherIcon(nodeProps) {
      return renderSwitcherIcon(prefixCls, _switcherIcon, showLine, nodeProps);
    },
    draggable: draggableConfig,
    children: children
  }));
});
const TreePure = Tree$2;

// This icon file is generated automatically.
var FolderOpenOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z" } }] }, "name": "folder-open", "theme": "outlined" };
const FolderOpenOutlinedSvg = FolderOpenOutlined$2;

var FolderOpenOutlined = function FolderOpenOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: FolderOpenOutlinedSvg
      })
    })
  );
};
FolderOpenOutlined.displayName = 'FolderOpenOutlined';
const FolderOpenOutlined$1 = /*#__PURE__*/react.exports.forwardRef(FolderOpenOutlined);

// This icon file is generated automatically.
var FolderOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z" } }] }, "name": "folder", "theme": "outlined" };
const FolderOutlinedSvg = FolderOutlined$2;

var FolderOutlined = function FolderOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: FolderOutlinedSvg
      })
    })
  );
};
FolderOutlined.displayName = 'FolderOutlined';
const FolderOutlined$1 = /*#__PURE__*/react.exports.forwardRef(FolderOutlined);

var Record;
(function (Record) {
  Record[Record["None"] = 0] = "None";
  Record[Record["Start"] = 1] = "Start";
  Record[Record["End"] = 2] = "End";
})(Record || (Record = {}));
function traverseNodesKey(treeData, callback) {
  function processNode(dataNode) {
    var key = dataNode.key,
      children = dataNode.children;
    if (callback(key, dataNode) !== false) {
      traverseNodesKey(children || [], callback);
    }
  }
  treeData.forEach(processNode);
}
/** expanded */
function calcRangeKeys(_ref) {
  var treeData = _ref.treeData,
    expandedKeys = _ref.expandedKeys,
    startKey = _ref.startKey,
    endKey = _ref.endKey;
  var keys = [];
  var record = Record.None;
  if (startKey && startKey === endKey) {
    return [startKey];
  }
  if (!startKey || !endKey) {
    return [];
  }
  function matchKey(key) {
    return key === startKey || key === endKey;
  }
  traverseNodesKey(treeData, function (key) {
    if (record === Record.End) {
      return false;
    }
    if (matchKey(key)) {
      // Match test
      keys.push(key);
      if (record === Record.None) {
        record = Record.Start;
      } else if (record === Record.Start) {
        record = Record.End;
        return false;
      }
    } else if (record === Record.Start) {
      // Append selection
      keys.push(key);
    }
    return expandedKeys.includes(key);
  });
  return keys;
}
function convertDirectoryKeysToNodes(treeData, keys) {
  var restKeys = _toConsumableArray(keys);
  var nodes = [];
  traverseNodesKey(treeData, function (key, node) {
    var index = restKeys.indexOf(key);
    if (index !== -1) {
      nodes.push(node);
      restKeys.splice(index, 1);
    }
    return !!restKeys.length;
  });
  return nodes;
}

var __rest$8 = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function getIcon(props) {
  var isLeaf = props.isLeaf,
    expanded = props.expanded;
  if (isLeaf) {
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(FileOutlined$1, {})
    );
  }
  return expanded ?
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(FolderOpenOutlined$1, {}) :
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1(FolderOutlined$1, {});
}
function getTreeData(_ref) {
  var treeData = _ref.treeData,
    children = _ref.children;
  return treeData || convertTreeToData(children);
}
var DirectoryTree = function DirectoryTree(_a, ref) {
  var defaultExpandAll = _a.defaultExpandAll,
    defaultExpandParent = _a.defaultExpandParent,
    defaultExpandedKeys = _a.defaultExpandedKeys,
    props = __rest$8(_a, ["defaultExpandAll", "defaultExpandParent", "defaultExpandedKeys"]);
  // Shift click usage
  var lastSelectedKey = react.exports.useRef();
  var cachedSelectedKeys = react.exports.useRef();
  var getInitExpandedKeys = function getInitExpandedKeys() {
    var _convertDataToEntitie = convertDataToEntities(getTreeData(props)),
      keyEntities = _convertDataToEntitie.keyEntities;
    var initExpandedKeys;
    // Expanded keys
    if (defaultExpandAll) {
      initExpandedKeys = Object.keys(keyEntities);
    } else if (defaultExpandParent) {
      initExpandedKeys = conductExpandParent(props.expandedKeys || defaultExpandedKeys || [], keyEntities);
    } else {
      initExpandedKeys = props.expandedKeys || defaultExpandedKeys;
    }
    return initExpandedKeys;
  };
  var _React$useState = react.exports.useState(props.selectedKeys || props.defaultSelectedKeys || []),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    selectedKeys = _React$useState2[0],
    setSelectedKeys = _React$useState2[1];
  var _React$useState3 = react.exports.useState(function () {
      return getInitExpandedKeys();
    }),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    expandedKeys = _React$useState4[0],
    setExpandedKeys = _React$useState4[1];
  react.exports.useEffect(function () {
    if ('selectedKeys' in props) {
      setSelectedKeys(props.selectedKeys);
    }
  }, [props.selectedKeys]);
  react.exports.useEffect(function () {
    if ('expandedKeys' in props) {
      setExpandedKeys(props.expandedKeys);
    }
  }, [props.expandedKeys]);
  var onExpand = function onExpand(keys, info) {
    var _a;
    if (!('expandedKeys' in props)) {
      setExpandedKeys(keys);
    }
    // Call origin function
    return (_a = props.onExpand) === null || _a === void 0 ? void 0 : _a.call(props, keys, info);
  };
  var onSelect = function onSelect(keys, event) {
    var _a;
    var multiple = props.multiple;
    var node = event.node,
      nativeEvent = event.nativeEvent;
    var _node$key = node.key,
      key = _node$key === void 0 ? '' : _node$key;
    var treeData = getTreeData(props);
    // const newState: DirectoryTreeState = {};
    // We need wrap this event since some value is not same
    var newEvent = _extends$2(_extends$2({}, event), {
      selected: true
    });
    // Windows / Mac single pick
    var ctrlPick = (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.ctrlKey) || (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.metaKey);
    var shiftPick = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.shiftKey;
    // Generate new selected keys
    var newSelectedKeys;
    if (multiple && ctrlPick) {
      // Control click
      newSelectedKeys = keys;
      lastSelectedKey.current = key;
      cachedSelectedKeys.current = newSelectedKeys;
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys);
    } else if (multiple && shiftPick) {
      // Shift click
      newSelectedKeys = Array.from(new Set([].concat(_toConsumableArray(cachedSelectedKeys.current || []), _toConsumableArray(calcRangeKeys({
        treeData: treeData,
        expandedKeys: expandedKeys,
        startKey: key,
        endKey: lastSelectedKey.current
      })))));
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys);
    } else {
      // Single click
      newSelectedKeys = [key];
      lastSelectedKey.current = key;
      cachedSelectedKeys.current = newSelectedKeys;
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys);
    }
    (_a = props.onSelect) === null || _a === void 0 ? void 0 : _a.call(props, newSelectedKeys, newEvent);
    if (!('selectedKeys' in props)) {
      setSelectedKeys(newSelectedKeys);
    }
  };
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    _props$showIcon = props.showIcon,
    showIcon = _props$showIcon === void 0 ? true : _props$showIcon,
    _props$expandAction = props.expandAction,
    expandAction = _props$expandAction === void 0 ? 'click' : _props$expandAction,
    otherProps = __rest$8(props, ["prefixCls", "className", "showIcon", "expandAction"]);
  var prefixCls = getPrefixCls('tree', customizePrefixCls);
  var connectClassName = classNames$1(prefixCls + "-directory", _defineProperty$1({}, prefixCls + "-directory-rtl", direction === 'rtl'), className);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(TreePure, {
      icon: getIcon,
      ref: ref,
      blockNode: true,
      ...otherProps,
      showIcon: showIcon,
      expandAction: expandAction,
      prefixCls: prefixCls,
      className: connectClassName,
      expandedKeys: expandedKeys,
      selectedKeys: selectedKeys,
      onSelect: onSelect,
      onExpand: onExpand
    })
  );
};
var ForwardDirectoryTree = /*#__PURE__*/react.exports.forwardRef(DirectoryTree);
const DirectoryTree$1 = ForwardDirectoryTree;

var Tree = TreePure;
Tree.DirectoryTree = DirectoryTree$1;
Tree.TreeNode = ContextTreeNode;
const Tree$1 = Tree;

function useSyncState(initialValue) {
  var ref = react.exports.useRef(initialValue);
  var forceUpdate = useForceUpdate();
  return [function () {
    return ref.current;
  }, function (newValue) {
    ref.current = newValue;
    // re-render
    forceUpdate();
  }];
}

function FilterSearch(_ref) {
  var value = _ref.value,
    onChange = _ref.onChange,
    filterSearch = _ref.filterSearch,
    tablePrefixCls = _ref.tablePrefixCls,
    locale = _ref.locale;
  if (!filterSearch) {
    return null;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      className: tablePrefixCls + "-filter-dropdown-search",
      children: /*#__PURE__*/jsx$1(Input$2, {
        prefix:
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(SearchOutlined$1, {}),
        placeholder: locale.filterSearchPlaceholder,
        onChange: onChange,
        value: value,
        htmlSize: 1,
        className: tablePrefixCls + "-filter-dropdown-search-input"
      })
    })
  );
}

var onKeyDown = function onKeyDown(event) {
  var keyCode = event.keyCode;
  if (keyCode === KeyCode.ENTER) {
    event.stopPropagation();
  }
};
var FilterDropdownMenuWrapper = function FilterDropdownMenuWrapper(props) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      className: props.className,
      onClick: function onClick(e) {
        return e.stopPropagation();
      },
      onKeyDown: onKeyDown,
      children: props.children
    })
  );
};
const FilterDropdownMenuWrapper$1 = FilterDropdownMenuWrapper;

function hasSubMenu(filters) {
  return filters.some(function (_ref) {
    var children = _ref.children;
    return children;
  });
}
function searchValueMatched(searchValue, text) {
  if (typeof text === 'string' || typeof text === 'number') {
    return text === null || text === void 0 ? void 0 : text.toString().toLowerCase().includes(searchValue.trim().toLowerCase());
  }
  return false;
}
function renderFilterItems(_ref2) {
  var filters = _ref2.filters,
    prefixCls = _ref2.prefixCls,
    filteredKeys = _ref2.filteredKeys,
    filterMultiple = _ref2.filterMultiple,
    searchValue = _ref2.searchValue,
    filterSearch = _ref2.filterSearch;
  return filters.map(function (filter, index) {
    var key = String(filter.value);
    if (filter.children) {
      return {
        key: key || index,
        label: filter.text,
        popupClassName: prefixCls + "-dropdown-submenu",
        children: renderFilterItems({
          filters: filter.children,
          prefixCls: prefixCls,
          filteredKeys: filteredKeys,
          filterMultiple: filterMultiple,
          searchValue: searchValue,
          filterSearch: filterSearch
        })
      };
    }
    var Component = filterMultiple ? Checkbox$1 : Radio$1;
    var item = {
      key: filter.value !== undefined ? key : index,
      label:
      /*#__PURE__*/
      /*#__PURE__*/
      jsxs(Fragment, {
        children: [/*#__PURE__*/jsx$1(Component, {
          checked: filteredKeys.includes(key)
        }), /*#__PURE__*/jsx$1("span", {
          children: filter.text
        })]
      })
    };
    if (searchValue.trim()) {
      if (typeof filterSearch === 'function') {
        return filterSearch(searchValue, filter) ? item : null;
      }
      return searchValueMatched(searchValue, filter.text) ? item : null;
    }
    return item;
  });
}
function FilterDropdown(props) {
  var _a, _b;
  var tablePrefixCls = props.tablePrefixCls,
    prefixCls = props.prefixCls,
    column = props.column,
    dropdownPrefixCls = props.dropdownPrefixCls,
    columnKey = props.columnKey,
    filterMultiple = props.filterMultiple,
    _props$filterMode = props.filterMode,
    filterMode = _props$filterMode === void 0 ? 'menu' : _props$filterMode,
    _props$filterSearch = props.filterSearch,
    filterSearch = _props$filterSearch === void 0 ? false : _props$filterSearch,
    filterState = props.filterState,
    triggerFilter = props.triggerFilter,
    locale = props.locale,
    children = props.children,
    getPopupContainer = props.getPopupContainer;
  var filterDropdownOpen = column.filterDropdownOpen,
    onFilterDropdownOpenChange = column.onFilterDropdownOpenChange,
    filterResetToDefaultFilteredValue = column.filterResetToDefaultFilteredValue,
    defaultFilteredValue = column.defaultFilteredValue,
    filterDropdownVisible = column.filterDropdownVisible,
    onFilterDropdownVisibleChange = column.onFilterDropdownVisibleChange;
  var _React$useState = react.exports.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    visible = _React$useState2[0],
    setVisible = _React$useState2[1];
  var filtered = !!(filterState && (((_a = filterState.filteredKeys) === null || _a === void 0 ? void 0 : _a.length) || filterState.forceFiltered));
  var triggerVisible = function triggerVisible(newVisible) {
    setVisible(newVisible);
    onFilterDropdownOpenChange === null || onFilterDropdownOpenChange === void 0 ? void 0 : onFilterDropdownOpenChange(newVisible);
    onFilterDropdownVisibleChange === null || onFilterDropdownVisibleChange === void 0 ? void 0 : onFilterDropdownVisibleChange(newVisible);
  };
  var mergedVisible = (_b = filterDropdownOpen !== null && filterDropdownOpen !== void 0 ? filterDropdownOpen : filterDropdownVisible) !== null && _b !== void 0 ? _b : visible;
  // ===================== Select Keys =====================
  var propFilteredKeys = filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys;
  var _useSyncState = useSyncState(propFilteredKeys || []),
    _useSyncState2 = _slicedToArray(_useSyncState, 2),
    getFilteredKeysSync = _useSyncState2[0],
    setFilteredKeysSync = _useSyncState2[1];
  var onSelectKeys = function onSelectKeys(_ref5) {
    var selectedKeys = _ref5.selectedKeys;
    setFilteredKeysSync(selectedKeys);
  };
  var onCheck = function onCheck(keys, _ref6) {
    var node = _ref6.node,
      checked = _ref6.checked;
    if (!filterMultiple) {
      onSelectKeys({
        selectedKeys: checked && node.key ? [node.key] : []
      });
    } else {
      onSelectKeys({
        selectedKeys: keys
      });
    }
  };
  react.exports.useEffect(function () {
    if (!visible) {
      return;
    }
    onSelectKeys({
      selectedKeys: propFilteredKeys || []
    });
  }, [propFilteredKeys]);
  // ====================== Open Keys ======================
  var _React$useState3 = react.exports.useState([]),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    openKeys = _React$useState4[0],
    setOpenKeys = _React$useState4[1];
  var onOpenChange = function onOpenChange(keys) {
    setOpenKeys(keys);
  };
  // search in tree mode column filter
  var _React$useState5 = react.exports.useState(''),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    searchValue = _React$useState6[0],
    setSearchValue = _React$useState6[1];
  var onSearch = function onSearch(e) {
    var value = e.target.value;
    setSearchValue(value);
  };
  // clear search value after close filter dropdown
  react.exports.useEffect(function () {
    if (!visible) {
      setSearchValue('');
    }
  }, [visible]);
  // ======================= Submit ========================
  var internalTriggerFilter = function internalTriggerFilter(keys) {
    var mergedKeys = keys && keys.length ? keys : null;
    if (mergedKeys === null && (!filterState || !filterState.filteredKeys)) {
      return null;
    }
    if (shallowequal(mergedKeys, filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys)) {
      return null;
    }
    triggerFilter({
      column: column,
      key: columnKey,
      filteredKeys: mergedKeys
    });
  };
  var onConfirm = function onConfirm() {
    triggerVisible(false);
    internalTriggerFilter(getFilteredKeysSync());
  };
  var onReset = function onReset() {
    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        confirm: false,
        closeDropdown: false
      },
      confirm = _ref7.confirm,
      closeDropdown = _ref7.closeDropdown;
    if (confirm) {
      internalTriggerFilter([]);
    }
    if (closeDropdown) {
      triggerVisible(false);
    }
    setSearchValue('');
    if (filterResetToDefaultFilteredValue) {
      setFilteredKeysSync((defaultFilteredValue || []).map(function (key) {
        return String(key);
      }));
    } else {
      setFilteredKeysSync([]);
    }
  };
  var doFilter = function doFilter() {
    var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        closeDropdown: true
      },
      closeDropdown = _ref8.closeDropdown;
    if (closeDropdown) {
      triggerVisible(false);
    }
    internalTriggerFilter(getFilteredKeysSync());
  };
  var onVisibleChange = function onVisibleChange(newVisible) {
    if (newVisible && propFilteredKeys !== undefined) {
      // Sync filteredKeys on appear in controlled mode (propFilteredKeys !== undefiend)
      setFilteredKeysSync(propFilteredKeys || []);
    }
    triggerVisible(newVisible);
    // Default will filter when closed
    if (!newVisible && !column.filterDropdown) {
      onConfirm();
    }
  };
  // ======================== Style ========================
  var dropdownMenuClass = classNames$1(_defineProperty$1({}, dropdownPrefixCls + "-menu-without-submenu", !hasSubMenu(column.filters || [])));
  var onCheckAll = function onCheckAll(e) {
    if (e.target.checked) {
      var allFilterKeys = flattenKeys(column === null || column === void 0 ? void 0 : column.filters).map(function (key) {
        return String(key);
      });
      setFilteredKeysSync(allFilterKeys);
    } else {
      setFilteredKeysSync([]);
    }
  };
  var getTreeData = function getTreeData(_ref9) {
    var filters = _ref9.filters;
    return (filters || []).map(function (filter, index) {
      var key = String(filter.value);
      var item = {
        title: filter.text,
        key: filter.value !== undefined ? key : index
      };
      if (filter.children) {
        item.children = getTreeData({
          filters: filter.children
        });
      }
      return item;
    });
  };
  var getFilterData = function getFilterData(node) {
    var _a;
    return _extends$2(_extends$2({}, node), {
      text: node.title,
      value: node.key,
      children: ((_a = node.children) === null || _a === void 0 ? void 0 : _a.map(function (item) {
        return getFilterData(item);
      })) || []
    });
  };
  var dropdownContent;
  if (typeof column.filterDropdown === 'function') {
    dropdownContent = column.filterDropdown({
      prefixCls: dropdownPrefixCls + "-custom",
      setSelectedKeys: function setSelectedKeys(selectedKeys) {
        return onSelectKeys({
          selectedKeys: selectedKeys
        });
      },
      selectedKeys: getFilteredKeysSync(),
      confirm: doFilter,
      clearFilters: onReset,
      filters: column.filters,
      visible: mergedVisible,
      close: function close() {
        triggerVisible(false);
      }
    });
  } else if (column.filterDropdown) {
    dropdownContent = column.filterDropdown;
  } else {
    var selectedKeys = getFilteredKeysSync() || [];
    var getFilterComponent = function getFilterComponent() {
      if ((column.filters || []).length === 0) {
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(Empty$1, {
            image: Empty$1.PRESENTED_IMAGE_SIMPLE,
            description: locale.filterEmptyText,
            imageStyle: {
              height: 24
            },
            style: {
              margin: 0,
              padding: '16px 0'
            }
          })
        );
      }
      if (filterMode === 'tree') {
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsxs(Fragment, {
            children: [/*#__PURE__*/jsx$1(FilterSearch, {
              filterSearch: filterSearch,
              value: searchValue,
              onChange: onSearch,
              tablePrefixCls: tablePrefixCls,
              locale: locale
            }), /*#__PURE__*/jsxs("div", {
              className: tablePrefixCls + "-filter-dropdown-tree",
              children: [filterMultiple ?
              /*#__PURE__*/
              /*#__PURE__*/
              jsx$1(Checkbox$1, {
                checked: selectedKeys.length === flattenKeys(column.filters).length,
                indeterminate: selectedKeys.length > 0 && selectedKeys.length < flattenKeys(column.filters).length,
                className: tablePrefixCls + "-filter-dropdown-checkall",
                onChange: onCheckAll,
                children: locale.filterCheckall
              }) : null, /*#__PURE__*/jsx$1(Tree$1, {
                checkable: true,
                selectable: false,
                blockNode: true,
                multiple: filterMultiple,
                checkStrictly: !filterMultiple,
                className: dropdownPrefixCls + "-menu",
                onCheck: onCheck,
                checkedKeys: selectedKeys,
                selectedKeys: selectedKeys,
                showIcon: false,
                treeData: getTreeData({
                  filters: column.filters
                }),
                autoExpandParent: true,
                defaultExpandAll: true,
                filterTreeNode: searchValue.trim() ? function (node) {
                  if (typeof filterSearch === 'function') {
                    return filterSearch(searchValue, getFilterData(node));
                  }
                  return searchValueMatched(searchValue, node.title);
                } : undefined
              })]
            })]
          })
        );
      }
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsxs(Fragment, {
          children: [/*#__PURE__*/jsx$1(FilterSearch, {
            filterSearch: filterSearch,
            value: searchValue,
            onChange: onSearch,
            tablePrefixCls: tablePrefixCls,
            locale: locale
          }), /*#__PURE__*/jsx$1(Menu$2, {
            selectable: true,
            multiple: filterMultiple,
            prefixCls: dropdownPrefixCls + "-menu",
            className: dropdownMenuClass,
            onSelect: onSelectKeys,
            onDeselect: onSelectKeys,
            selectedKeys: selectedKeys,
            getPopupContainer: getPopupContainer,
            openKeys: openKeys,
            onOpenChange: onOpenChange,
            items: renderFilterItems({
              filters: column.filters || [],
              filterSearch: filterSearch,
              prefixCls: prefixCls,
              filteredKeys: getFilteredKeysSync(),
              filterMultiple: filterMultiple,
              searchValue: searchValue
            })
          })]
        })
      );
    };
    var getResetDisabled = function getResetDisabled() {
      if (filterResetToDefaultFilteredValue) {
        return shallowequal((defaultFilteredValue || []).map(function (key) {
          return String(key);
        }), selectedKeys);
      }
      return selectedKeys.length === 0;
    };
    dropdownContent =
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs(Fragment, {
      children: [getFilterComponent(), /*#__PURE__*/jsxs("div", {
        className: prefixCls + "-dropdown-btns",
        children: [/*#__PURE__*/jsx$1(Button$2, {
          type: "link",
          size: "small",
          disabled: getResetDisabled(),
          onClick: function onClick() {
            return onReset();
          },
          children: locale.filterReset
        }), /*#__PURE__*/jsx$1(Button$2, {
          type: "primary",
          size: "small",
          onClick: onConfirm,
          children: locale.filterConfirm
        })]
      })]
    });
  }
  // We should not block customize Menu with additional props
  if (column.filterDropdown) {
    dropdownContent =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(OverrideProvider, {
      selectable: undefined,
      children: dropdownContent
    });
  }
  var menu = function menu() {
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(FilterDropdownMenuWrapper$1, {
        className: prefixCls + "-dropdown",
        children: dropdownContent
      })
    );
  };
  var filterIcon;
  if (typeof column.filterIcon === 'function') {
    filterIcon = column.filterIcon(filtered);
  } else if (column.filterIcon) {
    filterIcon = column.filterIcon;
  } else {
    filterIcon =
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(FilterFilled$1, {});
  }
  var _React$useContext = react.exports.useContext(ConfigContext),
    direction = _React$useContext.direction;
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs("div", {
      className: prefixCls + "-column",
      children: [/*#__PURE__*/jsx$1("span", {
        className: tablePrefixCls + "-column-title",
        children: children
      }), /*#__PURE__*/jsx$1(Dropdown$1, {
        dropdownRender: menu,
        trigger: ['click'],
        open: mergedVisible,
        onOpenChange: onVisibleChange,
        getPopupContainer: getPopupContainer,
        placement: direction === 'rtl' ? 'bottomLeft' : 'bottomRight',
        children: /*#__PURE__*/jsx$1("span", {
          role: "button",
          tabIndex: -1,
          className: classNames$1(prefixCls + "-trigger", {
            active: filtered
          }),
          onClick: function onClick(e) {
            e.stopPropagation();
          },
          children: filterIcon
        })
      })]
    })
  );
}

function collectFilterStates(columns, init, pos) {
  var filterStates = [];
  (columns || []).forEach(function (column, index) {
    var _a;
    var columnPos = getColumnPos(index, pos);
    if (column.filters || 'filterDropdown' in column || 'onFilter' in column) {
      if ('filteredValue' in column) {
        // Controlled
        var filteredValues = column.filteredValue;
        if (!('filterDropdown' in column)) {
          filteredValues = (_a = filteredValues === null || filteredValues === void 0 ? void 0 : filteredValues.map(String)) !== null && _a !== void 0 ? _a : filteredValues;
        }
        filterStates.push({
          column: column,
          key: getColumnKey(column, columnPos),
          filteredKeys: filteredValues,
          forceFiltered: column.filtered
        });
      } else {
        // Uncontrolled
        filterStates.push({
          column: column,
          key: getColumnKey(column, columnPos),
          filteredKeys: init && column.defaultFilteredValue ? column.defaultFilteredValue : undefined,
          forceFiltered: column.filtered
        });
      }
    }
    if ('children' in column) {
      filterStates = [].concat(_toConsumableArray(filterStates), _toConsumableArray(collectFilterStates(column.children, init, columnPos)));
    }
  });
  return filterStates;
}
function injectFilter(prefixCls, dropdownPrefixCls, columns, filterStates, triggerFilter, getPopupContainer, locale, pos) {
  return columns.map(function (column, index) {
    var columnPos = getColumnPos(index, pos);
    var _column$filterMultipl = column.filterMultiple,
      filterMultiple = _column$filterMultipl === void 0 ? true : _column$filterMultipl,
      filterMode = column.filterMode,
      filterSearch = column.filterSearch;
    var newColumn = column;
    if (newColumn.filters || newColumn.filterDropdown) {
      var columnKey = getColumnKey(newColumn, columnPos);
      var filterState = filterStates.find(function (_ref) {
        var key = _ref.key;
        return columnKey === key;
      });
      newColumn = _extends$2(_extends$2({}, newColumn), {
        title: function title(renderProps) {
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1(FilterDropdown, {
              tablePrefixCls: prefixCls,
              prefixCls: prefixCls + "-filter",
              dropdownPrefixCls: dropdownPrefixCls,
              column: newColumn,
              columnKey: columnKey,
              filterState: filterState,
              filterMultiple: filterMultiple,
              filterMode: filterMode,
              filterSearch: filterSearch,
              triggerFilter: triggerFilter,
              locale: locale,
              getPopupContainer: getPopupContainer,
              children: renderColumnTitle(column.title, renderProps)
            })
          );
        }
      });
    }
    if ('children' in newColumn) {
      newColumn = _extends$2(_extends$2({}, newColumn), {
        children: injectFilter(prefixCls, dropdownPrefixCls, newColumn.children, filterStates, triggerFilter, getPopupContainer, locale, columnPos)
      });
    }
    return newColumn;
  });
}
function flattenKeys(filters) {
  var keys = [];
  (filters || []).forEach(function (_ref2) {
    var value = _ref2.value,
      children = _ref2.children;
    keys.push(value);
    if (children) {
      keys = [].concat(_toConsumableArray(keys), _toConsumableArray(flattenKeys(children)));
    }
  });
  return keys;
}
function generateFilterInfo(filterStates) {
  var currentFilters = {};
  filterStates.forEach(function (_ref3) {
    var key = _ref3.key,
      filteredKeys = _ref3.filteredKeys,
      column = _ref3.column;
    var filters = column.filters,
      filterDropdown = column.filterDropdown;
    if (filterDropdown) {
      currentFilters[key] = filteredKeys || null;
    } else if (Array.isArray(filteredKeys)) {
      var keys = flattenKeys(filters);
      currentFilters[key] = keys.filter(function (originKey) {
        return filteredKeys.includes(String(originKey));
      });
    } else {
      currentFilters[key] = null;
    }
  });
  return currentFilters;
}
function getFilterData(data, filterStates) {
  return filterStates.reduce(function (currentData, filterState) {
    var _filterState$column = filterState.column,
      onFilter = _filterState$column.onFilter,
      filters = _filterState$column.filters,
      filteredKeys = filterState.filteredKeys;
    if (onFilter && filteredKeys && filteredKeys.length) {
      return currentData.filter(function (record) {
        return filteredKeys.some(function (key) {
          var keys = flattenKeys(filters);
          var keyIndex = keys.findIndex(function (k) {
            return String(k) === String(key);
          });
          var realKey = keyIndex !== -1 ? keys[keyIndex] : key;
          return onFilter(realKey, record);
        });
      });
    }
    return currentData;
  }, data);
}
function useFilter(_ref4) {
  var prefixCls = _ref4.prefixCls,
    dropdownPrefixCls = _ref4.dropdownPrefixCls,
    mergedColumns = _ref4.mergedColumns,
    onFilterChange = _ref4.onFilterChange,
    getPopupContainer = _ref4.getPopupContainer,
    tableLocale = _ref4.locale;
  var _React$useState = react.exports.useState(function () {
      return collectFilterStates(mergedColumns, true);
    }),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    filterStates = _React$useState2[0],
    setFilterStates = _React$useState2[1];
  var mergedFilterStates = react.exports.useMemo(function () {
    var collectedStates = collectFilterStates(mergedColumns, false);
    if (collectedStates.length === 0) {
      return collectedStates;
    }
    var filteredKeysIsAllNotControlled = true;
    collectedStates.forEach(function (_ref5) {
      var filteredKeys = _ref5.filteredKeys;
      if (filteredKeys !== undefined) {
        filteredKeysIsAllNotControlled = false;
      }
    });
    // Return if not controlled
    if (filteredKeysIsAllNotControlled) {
      // Filter column may have been removed
      var keyList = (mergedColumns || []).map(function (column, index) {
        return getColumnKey(column, getColumnPos(index));
      });
      return filterStates.filter(function (_ref6) {
        var key = _ref6.key;
        return keyList.includes(key);
      });
    }
    return collectedStates;
  }, [mergedColumns, filterStates]);
  var filters = react.exports.useMemo(function () {
    return generateFilterInfo(mergedFilterStates);
  }, [mergedFilterStates]);
  var triggerFilter = function triggerFilter(filterState) {
    var newFilterStates = mergedFilterStates.filter(function (_ref7) {
      var key = _ref7.key;
      return key !== filterState.key;
    });
    newFilterStates.push(filterState);
    setFilterStates(newFilterStates);
    onFilterChange(generateFilterInfo(newFilterStates), newFilterStates);
  };
  var transformColumns = function transformColumns(innerColumns) {
    return injectFilter(prefixCls, dropdownPrefixCls, innerColumns, mergedFilterStates, triggerFilter, getPopupContainer, tableLocale);
  };
  return [transformColumns, mergedFilterStates, filters];
}

function useLazyKVMap(data, childrenColumnName, getRowKey) {
  var mapCacheRef = react.exports.useRef({});
  function getRecordByKey(key) {
    if (!mapCacheRef.current || mapCacheRef.current.data !== data || mapCacheRef.current.childrenColumnName !== childrenColumnName || mapCacheRef.current.getRowKey !== getRowKey) {
      var kvMap = new Map();
      /* eslint-disable no-inner-declarations */
      function dig(records) {
        records.forEach(function (record, index) {
          var rowKey = getRowKey(record, index);
          kvMap.set(rowKey, record);
          if (record && _typeof$1(record) === 'object' && childrenColumnName in record) {
            dig(record[childrenColumnName] || []);
          }
        });
      }
      /* eslint-enable */
      dig(data);
      mapCacheRef.current = {
        data: data,
        childrenColumnName: childrenColumnName,
        kvMap: kvMap,
        getRowKey: getRowKey
      };
    }
    return mapCacheRef.current.kvMap.get(key);
  }
  return [getRecordByKey];
}

var __rest$7 = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var DEFAULT_PAGE_SIZE = 10;
function getPaginationParam(pagination, mergedPagination) {
  var param = {
    current: mergedPagination.current,
    pageSize: mergedPagination.pageSize
  };
  var paginationObj = pagination && _typeof$1(pagination) === 'object' ? pagination : {};
  Object.keys(paginationObj).forEach(function (pageProp) {
    var value = mergedPagination[pageProp];
    if (typeof value !== 'function') {
      param[pageProp] = value;
    }
  });
  return param;
}
function extendsObject() {
  var result = {};
  for (var _len = arguments.length, list = new Array(_len), _key = 0; _key < _len; _key++) {
    list[_key] = arguments[_key];
  }
  list.forEach(function (obj) {
    if (obj) {
      Object.keys(obj).forEach(function (key) {
        var val = obj[key];
        if (val !== undefined) {
          result[key] = val;
        }
      });
    }
  });
  return result;
}
function usePagination(total, pagination, onChange) {
  var _a = pagination && _typeof$1(pagination) === 'object' ? pagination : {},
    _a$total = _a.total,
    paginationTotal = _a$total === void 0 ? 0 : _a$total,
    paginationObj = __rest$7(_a, ["total"]);
  var _useState = react.exports.useState(function () {
      return {
        current: 'defaultCurrent' in paginationObj ? paginationObj.defaultCurrent : 1,
        pageSize: 'defaultPageSize' in paginationObj ? paginationObj.defaultPageSize : DEFAULT_PAGE_SIZE
      };
    }),
    _useState2 = _slicedToArray(_useState, 2),
    innerPagination = _useState2[0],
    setInnerPagination = _useState2[1];
  // ============ Basic Pagination Config ============
  var mergedPagination = extendsObject(innerPagination, paginationObj, {
    total: paginationTotal > 0 ? paginationTotal : total
  });
  // Reset `current` if data length or pageSize changed
  var maxPage = Math.ceil((paginationTotal || total) / mergedPagination.pageSize);
  if (mergedPagination.current > maxPage) {
    // Prevent a maximum page count of 0
    mergedPagination.current = maxPage || 1;
  }
  var refreshPagination = function refreshPagination(current, pageSize) {
    setInnerPagination({
      current: current !== null && current !== void 0 ? current : 1,
      pageSize: pageSize || mergedPagination.pageSize
    });
  };
  var onInternalChange = function onInternalChange(current, pageSize) {
    var _a;
    if (pagination) {
      (_a = pagination.onChange) === null || _a === void 0 ? void 0 : _a.call(pagination, current, pageSize);
    }
    refreshPagination(current, pageSize);
    onChange(current, pageSize || (mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.pageSize));
  };
  if (pagination === false) {
    return [{}, function () {}];
  }
  return [_extends$2(_extends$2({}, mergedPagination), {
    onChange: onInternalChange
  }), refreshPagination];
}

var SELECTION_COLUMN = {};
var SELECTION_ALL = 'SELECT_ALL';
var SELECTION_INVERT = 'SELECT_INVERT';
var SELECTION_NONE = 'SELECT_NONE';
var EMPTY_LIST$1 = [];
function flattenData(data, childrenColumnName) {
  var list = [];
  (data || []).forEach(function (record) {
    list.push(record);
    if (record && _typeof$1(record) === 'object' && childrenColumnName in record) {
      list = [].concat(_toConsumableArray(list), _toConsumableArray(flattenData(record[childrenColumnName], childrenColumnName)));
    }
  });
  return list;
}
function useSelection(rowSelection, config) {
  var _ref = rowSelection || {},
    preserveSelectedRowKeys = _ref.preserveSelectedRowKeys,
    selectedRowKeys = _ref.selectedRowKeys,
    defaultSelectedRowKeys = _ref.defaultSelectedRowKeys,
    getCheckboxProps = _ref.getCheckboxProps,
    onSelectionChange = _ref.onChange,
    onSelect = _ref.onSelect,
    onSelectAll = _ref.onSelectAll,
    onSelectInvert = _ref.onSelectInvert,
    onSelectNone = _ref.onSelectNone,
    onSelectMultiple = _ref.onSelectMultiple,
    selectionColWidth = _ref.columnWidth,
    selectionType = _ref.type,
    selections = _ref.selections,
    fixed = _ref.fixed,
    customizeRenderCell = _ref.renderCell,
    hideSelectAll = _ref.hideSelectAll,
    _ref$checkStrictly = _ref.checkStrictly,
    checkStrictly = _ref$checkStrictly === void 0 ? true : _ref$checkStrictly;
  var prefixCls = config.prefixCls,
    data = config.data,
    pageData = config.pageData,
    getRecordByKey = config.getRecordByKey,
    getRowKey = config.getRowKey,
    expandType = config.expandType,
    childrenColumnName = config.childrenColumnName,
    tableLocale = config.locale,
    getPopupContainer = config.getPopupContainer;
  // ========================= Keys =========================
  var _useMergedState = useMergedState(selectedRowKeys || defaultSelectedRowKeys || EMPTY_LIST$1, {
      value: selectedRowKeys
    }),
    _useMergedState2 = _slicedToArray(_useMergedState, 2),
    mergedSelectedKeys = _useMergedState2[0],
    setMergedSelectedKeys = _useMergedState2[1];
  // ======================== Caches ========================
  var preserveRecordsRef = react.exports.useRef(new Map());
  var updatePreserveRecordsCache = react.exports.useCallback(function (keys) {
    if (preserveSelectedRowKeys) {
      var newCache = new Map();
      // Keep key if mark as preserveSelectedRowKeys
      keys.forEach(function (key) {
        var record = getRecordByKey(key);
        if (!record && preserveRecordsRef.current.has(key)) {
          record = preserveRecordsRef.current.get(key);
        }
        newCache.set(key, record);
      });
      // Refresh to new cache
      preserveRecordsRef.current = newCache;
    }
  }, [getRecordByKey, preserveSelectedRowKeys]);
  // Update cache with selectedKeys
  react.exports.useEffect(function () {
    updatePreserveRecordsCache(mergedSelectedKeys);
  }, [mergedSelectedKeys]);
  var _useMemo = react.exports.useMemo(function () {
      return checkStrictly ? {
        keyEntities: null
      } : convertDataToEntities(data, {
        externalGetKey: getRowKey,
        childrenPropName: childrenColumnName
      });
    }, [data, getRowKey, checkStrictly, childrenColumnName]),
    keyEntities = _useMemo.keyEntities;
  // Get flatten data
  var flattedData = react.exports.useMemo(function () {
    return flattenData(pageData, childrenColumnName);
  }, [pageData, childrenColumnName]);
  // Get all checkbox props
  var checkboxPropsMap = react.exports.useMemo(function () {
    var map = new Map();
    flattedData.forEach(function (record, index) {
      var key = getRowKey(record, index);
      var checkboxProps = (getCheckboxProps ? getCheckboxProps(record) : null) || {};
      map.set(key, checkboxProps);
    });
    return map;
  }, [flattedData, getRowKey, getCheckboxProps]);
  var isCheckboxDisabled = react.exports.useCallback(function (r) {
    var _a;
    return !!((_a = checkboxPropsMap.get(getRowKey(r))) === null || _a === void 0 ? void 0 : _a.disabled);
  }, [checkboxPropsMap, getRowKey]);
  var _useMemo2 = react.exports.useMemo(function () {
      if (checkStrictly) {
        return [mergedSelectedKeys || [], []];
      }
      var _conductCheck = conductCheck(mergedSelectedKeys, true, keyEntities, isCheckboxDisabled),
        checkedKeys = _conductCheck.checkedKeys,
        halfCheckedKeys = _conductCheck.halfCheckedKeys;
      return [checkedKeys || [], halfCheckedKeys];
    }, [mergedSelectedKeys, checkStrictly, keyEntities, isCheckboxDisabled]),
    _useMemo3 = _slicedToArray(_useMemo2, 2),
    derivedSelectedKeys = _useMemo3[0],
    derivedHalfSelectedKeys = _useMemo3[1];
  var derivedSelectedKeySet = react.exports.useMemo(function () {
    var keys = selectionType === 'radio' ? derivedSelectedKeys.slice(0, 1) : derivedSelectedKeys;
    return new Set(keys);
  }, [derivedSelectedKeys, selectionType]);
  var derivedHalfSelectedKeySet = react.exports.useMemo(function () {
    return selectionType === 'radio' ? new Set() : new Set(derivedHalfSelectedKeys);
  }, [derivedHalfSelectedKeys, selectionType]);
  // Save last selected key to enable range selection
  var _useState = react.exports.useState(null),
    _useState2 = _slicedToArray(_useState, 2),
    lastSelectedKey = _useState2[0],
    setLastSelectedKey = _useState2[1];
  // Reset if rowSelection reset
  react.exports.useEffect(function () {
    if (!rowSelection) {
      setMergedSelectedKeys(EMPTY_LIST$1);
    }
  }, [!!rowSelection]);
  var setSelectedKeys = react.exports.useCallback(function (keys, method) {
    var availableKeys;
    var records;
    updatePreserveRecordsCache(keys);
    if (preserveSelectedRowKeys) {
      availableKeys = keys;
      records = keys.map(function (key) {
        return preserveRecordsRef.current.get(key);
      });
    } else {
      // Filter key which not exist in the `dataSource`
      availableKeys = [];
      records = [];
      keys.forEach(function (key) {
        var record = getRecordByKey(key);
        if (record !== undefined) {
          availableKeys.push(key);
          records.push(record);
        }
      });
    }
    setMergedSelectedKeys(availableKeys);
    onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(availableKeys, records, {
      type: method
    });
  }, [setMergedSelectedKeys, getRecordByKey, onSelectionChange, preserveSelectedRowKeys]);
  // ====================== Selections ======================
  // Trigger single `onSelect` event
  var triggerSingleSelection = react.exports.useCallback(function (key, selected, keys, event) {
    if (onSelect) {
      var rows = keys.map(function (k) {
        return getRecordByKey(k);
      });
      onSelect(getRecordByKey(key), selected, rows, event);
    }
    setSelectedKeys(keys, 'single');
  }, [onSelect, getRecordByKey, setSelectedKeys]);
  var mergedSelections = react.exports.useMemo(function () {
    if (!selections || hideSelectAll) {
      return null;
    }
    var selectionList = selections === true ? [SELECTION_ALL, SELECTION_INVERT, SELECTION_NONE] : selections;
    return selectionList.map(function (selection) {
      if (selection === SELECTION_ALL) {
        return {
          key: 'all',
          text: tableLocale.selectionAll,
          onSelect: function onSelect() {
            setSelectedKeys(data.map(function (record, index) {
              return getRowKey(record, index);
            }).filter(function (key) {
              var checkProps = checkboxPropsMap.get(key);
              return !(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled) || derivedSelectedKeySet.has(key);
            }), 'all');
          }
        };
      }
      if (selection === SELECTION_INVERT) {
        return {
          key: 'invert',
          text: tableLocale.selectInvert,
          onSelect: function onSelect() {
            var keySet = new Set(derivedSelectedKeySet);
            pageData.forEach(function (record, index) {
              var key = getRowKey(record, index);
              var checkProps = checkboxPropsMap.get(key);
              if (!(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled)) {
                if (keySet.has(key)) {
                  keySet["delete"](key);
                } else {
                  keySet.add(key);
                }
              }
            });
            var keys = Array.from(keySet);
            if (onSelectInvert) {
              onSelectInvert(keys);
            }
            setSelectedKeys(keys, 'invert');
          }
        };
      }
      if (selection === SELECTION_NONE) {
        return {
          key: 'none',
          text: tableLocale.selectNone,
          onSelect: function onSelect() {
            onSelectNone === null || onSelectNone === void 0 ? void 0 : onSelectNone();
            setSelectedKeys(Array.from(derivedSelectedKeySet).filter(function (key) {
              var checkProps = checkboxPropsMap.get(key);
              return checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled;
            }), 'none');
          }
        };
      }
      return selection;
    }).map(function (selection) {
      return _extends$2(_extends$2({}, selection), {
        onSelect: function onSelect() {
          var _a2;
          var _a;
          for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
            rest[_key] = arguments[_key];
          }
          (_a = selection.onSelect) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [selection].concat(rest));
          setLastSelectedKey(null);
        }
      });
    });
  }, [selections, derivedSelectedKeySet, pageData, getRowKey, onSelectInvert, setSelectedKeys]);
  // ======================= Columns ========================
  var transformColumns = react.exports.useCallback(function (columns) {
    var _a;
    // >>>>>>>>>>> Skip if not exists `rowSelection`
    if (!rowSelection) {
      return columns.filter(function (col) {
        return col !== SELECTION_COLUMN;
      });
    }
    // >>>>>>>>>>> Support selection
    var cloneColumns = _toConsumableArray(columns);
    var keySet = new Set(derivedSelectedKeySet);
    // Record key only need check with enabled
    var recordKeys = flattedData.map(getRowKey).filter(function (key) {
      return !checkboxPropsMap.get(key).disabled;
    });
    var checkedCurrentAll = recordKeys.every(function (key) {
      return keySet.has(key);
    });
    var checkedCurrentSome = recordKeys.some(function (key) {
      return keySet.has(key);
    });
    var onSelectAllChange = function onSelectAllChange() {
      var changeKeys = [];
      if (checkedCurrentAll) {
        recordKeys.forEach(function (key) {
          keySet["delete"](key);
          changeKeys.push(key);
        });
      } else {
        recordKeys.forEach(function (key) {
          if (!keySet.has(key)) {
            keySet.add(key);
            changeKeys.push(key);
          }
        });
      }
      var keys = Array.from(keySet);
      onSelectAll === null || onSelectAll === void 0 ? void 0 : onSelectAll(!checkedCurrentAll, keys.map(function (k) {
        return getRecordByKey(k);
      }), changeKeys.map(function (k) {
        return getRecordByKey(k);
      }));
      setSelectedKeys(keys, 'all');
      setLastSelectedKey(null);
    };
    // ===================== Render =====================
    // Title Cell
    var title;
    if (selectionType !== 'radio') {
      var customizeSelections;
      if (mergedSelections) {
        var menu = {
          getPopupContainer: getPopupContainer,
          items: mergedSelections.map(function (selection, index) {
            var key = selection.key,
              text = selection.text,
              onSelectionClick = selection.onSelect;
            return {
              key: key || index,
              onClick: function onClick() {
                onSelectionClick === null || onSelectionClick === void 0 ? void 0 : onSelectionClick(recordKeys);
              },
              label: text
            };
          })
        };
        customizeSelections =
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1("div", {
          className: prefixCls + "-selection-extra",
          children: /*#__PURE__*/jsx$1(Dropdown$1, {
            menu: menu,
            getPopupContainer: getPopupContainer,
            children: /*#__PURE__*/jsx$1("span", {
              children: /*#__PURE__*/jsx$1(DownOutlined$1, {})
            })
          })
        });
      }
      var allDisabledData = flattedData.map(function (record, index) {
        var key = getRowKey(record, index);
        var checkboxProps = checkboxPropsMap.get(key) || {};
        return _extends$2({
          checked: keySet.has(key)
        }, checkboxProps);
      }).filter(function (_ref2) {
        var disabled = _ref2.disabled;
        return disabled;
      });
      var allDisabled = !!allDisabledData.length && allDisabledData.length === flattedData.length;
      var allDisabledAndChecked = allDisabled && allDisabledData.every(function (_ref3) {
        var checked = _ref3.checked;
        return checked;
      });
      var allDisabledSomeChecked = allDisabled && allDisabledData.some(function (_ref4) {
        var checked = _ref4.checked;
        return checked;
      });
      title = !hideSelectAll &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsxs("div", {
        className: prefixCls + "-selection",
        children: [/*#__PURE__*/jsx$1(Checkbox$1, {
          checked: !allDisabled ? !!flattedData.length && checkedCurrentAll : allDisabledAndChecked,
          indeterminate: !allDisabled ? !checkedCurrentAll && checkedCurrentSome : !allDisabledAndChecked && allDisabledSomeChecked,
          onChange: onSelectAllChange,
          disabled: flattedData.length === 0 || allDisabled,
          "aria-label": customizeSelections ? 'Custom selection' : 'Select all',
          skipGroup: true
        }), customizeSelections]
      });
    }
    // Body Cell
    var renderCell;
    if (selectionType === 'radio') {
      renderCell = function renderCell(_, record, index) {
        var key = getRowKey(record, index);
        var checked = keySet.has(key);
        return {
          node:
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(Radio$1, {
            ...checkboxPropsMap.get(key),
            checked: checked,
            onClick: function onClick(e) {
              return e.stopPropagation();
            },
            onChange: function onChange(event) {
              if (!keySet.has(key)) {
                triggerSingleSelection(key, true, [key], event.nativeEvent);
              }
            }
          }),
          checked: checked
        };
      };
    } else {
      renderCell = function renderCell(_, record, index) {
        var _a;
        var key = getRowKey(record, index);
        var checked = keySet.has(key);
        var indeterminate = derivedHalfSelectedKeySet.has(key);
        var checkboxProps = checkboxPropsMap.get(key);
        var mergedIndeterminate;
        if (expandType === 'nest') {
          mergedIndeterminate = indeterminate;
        } else {
          mergedIndeterminate = (_a = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.indeterminate) !== null && _a !== void 0 ? _a : indeterminate;
        }
        // Record checked
        return {
          node:
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(Checkbox$1, {
            ...checkboxProps,
            indeterminate: mergedIndeterminate,
            checked: checked,
            skipGroup: true,
            onClick: function onClick(e) {
              return e.stopPropagation();
            },
            onChange: function onChange(_ref5) {
              var nativeEvent = _ref5.nativeEvent;
              var shiftKey = nativeEvent.shiftKey;
              var startIndex = -1;
              var endIndex = -1;
              // Get range of this
              if (shiftKey && checkStrictly) {
                var pointKeys = new Set([lastSelectedKey, key]);
                recordKeys.some(function (recordKey, recordIndex) {
                  if (pointKeys.has(recordKey)) {
                    if (startIndex === -1) {
                      startIndex = recordIndex;
                    } else {
                      endIndex = recordIndex;
                      return true;
                    }
                  }
                  return false;
                });
              }
              if (endIndex !== -1 && startIndex !== endIndex && checkStrictly) {
                // Batch update selections
                var rangeKeys = recordKeys.slice(startIndex, endIndex + 1);
                var changedKeys = [];
                if (checked) {
                  rangeKeys.forEach(function (recordKey) {
                    if (keySet.has(recordKey)) {
                      changedKeys.push(recordKey);
                      keySet["delete"](recordKey);
                    }
                  });
                } else {
                  rangeKeys.forEach(function (recordKey) {
                    if (!keySet.has(recordKey)) {
                      changedKeys.push(recordKey);
                      keySet.add(recordKey);
                    }
                  });
                }
                var keys = Array.from(keySet);
                onSelectMultiple === null || onSelectMultiple === void 0 ? void 0 : onSelectMultiple(!checked, keys.map(function (recordKey) {
                  return getRecordByKey(recordKey);
                }), changedKeys.map(function (recordKey) {
                  return getRecordByKey(recordKey);
                }));
                setSelectedKeys(keys, 'multiple');
              } else {
                // Single record selected
                var originCheckedKeys = derivedSelectedKeys;
                if (checkStrictly) {
                  var checkedKeys = checked ? arrDel(originCheckedKeys, key) : arrAdd(originCheckedKeys, key);
                  triggerSingleSelection(key, !checked, checkedKeys, nativeEvent);
                } else {
                  // Always fill first
                  var result = conductCheck([].concat(_toConsumableArray(originCheckedKeys), [key]), true, keyEntities, isCheckboxDisabled);
                  var _checkedKeys = result.checkedKeys,
                    halfCheckedKeys = result.halfCheckedKeys;
                  var nextCheckedKeys = _checkedKeys;
                  // If remove, we do it again to correction
                  if (checked) {
                    var tempKeySet = new Set(_checkedKeys);
                    tempKeySet["delete"](key);
                    nextCheckedKeys = conductCheck(Array.from(tempKeySet), {
                      checked: false,
                      halfCheckedKeys: halfCheckedKeys
                    }, keyEntities, isCheckboxDisabled).checkedKeys;
                  }
                  triggerSingleSelection(key, !checked, nextCheckedKeys, nativeEvent);
                }
              }
              if (checked) {
                setLastSelectedKey(null);
              } else {
                setLastSelectedKey(key);
              }
            }
          }),
          checked: checked
        };
      };
    }
    var renderSelectionCell = function renderSelectionCell(_, record, index) {
      var _renderCell = renderCell(_, record, index),
        node = _renderCell.node,
        checked = _renderCell.checked;
      if (customizeRenderCell) {
        return customizeRenderCell(checked, record, index, node);
      }
      return node;
    };
    // Insert selection column if not exist
    if (!cloneColumns.includes(SELECTION_COLUMN)) {
      // Always after expand icon
      if (cloneColumns.findIndex(function (col) {
        var _a;
        return ((_a = col[INTERNAL_COL_DEFINE]) === null || _a === void 0 ? void 0 : _a.columnType) === 'EXPAND_COLUMN';
      }) === 0) {
        var _cloneColumns = cloneColumns,
          _cloneColumns2 = _toArray(_cloneColumns),
          expandColumn = _cloneColumns2[0],
          restColumns = _cloneColumns2.slice(1);
        cloneColumns = [expandColumn, SELECTION_COLUMN].concat(_toConsumableArray(restColumns));
      } else {
        // Normal insert at first column
        cloneColumns = [SELECTION_COLUMN].concat(_toConsumableArray(cloneColumns));
      }
    }
    // Deduplicate selection column
    var selectionColumnIndex = cloneColumns.indexOf(SELECTION_COLUMN);
    cloneColumns = cloneColumns.filter(function (column, index) {
      return column !== SELECTION_COLUMN || index === selectionColumnIndex;
    });
    // Fixed column logic
    var prevCol = cloneColumns[selectionColumnIndex - 1];
    var nextCol = cloneColumns[selectionColumnIndex + 1];
    var mergedFixed = fixed;
    if (mergedFixed === undefined) {
      if ((nextCol === null || nextCol === void 0 ? void 0 : nextCol.fixed) !== undefined) {
        mergedFixed = nextCol.fixed;
      } else if ((prevCol === null || prevCol === void 0 ? void 0 : prevCol.fixed) !== undefined) {
        mergedFixed = prevCol.fixed;
      }
    }
    if (mergedFixed && prevCol && ((_a = prevCol[INTERNAL_COL_DEFINE]) === null || _a === void 0 ? void 0 : _a.columnType) === 'EXPAND_COLUMN' && prevCol.fixed === undefined) {
      prevCol.fixed = mergedFixed;
    }
    // Replace with real selection column
    var selectionColumn = _defineProperty$1({
      fixed: mergedFixed,
      width: selectionColWidth,
      className: prefixCls + "-selection-column",
      title: rowSelection.columnTitle || title,
      render: renderSelectionCell
    }, INTERNAL_COL_DEFINE, {
      className: prefixCls + "-selection-col"
    });
    return cloneColumns.map(function (col) {
      return col === SELECTION_COLUMN ? selectionColumn : col;
    });
  }, [getRowKey, flattedData, rowSelection, derivedSelectedKeys, derivedSelectedKeySet, derivedHalfSelectedKeySet, selectionColWidth, mergedSelections, expandType, lastSelectedKey, checkboxPropsMap, onSelectMultiple, triggerSingleSelection, isCheckboxDisabled]);
  return [transformColumns, derivedSelectedKeySet];
}

// This icon file is generated automatically.
var CaretDownOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "outlined" };
const CaretDownOutlinedSvg = CaretDownOutlined$2;

var CaretDownOutlined = function CaretDownOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: CaretDownOutlinedSvg
      })
    })
  );
};
CaretDownOutlined.displayName = 'CaretDownOutlined';
const CaretDownOutlined$1 = /*#__PURE__*/react.exports.forwardRef(CaretDownOutlined);

// This icon file is generated automatically.
var CaretUpOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z" } }] }, "name": "caret-up", "theme": "outlined" };
const CaretUpOutlinedSvg = CaretUpOutlined$2;

var CaretUpOutlined = function CaretUpOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: CaretUpOutlinedSvg
      })
    })
  );
};
CaretUpOutlined.displayName = 'CaretUpOutlined';
const CaretUpOutlined$1 = /*#__PURE__*/react.exports.forwardRef(CaretUpOutlined);

var ASCEND = 'ascend';
var DESCEND = 'descend';
function getMultiplePriority(column) {
  if (_typeof$1(column.sorter) === 'object' && typeof column.sorter.multiple === 'number') {
    return column.sorter.multiple;
  }
  return false;
}
function getSortFunction(sorter) {
  if (typeof sorter === 'function') {
    return sorter;
  }
  if (sorter && _typeof$1(sorter) === 'object' && sorter.compare) {
    return sorter.compare;
  }
  return false;
}
function nextSortDirection(sortDirections, current) {
  if (!current) {
    return sortDirections[0];
  }
  return sortDirections[sortDirections.indexOf(current) + 1];
}
function collectSortStates(columns, init, pos) {
  var sortStates = [];
  function pushState(column, columnPos) {
    sortStates.push({
      column: column,
      key: getColumnKey(column, columnPos),
      multiplePriority: getMultiplePriority(column),
      sortOrder: column.sortOrder
    });
  }
  (columns || []).forEach(function (column, index) {
    var columnPos = getColumnPos(index, pos);
    if (column.children) {
      if ('sortOrder' in column) {
        // Controlled
        pushState(column, columnPos);
      }
      sortStates = [].concat(_toConsumableArray(sortStates), _toConsumableArray(collectSortStates(column.children, init, columnPos)));
    } else if (column.sorter) {
      if ('sortOrder' in column) {
        // Controlled
        pushState(column, columnPos);
      } else if (init && column.defaultSortOrder) {
        // Default sorter
        sortStates.push({
          column: column,
          key: getColumnKey(column, columnPos),
          multiplePriority: getMultiplePriority(column),
          sortOrder: column.defaultSortOrder
        });
      }
    }
  });
  return sortStates;
}
function injectSorter(prefixCls, columns, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, pos) {
  return (columns || []).map(function (column, index) {
    var columnPos = getColumnPos(index, pos);
    var newColumn = column;
    if (newColumn.sorter) {
      var sortDirections = newColumn.sortDirections || defaultSortDirections;
      var showSorterTooltip = newColumn.showSorterTooltip === undefined ? tableShowSorterTooltip : newColumn.showSorterTooltip;
      var columnKey = getColumnKey(newColumn, columnPos);
      var sorterState = sorterStates.find(function (_ref) {
        var key = _ref.key;
        return key === columnKey;
      });
      var sorterOrder = sorterState ? sorterState.sortOrder : null;
      var nextSortOrder = nextSortDirection(sortDirections, sorterOrder);
      var upNode = sortDirections.includes(ASCEND) &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(CaretUpOutlined$1, {
        className: classNames$1(prefixCls + "-column-sorter-up", {
          active: sorterOrder === ASCEND
        }),
        role: "presentation"
      });
      var downNode = sortDirections.includes(DESCEND) &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(CaretDownOutlined$1, {
        className: classNames$1(prefixCls + "-column-sorter-down", {
          active: sorterOrder === DESCEND
        }),
        role: "presentation"
      });
      var _ref2 = tableLocale || {},
        cancelSort = _ref2.cancelSort,
        triggerAsc = _ref2.triggerAsc,
        triggerDesc = _ref2.triggerDesc;
      var sortTip = cancelSort;
      if (nextSortOrder === DESCEND) {
        sortTip = triggerDesc;
      } else if (nextSortOrder === ASCEND) {
        sortTip = triggerAsc;
      }
      var tooltipProps = _typeof$1(showSorterTooltip) === 'object' ? showSorterTooltip : {
        title: sortTip
      };
      newColumn = _extends$2(_extends$2({}, newColumn), {
        className: classNames$1(newColumn.className, _defineProperty$1({}, prefixCls + "-column-sort", sorterOrder)),
        title: function title(renderProps) {
          var renderSortTitle =
          /*#__PURE__*/
          /*#__PURE__*/
          jsxs("div", {
            className: prefixCls + "-column-sorters",
            children: [/*#__PURE__*/jsx$1("span", {
              className: prefixCls + "-column-title",
              children: renderColumnTitle(column.title, renderProps)
            }), /*#__PURE__*/jsx$1("span", {
              className: classNames$1(prefixCls + "-column-sorter", _defineProperty$1({}, prefixCls + "-column-sorter-full", !!(upNode && downNode))),
              children: /*#__PURE__*/jsxs("span", {
                className: prefixCls + "-column-sorter-inner",
                children: [upNode, downNode]
              })
            })]
          });
          return showSorterTooltip ?
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(Tooltip$1, {
            ...tooltipProps,
            children: renderSortTitle
          }) : renderSortTitle;
        },
        onHeaderCell: function onHeaderCell(col) {
          var cell = column.onHeaderCell && column.onHeaderCell(col) || {};
          var originOnClick = cell.onClick;
          var originOKeyDown = cell.onKeyDown;
          cell.onClick = function (event) {
            triggerSorter({
              column: column,
              key: columnKey,
              sortOrder: nextSortOrder,
              multiplePriority: getMultiplePriority(column)
            });
            originOnClick === null || originOnClick === void 0 ? void 0 : originOnClick(event);
          };
          cell.onKeyDown = function (event) {
            if (event.keyCode === KeyCode.ENTER) {
              triggerSorter({
                column: column,
                key: columnKey,
                sortOrder: nextSortOrder,
                multiplePriority: getMultiplePriority(column)
              });
              originOKeyDown === null || originOKeyDown === void 0 ? void 0 : originOKeyDown(event);
            }
          };
          var renderTitle = safeColumnTitle(column.title, {});
          var displayTitle = renderTitle === null || renderTitle === void 0 ? void 0 : renderTitle.toString();
          // Inform the screen-reader so it can tell the visually impaired user which column is sorted
          if (sorterOrder) {
            cell['aria-sort'] = sorterOrder === 'ascend' ? 'ascending' : 'descending';
          } else {
            cell['aria-label'] = (displayTitle ? "this column's title is " + displayTitle + "," : '') + "this column is sortable";
          }
          cell.className = classNames$1(cell.className, prefixCls + "-column-has-sorters");
          cell.tabIndex = 0;
          if (column.ellipsis) {
            cell.title = (renderTitle !== null && renderTitle !== void 0 ? renderTitle : '').toString();
          }
          return cell;
        }
      });
    }
    if ('children' in newColumn) {
      newColumn = _extends$2(_extends$2({}, newColumn), {
        children: injectSorter(prefixCls, newColumn.children, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, columnPos)
      });
    }
    return newColumn;
  });
}
function stateToInfo(sorterStates) {
  var column = sorterStates.column,
    sortOrder = sorterStates.sortOrder;
  return {
    column: column,
    order: sortOrder,
    field: column.dataIndex,
    columnKey: column.key
  };
}
function generateSorterInfo(sorterStates) {
  var list = sorterStates.filter(function (_ref3) {
    var sortOrder = _ref3.sortOrder;
    return sortOrder;
  }).map(stateToInfo);
  // =========== Legacy compatible support ===========
  // https://github.com/ant-design/ant-design/pull/19226
  if (list.length === 0 && sorterStates.length) {
    return _extends$2(_extends$2({}, stateToInfo(sorterStates[sorterStates.length - 1])), {
      column: undefined
    });
  }
  if (list.length <= 1) {
    return list[0] || {};
  }
  return list;
}
function getSortData(data, sortStates, childrenColumnName) {
  var innerSorterStates = sortStates.slice().sort(function (a, b) {
    return b.multiplePriority - a.multiplePriority;
  });
  var cloneData = data.slice();
  var runningSorters = innerSorterStates.filter(function (_ref4) {
    var sorter = _ref4.column.sorter,
      sortOrder = _ref4.sortOrder;
    return getSortFunction(sorter) && sortOrder;
  });
  // Skip if no sorter needed
  if (!runningSorters.length) {
    return cloneData;
  }
  return cloneData.sort(function (record1, record2) {
    for (var i = 0; i < runningSorters.length; i += 1) {
      var sorterState = runningSorters[i];
      var sorter = sorterState.column.sorter,
        sortOrder = sorterState.sortOrder;
      var compareFn = getSortFunction(sorter);
      if (compareFn && sortOrder) {
        var compareResult = compareFn(record1, record2, sortOrder);
        if (compareResult !== 0) {
          return sortOrder === ASCEND ? compareResult : -compareResult;
        }
      }
    }
    return 0;
  }).map(function (record) {
    var subRecords = record[childrenColumnName];
    if (subRecords) {
      return _extends$2(_extends$2({}, record), _defineProperty$1({}, childrenColumnName, getSortData(subRecords, sortStates, childrenColumnName)));
    }
    return record;
  });
}
function useFilterSorter(_ref5) {
  var prefixCls = _ref5.prefixCls,
    mergedColumns = _ref5.mergedColumns,
    onSorterChange = _ref5.onSorterChange,
    sortDirections = _ref5.sortDirections,
    tableLocale = _ref5.tableLocale,
    showSorterTooltip = _ref5.showSorterTooltip;
  var _React$useState = react.exports.useState(collectSortStates(mergedColumns, true)),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    sortStates = _React$useState2[0],
    setSortStates = _React$useState2[1];
  var mergedSorterStates = react.exports.useMemo(function () {
    var validate = true;
    var collectedStates = collectSortStates(mergedColumns, false);
    // Return if not controlled
    if (!collectedStates.length) {
      return sortStates;
    }
    var validateStates = [];
    function patchStates(state) {
      if (validate) {
        validateStates.push(state);
      } else {
        validateStates.push(_extends$2(_extends$2({}, state), {
          sortOrder: null
        }));
      }
    }
    var multipleMode = null;
    collectedStates.forEach(function (state) {
      if (multipleMode === null) {
        patchStates(state);
        if (state.sortOrder) {
          if (state.multiplePriority === false) {
            validate = false;
          } else {
            multipleMode = true;
          }
        }
      } else if (multipleMode && state.multiplePriority !== false) {
        patchStates(state);
      } else {
        validate = false;
        patchStates(state);
      }
    });
    return validateStates;
  }, [mergedColumns, sortStates]);
  // Get render columns title required props
  var columnTitleSorterProps = react.exports.useMemo(function () {
    var sortColumns = mergedSorterStates.map(function (_ref6) {
      var column = _ref6.column,
        sortOrder = _ref6.sortOrder;
      return {
        column: column,
        order: sortOrder
      };
    });
    return {
      sortColumns: sortColumns,
      // Legacy
      sortColumn: sortColumns[0] && sortColumns[0].column,
      sortOrder: sortColumns[0] && sortColumns[0].order
    };
  }, [mergedSorterStates]);
  function triggerSorter(sortState) {
    var newSorterStates;
    if (sortState.multiplePriority === false || !mergedSorterStates.length || mergedSorterStates[0].multiplePriority === false) {
      newSorterStates = [sortState];
    } else {
      newSorterStates = [].concat(_toConsumableArray(mergedSorterStates.filter(function (_ref7) {
        var key = _ref7.key;
        return key !== sortState.key;
      })), [sortState]);
    }
    setSortStates(newSorterStates);
    onSorterChange(generateSorterInfo(newSorterStates), newSorterStates);
  }
  var transformColumns = function transformColumns(innerColumns) {
    return injectSorter(prefixCls, innerColumns, mergedSorterStates, triggerSorter, sortDirections, tableLocale, showSorterTooltip);
  };
  var getSorters = function getSorters() {
    return generateSorterInfo(mergedSorterStates);
  };
  return [transformColumns, mergedSorterStates, columnTitleSorterProps, getSorters];
}

function fillTitle(columns, columnTitleProps) {
  return columns.map(function (column) {
    var cloneColumn = _extends$2({}, column);
    cloneColumn.title = renderColumnTitle(column.title, columnTitleProps);
    if ('children' in cloneColumn) {
      cloneColumn.children = fillTitle(cloneColumn.children, columnTitleProps);
    }
    return cloneColumn;
  });
}
function useTitleColumns(columnTitleProps) {
  var filledColumns = react.exports.useCallback(function (columns) {
    return fillTitle(columns, columnTitleProps);
  }, [columnTitleProps]);
  return [filledColumns];
}

var genBorderedStyle = function genBorderedStyle(token) {
  var _table, _ref4, _extends2, _ref6, _ref7;
  var componentCls = token.componentCls;
  var tableBorder = token.lineWidth + "px " + token.lineType + " " + token.tableBorderColor;
  var getSizeBorderStyle = function getSizeBorderStyle(size, paddingVertical, paddingHorizontal) {
    return _defineProperty$1({}, "&" + componentCls + "-" + size, _defineProperty$1({}, "> " + componentCls + "-container", _defineProperty$1({}, "> " + componentCls + "-content, > " + componentCls + "-body", {
      '> table > tbody > tr > td': _defineProperty$1({}, "> " + componentCls + "-expanded-row-fixed", {
        margin: "-" + paddingVertical + "px -" + (paddingHorizontal + token.lineWidth) + "px"
      })
    })));
  };
  return _defineProperty$1({}, componentCls + "-wrapper", (_ref7 = {}, _defineProperty$1(_ref7, "" + componentCls + componentCls + "-bordered", _extends$2(_extends$2(_extends$2((_extends2 = {}, _defineProperty$1(_extends2, "> " + componentCls + "-title", {
    border: tableBorder,
    borderBottom: 0
  }), _defineProperty$1(_extends2, "> " + componentCls + "-container", (_ref4 = {
    borderInlineStart: tableBorder
  }, _defineProperty$1(_ref4, "\n            > " + componentCls + "-content,\n            > " + componentCls + "-header,\n            > " + componentCls + "-body,\n            > " + componentCls + "-summary\n          ", {
    '> table': (_table = {}, _defineProperty$1(_table, "\n                > thead > tr > th,\n                > tbody > tr > td,\n                > tfoot > tr > th,\n                > tfoot > tr > td\n              ", {
      borderInlineEnd: tableBorder
    }), _defineProperty$1(_table, '> thead', {
      '> tr:not(:last-child) > th': {
        borderBottom: tableBorder
      },
      '> tr > th::before': {
        backgroundColor: 'transparent !important'
      }
    }), _defineProperty$1(_table, "\n                > thead > tr,\n                > tbody > tr,\n                > tfoot > tr\n              ", _defineProperty$1({}, "> " + componentCls + "-cell-fix-right-first::after", {
      borderInlineEnd: tableBorder
    })), _defineProperty$1(_table, '> tbody > tr > td', _defineProperty$1({}, "> " + componentCls + "-expanded-row-fixed", {
      margin: "-" + token.tablePaddingVertical + "px -" + (token.tablePaddingHorizontal + token.lineWidth) + "px",
      '&::after': {
        position: 'absolute',
        top: 0,
        insetInlineEnd: token.lineWidth,
        bottom: 0,
        borderInlineEnd: tableBorder,
        content: '""'
      }
    })), _table)
  }), _defineProperty$1(_ref4, "\n            > " + componentCls + "-content,\n            > " + componentCls + "-header\n          ", {
    '> table': {
      borderTop: tableBorder
    }
  }), _ref4)), _defineProperty$1(_extends2, "&" + componentCls + "-scroll-horizontal", _defineProperty$1({}, "> " + componentCls + "-container > " + componentCls + "-body", {
    '> table > tbody': _defineProperty$1({}, "\n                > tr" + componentCls + "-expanded-row,\n                > tr" + componentCls + "-placeholder\n              ", {
      '> td': {
        borderInlineEnd: 0
      }
    })
  })), _extends2), getSizeBorderStyle('middle', token.tablePaddingVerticalMiddle, token.tablePaddingHorizontalMiddle)), getSizeBorderStyle('small', token.tablePaddingVerticalSmall, token.tablePaddingHorizontalSmall)), _defineProperty$1({}, "> " + componentCls + "-footer", {
    border: tableBorder,
    borderTop: 0
  }))), _defineProperty$1(_ref7, componentCls + "-cell", (_ref6 = {}, _defineProperty$1(_ref6, componentCls + "-container:first-child", {
    // :first-child to avoid the case when bordered and title is set
    borderTop: 0
  }), _defineProperty$1(_ref6, '&-scrollbar:not([rowspan])', {
    boxShadow: "0 " + token.lineWidth + "px 0 " + token.lineWidth + "px " + token.tableHeaderBg
  }), _ref6)), _ref7));
};
const genBorderedStyle$1 = genBorderedStyle;

var genEllipsisStyle = function genEllipsisStyle(token) {
  var _extends2;
  var componentCls = token.componentCls;
  return _defineProperty$1({}, componentCls + "-wrapper", _defineProperty$1({}, componentCls + "-cell-ellipsis", _extends$2(_extends$2({}, textEllipsis), (_extends2 = {
    wordBreak: 'keep-all'
  }, _defineProperty$1(_extends2, "\n          &" + componentCls + "-cell-fix-left-last,\n          &" + componentCls + "-cell-fix-right-first\n        ", _defineProperty$1({
    overflow: 'visible'
  }, componentCls + "-cell-content", {
    display: 'block',
    overflow: 'hidden',
    textOverflow: 'ellipsis'
  })), _defineProperty$1(_extends2, componentCls + "-column-title", {
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    wordBreak: 'keep-all'
  }), _extends2))));
};
const genEllipsisStyle$1 = genEllipsisStyle;

// ========================= Placeholder ==========================
var genEmptyStyle = function genEmptyStyle(token) {
  var componentCls = token.componentCls;
  return _defineProperty$1({}, componentCls + "-wrapper", _defineProperty$1({}, componentCls + "-tbody > tr" + componentCls + "-placeholder", {
    textAlign: 'center',
    color: token.colorTextDisabled,
    '&:hover > td': {
      background: token.colorBgContainer
    }
  }));
};
const genEmptyStyle$1 = genEmptyStyle;

var genExpandStyle = function genExpandStyle(token) {
  var _extends2, _ref3;
  var componentCls = token.componentCls,
    antCls = token.antCls,
    checkboxSize = token.controlInteractiveSize,
    motionDurationSlow = token.motionDurationSlow,
    lineWidth = token.lineWidth,
    paddingXS = token.paddingXS,
    lineType = token.lineType,
    tableBorderColor = token.tableBorderColor,
    tableExpandIconBg = token.tableExpandIconBg,
    tableExpandColumnWidth = token.tableExpandColumnWidth,
    borderRadius = token.borderRadius,
    fontSize = token.fontSize,
    fontSizeSM = token.fontSizeSM,
    lineHeight = token.lineHeight,
    tablePaddingVertical = token.tablePaddingVertical,
    tablePaddingHorizontal = token.tablePaddingHorizontal,
    tableExpandedRowBg = token.tableExpandedRowBg,
    paddingXXS = token.paddingXXS;
  var halfInnerSize = checkboxSize / 2 - lineWidth;
  // must be odd number, unless it cannot align center
  var expandIconSize = halfInnerSize * 2 + lineWidth * 3;
  var tableBorder = lineWidth + "px " + lineType + " " + tableBorderColor;
  var expandIconLineOffset = paddingXXS - lineWidth;
  return _defineProperty$1({}, componentCls + "-wrapper", (_ref3 = {}, _defineProperty$1(_ref3, componentCls + "-expand-icon-col", {
    width: tableExpandColumnWidth
  }), _defineProperty$1(_ref3, componentCls + "-row-expand-icon-cell", _defineProperty$1({
    textAlign: 'center'
  }, componentCls + "-row-expand-icon", {
    display: 'inline-flex',
    "float": 'none',
    verticalAlign: 'sub'
  })), _defineProperty$1(_ref3, componentCls + "-row-indent", {
    height: 1,
    "float": 'left'
  }), _defineProperty$1(_ref3, componentCls + "-row-expand-icon", _extends$2(_extends$2({}, operationUnit(token)), (_extends2 = {
    position: 'relative',
    "float": 'left',
    boxSizing: 'border-box',
    width: expandIconSize,
    height: expandIconSize,
    padding: 0,
    color: 'inherit',
    lineHeight: expandIconSize + "px",
    background: tableExpandIconBg,
    border: tableBorder,
    borderRadius: borderRadius,
    transform: "scale(" + checkboxSize / expandIconSize + ")",
    transition: "all " + motionDurationSlow,
    userSelect: 'none'
  }, _defineProperty$1(_extends2, "&:focus, &:hover, &:active", {
    borderColor: 'currentcolor'
  }), _defineProperty$1(_extends2, "&::before, &::after", {
    position: 'absolute',
    background: 'currentcolor',
    transition: "transform " + motionDurationSlow + " ease-out",
    content: '""'
  }), _defineProperty$1(_extends2, '&::before', {
    top: halfInnerSize,
    insetInlineEnd: expandIconLineOffset,
    insetInlineStart: expandIconLineOffset,
    height: lineWidth
  }), _defineProperty$1(_extends2, '&::after', {
    top: expandIconLineOffset,
    bottom: expandIconLineOffset,
    insetInlineStart: halfInnerSize,
    width: lineWidth,
    transform: 'rotate(90deg)'
  }), _defineProperty$1(_extends2, '&-collapsed::before', {
    transform: 'rotate(-180deg)'
  }), _defineProperty$1(_extends2, '&-collapsed::after', {
    transform: 'rotate(0deg)'
  }), _defineProperty$1(_extends2, '&-spaced', {
    '&::before, &::after': {
      display: 'none',
      content: 'none'
    },
    background: 'transparent',
    border: 0,
    visibility: 'hidden'
  }), _extends2))), _defineProperty$1(_ref3, componentCls + "-row-indent + " + componentCls + "-row-expand-icon", {
    marginTop: (fontSize * lineHeight - lineWidth * 3) / 2 - Math.ceil((fontSizeSM * 1.4 - lineWidth * 3) / 2),
    marginInlineEnd: paddingXS
  }), _defineProperty$1(_ref3, "tr" + componentCls + "-expanded-row", _defineProperty$1({
    '&, &:hover': {
      '> td': {
        background: tableExpandedRowBg
      }
    }
  }, antCls + "-descriptions-view", {
    display: 'flex',
    table: {
      flex: 'auto',
      width: 'auto'
    }
  })), _defineProperty$1(_ref3, componentCls + "-expanded-row-fixed", {
    position: 'relative',
    margin: "-" + tablePaddingVertical + "px -" + tablePaddingHorizontal + "px",
    padding: tablePaddingVertical + "px " + tablePaddingHorizontal + "px"
  }), _ref3));
};
const genExpandStyle$1 = genExpandStyle;

var genFilterStyle = function genFilterStyle(token) {
  var _ref, _ref3, _extends2, _ref6;
  var componentCls = token.componentCls,
    antCls = token.antCls,
    iconCls = token.iconCls,
    tableFilterDropdownWidth = token.tableFilterDropdownWidth,
    tableFilterDropdownSearchWidth = token.tableFilterDropdownSearchWidth,
    paddingXXS = token.paddingXXS,
    paddingXS = token.paddingXS,
    colorText = token.colorText,
    lineWidth = token.lineWidth,
    lineType = token.lineType,
    tableBorderColor = token.tableBorderColor,
    tableHeaderIconColor = token.tableHeaderIconColor,
    fontSizeSM = token.fontSizeSM,
    tablePaddingHorizontal = token.tablePaddingHorizontal,
    borderRadius = token.borderRadius,
    motionDurationSlow = token.motionDurationSlow,
    colorTextDescription = token.colorTextDescription,
    colorPrimary = token.colorPrimary,
    colorPrimaryActive = token.colorPrimaryActive,
    tableHeaderFilterActiveBg = token.tableHeaderFilterActiveBg,
    colorTextDisabled = token.colorTextDisabled,
    tableFilterDropdownBg = token.tableFilterDropdownBg,
    tableFilterDropdownHeight = token.tableFilterDropdownHeight,
    controlItemBgHover = token.controlItemBgHover,
    boxShadow = token.boxShadow;
  var dropdownPrefixCls = antCls + "-dropdown";
  var tableFilterDropdownPrefixCls = componentCls + "-filter-dropdown";
  var treePrefixCls = antCls + "-tree";
  var tableBorder = lineWidth + "px " + lineType + " " + tableBorderColor;
  return [_defineProperty$1({}, componentCls + "-wrapper", (_ref = {}, _defineProperty$1(_ref, componentCls + "-filter-column", {
    display: 'flex',
    justifyContent: 'space-between'
  }), _defineProperty$1(_ref, componentCls + "-filter-trigger", {
    position: 'relative',
    display: 'flex',
    alignItems: 'center',
    marginBlock: -paddingXXS,
    marginInline: paddingXXS + "px " + -tablePaddingHorizontal / 2 + "px",
    padding: "0 " + paddingXXS + "px",
    color: tableHeaderIconColor,
    fontSize: fontSizeSM,
    borderRadius: borderRadius,
    cursor: 'pointer',
    transition: "all " + motionDurationSlow,
    '&:hover': {
      color: colorTextDescription,
      background: tableHeaderFilterActiveBg
    },
    '&.active': {
      color: colorPrimary
    }
  }), _ref)), _defineProperty$1({}, antCls + "-dropdown", _defineProperty$1({}, tableFilterDropdownPrefixCls, _extends$2(_extends$2({}, resetComponent(token)), (_extends2 = {
    minWidth: tableFilterDropdownWidth,
    backgroundColor: tableFilterDropdownBg,
    borderRadius: borderRadius,
    boxShadow: boxShadow
  }, _defineProperty$1(_extends2, dropdownPrefixCls + "-menu", {
    // https://github.com/ant-design/ant-design/issues/4916
    // https://github.com/ant-design/ant-design/issues/19542
    maxHeight: tableFilterDropdownHeight,
    overflowX: 'hidden',
    border: 0,
    boxShadow: 'none',
    '&:empty::after': {
      display: 'block',
      padding: paddingXS + "px 0",
      color: colorTextDisabled,
      fontSize: fontSizeSM,
      textAlign: 'center',
      content: '"Not Found"'
    }
  }), _defineProperty$1(_extends2, tableFilterDropdownPrefixCls + "-tree", (_ref3 = {
    paddingBlock: paddingXS + "px 0",
    paddingInline: paddingXS
  }, _defineProperty$1(_ref3, treePrefixCls, {
    padding: 0
  }), _defineProperty$1(_ref3, treePrefixCls + "-treenode " + treePrefixCls + "-node-content-wrapper:hover", {
    backgroundColor: controlItemBgHover
  }), _defineProperty$1(_ref3, treePrefixCls + "-treenode-checkbox-checked " + treePrefixCls + "-node-content-wrapper", {
    '&, &:hover': {
      backgroundColor: colorPrimaryActive
    }
  }), _ref3)), _defineProperty$1(_extends2, tableFilterDropdownPrefixCls + "-search", {
    padding: paddingXS,
    borderBottom: tableBorder,
    '&-input': _defineProperty$1({
      input: {
        minWidth: tableFilterDropdownSearchWidth
      }
    }, iconCls, {
      color: colorTextDisabled
    })
  }), _defineProperty$1(_extends2, tableFilterDropdownPrefixCls + "-checkall", {
    width: '100%',
    marginBottom: paddingXXS,
    marginInlineStart: paddingXXS
  }), _defineProperty$1(_extends2, tableFilterDropdownPrefixCls + "-btns", {
    display: 'flex',
    justifyContent: 'space-between',
    padding: paddingXS - lineWidth + "px " + paddingXS + "px",
    overflow: 'hidden',
    backgroundColor: 'inherit',
    borderTop: tableBorder
  }), _extends2)))), // Dropdown Menu & SubMenu
  _defineProperty$1({}, antCls + "-dropdown " + tableFilterDropdownPrefixCls + ", " + tableFilterDropdownPrefixCls + "-submenu", (_ref6 = {}, _defineProperty$1(_ref6, antCls + "-checkbox-wrapper + span", {
    paddingInlineStart: paddingXS,
    color: colorText
  }), _defineProperty$1(_ref6, "> ul", {
    maxHeight: 'calc(100vh - 130px)',
    overflowX: 'hidden',
    overflowY: 'auto'
  }), _ref6))];
};
const genFilterStyle$1 = genFilterStyle;

var genFixedStyle = function genFixedStyle(token) {
  var _ref, _ref2, _ref3;
  var componentCls = token.componentCls,
    lineWidth = token.lineWidth,
    colorSplit = token.colorSplit,
    motionDurationSlow = token.motionDurationSlow,
    zIndexTableFixed = token.zIndexTableFixed,
    tableBg = token.tableBg;
  var shadowColor = colorSplit;
  // Follow style is magic of shadow which should not follow token:
  return _defineProperty$1({}, componentCls + "-wrapper", (_ref3 = {}, _defineProperty$1(_ref3, "\n        " + componentCls + "-cell-fix-left,\n        " + componentCls + "-cell-fix-right\n      ", {
    position: 'sticky !important',
    zIndex: zIndexTableFixed,
    background: tableBg
  }), _defineProperty$1(_ref3, "\n        " + componentCls + "-cell-fix-left-first::after,\n        " + componentCls + "-cell-fix-left-last::after\n      ", {
    position: 'absolute',
    top: 0,
    right: {
      _skip_check_: true,
      value: 0
    },
    bottom: -lineWidth,
    width: 30,
    transform: 'translateX(100%)',
    transition: "box-shadow " + motionDurationSlow,
    content: '""',
    pointerEvents: 'none'
  }), _defineProperty$1(_ref3, componentCls + "-cell-fix-left-all::after", {
    display: 'none'
  }), _defineProperty$1(_ref3, "\n        " + componentCls + "-cell-fix-right-first::after,\n        " + componentCls + "-cell-fix-right-last::after\n      ", {
    position: 'absolute',
    top: 0,
    bottom: -lineWidth,
    left: {
      _skip_check_: true,
      value: 0
    },
    width: 30,
    transform: 'translateX(-100%)',
    transition: "box-shadow " + motionDurationSlow,
    content: '""',
    pointerEvents: 'none'
  }), _defineProperty$1(_ref3, componentCls + "-container", {
    '&::before, &::after': {
      position: 'absolute',
      top: 0,
      bottom: 0,
      zIndex: zIndexTableFixed,
      width: 30,
      transition: "box-shadow " + motionDurationSlow,
      content: '""',
      pointerEvents: 'none'
    },
    '&::before': {
      insetInlineStart: 0
    },
    '&::after': {
      insetInlineEnd: 0
    }
  }), _defineProperty$1(_ref3, componentCls + "-ping-left", (_ref = {}, _defineProperty$1(_ref, "&:not(" + componentCls + "-has-fix-left) " + componentCls + "-container", {
    position: 'relative',
    '&::before': {
      boxShadow: "inset 10px 0 8px -8px " + shadowColor
    }
  }), _defineProperty$1(_ref, "\n          " + componentCls + "-cell-fix-left-first::after,\n          " + componentCls + "-cell-fix-left-last::after\n        ", {
    boxShadow: "inset 10px 0 8px -8px " + shadowColor
  }), _defineProperty$1(_ref, componentCls + "-cell-fix-left-last::before", {
    backgroundColor: 'transparent !important'
  }), _ref)), _defineProperty$1(_ref3, componentCls + "-ping-right", (_ref2 = {}, _defineProperty$1(_ref2, "&:not(" + componentCls + "-has-fix-right) " + componentCls + "-container", {
    position: 'relative',
    '&::after': {
      boxShadow: "inset -10px 0 8px -8px " + shadowColor
    }
  }), _defineProperty$1(_ref2, "\n          " + componentCls + "-cell-fix-right-first::after,\n          " + componentCls + "-cell-fix-right-last::after\n        ", {
    boxShadow: "inset -10px 0 8px -8px " + shadowColor
  }), _ref2)), _ref3));
};
const genFixedStyle$1 = genFixedStyle;

var genPaginationStyle = function genPaginationStyle(token) {
  var _ref;
  var componentCls = token.componentCls,
    antCls = token.antCls;
  return _defineProperty$1({}, componentCls + "-wrapper", (_ref = {}, _defineProperty$1(_ref, componentCls + "-pagination" + antCls + "-pagination", {
    margin: token.margin + "px 0"
  }), _defineProperty$1(_ref, componentCls + "-pagination", {
    display: 'flex',
    flexWrap: 'wrap',
    rowGap: token.paddingXS,
    '> *': {
      flex: 'none'
    },
    '&-left': {
      justifyContent: 'flex-start'
    },
    '&-center': {
      justifyContent: 'center'
    },
    '&-right': {
      justifyContent: 'flex-end'
    }
  }), _ref));
};
const genPaginationStyle$1 = genPaginationStyle;

var genRadiusStyle = function genRadiusStyle(token) {
  var _componentCls;
  var componentCls = token.componentCls,
    tableRadius = token.tableRadius;
  return _defineProperty$1({}, componentCls + "-wrapper", _defineProperty$1({}, componentCls, (_componentCls = {}, _defineProperty$1(_componentCls, componentCls + "-title", {
    borderRadius: tableRadius + "px " + tableRadius + "px 0 0"
  }), _defineProperty$1(_componentCls, componentCls + "-title + " + componentCls + "-container", {
    borderStartStartRadius: 0,
    borderStartEndRadius: 0,
    table: {
      borderRadius: 0,
      '> thead > tr:first-child': {
        'th:first-child': {
          borderRadius: 0
        },
        'th:last-child': {
          borderRadius: 0
        }
      }
    }
  }), _defineProperty$1(_componentCls, '&-container', {
    borderStartStartRadius: tableRadius,
    borderStartEndRadius: tableRadius,
    'table > thead > tr:first-child': {
      'th:first-child': {
        borderStartStartRadius: tableRadius
      },
      'th:last-child': {
        borderStartEndRadius: tableRadius
      }
    }
  }), _defineProperty$1(_componentCls, '&-footer', {
    borderRadius: "0 0 " + tableRadius + "px " + tableRadius + "px"
  }), _componentCls)));
};
const genRadiusStyle$1 = genRadiusStyle;

var genStyle = function genStyle(token) {
  var _ref;
  var componentCls = token.componentCls;
  return _defineProperty$1({}, componentCls + "-wrapper-rtl", (_ref = {
    direction: 'rtl',
    table: {
      direction: 'rtl'
    }
  }, _defineProperty$1(_ref, componentCls + "-pagination-left", {
    justifyContent: 'flex-end'
  }), _defineProperty$1(_ref, componentCls + "-pagination-right", {
    justifyContent: 'flex-start'
  }), _defineProperty$1(_ref, componentCls + "-row-expand-icon", {
    '&::after': {
      transform: 'rotate(-90deg)'
    },
    '&-collapsed::before': {
      transform: 'rotate(180deg)'
    },
    '&-collapsed::after': {
      transform: 'rotate(0deg)'
    }
  }), _ref));
};
const genRtlStyle = genStyle;

var genSelectionStyle = function genSelectionStyle(token) {
  var _ref3;
  var componentCls = token.componentCls,
    antCls = token.antCls,
    iconCls = token.iconCls,
    fontSizeIcon = token.fontSizeIcon,
    paddingXS = token.paddingXS,
    tableHeaderIconColor = token.tableHeaderIconColor,
    tableHeaderIconColorHover = token.tableHeaderIconColorHover;
  return _defineProperty$1({}, componentCls + "-wrapper", (_ref3 = {}, _defineProperty$1(_ref3, componentCls + "-selection-col", {
    width: token.tableSelectionColumnWidth
  }), _defineProperty$1(_ref3, componentCls + "-bordered " + componentCls + "-selection-col", {
    width: token.tableSelectionColumnWidth + paddingXS * 2
  }), _defineProperty$1(_ref3, "\n        table tr th" + componentCls + "-selection-column,\n        table tr td" + componentCls + "-selection-column\n      ", _defineProperty$1({
    paddingInlineEnd: token.paddingXS,
    paddingInlineStart: token.paddingXS,
    textAlign: 'center'
  }, antCls + "-radio-wrapper", {
    marginInlineEnd: 0
  })), _defineProperty$1(_ref3, "table tr th" + componentCls + "-selection-column" + componentCls + "-cell-fix-left", {
    zIndex: token.zIndexTableFixed
  }), _defineProperty$1(_ref3, "table tr th" + componentCls + "-selection-column::after", {
    backgroundColor: 'transparent !important'
  }), _defineProperty$1(_ref3, componentCls + "-selection", {
    position: 'relative',
    display: 'inline-flex',
    flexDirection: 'column'
  }), _defineProperty$1(_ref3, componentCls + "-selection-extra", _defineProperty$1({
    position: 'absolute',
    top: 0,
    zIndex: 1,
    cursor: 'pointer',
    transition: "all " + token.motionDurationSlow,
    marginInlineStart: '100%',
    paddingInlineStart: token.tablePaddingHorizontal / 4 + "px"
  }, iconCls, {
    color: tableHeaderIconColor,
    fontSize: fontSizeIcon,
    verticalAlign: 'baseline',
    '&:hover': {
      color: tableHeaderIconColorHover
    }
  })), _ref3));
};
const genSelectionStyle$1 = genSelectionStyle;

var genSizeStyle = function genSizeStyle(token) {
  var componentCls = token.componentCls;
  var getSizeStyle = function getSizeStyle(size, paddingVertical, paddingHorizontal, fontSize) {
    var _ref2;
    return _defineProperty$1({}, "" + componentCls + componentCls + "-" + size, (_ref2 = {
      fontSize: fontSize
    }, _defineProperty$1(_ref2, "\n        " + componentCls + "-title,\n        " + componentCls + "-footer,\n        " + componentCls + "-thead > tr > th,\n        " + componentCls + "-tbody > tr > td,\n        tfoot > tr > th,\n        tfoot > tr > td\n      ", {
      padding: paddingVertical + "px " + paddingHorizontal + "px"
    }), _defineProperty$1(_ref2, componentCls + "-filter-trigger", {
      marginInlineEnd: "-" + paddingHorizontal / 2 + "px"
    }), _defineProperty$1(_ref2, componentCls + "-expanded-row-fixed", {
      margin: "-" + paddingVertical + "px -" + paddingHorizontal + "px"
    }), _defineProperty$1(_ref2, componentCls + "-tbody", _defineProperty$1({}, componentCls + "-wrapper:only-child " + componentCls, {
      marginBlock: "-" + paddingVertical + "px",
      marginInline: token.tableExpandColumnWidth - paddingHorizontal + "px -" + paddingHorizontal + "px"
    })), _defineProperty$1(_ref2, componentCls + "-selection-column", {
      paddingInlineStart: paddingHorizontal / 4 + "px"
    }), _ref2));
  };
  return _defineProperty$1({}, componentCls + "-wrapper", _extends$2(_extends$2({}, getSizeStyle('middle', token.tablePaddingVerticalMiddle, token.tablePaddingHorizontalMiddle, token.tableFontSizeMiddle)), getSizeStyle('small', token.tablePaddingVerticalSmall, token.tablePaddingHorizontalSmall, token.tableFontSizeSmall)));
};
const genSizeStyle$1 = genSizeStyle;

var genSorterStyle = function genSorterStyle(token) {
  var _ref3;
  var componentCls = token.componentCls,
    marginXXS = token.marginXXS,
    fontSizeIcon = token.fontSizeIcon,
    tableHeaderIconColor = token.tableHeaderIconColor,
    tableHeaderIconColorHover = token.tableHeaderIconColorHover;
  return _defineProperty$1({}, componentCls + "-wrapper", (_ref3 = {}, _defineProperty$1(_ref3, componentCls + "-thead th" + componentCls + "-column-has-sorters", _defineProperty$1({
    outline: 'none',
    cursor: 'pointer',
    transition: "all " + token.motionDurationSlow,
    '&:hover': {
      background: token.tableHeaderSortHoverBg,
      '&::before': {
        backgroundColor: 'transparent !important'
      }
    },
    '&:focus-visible': {
      color: token.colorPrimary
    }
  }, "\n          &" + componentCls + "-cell-fix-left:hover,\n          &" + componentCls + "-cell-fix-right:hover\n        ", {
    background: token.tableFixedHeaderSortActiveBg
  })), _defineProperty$1(_ref3, componentCls + "-thead th" + componentCls + "-column-sort", {
    background: token.tableHeaderSortBg,
    '&::before': {
      backgroundColor: 'transparent !important'
    }
  }), _defineProperty$1(_ref3, "td" + componentCls + "-column-sort", {
    background: token.tableBodySortBg
  }), _defineProperty$1(_ref3, componentCls + "-column-title", {
    position: 'relative',
    zIndex: 1,
    flex: 1
  }), _defineProperty$1(_ref3, componentCls + "-column-sorters", {
    display: 'flex',
    flex: 'auto',
    alignItems: 'center',
    justifyContent: 'space-between',
    '&::after': {
      position: 'absolute',
      inset: 0,
      width: '100%',
      height: '100%',
      content: '""'
    }
  }), _defineProperty$1(_ref3, componentCls + "-column-sorter", _defineProperty$1({
    marginInlineStart: marginXXS,
    color: tableHeaderIconColor,
    fontSize: 0,
    transition: "color " + token.motionDurationSlow,
    '&-inner': {
      display: 'inline-flex',
      flexDirection: 'column',
      alignItems: 'center'
    },
    '&-up, &-down': {
      fontSize: fontSizeIcon,
      '&.active': {
        color: token.colorPrimary
      }
    }
  }, componentCls + "-column-sorter-up + " + componentCls + "-column-sorter-down", {
    marginTop: '-0.3em'
  })), _defineProperty$1(_ref3, componentCls + "-column-sorters:hover " + componentCls + "-column-sorter", {
    color: tableHeaderIconColorHover
  }), _ref3));
};
const genSorterStyle$1 = genSorterStyle;

var genStickyStyle = function genStickyStyle(token) {
  var componentCls = token.componentCls,
    opacityLoading = token.opacityLoading,
    tableScrollThumbBg = token.tableScrollThumbBg,
    tableScrollThumbBgHover = token.tableScrollThumbBgHover,
    tableScrollThumbSize = token.tableScrollThumbSize,
    tableScrollBg = token.tableScrollBg,
    zIndexTableSticky = token.zIndexTableSticky;
  var tableBorder = token.lineWidth + "px " + token.lineType + " " + token.tableBorderColor;
  return _defineProperty$1({}, componentCls + "-wrapper", _defineProperty$1({}, componentCls + "-sticky", {
    '&-holder': {
      position: 'sticky',
      zIndex: zIndexTableSticky,
      background: token.colorBgContainer
    },
    '&-scroll': {
      position: 'sticky',
      bottom: 0,
      height: tableScrollThumbSize + "px !important",
      zIndex: zIndexTableSticky,
      display: 'flex',
      alignItems: 'center',
      background: tableScrollBg,
      borderTop: tableBorder,
      opacity: opacityLoading,
      '&:hover': {
        transformOrigin: 'center bottom'
      },
      // fake scrollbar style of sticky
      '&-bar': {
        height: tableScrollThumbSize,
        backgroundColor: tableScrollThumbBg,
        borderRadius: 100,
        transition: "all " + token.motionDurationSlow + ", transform none",
        position: 'absolute',
        bottom: 0,
        '&:hover, &-active': {
          backgroundColor: tableScrollThumbBgHover
        }
      }
    }
  }));
};
const genStickyStyle$1 = genStickyStyle;

var genSummaryStyle = function genSummaryStyle(token) {
  var _ref;
  var componentCls = token.componentCls,
    lineWidth = token.lineWidth,
    tableBorderColor = token.tableBorderColor;
  var tableBorder = lineWidth + "px " + token.lineType + " " + tableBorderColor;
  return _defineProperty$1({}, componentCls + "-wrapper", (_ref = {}, _defineProperty$1(_ref, componentCls + "-summary", {
    position: 'relative',
    zIndex: token.zIndexTableFixed,
    background: token.tableBg,
    '> tr': {
      '> th, > td': {
        borderBottom: tableBorder
      }
    }
  }), _defineProperty$1(_ref, "div" + componentCls + "-summary", {
    boxShadow: "0 -" + lineWidth + "px 0 " + tableBorderColor
  }), _ref));
};
const genSummaryStyle$1 = genSummaryStyle;

var genTableStyle = function genTableStyle(token) {
  var _ref, _tr, _ref4, _extends2;
  var componentCls = token.componentCls,
    fontWeightStrong = token.fontWeightStrong,
    tablePaddingVertical = token.tablePaddingVertical,
    tablePaddingHorizontal = token.tablePaddingHorizontal,
    lineWidth = token.lineWidth,
    lineType = token.lineType,
    tableBorderColor = token.tableBorderColor,
    tableFontSize = token.tableFontSize,
    tableBg = token.tableBg,
    tableRadius = token.tableRadius,
    tableHeaderTextColor = token.tableHeaderTextColor,
    motionDurationSlow = token.motionDurationSlow,
    tableHeaderBg = token.tableHeaderBg,
    tableHeaderCellSplitColor = token.tableHeaderCellSplitColor,
    tableRowHoverBg = token.tableRowHoverBg,
    tableSelectedRowBg = token.tableSelectedRowBg,
    tableSelectedRowHoverBg = token.tableSelectedRowHoverBg,
    tableFooterTextColor = token.tableFooterTextColor,
    tableFooterBg = token.tableFooterBg,
    paddingContentVerticalLG = token.paddingContentVerticalLG,
    wireframe = token.wireframe;
  var tableBorder = lineWidth + "px " + lineType + " " + tableBorderColor;
  return _defineProperty$1({}, componentCls + "-wrapper", _extends$2(_extends$2({
    clear: 'both',
    maxWidth: '100%'
  }, clearFix()), (_extends2 = {}, _defineProperty$1(_extends2, componentCls, _extends$2(_extends$2({}, resetComponent(token)), {
    fontSize: tableFontSize,
    background: tableBg,
    borderRadius: tableRadius
  })), _defineProperty$1(_extends2, "table", {
    width: '100%',
    textAlign: 'start',
    borderRadius: tableRadius + "px " + tableRadius + "px 0 0",
    borderCollapse: 'separate',
    borderSpacing: 0
  }), _defineProperty$1(_extends2, "\n          " + componentCls + "-thead > tr > th,\n          " + componentCls + "-tbody > tr > td,\n          tfoot > tr > th,\n          tfoot > tr > td\n        ", {
    position: 'relative',
    padding: paddingContentVerticalLG + "px " + tablePaddingHorizontal + "px",
    overflowWrap: 'break-word'
  }), _defineProperty$1(_extends2, componentCls + "-title", {
    padding: tablePaddingVertical + "px " + tablePaddingHorizontal + "px"
  }), _defineProperty$1(_extends2, componentCls + "-thead", (_ref = {}, _defineProperty$1(_ref, "\n          > tr > th,\n          > tr > td\n        ", _defineProperty$1({
    position: 'relative',
    color: tableHeaderTextColor,
    fontWeight: fontWeightStrong,
    textAlign: 'start',
    background: tableHeaderBg,
    borderBottom: tableBorder,
    transition: "background " + motionDurationSlow + " ease",
    "&[colspan]:not([colspan='1'])": {
      textAlign: 'center'
    }
  }, "&:not(:last-child):not(" + componentCls + "-selection-column):not(" + componentCls + "-row-expand-icon-cell):not([colspan])::before", {
    position: 'absolute',
    top: '50%',
    insetInlineEnd: 0,
    width: 1,
    height: '1.6em',
    backgroundColor: tableHeaderCellSplitColor,
    transform: 'translateY(-50%)',
    transition: "background-color " + motionDurationSlow,
    content: '""'
  })), _defineProperty$1(_ref, '> tr:not(:last-child) > th[colspan]', {
    borderBottom: 0
  }), _ref)), _defineProperty$1(_extends2, componentCls + "-tbody", {
    '> tr': (_tr = {
      '> td': _defineProperty$1({
        borderTop: tableBorder,
        transition: "background " + motionDurationSlow
      }, "\n              > " + componentCls + "-wrapper:only-child,\n              > " + componentCls + "-expanded-row-fixed > " + componentCls + "-wrapper:only-child\n            ", _defineProperty$1({}, componentCls, _defineProperty$1({
        marginBlock: "-" + tablePaddingVertical + "px",
        marginInline: token.tableExpandColumnWidth - tablePaddingHorizontal + "px -" + tablePaddingHorizontal + "px"
      }, componentCls + "-tbody > tr:last-child > td", {
        borderBottom: 0,
        '&:first-child, &:last-child': {
          borderRadius: 0
        }
      }))),
      '&:last-child > td': {
        borderBottom: tableBorder
      }
    }, _defineProperty$1(_tr, "&:first-child > td,\n            &" + componentCls + "-measure-row + tr > td", {
      borderTop: 'none'
    }), _defineProperty$1(_tr, "\n            &" + componentCls + "-row:hover > td,\n            > td" + componentCls + "-cell-row-hover\n          ", {
      background: tableRowHoverBg
    }), _defineProperty$1(_tr, "&" + componentCls + "-row-selected", {
      '> td': {
        background: tableSelectedRowBg
      },
      '&:hover > td': {
        background: tableSelectedRowHoverBg
      }
    }), _tr)
  }), _defineProperty$1(_extends2, componentCls + ":not(" + componentCls + "-bordered) " + componentCls + "-tbody > tr", wireframe ? undefined : (_ref4 = {}, _defineProperty$1(_ref4, "&" + componentCls + "-row:hover, &" + componentCls + "-row" + componentCls + "-row-selected", _defineProperty$1({}, "+ tr" + componentCls + "-row > td", {
    borderTopColor: 'transparent'
  })), _defineProperty$1(_ref4, "&" + componentCls + "-row:last-child:hover > td,\n          &" + componentCls + "-row" + componentCls + "-row-selected:last-child > td", {
    borderBottomColor: 'transparent'
  }), _defineProperty$1(_ref4, "\n          &" + componentCls + "-row:hover > td,\n          > td" + componentCls + "-cell-row-hover,\n          &" + componentCls + "-row" + componentCls + "-row-selected > td\n        ", {
    borderTopColor: 'transparent',
    '&:first-child': {
      borderStartStartRadius: tableRadius,
      borderEndStartRadius: tableRadius
    },
    '&:last-child': {
      borderStartEndRadius: tableRadius,
      borderEndEndRadius: tableRadius
    }
  }), _ref4)), _defineProperty$1(_extends2, componentCls + "-footer", {
    padding: tablePaddingVertical + "px " + tablePaddingHorizontal + "px",
    color: tableFooterTextColor,
    background: tableFooterBg
  }), _extends2)));
};
// ============================== Export ==============================
const useStyle$1 = genComponentStyleHook('Table', function (token) {
  var controlItemBgActive = token.controlItemBgActive,
    controlItemBgActiveHover = token.controlItemBgActiveHover,
    colorTextPlaceholder = token.colorTextPlaceholder,
    colorTextHeading = token.colorTextHeading,
    colorSplit = token.colorSplit,
    fontSize = token.fontSize,
    padding = token.padding,
    paddingXS = token.paddingXS,
    paddingSM = token.paddingSM,
    controlHeight = token.controlHeight,
    colorFillAlter = token.colorFillAlter,
    colorIcon = token.colorIcon,
    colorIconHover = token.colorIconHover,
    opacityLoading = token.opacityLoading,
    colorBgContainer = token.colorBgContainer,
    colorFillSecondary = token.colorFillSecondary,
    borderRadiusLG = token.borderRadiusLG,
    colorFillContent = token.colorFillContent,
    checkboxSize = token.controlInteractiveSize;
  var baseColorAction = new TinyColor(colorIcon);
  var baseColorActionHover = new TinyColor(colorIconHover);
  var tableSelectedRowBg = controlItemBgActive;
  var zIndexTableFixed = 2;
  var colorFillAlterSolid = new TinyColor(colorFillAlter).onBackground(colorBgContainer).toHexString();
  var tableToken = merge$2(token, {
    tableFontSize: fontSize,
    tableBg: colorBgContainer,
    tableRadius: borderRadiusLG,
    tablePaddingVertical: padding,
    tablePaddingHorizontal: padding,
    tablePaddingVerticalMiddle: paddingSM,
    tablePaddingHorizontalMiddle: paddingXS,
    tablePaddingVerticalSmall: paddingXS,
    tablePaddingHorizontalSmall: paddingXS,
    tableBorderColor: colorSplit,
    tableHeaderTextColor: colorTextHeading,
    tableHeaderBg: colorFillAlterSolid,
    tableFooterTextColor: colorTextHeading,
    tableFooterBg: colorFillAlterSolid,
    tableHeaderCellSplitColor: colorSplit,
    tableHeaderSortBg: colorFillSecondary,
    tableHeaderSortHoverBg: colorFillContent,
    tableHeaderIconColor: baseColorAction.clone().setAlpha(baseColorAction.getAlpha() * opacityLoading).toRgbString(),
    tableHeaderIconColorHover: baseColorActionHover.clone().setAlpha(baseColorActionHover.getAlpha() * opacityLoading).toRgbString(),
    tableBodySortBg: colorFillAlter,
    tableFixedHeaderSortActiveBg: colorFillSecondary,
    tableHeaderFilterActiveBg: colorFillContent,
    tableFilterDropdownBg: colorBgContainer,
    tableRowHoverBg: colorFillAlterSolid,
    tableSelectedRowBg: tableSelectedRowBg,
    tableSelectedRowHoverBg: controlItemBgActiveHover,
    zIndexTableFixed: zIndexTableFixed,
    zIndexTableSticky: zIndexTableFixed + 1,
    tableFontSizeMiddle: fontSize,
    tableFontSizeSmall: fontSize,
    tableSelectionColumnWidth: controlHeight,
    tableExpandIconBg: colorBgContainer,
    tableExpandColumnWidth: checkboxSize + 2 * token.padding,
    tableExpandedRowBg: colorFillAlter,
    // Dropdown
    tableFilterDropdownWidth: 120,
    tableFilterDropdownHeight: 264,
    tableFilterDropdownSearchWidth: 140,
    // Virtual Scroll Bar
    tableScrollThumbSize: 8,
    tableScrollThumbBg: colorTextPlaceholder,
    tableScrollThumbBgHover: colorTextHeading,
    tableScrollBg: colorSplit
  });
  return [genTableStyle(tableToken), genPaginationStyle$1(tableToken), genSummaryStyle$1(tableToken), genSorterStyle$1(tableToken), genFilterStyle$1(tableToken), genBorderedStyle$1(tableToken), genRadiusStyle$1(tableToken), genExpandStyle$1(tableToken), genSummaryStyle$1(tableToken), genEmptyStyle$1(tableToken), genSelectionStyle$1(tableToken), genFixedStyle$1(tableToken), genStickyStyle$1(tableToken), genEllipsisStyle$1(tableToken), genSizeStyle$1(tableToken), genRtlStyle(tableToken)];
});

var EMPTY_LIST = [];
function InternalTable(props, ref) {
  var _classNames3;
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    style = props.style,
    customizeSize = props.size,
    bordered = props.bordered,
    customizeDropdownPrefixCls = props.dropdownPrefixCls,
    dataSource = props.dataSource,
    pagination = props.pagination,
    rowSelection = props.rowSelection,
    _props$rowKey = props.rowKey,
    rowKey = _props$rowKey === void 0 ? 'key' : _props$rowKey,
    rowClassName = props.rowClassName,
    columns = props.columns,
    children = props.children,
    legacyChildrenColumnName = props.childrenColumnName,
    onChange = props.onChange,
    getPopupContainer = props.getPopupContainer,
    loading = props.loading,
    expandIcon = props.expandIcon,
    expandable = props.expandable,
    expandedRowRender = props.expandedRowRender,
    expandIconColumnIndex = props.expandIconColumnIndex,
    indentSize = props.indentSize,
    scroll = props.scroll,
    sortDirections = props.sortDirections,
    locale = props.locale,
    _props$showSorterTool = props.showSorterTooltip,
    showSorterTooltip = _props$showSorterTool === void 0 ? true : _props$showSorterTool;
  var baseColumns = react.exports.useMemo(function () {
    return columns || convertChildrenToColumns(children);
  }, [columns, children]);
  var needResponsive = react.exports.useMemo(function () {
    return baseColumns.some(function (col) {
      return col.responsive;
    });
  }, [baseColumns]);
  var screens = useBreakpoint(needResponsive);
  var mergedColumns = react.exports.useMemo(function () {
    var matched = new Set(Object.keys(screens).filter(function (m) {
      return screens[m];
    }));
    return baseColumns.filter(function (c) {
      return !c.responsive || c.responsive.some(function (r) {
        return matched.has(r);
      });
    });
  }, [baseColumns, screens]);
  var tableProps = omit$1(props, ['className', 'style', 'columns']);
  var size = react.exports.useContext(SizeContext);
  var _React$useContext = react.exports.useContext(ConfigContext),
    _React$useContext$loc = _React$useContext.locale,
    contextLocale = _React$useContext$loc === void 0 ? defaultLocale : _React$useContext$loc,
    renderEmpty = _React$useContext.renderEmpty,
    direction = _React$useContext.direction;
  var mergedSize = customizeSize || size;
  var tableLocale = _extends$2(_extends$2({}, contextLocale.Table), locale);
  var rawData = dataSource || EMPTY_LIST;
  var _React$useContext2 = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext2.getPrefixCls;
  var prefixCls = getPrefixCls('table', customizePrefixCls);
  var dropdownPrefixCls = getPrefixCls('dropdown', customizeDropdownPrefixCls);
  var mergedExpandable = _extends$2({
    childrenColumnName: legacyChildrenColumnName,
    expandIconColumnIndex: expandIconColumnIndex
  }, expandable);
  var _mergedExpandable$chi = mergedExpandable.childrenColumnName,
    childrenColumnName = _mergedExpandable$chi === void 0 ? 'children' : _mergedExpandable$chi;
  var expandType = react.exports.useMemo(function () {
    if (rawData.some(function (item) {
      return item === null || item === void 0 ? void 0 : item[childrenColumnName];
    })) {
      return 'nest';
    }
    if (expandedRowRender || expandable && expandable.expandedRowRender) {
      return 'row';
    }
    return null;
  }, [rawData]);
  var internalRefs = {
    body: react.exports.useRef()
  };
  // ============================ RowKey ============================
  var getRowKey = react.exports.useMemo(function () {
    if (typeof rowKey === 'function') {
      return rowKey;
    }
    return function (record) {
      return record === null || record === void 0 ? void 0 : record[rowKey];
    };
  }, [rowKey]);
  var _useLazyKVMap = useLazyKVMap(rawData, childrenColumnName, getRowKey),
    _useLazyKVMap2 = _slicedToArray(_useLazyKVMap, 1),
    getRecordByKey = _useLazyKVMap2[0];
  // ============================ Events =============================
  var changeEventInfo = {};
  var triggerOnChange = function triggerOnChange(info, action) {
    var reset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var changeInfo = _extends$2(_extends$2({}, changeEventInfo), info);
    if (reset) {
      changeEventInfo.resetPagination();
      // Reset event param
      if (changeInfo.pagination.current) {
        changeInfo.pagination.current = 1;
      }
      // Trigger pagination events
      if (pagination && pagination.onChange) {
        pagination.onChange(1, changeInfo.pagination.pageSize);
      }
    }
    if (scroll && scroll.scrollToFirstRowOnChange !== false && internalRefs.body.current) {
      scrollTo$1(0, {
        getContainer: function getContainer() {
          return internalRefs.body.current;
        }
      });
    }
    onChange === null || onChange === void 0 ? void 0 : onChange(changeInfo.pagination, changeInfo.filters, changeInfo.sorter, {
      currentDataSource: getFilterData(getSortData(rawData, changeInfo.sorterStates, childrenColumnName), changeInfo.filterStates),
      action: action
    });
  };
  /**
   * Controlled state in `columns` is not a good idea that makes too many code (1000+ line?) to read
   * state out and then put it back to title render. Move these code into `hooks` but still too
   * complex. We should provides Table props like `sorter` & `filter` to handle control in next big
   * version.
   */
  // ============================ Sorter =============================
  var onSorterChange = function onSorterChange(sorter, sorterStates) {
    triggerOnChange({
      sorter: sorter,
      sorterStates: sorterStates
    }, 'sort', false);
  };
  var _useSorter = useFilterSorter({
      prefixCls: prefixCls,
      mergedColumns: mergedColumns,
      onSorterChange: onSorterChange,
      sortDirections: sortDirections || ['ascend', 'descend'],
      tableLocale: tableLocale,
      showSorterTooltip: showSorterTooltip
    }),
    _useSorter2 = _slicedToArray(_useSorter, 4),
    transformSorterColumns = _useSorter2[0],
    sortStates = _useSorter2[1],
    sorterTitleProps = _useSorter2[2],
    getSorters = _useSorter2[3];
  var sortedData = react.exports.useMemo(function () {
    return getSortData(rawData, sortStates, childrenColumnName);
  }, [rawData, sortStates]);
  changeEventInfo.sorter = getSorters();
  changeEventInfo.sorterStates = sortStates;
  // ============================ Filter ============================
  var onFilterChange = function onFilterChange(filters, filterStates) {
    triggerOnChange({
      filters: filters,
      filterStates: filterStates
    }, 'filter', true);
  };
  var _useFilter = useFilter({
      prefixCls: prefixCls,
      locale: tableLocale,
      dropdownPrefixCls: dropdownPrefixCls,
      mergedColumns: mergedColumns,
      onFilterChange: onFilterChange,
      getPopupContainer: getPopupContainer
    }),
    _useFilter2 = _slicedToArray(_useFilter, 3),
    transformFilterColumns = _useFilter2[0],
    filterStates = _useFilter2[1],
    filters = _useFilter2[2];
  var mergedData = getFilterData(sortedData, filterStates);
  changeEventInfo.filters = filters;
  changeEventInfo.filterStates = filterStates;
  // ============================ Column ============================
  var columnTitleProps = react.exports.useMemo(function () {
    var mergedFilters = {};
    Object.keys(filters).forEach(function (filterKey) {
      if (filters[filterKey] !== null) {
        mergedFilters[filterKey] = filters[filterKey];
      }
    });
    return _extends$2(_extends$2({}, sorterTitleProps), {
      filters: mergedFilters
    });
  }, [sorterTitleProps, filters]);
  var _useTitleColumns = useTitleColumns(columnTitleProps),
    _useTitleColumns2 = _slicedToArray(_useTitleColumns, 1),
    transformTitleColumns = _useTitleColumns2[0];
  // ========================== Pagination ==========================
  var onPaginationChange = function onPaginationChange(current, pageSize) {
    triggerOnChange({
      pagination: _extends$2(_extends$2({}, changeEventInfo.pagination), {
        current: current,
        pageSize: pageSize
      })
    }, 'paginate');
  };
  var _usePagination = usePagination(mergedData.length, pagination, onPaginationChange),
    _usePagination2 = _slicedToArray(_usePagination, 2),
    mergedPagination = _usePagination2[0],
    resetPagination = _usePagination2[1];
  changeEventInfo.pagination = pagination === false ? {} : getPaginationParam(pagination, mergedPagination);
  changeEventInfo.resetPagination = resetPagination;
  // ============================= Data =============================
  var pageData = react.exports.useMemo(function () {
    if (pagination === false || !mergedPagination.pageSize) {
      return mergedData;
    }
    var _mergedPagination$cur = mergedPagination.current,
      current = _mergedPagination$cur === void 0 ? 1 : _mergedPagination$cur,
      total = mergedPagination.total,
      _mergedPagination$pag = mergedPagination.pageSize,
      pageSize = _mergedPagination$pag === void 0 ? DEFAULT_PAGE_SIZE : _mergedPagination$pag;
    // Dynamic table data
    if (mergedData.length < total) {
      if (mergedData.length > pageSize) {
        return mergedData.slice((current - 1) * pageSize, current * pageSize);
      }
      return mergedData;
    }
    return mergedData.slice((current - 1) * pageSize, current * pageSize);
  }, [!!pagination, mergedData, mergedPagination && mergedPagination.current, mergedPagination && mergedPagination.pageSize, mergedPagination && mergedPagination.total]);
  // ========================== Selections ==========================
  var _useSelection = useSelection(rowSelection, {
      prefixCls: prefixCls,
      data: mergedData,
      pageData: pageData,
      getRowKey: getRowKey,
      getRecordByKey: getRecordByKey,
      expandType: expandType,
      childrenColumnName: childrenColumnName,
      locale: tableLocale,
      getPopupContainer: getPopupContainer
    }),
    _useSelection2 = _slicedToArray(_useSelection, 2),
    transformSelectionColumns = _useSelection2[0],
    selectedKeySet = _useSelection2[1];
  var internalRowClassName = function internalRowClassName(record, index, indent) {
    var mergedRowClassName;
    if (typeof rowClassName === 'function') {
      mergedRowClassName = classNames$1(rowClassName(record, index, indent));
    } else {
      mergedRowClassName = classNames$1(rowClassName);
    }
    return classNames$1(_defineProperty$1({}, prefixCls + "-row-selected", selectedKeySet.has(getRowKey(record, index))), mergedRowClassName);
  };
  // ========================== Expandable ==========================
  // Pass origin render status into `rc-table`, this can be removed when refactor with `rc-table`
  mergedExpandable.__PARENT_RENDER_ICON__ = mergedExpandable.expandIcon;
  // Customize expandable icon
  mergedExpandable.expandIcon = mergedExpandable.expandIcon || expandIcon || renderExpandIcon(tableLocale);
  // Adjust expand icon index, no overwrite expandIconColumnIndex if set.
  if (expandType === 'nest' && mergedExpandable.expandIconColumnIndex === undefined) {
    mergedExpandable.expandIconColumnIndex = rowSelection ? 1 : 0;
  } else if (mergedExpandable.expandIconColumnIndex > 0 && rowSelection) {
    mergedExpandable.expandIconColumnIndex -= 1;
  }
  // Indent size
  if (typeof mergedExpandable.indentSize !== 'number') {
    mergedExpandable.indentSize = typeof indentSize === 'number' ? indentSize : 15;
  }
  // ============================ Render ============================
  var transformColumns = react.exports.useCallback(function (innerColumns) {
    return transformTitleColumns(transformSelectionColumns(transformFilterColumns(transformSorterColumns(innerColumns))));
  }, [transformSorterColumns, transformFilterColumns, transformSelectionColumns]);
  var topPaginationNode;
  var bottomPaginationNode;
  if (pagination !== false && (mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.total)) {
    var paginationSize;
    if (mergedPagination.size) {
      paginationSize = mergedPagination.size;
    } else {
      paginationSize = mergedSize === 'small' || mergedSize === 'middle' ? 'small' : undefined;
    }
    var renderPagination = function renderPagination(position) {
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(Pagination$1, {
          ...mergedPagination,
          className: classNames$1(prefixCls + "-pagination " + prefixCls + "-pagination-" + position, mergedPagination.className),
          size: paginationSize
        })
      );
    };
    var defaultPosition = direction === 'rtl' ? 'left' : 'right';
    var position = mergedPagination.position;
    if (position !== null && Array.isArray(position)) {
      var topPos = position.find(function (p) {
        return p.includes('top');
      });
      var bottomPos = position.find(function (p) {
        return p.includes('bottom');
      });
      var isDisable = position.every(function (p) {
        return "" + p === 'none';
      });
      if (!topPos && !bottomPos && !isDisable) {
        bottomPaginationNode = renderPagination(defaultPosition);
      }
      if (topPos) {
        topPaginationNode = renderPagination(topPos.toLowerCase().replace('top', ''));
      }
      if (bottomPos) {
        bottomPaginationNode = renderPagination(bottomPos.toLowerCase().replace('bottom', ''));
      }
    } else {
      bottomPaginationNode = renderPagination(defaultPosition);
    }
  }
  // >>>>>>>>> Spinning
  var spinProps;
  if (typeof loading === 'boolean') {
    spinProps = {
      spinning: loading
    };
  } else if (_typeof$1(loading) === 'object') {
    spinProps = _extends$2({
      spinning: true
    }, loading);
  }
  // Style
  var _useStyle = useStyle$1(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var wrapperClassNames = classNames$1(prefixCls + "-wrapper", _defineProperty$1({}, prefixCls + "-wrapper-rtl", direction === 'rtl'), className, hashId);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsx$1("div", {
    ref: ref,
    className: wrapperClassNames,
    style: style,
    children: /*#__PURE__*/jsxs(Spin$1, {
      spinning: false,
      ...spinProps,
      children: [topPaginationNode, /*#__PURE__*/jsx$1(Table$2, {
        ...tableProps,
        columns: mergedColumns,
        direction: direction,
        expandable: mergedExpandable,
        prefixCls: prefixCls,
        className: classNames$1((_classNames3 = {}, _defineProperty$1(_classNames3, prefixCls + "-middle", mergedSize === 'middle'), _defineProperty$1(_classNames3, prefixCls + "-small", mergedSize === 'small'), _defineProperty$1(_classNames3, prefixCls + "-bordered", bordered), _defineProperty$1(_classNames3, prefixCls + "-empty", rawData.length === 0), _classNames3)),
        data: pageData,
        rowKey: getRowKey,
        rowClassName: internalRowClassName,
        emptyText: locale && locale.emptyText || (renderEmpty || defaultRenderEmpty$1)('Table'),
        internalHooks: INTERNAL_HOOKS,
        internalRefs: internalRefs,
        transformColumns: transformColumns
      }), bottomPaginationNode]
    })
  }));
}
var ForwardTable = /*#__PURE__*/react.exports.forwardRef(InternalTable);
var Table = ForwardTable;
Table.SELECTION_COLUMN = SELECTION_COLUMN;
Table.EXPAND_COLUMN = Table$2.EXPAND_COLUMN;
Table.SELECTION_ALL = SELECTION_ALL;
Table.SELECTION_INVERT = SELECTION_INVERT;
Table.SELECTION_NONE = SELECTION_NONE;
Table.Column = Column;
Table.ColumnGroup = ColumnGroup;
Table.Summary = FooterComponents;
const Table$1 = Table;

var __rest$6 = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var inlineStyle = {
  border: 0,
  background: 'transparent',
  padding: 0,
  lineHeight: 'inherit',
  display: 'inline-block'
};
var TransButton = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var onKeyDown = function onKeyDown(event) {
    var keyCode = event.keyCode;
    if (keyCode === KeyCode.ENTER) {
      event.preventDefault();
    }
  };
  var onKeyUp = function onKeyUp(event) {
    var keyCode = event.keyCode;
    var onClick = props.onClick;
    if (keyCode === KeyCode.ENTER && onClick) {
      onClick();
    }
  };
  var style = props.style,
    noStyle = props.noStyle,
    disabled = props.disabled,
    restProps = __rest$6(props, ["style", "noStyle", "disabled"]);
  var mergedStyle = {};
  if (!noStyle) {
    mergedStyle = _extends$2({}, inlineStyle);
  }
  if (disabled) {
    mergedStyle.pointerEvents = 'none';
  }
  mergedStyle = _extends$2(_extends$2({}, mergedStyle), style);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("div", {
      role: "button",
      tabIndex: 0,
      ref: ref,
      ...restProps,
      onKeyDown: onKeyDown,
      onKeyUp: onKeyUp,
      style: mergedStyle
    })
  );
});
const TransButton$1 = TransButton;

// This icon file is generated automatically.
var CopyOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" } }] }, "name": "copy", "theme": "outlined" };
const CopyOutlinedSvg = CopyOutlined$2;

var CopyOutlined = function CopyOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: CopyOutlinedSvg
      })
    })
  );
};
CopyOutlined.displayName = 'CopyOutlined';
const CopyOutlined$1 = /*#__PURE__*/react.exports.forwardRef(CopyOutlined);

// This icon file is generated automatically.
var EditOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" } }] }, "name": "edit", "theme": "outlined" };
const EditOutlinedSvg = EditOutlined$2;

var EditOutlined = function EditOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: EditOutlinedSvg
      })
    })
  );
};
EditOutlined.displayName = 'EditOutlined';
const EditOutlined$1 = /*#__PURE__*/react.exports.forwardRef(EditOutlined);

var toggleSelection = function () {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function () {};
  }
  var active = document.activeElement;

  var ranges = [];
  for (var i = 0; i < selection.rangeCount; i++) {
    ranges.push(selection.getRangeAt(i));
  }

  switch (active.tagName.toUpperCase()) { // .toUpperCase handles XHTML
    case 'INPUT':
    case 'TEXTAREA':
      active.blur();
      break;

    default:
      active = null;
      break;
  }

  selection.removeAllRanges();
  return function () {
    selection.type === 'Caret' &&
    selection.removeAllRanges();

    if (!selection.rangeCount) {
      ranges.forEach(function(range) {
        selection.addRange(range);
      });
    }

    active &&
    active.focus();
  };
};

var deselectCurrent = toggleSelection;

var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
};

var defaultMessage = "Copy to clipboard: #{key}, Enter";

function format(message) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
  return message.replace(/#{\s*key\s*}/g, copyKey);
}

function copy(text, options) {
  var debug,
    message,
    reselectPrevious,
    range,
    selection,
    mark,
    success = false;
  if (!options) {
    options = {};
  }
  debug = options.debug || false;
  try {
    reselectPrevious = deselectCurrent();

    range = document.createRange();
    selection = document.getSelection();

    mark = document.createElement("span");
    mark.textContent = text;
    // avoid screen readers from reading out loud the text
    mark.ariaHidden = "true";
    // reset user styles for span element
    mark.style.all = "unset";
    // prevents scrolling to the end of the page
    mark.style.position = "fixed";
    mark.style.top = 0;
    mark.style.clip = "rect(0, 0, 0, 0)";
    // used to preserve spaces and line breaks
    mark.style.whiteSpace = "pre";
    // do not inherit user-select (it may be `none`)
    mark.style.webkitUserSelect = "text";
    mark.style.MozUserSelect = "text";
    mark.style.msUserSelect = "text";
    mark.style.userSelect = "text";
    mark.addEventListener("copy", function(e) {
      e.stopPropagation();
      if (options.format) {
        e.preventDefault();
        if (typeof e.clipboardData === "undefined") { // IE 11
          debug && console.warn("unable to use e.clipboardData");
          debug && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format, text);
        } else { // all other browsers
          e.clipboardData.clearData();
          e.clipboardData.setData(options.format, text);
        }
      }
      if (options.onCopy) {
        e.preventDefault();
        options.onCopy(e.clipboardData);
      }
    });

    document.body.appendChild(mark);

    range.selectNodeContents(mark);
    selection.addRange(range);

    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err);
    debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err) {
      debug && console.error("unable to copy using clipboardData: ", err);
      debug && console.error("falling back to prompt");
      message = format("message" in options ? options.message : defaultMessage);
      window.prompt(message, text);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range);
      } else {
        selection.removeAllRanges();
      }
    }

    if (mark) {
      document.body.removeChild(mark);
    }
    reselectPrevious();
  }

  return success;
}

var copyToClipboard = copy;

// This icon file is generated automatically.
var EnterOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z" } }] }, "name": "enter", "theme": "outlined" };
const EnterOutlinedSvg = EnterOutlined$2;

var EnterOutlined = function EnterOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: EnterOutlinedSvg
      })
    })
  );
};
EnterOutlined.displayName = 'EnterOutlined';
const EnterOutlined$1 = /*#__PURE__*/react.exports.forwardRef(EnterOutlined);

// eslint-disable-next-line import/prefer-default-export
var getTitleStyle = function getTitleStyle(fontSize, lineHeight, color, token) {
  var sizeMarginHeadingVerticalEnd = token.sizeMarginHeadingVerticalEnd,
    fontWeightStrong = token.fontWeightStrong;
  return {
    marginBottom: sizeMarginHeadingVerticalEnd,
    color: color,
    fontWeight: fontWeightStrong,
    fontSize: fontSize,
    lineHeight: lineHeight
  };
};
// eslint-disable-next-line import/prefer-default-export
var getTitleStyles = function getTitleStyles(token) {
  var headings = [1, 2, 3, 4, 5];
  var styles = {};
  headings.forEach(function (headingLevel) {
    styles["\n      h" + headingLevel + "&,\n      div&-h" + headingLevel + ",\n      div&-h" + headingLevel + " > textarea,\n      h" + headingLevel + "\n    "] = getTitleStyle(token["fontSizeHeading" + headingLevel], token["lineHeightHeading" + headingLevel], token.colorTextHeading, token);
  });
  return styles;
};
var getLinkStyles = function getLinkStyles(token) {
  var componentCls = token.componentCls;
  return {
    'a&, a': _extends$2(_extends$2({}, operationUnit(token)), _defineProperty$1({
      textDecoration: token.linkDecoration,
      '&:active, &:hover': {
        textDecoration: token.linkHoverDecoration
      }
    }, "&[disabled], &" + componentCls + "-disabled", {
      color: token.colorTextDisabled,
      cursor: 'not-allowed',
      '&:active, &:hover': {
        color: token.colorTextDisabled
      },
      '&:active': {
        pointerEvents: 'none'
      }
    }))
  };
};
var getResetStyles = function getResetStyles() {
  return {
    code: {
      margin: '0 0.2em',
      paddingInline: '0.4em',
      paddingBlock: '0.2em 0.1em',
      fontSize: '85%',
      background: 'rgba(150, 150, 150, 0.1)',
      border: '1px solid rgba(100, 100, 100, 0.2)',
      borderRadius: 3
    },
    kbd: {
      margin: '0 0.2em',
      paddingInline: '0.4em',
      paddingBlock: '0.15em 0.1em',
      fontSize: '90%',
      background: 'rgba(150, 150, 150, 0.06)',
      border: '1px solid rgba(100, 100, 100, 0.2)',
      borderBottomWidth: 2,
      borderRadius: 3
    },
    mark: {
      padding: 0,
      // FIXME hardcode in v4
      backgroundColor: gold[2]
    },
    'u, ins': {
      textDecoration: 'underline',
      textDecorationSkipInk: 'auto'
    },
    's, del': {
      textDecoration: 'line-through'
    },
    strong: {
      fontWeight: 600
    },
    // list
    'ul, ol': {
      marginInline: 0,
      marginBlock: '0 1em',
      padding: 0,
      li: {
        marginInline: '20px 0',
        marginBlock: 0,
        paddingInline: '4px 0',
        paddingBlock: 0
      }
    },
    ul: {
      listStyleType: 'circle',
      ul: {
        listStyleType: 'disc'
      }
    },
    ol: {
      listStyleType: 'decimal'
    },
    // pre & block
    'pre, blockquote': {
      margin: '1em 0'
    },
    pre: {
      padding: '0.4em 0.6em',
      whiteSpace: 'pre-wrap',
      wordWrap: 'break-word',
      background: 'rgba(150, 150, 150, 0.1)',
      border: '1px solid rgba(100, 100, 100, 0.2)',
      borderRadius: 3,
      // Compatible for marked
      code: {
        display: 'inline',
        margin: 0,
        padding: 0,
        fontSize: 'inherit',
        fontFamily: 'inherit',
        background: 'transparent',
        border: 0
      }
    },
    blockquote: {
      paddingInline: '0.6em 0',
      paddingBlock: 0,
      borderInlineStart: '4px solid rgba(100, 100, 100, 0.2)',
      opacity: 0.85
    }
  };
};
var getEditableStyles = function getEditableStyles(token) {
  var _editContent;
  var componentCls = token.componentCls;
  var inputToken = initInputToken(token);
  var inputShift = inputToken.inputPaddingVertical + 1;
  return {
    '&-edit-content': (_editContent = {
      position: 'relative',
      'div&': {
        insetInlineStart: -token.paddingSM,
        marginTop: -inputShift,
        marginBottom: "calc(1em - " + inputShift + "px)"
      }
    }, _defineProperty$1(_editContent, componentCls + "-edit-content-confirm", {
      position: 'absolute',
      insetInlineEnd: token.marginXS + 2,
      insetBlockEnd: token.marginXS,
      color: token.colorTextDescription,
      // default style
      fontWeight: 'normal',
      fontSize: token.fontSize,
      fontStyle: 'normal',
      pointerEvents: 'none'
    }), _defineProperty$1(_editContent, "textarea", {
      margin: '0!important',
      // Fix Editable Textarea flash in Firefox
      MozTransition: 'none',
      height: '1em'
    }), _editContent)
  };
};
var getCopiableStyles = function getCopiableStyles(token) {
  return {
    '&-copy-success': _defineProperty$1({}, "\n    &,\n    &:hover,\n    &:focus", {
      color: token.colorSuccess
    })
  };
};
var getEllipsisStyles = function getEllipsisStyles() {
  var _ref;
  return _ref = {}, _defineProperty$1(_ref, "\n  a&-ellipsis,\n  span&-ellipsis\n  ", {
    display: 'inline-block',
    maxWidth: '100%'
  }), _defineProperty$1(_ref, '&-single-line', {
    whiteSpace: 'nowrap'
  }), _defineProperty$1(_ref, '&-ellipsis-single-line', {
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    // https://blog.csdn.net/iefreer/article/details/50421025
    'a&, span&': {
      verticalAlign: 'bottom'
    }
  }), _defineProperty$1(_ref, '&-ellipsis-multiple-line', {
    display: '-webkit-box',
    overflow: 'hidden',
    WebkitLineClamp: 3,
    WebkitBoxOrient: 'vertical'
  }), _ref;
};

var genTypographyStyle = function genTypographyStyle(token) {
  var _extends3;
  var componentCls = token.componentCls,
    sizeMarginHeadingVerticalStart = token.sizeMarginHeadingVerticalStart;
  return _defineProperty$1({}, componentCls, _extends$2(_extends$2(_extends$2(_extends$2(_extends$2(_extends$2(_extends$2(_extends$2(_extends$2(_defineProperty$1({
    color: token.colorText,
    wordBreak: 'break-word',
    lineHeight: token.lineHeight,
    '&&-secondary': {
      color: token.colorTextDescription
    },
    '&&-success': {
      color: token.colorSuccess
    },
    '&&-warning': {
      color: token.colorWarning
    },
    '&&-danger': {
      color: token.colorError,
      'a&:active, a&:focus': {
        color: token.colorErrorActive
      },
      'a&:hover': {
        color: token.colorErrorHover
      }
    },
    '&&-disabled': {
      color: token.colorTextDisabled,
      cursor: 'not-allowed',
      userSelect: 'none'
    }
  }, "\n        div&,\n        p\n      ", {
    marginBottom: '1em'
  }), getTitleStyles(token)), (_extends3 = {}, _defineProperty$1(_extends3, "\n      & + h1&,\n      & + h2&,\n      & + h3&,\n      & + h4&,\n      & + h5&\n      ", {
    marginTop: sizeMarginHeadingVerticalStart
  }), _defineProperty$1(_extends3, "\n      div,\n      ul,\n      li,\n      p,\n      h1,\n      h2,\n      h3,\n      h4,\n      h5", _defineProperty$1({}, "\n        + h1,\n        + h2,\n        + h3,\n        + h4,\n        + h5\n        ", {
    marginTop: sizeMarginHeadingVerticalStart
  })), _extends3)), getResetStyles()), getLinkStyles(token)), _defineProperty$1({}, "\n        " + componentCls + "-expand,\n        " + componentCls + "-edit,\n        " + componentCls + "-copy\n      ", _extends$2(_extends$2({}, operationUnit(token)), {
    marginInlineStart: token.marginXXS
  }))), getEditableStyles(token)), getCopiableStyles(token)), getEllipsisStyles()), {
    '&-rtl': {
      direction: 'rtl'
    }
  }));
};
// ============================== Export ==============================
const useStyle = genComponentStyleHook('Typography', function (token) {
  return [genTypographyStyle(token)];
}, {
  sizeMarginHeadingVerticalStart: '1.2em',
  sizeMarginHeadingVerticalEnd: '0.5em'
});

var Editable = function Editable(_ref) {
  var prefixCls = _ref.prefixCls,
    ariaLabel = _ref['aria-label'],
    className = _ref.className,
    style = _ref.style,
    direction = _ref.direction,
    maxLength = _ref.maxLength,
    _ref$autoSize = _ref.autoSize,
    autoSize = _ref$autoSize === void 0 ? true : _ref$autoSize,
    value = _ref.value,
    onSave = _ref.onSave,
    onCancel = _ref.onCancel,
    onEnd = _ref.onEnd,
    component = _ref.component,
    _ref$enterIcon = _ref.enterIcon,
    enterIcon = _ref$enterIcon === void 0 ?
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(EnterOutlined$1, {}) : _ref$enterIcon;
  var ref = react.exports.useRef(null);
  var inComposition = react.exports.useRef(false);
  var lastKeyCode = react.exports.useRef();
  var _React$useState = react.exports.useState(value),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    current = _React$useState2[0],
    setCurrent = _React$useState2[1];
  react.exports.useEffect(function () {
    setCurrent(value);
  }, [value]);
  react.exports.useEffect(function () {
    if (ref.current && ref.current.resizableTextArea) {
      var textArea = ref.current.resizableTextArea.textArea;
      textArea.focus();
      var length = textArea.value.length;
      textArea.setSelectionRange(length, length);
    }
  }, []);
  var onChange = function onChange(_ref2) {
    var target = _ref2.target;
    setCurrent(target.value.replace(/[\n\r]/g, ''));
  };
  var onCompositionStart = function onCompositionStart() {
    inComposition.current = true;
  };
  var onCompositionEnd = function onCompositionEnd() {
    inComposition.current = false;
  };
  var onKeyDown = function onKeyDown(_ref3) {
    var keyCode = _ref3.keyCode;
    // We don't record keyCode when IME is using
    if (inComposition.current) return;
    lastKeyCode.current = keyCode;
  };
  var confirmChange = function confirmChange() {
    onSave(current.trim());
  };
  var onKeyUp = function onKeyUp(_ref4) {
    var keyCode = _ref4.keyCode,
      ctrlKey = _ref4.ctrlKey,
      altKey = _ref4.altKey,
      metaKey = _ref4.metaKey,
      shiftKey = _ref4.shiftKey;
    // Check if it's a real key
    if (lastKeyCode.current === keyCode && !inComposition.current && !ctrlKey && !altKey && !metaKey && !shiftKey) {
      if (keyCode === KeyCode.ENTER) {
        confirmChange();
        onEnd === null || onEnd === void 0 ? void 0 : onEnd();
      } else if (keyCode === KeyCode.ESC) {
        onCancel();
      }
    }
  };
  var onBlur = function onBlur() {
    confirmChange();
  };
  var textClassName = component ? prefixCls + "-" + component : '';
  var _useStyle = useStyle(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var textAreaClassName = classNames$1(prefixCls, prefixCls + "-edit-content", _defineProperty$1({}, prefixCls + "-rtl", direction === 'rtl'), className, textClassName, hashId);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  jsxs("div", {
    className: textAreaClassName,
    style: style,
    children: [/*#__PURE__*/jsx$1(TextArea$1, {
      ref: ref,
      maxLength: maxLength,
      value: current,
      onChange: onChange,
      onKeyDown: onKeyDown,
      onKeyUp: onKeyUp,
      onCompositionStart: onCompositionStart,
      onCompositionEnd: onCompositionEnd,
      onBlur: onBlur,
      "aria-label": ariaLabel,
      rows: 1,
      autoSize: autoSize
    }), enterIcon !== null ? cloneElement(enterIcon, {
      className: prefixCls + "-edit-content-confirm"
    }) : null]
  }));
};
const Editable$1 = Editable;

function useMergedConfig(propConfig, templateConfig) {
  return react.exports.useMemo(function () {
    var support = !!propConfig;
    return [support, _extends$2(_extends$2({}, templateConfig), support && _typeof$1(propConfig) === 'object' ? propConfig : null)];
  }, [propConfig]);
}

/** Similar with `useEffect` but only trigger after mounted */
var useUpdatedEffect = function useUpdatedEffect(callback, conditions) {
  var mountRef = react.exports.useRef(false);
  react.exports.useEffect(function () {
    if (mountRef.current) {
      callback();
    } else {
      mountRef.current = true;
    }
  }, conditions);
};
const useUpdatedEffect$1 = useUpdatedEffect;

var __rest$5 = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var Typography$2 = /*#__PURE__*/react.exports.forwardRef(function (_a, ref) {
  var customizePrefixCls = _a.prefixCls,
    _a$component = _a.component,
    Component = _a$component === void 0 ? 'article' : _a$component,
    className = _a.className,
    setContentRef = _a.setContentRef,
    children = _a.children,
    typographyDirection = _a.direction,
    restProps = __rest$5(_a, ["prefixCls", "component", "className", "setContentRef", "children", "direction"]);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    contextDirection = _React$useContext.direction;
  var direction = typographyDirection !== null && typographyDirection !== void 0 ? typographyDirection : contextDirection;
  var mergedRef = ref;
  if (setContentRef) {
    mergedRef = composeRef(ref, setContentRef);
  }
  var prefixCls = getPrefixCls('typography', customizePrefixCls);
  // Style
  var _useStyle = useStyle(prefixCls),
    _useStyle2 = _slicedToArray(_useStyle, 2),
    wrapSSR = _useStyle2[0],
    hashId = _useStyle2[1];
  var componentClassName = classNames$1(prefixCls, _defineProperty$1({}, prefixCls + "-rtl", direction === 'rtl'), className, hashId);
  return wrapSSR(
  /*#__PURE__*/
  /*#__PURE__*/
  // @ts-expect-error: Expression produces a union type that is too complex to represent.
  jsx$1(Component, {
    className: componentClassName,
    ref: mergedRef,
    ...restProps,
    children: children
  }));
});
// es default export should use const instead of let
const OriginTypography = Typography$2;

function cuttable(node) {
  var type = _typeof$1(node);
  return type === 'string' || type === 'number';
}
function getNodesLen(nodeList) {
  var totalLen = 0;
  nodeList.forEach(function (node) {
    if (cuttable(node)) {
      totalLen += String(node).length;
    } else {
      totalLen += 1;
    }
  });
  return totalLen;
}
function sliceNodes(nodeList, len) {
  var currLen = 0;
  var currentNodeList = [];
  for (var i = 0; i < nodeList.length; i += 1) {
    // Match to return
    if (currLen === len) {
      return currentNodeList;
    }
    var node = nodeList[i];
    var canCut = cuttable(node);
    var nodeLen = canCut ? String(node).length : 1;
    var nextLen = currLen + nodeLen;
    // Exceed but current not which means we need cut this
    // This will not happen on validate ReactElement
    if (nextLen > len) {
      var restLen = len - currLen;
      currentNodeList.push(String(node).slice(0, restLen));
      return currentNodeList;
    }
    currentNodeList.push(node);
    currLen = nextLen;
  }
  return nodeList;
}
var NONE = 0;
var PREPARE = 1;
var WALKING = 2;
var DONE_WITH_ELLIPSIS = 3;
var DONE_WITHOUT_ELLIPSIS = 4;
var Ellipsis = function Ellipsis(_ref) {
  var enabledMeasure = _ref.enabledMeasure,
    children = _ref.children,
    text = _ref.text,
    width = _ref.width,
    fontSize = _ref.fontSize,
    rows = _ref.rows,
    onEllipsis = _ref.onEllipsis;
  var _React$useState = react.exports.useState([0, 0, 0]),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    _React$useState2$ = _slicedToArray(_React$useState2[0], 3),
    startLen = _React$useState2$[0],
    midLen = _React$useState2$[1],
    endLen = _React$useState2$[2],
    setCutLength = _React$useState2[1];
  var _React$useState3 = react.exports.useState(NONE),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    walkingState = _React$useState4[0],
    setWalkingState = _React$useState4[1];
  var _React$useState5 = react.exports.useState(0),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    singleRowHeight = _React$useState6[0],
    setSingleRowHeight = _React$useState6[1];
  var singleRowRef = react.exports.useRef(null);
  var midRowRef = react.exports.useRef(null);
  var nodeList = react.exports.useMemo(function () {
    return toArray$5(text);
  }, [text]);
  var totalLen = react.exports.useMemo(function () {
    return getNodesLen(nodeList);
  }, [nodeList]);
  var mergedChildren = react.exports.useMemo(function () {
    if (!enabledMeasure || walkingState !== DONE_WITH_ELLIPSIS) {
      return children(nodeList, false);
    }
    return children(sliceNodes(nodeList, midLen), midLen < totalLen);
  }, [enabledMeasure, walkingState, children, nodeList, midLen, totalLen]);
  // ======================== Walk ========================
  useLayoutEffect$1(function () {
    if (enabledMeasure && width && fontSize && totalLen) {
      setWalkingState(PREPARE);
      setCutLength([0, Math.ceil(totalLen / 2), totalLen]);
    }
  }, [enabledMeasure, width, fontSize, text, totalLen, rows]);
  useLayoutEffect$1(function () {
    var _a;
    if (walkingState === PREPARE) {
      setSingleRowHeight(((_a = singleRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0);
    }
  }, [walkingState]);
  useLayoutEffect$1(function () {
    var _a, _b;
    if (singleRowHeight) {
      if (walkingState === PREPARE) {
        // Ignore if position is enough
        var midHeight = ((_a = midRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;
        var maxHeight = rows * singleRowHeight;
        if (midHeight <= maxHeight) {
          setWalkingState(DONE_WITHOUT_ELLIPSIS);
          onEllipsis(false);
        } else {
          setWalkingState(WALKING);
        }
      } else if (walkingState === WALKING) {
        if (startLen !== endLen) {
          var _midHeight = ((_b = midRowRef.current) === null || _b === void 0 ? void 0 : _b.offsetHeight) || 0;
          var _maxHeight = rows * singleRowHeight;
          var nextStartLen = startLen;
          var nextEndLen = endLen;
          // We reach the last round
          if (startLen === endLen - 1) {
            nextEndLen = startLen;
          } else if (_midHeight <= _maxHeight) {
            nextStartLen = midLen;
          } else {
            nextEndLen = midLen;
          }
          var nextMidLen = Math.ceil((nextStartLen + nextEndLen) / 2);
          setCutLength([nextStartLen, nextMidLen, nextEndLen]);
        } else {
          setWalkingState(DONE_WITH_ELLIPSIS);
          onEllipsis(true);
        }
      }
    }
  }, [walkingState, startLen, endLen, rows, singleRowHeight]);
  // ======================= Render =======================
  var measureStyle = {
    width: width,
    whiteSpace: 'normal',
    margin: 0,
    padding: 0
  };
  var renderMeasure = function renderMeasure(content, ref, style) {
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("span", {
        "aria-hidden": true,
        ref: ref,
        style: _extends$2({
          position: 'fixed',
          display: 'block',
          left: 0,
          top: 0,
          zIndex: -9999,
          visibility: 'hidden',
          pointerEvents: 'none',
          fontSize: Math.floor(fontSize / 2) * 2
        }, style),
        children: content
      })
    );
  };
  var renderMeasureSlice = function renderMeasureSlice(len, ref) {
    var sliceNodeList = sliceNodes(nodeList, len);
    return renderMeasure(children(sliceNodeList, true), ref, measureStyle);
  };
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs(Fragment, {
      children: [mergedChildren, enabledMeasure && walkingState !== DONE_WITH_ELLIPSIS && walkingState !== DONE_WITHOUT_ELLIPSIS &&
      /*#__PURE__*/
      /*#__PURE__*/
      jsxs(Fragment, {
        children: [renderMeasure('lg', singleRowRef, {
          wordBreak: 'keep-all',
          whiteSpace: 'nowrap'
        }), walkingState === PREPARE ? renderMeasure(children(nodeList, false), midRowRef, measureStyle) : renderMeasureSlice(midLen, midRowRef)]
      })]
    })
  );
};
const Ellipsis$1 = Ellipsis;

var EllipsisTooltip = function EllipsisTooltip(_ref) {
  var enabledEllipsis = _ref.enabledEllipsis,
    isEllipsis = _ref.isEllipsis,
    children = _ref.children,
    tooltipProps = _ref.tooltipProps;
  if (!(tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.title) || !enabledEllipsis) {
    return children;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Tooltip$1, {
      open: isEllipsis ? undefined : false,
      ...tooltipProps,
      children: children
    })
  );
};
const EllipsisTooltip$1 = EllipsisTooltip;

var __rest$4 = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
function wrapperDecorations(_ref, content) {
  var mark = _ref.mark,
    code = _ref.code,
    underline = _ref.underline,
    del = _ref["delete"],
    strong = _ref.strong,
    keyboard = _ref.keyboard,
    italic = _ref.italic;
  var currentContent = content;
  function wrap(needed, tag) {
    if (!needed) return;
    currentContent = /*#__PURE__*/react.exports.createElement(tag, {}, currentContent);
  }
  wrap(strong, 'strong');
  wrap(underline, 'u');
  wrap(del, 'del');
  wrap(code, 'code');
  wrap(mark, 'mark');
  wrap(keyboard, 'kbd');
  wrap(italic, 'i');
  return currentContent;
}
function getNode(dom, defaultNode, needDom) {
  if (dom === true || dom === undefined) {
    return defaultNode;
  }
  return dom || needDom && defaultNode;
}
function toList(val) {
  if (val === false) {
    return [false, false];
  }
  return Array.isArray(val) ? val : [val];
}
var ELLIPSIS_STR = '...';
var Base = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _a, _b, _c;
  var customizePrefixCls = props.prefixCls,
    className = props.className,
    style = props.style,
    type = props.type,
    disabled = props.disabled,
    children = props.children,
    ellipsis = props.ellipsis,
    editable = props.editable,
    copyable = props.copyable,
    component = props.component,
    title = props.title,
    restProps = __rest$4(props, ["prefixCls", "className", "style", "type", "disabled", "children", "ellipsis", "editable", "copyable", "component", "title"]);
  var _React$useContext = react.exports.useContext(ConfigContext),
    getPrefixCls = _React$useContext.getPrefixCls,
    direction = _React$useContext.direction;
  var textLocale = useLocaleReceiver('Text')[0]; // Force TS get this
  var typographyRef = react.exports.useRef(null);
  var editIconRef = react.exports.useRef(null);
  // ============================ MISC ============================
  var prefixCls = getPrefixCls('typography', customizePrefixCls);
  var textProps = omit$1(restProps, ['mark', 'code', 'delete', 'underline', 'strong', 'keyboard', 'italic']);
  // ========================== Editable ==========================
  var _useMergedConfig = useMergedConfig(editable),
    _useMergedConfig2 = _slicedToArray(_useMergedConfig, 2),
    enableEdit = _useMergedConfig2[0],
    editConfig = _useMergedConfig2[1];
  var _useMergedState = useMergedState(false, {
      value: editConfig.editing
    }),
    _useMergedState2 = _slicedToArray(_useMergedState, 2),
    editing = _useMergedState2[0],
    setEditing = _useMergedState2[1];
  var _editConfig$triggerTy = editConfig.triggerType,
    triggerType = _editConfig$triggerTy === void 0 ? ['icon'] : _editConfig$triggerTy;
  var triggerEdit = function triggerEdit(edit) {
    var _a;
    if (edit) {
      (_a = editConfig.onStart) === null || _a === void 0 ? void 0 : _a.call(editConfig);
    }
    setEditing(edit);
  };
  // Focus edit icon when back
  useUpdatedEffect$1(function () {
    var _a;
    if (!editing) {
      (_a = editIconRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }
  }, [editing]);
  var onEditClick = function onEditClick(e) {
    e === null || e === void 0 ? void 0 : e.preventDefault();
    triggerEdit(true);
  };
  var onEditChange = function onEditChange(value) {
    var _a;
    (_a = editConfig.onChange) === null || _a === void 0 ? void 0 : _a.call(editConfig, value);
    triggerEdit(false);
  };
  var onEditCancel = function onEditCancel() {
    var _a;
    (_a = editConfig.onCancel) === null || _a === void 0 ? void 0 : _a.call(editConfig);
    triggerEdit(false);
  };
  // ========================== Copyable ==========================
  var _useMergedConfig3 = useMergedConfig(copyable),
    _useMergedConfig4 = _slicedToArray(_useMergedConfig3, 2),
    enableCopy = _useMergedConfig4[0],
    copyConfig = _useMergedConfig4[1];
  var _React$useState = react.exports.useState(false),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    copied = _React$useState2[0],
    setCopied = _React$useState2[1];
  var copyIdRef = react.exports.useRef();
  var copyOptions = {};
  if (copyConfig.format) {
    copyOptions.format = copyConfig.format;
  }
  var cleanCopyId = function cleanCopyId() {
    window.clearTimeout(copyIdRef.current);
  };
  var onCopyClick = function onCopyClick(e) {
    var _a;
    e === null || e === void 0 ? void 0 : e.preventDefault();
    e === null || e === void 0 ? void 0 : e.stopPropagation();
    copyToClipboard(copyConfig.text || String(children) || '', copyOptions);
    setCopied(true);
    // Trigger tips update
    cleanCopyId();
    copyIdRef.current = window.setTimeout(function () {
      setCopied(false);
    }, 3000);
    (_a = copyConfig.onCopy) === null || _a === void 0 ? void 0 : _a.call(copyConfig, e);
  };
  react.exports.useEffect(function () {
    return cleanCopyId;
  }, []);
  // ========================== Ellipsis ==========================
  var _React$useState3 = react.exports.useState(false),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    isLineClampSupport = _React$useState4[0],
    setIsLineClampSupport = _React$useState4[1];
  var _React$useState5 = react.exports.useState(false),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    isTextOverflowSupport = _React$useState6[0],
    setIsTextOverflowSupport = _React$useState6[1];
  var _React$useState7 = react.exports.useState(false),
    _React$useState8 = _slicedToArray(_React$useState7, 2),
    expanded = _React$useState8[0],
    setExpanded = _React$useState8[1];
  var _React$useState9 = react.exports.useState(false),
    _React$useState10 = _slicedToArray(_React$useState9, 2),
    isJsEllipsis = _React$useState10[0],
    setIsJsEllipsis = _React$useState10[1];
  var _React$useState11 = react.exports.useState(false),
    _React$useState12 = _slicedToArray(_React$useState11, 2),
    isNativeEllipsis = _React$useState12[0],
    setIsNativeEllipsis = _React$useState12[1];
  var _React$useState13 = react.exports.useState(true),
    _React$useState14 = _slicedToArray(_React$useState13, 2),
    isNativeVisible = _React$useState14[0],
    setIsNativeVisible = _React$useState14[1];
  var _useMergedConfig5 = useMergedConfig(ellipsis, {
      expandable: false
    }),
    _useMergedConfig6 = _slicedToArray(_useMergedConfig5, 2),
    enableEllipsis = _useMergedConfig6[0],
    ellipsisConfig = _useMergedConfig6[1];
  var mergedEnableEllipsis = enableEllipsis && !expanded;
  // Shared prop to reduce bundle size
  var _ellipsisConfig$rows = ellipsisConfig.rows,
    rows = _ellipsisConfig$rows === void 0 ? 1 : _ellipsisConfig$rows;
  var needMeasureEllipsis = react.exports.useMemo(function () {
    return (
      // Disable ellipsis
      !mergedEnableEllipsis ||
      // Provide suffix
      ellipsisConfig.suffix !== undefined || ellipsisConfig.onEllipsis ||
      // Can't use css ellipsis since we need to provide the place for button
      ellipsisConfig.expandable || enableEdit || enableCopy
    );
  }, [mergedEnableEllipsis, ellipsisConfig, enableEdit, enableCopy]);
  useLayoutEffect$1(function () {
    if (enableEllipsis && !needMeasureEllipsis) {
      setIsLineClampSupport(isStyleSupport$1('webkitLineClamp'));
      setIsTextOverflowSupport(isStyleSupport$1('textOverflow'));
    }
  }, [needMeasureEllipsis, enableEllipsis]);
  var cssEllipsis = react.exports.useMemo(function () {
    if (needMeasureEllipsis) {
      return false;
    }
    if (rows === 1) {
      return isTextOverflowSupport;
    }
    return isLineClampSupport;
  }, [needMeasureEllipsis, isTextOverflowSupport, isLineClampSupport]);
  var isMergedEllipsis = mergedEnableEllipsis && (cssEllipsis ? isNativeEllipsis : isJsEllipsis);
  var cssTextOverflow = mergedEnableEllipsis && rows === 1 && cssEllipsis;
  var cssLineClamp = mergedEnableEllipsis && rows > 1 && cssEllipsis;
  // >>>>> Expand
  var onExpandClick = function onExpandClick(e) {
    var _a;
    setExpanded(true);
    (_a = ellipsisConfig.onExpand) === null || _a === void 0 ? void 0 : _a.call(ellipsisConfig, e);
  };
  var _React$useState15 = react.exports.useState(0),
    _React$useState16 = _slicedToArray(_React$useState15, 2),
    ellipsisWidth = _React$useState16[0],
    setEllipsisWidth = _React$useState16[1];
  var _React$useState17 = react.exports.useState(0),
    _React$useState18 = _slicedToArray(_React$useState17, 2),
    ellipsisFontSize = _React$useState18[0],
    setEllipsisFontSize = _React$useState18[1];
  var onResize = function onResize(_ref2, element) {
    var offsetWidth = _ref2.offsetWidth;
    var _a;
    setEllipsisWidth(offsetWidth);
    setEllipsisFontSize(parseInt((_a = window.getComputedStyle) === null || _a === void 0 ? void 0 : _a.call(window, element).fontSize, 10) || 0);
  };
  // >>>>> JS Ellipsis
  var onJsEllipsis = function onJsEllipsis(jsEllipsis) {
    var _a;
    setIsJsEllipsis(jsEllipsis);
    // Trigger if changed
    if (isJsEllipsis !== jsEllipsis) {
      (_a = ellipsisConfig.onEllipsis) === null || _a === void 0 ? void 0 : _a.call(ellipsisConfig, jsEllipsis);
    }
  };
  // >>>>> Native ellipsis
  react.exports.useEffect(function () {
    var textEle = typographyRef.current;
    if (enableEllipsis && cssEllipsis && textEle) {
      var currentEllipsis = cssLineClamp ? textEle.offsetHeight < textEle.scrollHeight : textEle.offsetWidth < textEle.scrollWidth;
      if (isNativeEllipsis !== currentEllipsis) {
        setIsNativeEllipsis(currentEllipsis);
      }
    }
  }, [enableEllipsis, cssEllipsis, children, cssLineClamp, isNativeVisible]);
  // https://github.com/ant-design/ant-design/issues/36786
  // Use IntersectionObserver to check if element is invisible
  react.exports.useEffect(function () {
    var textEle = typographyRef.current;
    if (typeof IntersectionObserver === 'undefined' || !textEle || !cssEllipsis || !mergedEnableEllipsis) {
      return;
    }
    /* eslint-disable-next-line compat/compat */
    var observer = new IntersectionObserver(function () {
      setIsNativeVisible(!!textEle.offsetParent);
    });
    observer.observe(textEle);
    return function () {
      observer.disconnect();
    };
  }, [cssEllipsis, mergedEnableEllipsis]);
  // ========================== Tooltip ===========================
  var tooltipProps = {};
  if (ellipsisConfig.tooltip === true) {
    tooltipProps = {
      title: (_a = editConfig.text) !== null && _a !== void 0 ? _a : children
    };
  } else if ( /*#__PURE__*/react.exports.isValidElement(ellipsisConfig.tooltip)) {
    tooltipProps = {
      title: ellipsisConfig.tooltip
    };
  } else if (_typeof$1(ellipsisConfig.tooltip) === 'object') {
    tooltipProps = _extends$2({
      title: (_b = editConfig.text) !== null && _b !== void 0 ? _b : children
    }, ellipsisConfig.tooltip);
  } else {
    tooltipProps = {
      title: ellipsisConfig.tooltip
    };
  }
  var topAriaLabel = react.exports.useMemo(function () {
    var isValid = function isValid(val) {
      return ['string', 'number'].includes(_typeof$1(val));
    };
    if (!enableEllipsis || cssEllipsis) {
      return undefined;
    }
    if (isValid(editConfig.text)) {
      return editConfig.text;
    }
    if (isValid(children)) {
      return children;
    }
    if (isValid(title)) {
      return title;
    }
    if (isValid(tooltipProps.title)) {
      return tooltipProps.title;
    }
    return undefined;
  }, [enableEllipsis, cssEllipsis, title, tooltipProps.title, isMergedEllipsis]);
  // =========================== Render ===========================
  // >>>>>>>>>>> Editing input
  if (editing) {
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(Editable$1, {
        value: (_c = editConfig.text) !== null && _c !== void 0 ? _c : typeof children === 'string' ? children : '',
        onSave: onEditChange,
        onCancel: onEditCancel,
        onEnd: editConfig.onEnd,
        prefixCls: prefixCls,
        className: className,
        style: style,
        direction: direction,
        component: component,
        maxLength: editConfig.maxLength,
        autoSize: editConfig.autoSize,
        enterIcon: editConfig.enterIcon
      })
    );
  }
  // >>>>>>>>>>> Typography
  // Expand
  var renderExpand = function renderExpand() {
    var expandable = ellipsisConfig.expandable,
      symbol = ellipsisConfig.symbol;
    if (!expandable) return null;
    var expandContent;
    if (symbol) {
      expandContent = symbol;
    } else {
      expandContent = textLocale.expand;
    }
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("a", {
        className: prefixCls + "-expand",
        onClick: onExpandClick,
        "aria-label": textLocale.expand,
        children: expandContent
      }, "expand")
    );
  };
  // Edit
  var renderEdit = function renderEdit() {
    if (!enableEdit) return;
    var icon = editConfig.icon,
      tooltip = editConfig.tooltip;
    var editTitle = toArray$5(tooltip)[0] || textLocale.edit;
    var ariaLabel = typeof editTitle === 'string' ? editTitle : '';
    return triggerType.includes('icon') ?
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Tooltip$1, {
      title: tooltip === false ? '' : editTitle,
      children: /*#__PURE__*/jsx$1(TransButton$1, {
        ref: editIconRef,
        className: prefixCls + "-edit",
        onClick: onEditClick,
        "aria-label": ariaLabel,
        children: icon ||
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(EditOutlined$1, {
          role: "button"
        })
      })
    }, "edit") : null;
  };
  // Copy
  var renderCopy = function renderCopy() {
    if (!enableCopy) return;
    var tooltips = copyConfig.tooltips,
      icon = copyConfig.icon;
    var tooltipNodes = toList(tooltips);
    var iconNodes = toList(icon);
    var copyTitle = copied ? getNode(tooltipNodes[1], textLocale.copied) : getNode(tooltipNodes[0], textLocale.copy);
    var systemStr = copied ? textLocale.copied : textLocale.copy;
    var ariaLabel = typeof copyTitle === 'string' ? copyTitle : systemStr;
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(Tooltip$1, {
        title: copyTitle,
        children: /*#__PURE__*/jsx$1(TransButton$1, {
          className: classNames$1(prefixCls + "-copy", copied && prefixCls + "-copy-success"),
          onClick: onCopyClick,
          "aria-label": ariaLabel,
          children: copied ? getNode(iconNodes[1],
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(CheckOutlined$1, {}), true) : getNode(iconNodes[0],
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(CopyOutlined$1, {}), true)
        })
      }, "copy")
    );
  };
  var renderOperations = function renderOperations(renderExpanded) {
    return [renderExpanded && renderExpand(), renderEdit(), renderCopy()];
  };
  var renderEllipsis = function renderEllipsis(needEllipsis) {
    return [needEllipsis &&
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1("span", {
      "aria-hidden": true,
      children: ELLIPSIS_STR
    }, "ellipsis"), ellipsisConfig.suffix, renderOperations(needEllipsis)];
  };
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(ResizeObserver$1, {
      onResize: onResize,
      disabled: !mergedEnableEllipsis || cssEllipsis,
      children: function (resizeRef) {
        var _classNames;
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(EllipsisTooltip$1, {
            tooltipProps: tooltipProps,
            enabledEllipsis: mergedEnableEllipsis,
            isEllipsis: isMergedEllipsis,
            children: /*#__PURE__*/jsx$1(OriginTypography, {
              className: classNames$1((_classNames = {}, _defineProperty$1(_classNames, prefixCls + "-" + type, type), _defineProperty$1(_classNames, prefixCls + "-disabled", disabled), _defineProperty$1(_classNames, prefixCls + "-ellipsis", enableEllipsis), _defineProperty$1(_classNames, prefixCls + "-single-line", mergedEnableEllipsis && rows === 1), _defineProperty$1(_classNames, prefixCls + "-ellipsis-single-line", cssTextOverflow), _defineProperty$1(_classNames, prefixCls + "-ellipsis-multiple-line", cssLineClamp), _classNames), className),
              prefixCls: customizePrefixCls,
              style: _extends$2(_extends$2({}, style), {
                WebkitLineClamp: cssLineClamp ? rows : undefined
              }),
              component: component,
              ref: composeRef(resizeRef, typographyRef, ref),
              direction: direction,
              onClick: triggerType.includes('text') ? onEditClick : undefined,
              "aria-label": topAriaLabel === null || topAriaLabel === void 0 ? void 0 : topAriaLabel.toString(),
              title: title,
              ...textProps,
              children: /*#__PURE__*/jsx$1(Ellipsis$1, {
                enabledMeasure: mergedEnableEllipsis && !cssEllipsis,
                text: children,
                rows: rows,
                width: ellipsisWidth,
                fontSize: ellipsisFontSize,
                onEllipsis: onJsEllipsis,
                children: function (node, needEllipsis) {
                  var renderNode = node;
                  if (node.length && needEllipsis && topAriaLabel) {
                    renderNode =
                    /*#__PURE__*/
                    /*#__PURE__*/
                    jsx$1("span", {
                      "aria-hidden": true,
                      children: renderNode
                    }, "show-content");
                  }
                  var wrappedContext = wrapperDecorations(props,
                  /*#__PURE__*/
                  /*#__PURE__*/
                  jsxs(Fragment, {
                    children: [renderNode, renderEllipsis(needEllipsis)]
                  }));
                  return wrappedContext;
                }
              })
            })
          })
        );
      }
    })
  );
});
const Base$1 = Base;

var __rest$3 = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var Link$1 = /*#__PURE__*/react.exports.forwardRef(function (_a, ref) {
  var ellipsis = _a.ellipsis,
    rel = _a.rel,
    restProps = __rest$3(_a, ["ellipsis", "rel"]);
  var mergedProps = _extends$2(_extends$2({}, restProps), {
    rel: rel === undefined && restProps.target === '_blank' ? 'noopener noreferrer' : rel
  });
  // @ts-expect-error: https://github.com/ant-design/ant-design/issues/26622
  delete mergedProps.navigate;
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Base$1, {
      ...mergedProps,
      ref: ref,
      ellipsis: !!ellipsis,
      component: "a"
    })
  );
});
const Link$2 = Link$1;

var Paragraph = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Base$1, {
      ref: ref,
      ...props,
      component: "div"
    })
  );
});
const Paragraph$1 = Paragraph;

var __rest$2 = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var Text = function Text(_a, ref) {
  var ellipsis = _a.ellipsis,
    restProps = __rest$2(_a, ["ellipsis"]);
  var mergedEllipsis = react.exports.useMemo(function () {
    if (ellipsis && _typeof$1(ellipsis) === 'object') {
      return omit$1(ellipsis, ['expandable', 'rows']);
    }
    return ellipsis;
  }, [ellipsis]);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Base$1, {
      ref: ref,
      ...restProps,
      ellipsis: mergedEllipsis,
      component: "span"
    })
  );
};
const Text$1 = /*#__PURE__*/react.exports.forwardRef(Text);

var __rest$1 = globalThis && globalThis.__rest || function (s, e) {
  var t = {};
  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
var TITLE_ELE_LIST = [1, 2, 3, 4, 5];
var Title = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var _props$level = props.level,
    level = _props$level === void 0 ? 1 : _props$level,
    restProps = __rest$1(props, ["level"]);
  var component;
  if (TITLE_ELE_LIST.includes(level)) {
    component = "h" + level;
  } else {
    component = 'h1';
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Base$1, {
      ref: ref,
      ...restProps,
      component: component
    })
  );
});
const Title$1 = Title;

var Typography = OriginTypography;
Typography.Text = Text$1;
Typography.Link = Link$2;
Typography.Title = Title$1;
Typography.Paragraph = Paragraph$1;
const Typography$1 = Typography;

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value
}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {
    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
  }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {
    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];
  }
  return target;
};
var qrcodegen;
(qrcodegen2 => {
  const _QrCode = class {
    constructor(version, errorCorrectionLevel, dataCodewords, msk) {
      this.version = version;
      this.errorCorrectionLevel = errorCorrectionLevel;
      this.modules = [];
      this.isFunction = [];
      if (version < _QrCode.MIN_VERSION || version > _QrCode.MAX_VERSION) throw new RangeError("Version value out of range");
      if (msk < -1 || msk > 7) throw new RangeError("Mask value out of range");
      this.size = version * 4 + 17;
      let row = [];
      for (let i = 0; i < this.size; i++) row.push(false);
      for (let i = 0; i < this.size; i++) {
        this.modules.push(row.slice());
        this.isFunction.push(row.slice());
      }
      this.drawFunctionPatterns();
      const allCodewords = this.addEccAndInterleave(dataCodewords);
      this.drawCodewords(allCodewords);
      if (msk == -1) {
        let minPenalty = 1e9;
        for (let i = 0; i < 8; i++) {
          this.applyMask(i);
          this.drawFormatBits(i);
          const penalty = this.getPenaltyScore();
          if (penalty < minPenalty) {
            msk = i;
            minPenalty = penalty;
          }
          this.applyMask(i);
        }
      }
      assert(0 <= msk && msk <= 7);
      this.mask = msk;
      this.applyMask(msk);
      this.drawFormatBits(msk);
      this.isFunction = [];
    }
    static encodeText(text, ecl) {
      const segs = qrcodegen2.QrSegment.makeSegments(text);
      return _QrCode.encodeSegments(segs, ecl);
    }
    static encodeBinary(data, ecl) {
      const seg = qrcodegen2.QrSegment.makeBytes(data);
      return _QrCode.encodeSegments([seg], ecl);
    }
    static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
      if (!(_QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= _QrCode.MAX_VERSION) || mask < -1 || mask > 7) throw new RangeError("Invalid value");
      let version;
      let dataUsedBits;
      for (version = minVersion;; version++) {
        const dataCapacityBits2 = _QrCode.getNumDataCodewords(version, ecl) * 8;
        const usedBits = QrSegment.getTotalBits(segs, version);
        if (usedBits <= dataCapacityBits2) {
          dataUsedBits = usedBits;
          break;
        }
        if (version >= maxVersion) throw new RangeError("Data too long");
      }
      for (const newEcl of [_QrCode.Ecc.MEDIUM, _QrCode.Ecc.QUARTILE, _QrCode.Ecc.HIGH]) {
        if (boostEcl && dataUsedBits <= _QrCode.getNumDataCodewords(version, newEcl) * 8) ecl = newEcl;
      }
      let bb = [];
      for (const seg of segs) {
        appendBits(seg.mode.modeBits, 4, bb);
        appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);
        for (const b of seg.getData()) bb.push(b);
      }
      assert(bb.length == dataUsedBits);
      const dataCapacityBits = _QrCode.getNumDataCodewords(version, ecl) * 8;
      assert(bb.length <= dataCapacityBits);
      appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
      appendBits(0, (8 - bb.length % 8) % 8, bb);
      assert(bb.length % 8 == 0);
      for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17) appendBits(padByte, 8, bb);
      let dataCodewords = [];
      while (dataCodewords.length * 8 < bb.length) dataCodewords.push(0);
      bb.forEach((b, i) => dataCodewords[i >>> 3] |= b << 7 - (i & 7));
      return new _QrCode(version, ecl, dataCodewords, mask);
    }
    getModule(x, y) {
      return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];
    }
    getModules() {
      return this.modules;
    }
    drawFunctionPatterns() {
      for (let i = 0; i < this.size; i++) {
        this.setFunctionModule(6, i, i % 2 == 0);
        this.setFunctionModule(i, 6, i % 2 == 0);
      }
      this.drawFinderPattern(3, 3);
      this.drawFinderPattern(this.size - 4, 3);
      this.drawFinderPattern(3, this.size - 4);
      const alignPatPos = this.getAlignmentPatternPositions();
      const numAlign = alignPatPos.length;
      for (let i = 0; i < numAlign; i++) {
        for (let j = 0; j < numAlign; j++) {
          if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0)) this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
        }
      }
      this.drawFormatBits(0);
      this.drawVersion();
    }
    drawFormatBits(mask) {
      const data = this.errorCorrectionLevel.formatBits << 3 | mask;
      let rem = data;
      for (let i = 0; i < 10; i++) rem = rem << 1 ^ (rem >>> 9) * 1335;
      const bits = (data << 10 | rem) ^ 21522;
      assert(bits >>> 15 == 0);
      for (let i = 0; i <= 5; i++) this.setFunctionModule(8, i, getBit(bits, i));
      this.setFunctionModule(8, 7, getBit(bits, 6));
      this.setFunctionModule(8, 8, getBit(bits, 7));
      this.setFunctionModule(7, 8, getBit(bits, 8));
      for (let i = 9; i < 15; i++) this.setFunctionModule(14 - i, 8, getBit(bits, i));
      for (let i = 0; i < 8; i++) this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
      for (let i = 8; i < 15; i++) this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
      this.setFunctionModule(8, this.size - 8, true);
    }
    drawVersion() {
      if (this.version < 7) return;
      let rem = this.version;
      for (let i = 0; i < 12; i++) rem = rem << 1 ^ (rem >>> 11) * 7973;
      const bits = this.version << 12 | rem;
      assert(bits >>> 18 == 0);
      for (let i = 0; i < 18; i++) {
        const color = getBit(bits, i);
        const a = this.size - 11 + i % 3;
        const b = Math.floor(i / 3);
        this.setFunctionModule(a, b, color);
        this.setFunctionModule(b, a, color);
      }
    }
    drawFinderPattern(x, y) {
      for (let dy = -4; dy <= 4; dy++) {
        for (let dx = -4; dx <= 4; dx++) {
          const dist = Math.max(Math.abs(dx), Math.abs(dy));
          const xx = x + dx;
          const yy = y + dy;
          if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size) this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
        }
      }
    }
    drawAlignmentPattern(x, y) {
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
      }
    }
    setFunctionModule(x, y, isDark) {
      this.modules[y][x] = isDark;
      this.isFunction[y][x] = true;
    }
    addEccAndInterleave(data) {
      const ver = this.version;
      const ecl = this.errorCorrectionLevel;
      if (data.length != _QrCode.getNumDataCodewords(ver, ecl)) throw new RangeError("Invalid argument");
      const numBlocks = _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
      const blockEccLen = _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
      const rawCodewords = Math.floor(_QrCode.getNumRawDataModules(ver) / 8);
      const numShortBlocks = numBlocks - rawCodewords % numBlocks;
      const shortBlockLen = Math.floor(rawCodewords / numBlocks);
      let blocks = [];
      const rsDiv = _QrCode.reedSolomonComputeDivisor(blockEccLen);
      for (let i = 0, k = 0; i < numBlocks; i++) {
        let dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
        k += dat.length;
        const ecc = _QrCode.reedSolomonComputeRemainder(dat, rsDiv);
        if (i < numShortBlocks) dat.push(0);
        blocks.push(dat.concat(ecc));
      }
      let result = [];
      for (let i = 0; i < blocks[0].length; i++) {
        blocks.forEach((block, j) => {
          if (i != shortBlockLen - blockEccLen || j >= numShortBlocks) result.push(block[i]);
        });
      }
      assert(result.length == rawCodewords);
      return result;
    }
    drawCodewords(data) {
      if (data.length != Math.floor(_QrCode.getNumRawDataModules(this.version) / 8)) throw new RangeError("Invalid argument");
      let i = 0;
      for (let right = this.size - 1; right >= 1; right -= 2) {
        if (right == 6) right = 5;
        for (let vert = 0; vert < this.size; vert++) {
          for (let j = 0; j < 2; j++) {
            const x = right - j;
            const upward = (right + 1 & 2) == 0;
            const y = upward ? this.size - 1 - vert : vert;
            if (!this.isFunction[y][x] && i < data.length * 8) {
              this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
              i++;
            }
          }
        }
      }
      assert(i == data.length * 8);
    }
    applyMask(mask) {
      if (mask < 0 || mask > 7) throw new RangeError("Mask value out of range");
      for (let y = 0; y < this.size; y++) {
        for (let x = 0; x < this.size; x++) {
          let invert;
          switch (mask) {
            case 0:
              invert = (x + y) % 2 == 0;
              break;
            case 1:
              invert = y % 2 == 0;
              break;
            case 2:
              invert = x % 3 == 0;
              break;
            case 3:
              invert = (x + y) % 3 == 0;
              break;
            case 4:
              invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;
              break;
            case 5:
              invert = x * y % 2 + x * y % 3 == 0;
              break;
            case 6:
              invert = (x * y % 2 + x * y % 3) % 2 == 0;
              break;
            case 7:
              invert = ((x + y) % 2 + x * y % 3) % 2 == 0;
              break;
            default:
              throw new Error("Unreachable");
          }
          if (!this.isFunction[y][x] && invert) this.modules[y][x] = !this.modules[y][x];
        }
      }
    }
    getPenaltyScore() {
      let result = 0;
      for (let y = 0; y < this.size; y++) {
        let runColor = false;
        let runX = 0;
        let runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let x = 0; x < this.size; x++) {
          if (this.modules[y][x] == runColor) {
            runX++;
            if (runX == 5) result += _QrCode.PENALTY_N1;else if (runX > 5) result++;
          } else {
            this.finderPenaltyAddHistory(runX, runHistory);
            if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;
            runColor = this.modules[y][x];
            runX = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * _QrCode.PENALTY_N3;
      }
      for (let x = 0; x < this.size; x++) {
        let runColor = false;
        let runY = 0;
        let runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let y = 0; y < this.size; y++) {
          if (this.modules[y][x] == runColor) {
            runY++;
            if (runY == 5) result += _QrCode.PENALTY_N1;else if (runY > 5) result++;
          } else {
            this.finderPenaltyAddHistory(runY, runHistory);
            if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;
            runColor = this.modules[y][x];
            runY = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * _QrCode.PENALTY_N3;
      }
      for (let y = 0; y < this.size - 1; y++) {
        for (let x = 0; x < this.size - 1; x++) {
          const color = this.modules[y][x];
          if (color == this.modules[y][x + 1] && color == this.modules[y + 1][x] && color == this.modules[y + 1][x + 1]) result += _QrCode.PENALTY_N2;
        }
      }
      let dark = 0;
      for (const row of this.modules) dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);
      const total = this.size * this.size;
      const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
      assert(0 <= k && k <= 9);
      result += k * _QrCode.PENALTY_N4;
      assert(0 <= result && result <= 2568888);
      return result;
    }
    getAlignmentPatternPositions() {
      if (this.version == 1) return [];else {
        const numAlign = Math.floor(this.version / 7) + 2;
        const step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
        let result = [6];
        for (let pos = this.size - 7; result.length < numAlign; pos -= step) result.splice(1, 0, pos);
        return result;
      }
    }
    static getNumRawDataModules(ver) {
      if (ver < _QrCode.MIN_VERSION || ver > _QrCode.MAX_VERSION) throw new RangeError("Version number out of range");
      let result = (16 * ver + 128) * ver + 64;
      if (ver >= 2) {
        const numAlign = Math.floor(ver / 7) + 2;
        result -= (25 * numAlign - 10) * numAlign - 55;
        if (ver >= 7) result -= 36;
      }
      assert(208 <= result && result <= 29648);
      return result;
    }
    static getNumDataCodewords(ver, ecl) {
      return Math.floor(_QrCode.getNumRawDataModules(ver) / 8) - _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
    }
    static reedSolomonComputeDivisor(degree) {
      if (degree < 1 || degree > 255) throw new RangeError("Degree out of range");
      let result = [];
      for (let i = 0; i < degree - 1; i++) result.push(0);
      result.push(1);
      let root = 1;
      for (let i = 0; i < degree; i++) {
        for (let j = 0; j < result.length; j++) {
          result[j] = _QrCode.reedSolomonMultiply(result[j], root);
          if (j + 1 < result.length) result[j] ^= result[j + 1];
        }
        root = _QrCode.reedSolomonMultiply(root, 2);
      }
      return result;
    }
    static reedSolomonComputeRemainder(data, divisor) {
      let result = divisor.map(_ => 0);
      for (const b of data) {
        const factor = b ^ result.shift();
        result.push(0);
        divisor.forEach((coef, i) => result[i] ^= _QrCode.reedSolomonMultiply(coef, factor));
      }
      return result;
    }
    static reedSolomonMultiply(x, y) {
      if (x >>> 8 != 0 || y >>> 8 != 0) throw new RangeError("Byte out of range");
      let z = 0;
      for (let i = 7; i >= 0; i--) {
        z = z << 1 ^ (z >>> 7) * 285;
        z ^= (y >>> i & 1) * x;
      }
      assert(z >>> 8 == 0);
      return z;
    }
    finderPenaltyCountPatterns(runHistory) {
      const n = runHistory[1];
      assert(n <= this.size * 3);
      const core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;
      return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
    }
    finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
      if (currentRunColor) {
        this.finderPenaltyAddHistory(currentRunLength, runHistory);
        currentRunLength = 0;
      }
      currentRunLength += this.size;
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      return this.finderPenaltyCountPatterns(runHistory);
    }
    finderPenaltyAddHistory(currentRunLength, runHistory) {
      if (runHistory[0] == 0) currentRunLength += this.size;
      runHistory.pop();
      runHistory.unshift(currentRunLength);
    }
  };
  let QrCode = _QrCode;
  QrCode.MIN_VERSION = 1;
  QrCode.MAX_VERSION = 40;
  QrCode.PENALTY_N1 = 3;
  QrCode.PENALTY_N2 = 3;
  QrCode.PENALTY_N3 = 40;
  QrCode.PENALTY_N4 = 10;
  QrCode.ECC_CODEWORDS_PER_BLOCK = [[-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28], [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]];
  QrCode.NUM_ERROR_CORRECTION_BLOCKS = [[-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25], [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49], [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68], [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]];
  qrcodegen2.QrCode = QrCode;
  function appendBits(val, len, bb) {
    if (len < 0 || len > 31 || val >>> len != 0) throw new RangeError("Value out of range");
    for (let i = len - 1; i >= 0; i--) bb.push(val >>> i & 1);
  }
  function getBit(x, i) {
    return (x >>> i & 1) != 0;
  }
  function assert(cond) {
    if (!cond) throw new Error("Assertion error");
  }
  const _QrSegment = class {
    constructor(mode, numChars, bitData) {
      this.mode = mode;
      this.numChars = numChars;
      this.bitData = bitData;
      if (numChars < 0) throw new RangeError("Invalid argument");
      this.bitData = bitData.slice();
    }
    static makeBytes(data) {
      let bb = [];
      for (const b of data) appendBits(b, 8, bb);
      return new _QrSegment(_QrSegment.Mode.BYTE, data.length, bb);
    }
    static makeNumeric(digits) {
      if (!_QrSegment.isNumeric(digits)) throw new RangeError("String contains non-numeric characters");
      let bb = [];
      for (let i = 0; i < digits.length;) {
        const n = Math.min(digits.length - i, 3);
        appendBits(parseInt(digits.substr(i, n), 10), n * 3 + 1, bb);
        i += n;
      }
      return new _QrSegment(_QrSegment.Mode.NUMERIC, digits.length, bb);
    }
    static makeAlphanumeric(text) {
      if (!_QrSegment.isAlphanumeric(text)) throw new RangeError("String contains unencodable characters in alphanumeric mode");
      let bb = [];
      let i;
      for (i = 0; i + 2 <= text.length; i += 2) {
        let temp = _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
        temp += _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
        appendBits(temp, 11, bb);
      }
      if (i < text.length) appendBits(_QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
      return new _QrSegment(_QrSegment.Mode.ALPHANUMERIC, text.length, bb);
    }
    static makeSegments(text) {
      if (text == "") return [];else if (_QrSegment.isNumeric(text)) return [_QrSegment.makeNumeric(text)];else if (_QrSegment.isAlphanumeric(text)) return [_QrSegment.makeAlphanumeric(text)];else return [_QrSegment.makeBytes(_QrSegment.toUtf8ByteArray(text))];
    }
    static makeEci(assignVal) {
      let bb = [];
      if (assignVal < 0) throw new RangeError("ECI assignment value out of range");else if (assignVal < 1 << 7) appendBits(assignVal, 8, bb);else if (assignVal < 1 << 14) {
        appendBits(2, 2, bb);
        appendBits(assignVal, 14, bb);
      } else if (assignVal < 1e6) {
        appendBits(6, 3, bb);
        appendBits(assignVal, 21, bb);
      } else throw new RangeError("ECI assignment value out of range");
      return new _QrSegment(_QrSegment.Mode.ECI, 0, bb);
    }
    static isNumeric(text) {
      return _QrSegment.NUMERIC_REGEX.test(text);
    }
    static isAlphanumeric(text) {
      return _QrSegment.ALPHANUMERIC_REGEX.test(text);
    }
    getData() {
      return this.bitData.slice();
    }
    static getTotalBits(segs, version) {
      let result = 0;
      for (const seg of segs) {
        const ccbits = seg.mode.numCharCountBits(version);
        if (seg.numChars >= 1 << ccbits) return Infinity;
        result += 4 + ccbits + seg.bitData.length;
      }
      return result;
    }
    static toUtf8ByteArray(str) {
      str = encodeURI(str);
      let result = [];
      for (let i = 0; i < str.length; i++) {
        if (str.charAt(i) != "%") result.push(str.charCodeAt(i));else {
          result.push(parseInt(str.substr(i + 1, 2), 16));
          i += 2;
        }
      }
      return result;
    }
  };
  let QrSegment = _QrSegment;
  QrSegment.NUMERIC_REGEX = /^[0-9]*$/;
  QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
  QrSegment.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
  qrcodegen2.QrSegment = QrSegment;
})(qrcodegen || (qrcodegen = {}));
(qrcodegen2 => {
  (QrCode2 => {
    const _Ecc = class {
      constructor(ordinal, formatBits) {
        this.ordinal = ordinal;
        this.formatBits = formatBits;
      }
    };
    let Ecc = _Ecc;
    Ecc.LOW = new _Ecc(0, 1);
    Ecc.MEDIUM = new _Ecc(1, 0);
    Ecc.QUARTILE = new _Ecc(2, 3);
    Ecc.HIGH = new _Ecc(3, 2);
    QrCode2.Ecc = Ecc;
  })(qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));
})(qrcodegen || (qrcodegen = {}));
(qrcodegen2 => {
  (QrSegment2 => {
    const _Mode = class {
      constructor(modeBits, numBitsCharCount) {
        this.modeBits = modeBits;
        this.numBitsCharCount = numBitsCharCount;
      }
      numCharCountBits(ver) {
        return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
      }
    };
    let Mode = _Mode;
    Mode.NUMERIC = new _Mode(1, [10, 12, 14]);
    Mode.ALPHANUMERIC = new _Mode(2, [9, 11, 13]);
    Mode.BYTE = new _Mode(4, [8, 16, 16]);
    Mode.KANJI = new _Mode(8, [8, 10, 12]);
    Mode.ECI = new _Mode(7, [0, 0, 0]);
    QrSegment2.Mode = Mode;
  })(qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));
})(qrcodegen || (qrcodegen = {}));
var qrcodegen_default = qrcodegen;

// src/index.tsx
/**
 * @license qrcode.react
 * Copyright (c) Paul O'Shannessy
 * SPDX-License-Identifier: ISC
 */
var ERROR_LEVEL_MAP = {
  L: qrcodegen_default.QrCode.Ecc.LOW,
  M: qrcodegen_default.QrCode.Ecc.MEDIUM,
  Q: qrcodegen_default.QrCode.Ecc.QUARTILE,
  H: qrcodegen_default.QrCode.Ecc.HIGH
};
var DEFAULT_SIZE = 128;
var DEFAULT_LEVEL = "L";
var DEFAULT_BGCOLOR = "#FFFFFF";
var DEFAULT_FGCOLOR = "#000000";
var DEFAULT_INCLUDEMARGIN = false;
var MARGIN_SIZE = 4;
var DEFAULT_IMG_SCALE = 0.1;
function generatePath(modules, margin = 0) {
  const ops = [];
  modules.forEach(function (row, y) {
    let start = null;
    row.forEach(function (cell, x) {
      if (!cell && start !== null) {
        ops.push(`M${start + margin} ${y + margin}h${x - start}v1H${start + margin}z`);
        start = null;
        return;
      }
      if (x === row.length - 1) {
        if (!cell) {
          return;
        }
        if (start === null) {
          ops.push(`M${x + margin},${y + margin} h1v1H${x + margin}z`);
        } else {
          ops.push(`M${start + margin},${y + margin} h${x + 1 - start}v1H${start + margin}z`);
        }
        return;
      }
      if (cell && start === null) {
        start = x;
      }
    });
  });
  return ops.join("");
}
function excavateModules(modules, excavation) {
  return modules.slice().map((row, y) => {
    if (y < excavation.y || y >= excavation.y + excavation.h) {
      return row;
    }
    return row.map((cell, x) => {
      if (x < excavation.x || x >= excavation.x + excavation.w) {
        return cell;
      }
      return false;
    });
  });
}
function getImageSettings(cells, size, includeMargin, imageSettings) {
  if (imageSettings == null) {
    return null;
  }
  const margin = includeMargin ? MARGIN_SIZE : 0;
  const numCells = cells.length + margin * 2;
  const defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
  const scale = numCells / size;
  const w = (imageSettings.width || defaultSize) * scale;
  const h = (imageSettings.height || defaultSize) * scale;
  const x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;
  const y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;
  let excavation = null;
  if (imageSettings.excavate) {
    let floorX = Math.floor(x);
    let floorY = Math.floor(y);
    let ceilW = Math.ceil(w + x - floorX);
    let ceilH = Math.ceil(h + y - floorY);
    excavation = {
      x: floorX,
      y: floorY,
      w: ceilW,
      h: ceilH
    };
  }
  return {
    x,
    y,
    h,
    w,
    excavation
  };
}
var SUPPORTS_PATH2D = function () {
  try {
    new Path2D().addPath(new Path2D());
  } catch (e) {
    return false;
  }
  return true;
}();
function QRCodeCanvas(props) {
  const _a = props,
    {
      value,
      size = DEFAULT_SIZE,
      level = DEFAULT_LEVEL,
      bgColor = DEFAULT_BGCOLOR,
      fgColor = DEFAULT_FGCOLOR,
      includeMargin = DEFAULT_INCLUDEMARGIN,
      style,
      imageSettings
    } = _a,
    otherProps = __objRest(_a, ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "style", "imageSettings"]);
  const imgSrc = imageSettings == null ? void 0 : imageSettings.src;
  const _canvas = react.exports.useRef(null);
  const _image = react.exports.useRef(null);
  const [isImgLoaded, setIsImageLoaded] = react.exports.useState(false);
  react.exports.useEffect(() => {
    if (_canvas.current != null) {
      const canvas = _canvas.current;
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        return;
      }
      let cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();
      const margin = includeMargin ? MARGIN_SIZE : 0;
      const numCells = cells.length + margin * 2;
      const calculatedImageSettings = getImageSettings(cells, size, includeMargin, imageSettings);
      const image = _image.current;
      const haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;
      if (haveImageToRender) {
        if (calculatedImageSettings.excavation != null) {
          cells = excavateModules(cells, calculatedImageSettings.excavation);
        }
      }
      const pixelRatio = window.devicePixelRatio || 1;
      canvas.height = canvas.width = size * pixelRatio;
      const scale = size / numCells * pixelRatio;
      ctx.scale(scale, scale);
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, numCells, numCells);
      ctx.fillStyle = fgColor;
      if (SUPPORTS_PATH2D) {
        ctx.fill(new Path2D(generatePath(cells, margin)));
      } else {
        cells.forEach(function (row, rdx) {
          row.forEach(function (cell, cdx) {
            if (cell) {
              ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
            }
          });
        });
      }
      if (haveImageToRender) {
        ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
      }
    }
  });
  react.exports.useEffect(() => {
    setIsImageLoaded(false);
  }, [imgSrc]);
  const canvasStyle = __spreadValues({
    height: size,
    width: size
  }, style);
  let img = null;
  if (imgSrc != null) {
    img =
    /*#__PURE__*/
    /* @__PURE__ */
    jsx$1("img", {
      src: imgSrc,
      style: {
        display: "none"
      },
      onLoad: () => {
        setIsImageLoaded(true);
      },
      ref: _image
    }, imgSrc);
  }
  return (
    /*#__PURE__*/
    /* @__PURE__ */
    jsxs(Fragment, {
      children: [/*#__PURE__*/jsx$1("canvas", {
        ...__spreadValues({
          style: canvasStyle,
          height: size,
          width: size,
          ref: _canvas
        }, otherProps)
      }), img]
    })
  );
}
function QRCodeSVG(props) {
  const _a = props,
    {
      value,
      size = DEFAULT_SIZE,
      level = DEFAULT_LEVEL,
      bgColor = DEFAULT_BGCOLOR,
      fgColor = DEFAULT_FGCOLOR,
      includeMargin = DEFAULT_INCLUDEMARGIN,
      imageSettings
    } = _a,
    otherProps = __objRest(_a, ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "imageSettings"]);
  let cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();
  const margin = includeMargin ? MARGIN_SIZE : 0;
  const numCells = cells.length + margin * 2;
  const calculatedImageSettings = getImageSettings(cells, size, includeMargin, imageSettings);
  let image = null;
  if (imageSettings != null && calculatedImageSettings != null) {
    if (calculatedImageSettings.excavation != null) {
      cells = excavateModules(cells, calculatedImageSettings.excavation);
    }
    image =
    /*#__PURE__*/
    /* @__PURE__ */
    jsx$1("image", {
      xlinkHref: imageSettings.src,
      height: calculatedImageSettings.h,
      width: calculatedImageSettings.w,
      x: calculatedImageSettings.x + margin,
      y: calculatedImageSettings.y + margin,
      preserveAspectRatio: "none"
    });
  }
  const fgPath = generatePath(cells, margin);
  return (
    /*#__PURE__*/
    /* @__PURE__ */
    jsxs("svg", {
      ...__spreadValues({
        height: size,
        width: size,
        viewBox: `0 0 ${numCells} ${numCells}`
      }, otherProps),
      children: [/*#__PURE__*/jsx$1("path", {
        fill: bgColor,
        d: `M0,0 h${numCells}v${numCells}H0z`,
        shapeRendering: "crispEdges"
      }), /*#__PURE__*/jsx$1("path", {
        fill: fgColor,
        d: fgPath,
        shapeRendering: "crispEdges"
      }), image]
    })
  );
}
var QRCode = props => {
  const _a = props,
    {
      renderAs
    } = _a,
    otherProps = __objRest(_a, ["renderAs"]);
  if (renderAs === "svg") {
    return (
      /*#__PURE__*/
      /* @__PURE__ */
      jsx$1(QRCodeSVG, {
        ...__spreadValues({}, otherProps)
      })
    );
  }
  return (
    /*#__PURE__*/
    /* @__PURE__ */
    jsx$1(QRCodeCanvas, {
      ...__spreadValues({}, otherProps)
    })
  );
};

// This icon file is generated automatically.
var ExclamationCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z" } }] }, "name": "exclamation-circle", "theme": "outlined" };
const ExclamationCircleOutlinedSvg = ExclamationCircleOutlined$2;

var ExclamationCircleOutlined = function ExclamationCircleOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: ExclamationCircleOutlinedSvg
      })
    })
  );
};
ExclamationCircleOutlined.displayName = 'ExclamationCircleOutlined';
const ExclamationCircleOutlined$1 = /*#__PURE__*/react.exports.forwardRef(ExclamationCircleOutlined);

// This icon file is generated automatically.
var MinusCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M696 480H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8z" } }, { "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, "name": "minus-circle", "theme": "outlined" };
const MinusCircleOutlinedSvg = MinusCircleOutlined$2;

var MinusCircleOutlined = function MinusCircleOutlined(props, ref) {
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(AntdIcon, {
      ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
        ref: ref,
        icon: MinusCircleOutlinedSvg
      })
    })
  );
};
MinusCircleOutlined.displayName = 'MinusCircleOutlined';
const MinusCircleOutlined$1 = /*#__PURE__*/react.exports.forwardRef(MinusCircleOutlined);

/**
 * @remix-run/router v1.0.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends$1.apply(this, arguments);
}

////////////////////////////////////////////////////////////////////////////////
//#region Types and Constants
////////////////////////////////////////////////////////////////////////////////

/**
 * Actions represent the type of change to a location value.
 */
var Action$1;

(function (Action) {
  /**
   * A POP indicates a change to an arbitrary index in the history stack, such
   * as a back or forward navigation. It does not describe the direction of the
   * navigation, only that the current index changed.
   *
   * Note: This is the default action for newly created history objects.
   */
  Action["Pop"] = "POP";
  /**
   * A PUSH indicates a new entry being added to the history stack, such as when
   * a link is clicked and a new page loads. When this happens, all subsequent
   * entries in the stack are lost.
   */

  Action["Push"] = "PUSH";
  /**
   * A REPLACE indicates the entry at the current index in the history stack
   * being replaced by a new one.
   */

  Action["Replace"] = "REPLACE";
})(Action$1 || (Action$1 = {}));

const PopStateEventType$1 = "popstate";
/**
 * Browser history stores the location in regular URLs. This is the standard for
 * most web apps, but it requires some configuration on the server to ensure you
 * serve the same app at multiple URLs.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
 */

function createBrowserHistory$1(options) {
  if (options === void 0) {
    options = {};
  }

  function createBrowserLocation(window, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window.location;
    return createLocation("", {
      pathname,
      search,
      hash
    }, // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }

  function createBrowserHref(window, to) {
    return typeof to === "string" ? to : createPath$1(to);
  }

  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}

function createKey$1() {
  return Math.random().toString(36).substr(2, 8);
}
/**
 * For browser-based histories, we combine the state and key into an object
 */


function getHistoryState(location) {
  return {
    usr: location.state,
    key: location.key
  };
}
/**
 * Creates a Location object with a unique key from the given Path
 */


function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }

  let location = _extends$1({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath$1(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey$1()
  });

  return location;
}
/**
 * Creates a string URL path from the given pathname, search, and hash components.
 */

function createPath$1(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
/**
 * Parses a string URL path into its separate pathname, search, and hash components.
 */

function parsePath$1(path) {
  let parsedPath = {};

  if (path) {
    let hashIndex = path.indexOf("#");

    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }

    let searchIndex = path.indexOf("?");

    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }

    if (path) {
      parsedPath.pathname = path;
    }
  }

  return parsedPath;
}
function createURL(location) {
  // window.location.origin is "null" (the literal string value) in Firefox
  // under certain conditions, notably when serving from a local HTML file
  // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297
  let base = typeof window !== "undefined" && typeof window.location !== "undefined" && window.location.origin !== "null" ? window.location.origin : "unknown://unknown";
  let href = typeof location === "string" ? location : createPath$1(location);
  return new URL(href, base);
}

function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }

  let {
    window = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window.history;
  let action = Action$1.Pop;
  let listener = null;

  function handlePop() {
    action = Action$1.Pop;

    if (listener) {
      listener({
        action,
        location: history.location
      });
    }
  }

  function push(to, state) {
    action = Action$1.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    let historyState = getHistoryState(location);
    let url = history.createHref(location); // try...catch because iOS limits us to 100 pushState calls :/

    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      // They are going to lose state here, but there is no real
      // way to warn them about it since the page will refresh...
      window.location.assign(url);
    }

    if (v5Compat && listener) {
      listener({
        action,
        location: history.location
      });
    }
  }

  function replace(to, state) {
    action = Action$1.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    let historyState = getHistoryState(location);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);

    if (v5Compat && listener) {
      listener({
        action,
        location: history.location
      });
    }
  }

  let history = {
    get action() {
      return action;
    },

    get location() {
      return getLocation(window, globalHistory);
    },

    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }

      window.addEventListener(PopStateEventType$1, handlePop);
      listener = fn;
      return () => {
        window.removeEventListener(PopStateEventType$1, handlePop);
        listener = null;
      };
    },

    createHref(to) {
      return createHref(window, to);
    },

    encodeLocation(location) {
      // Encode a Location the same way window.location would
      let url = createURL(createPath$1(location));
      return _extends$1({}, location, {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      });
    },

    push,
    replace,

    go(n) {
      return globalHistory.go(n);
    }

  };
  return history;
} //#endregion

var ResultType;

(function (ResultType) {
  ResultType["data"] = "data";
  ResultType["deferred"] = "deferred";
  ResultType["redirect"] = "redirect";
  ResultType["error"] = "error";
})(ResultType || (ResultType = {}));
/**
 * Matches the given routes to a location and returns the match data.
 *
 * @see https://reactrouter.com/docs/en/v6/utils/match-routes
 */

function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }

  let location = typeof locationArg === "string" ? parsePath$1(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);

  if (pathname == null) {
    return null;
  }

  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;

  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i], // Incoming pathnames are generally encoded from either window.location
    // or from router.navigate, but we want to match against the unencoded
    // paths in the route definitions.  Memory router locations won't be
    // encoded here but there also shouldn't be anything to decode so this
    // should be a safe operation.  This avoids needing matchRoutes to be
    // history-aware.
    safelyDecodeURI(pathname));
  }

  return matches;
}

function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }

  if (parentsMeta === void 0) {
    parentsMeta = [];
  }

  if (parentPath === void 0) {
    parentPath = "";
  }

  routes.forEach((route, index) => {
    let meta = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };

    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), "Absolute route path \"" + meta.relativePath + "\" nested under path " + ("\"" + parentPath + "\" is not valid. An absolute child route path ") + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }

    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the
    // route tree depth-first and child routes appear before their parents in
    // the "flattened" version.

    if (route.children && route.children.length > 0) {
      invariant( // Our types know better, but runtime JS may not!
      // @ts-expect-error
      route.index !== true, "Index routes must not have child routes. Please remove " + ("all child routes from route path \"" + path + "\"."));
      flattenRoutes(route.children, branches, routesMeta, path);
    } // Routes without a path shouldn't ever match by themselves unless they are
    // index routes, so don't add them to the list of possible branches.


    if (route.path == null && !route.index) {
      return;
    }

    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  });
  return branches;
}

function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first
  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
}

const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;

const isSplat = s => s === "*";

function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;

  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }

  if (index) {
    initialScore += indexRouteValue;
  }

  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}

function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? // If two routes are siblings, we should try to match the earlier sibling
  // first. This allows people to have fine-grained control over the matching
  // behavior by simply putting routes with identical paths in the order they
  // want them tried.
  a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,
  // so they sort equally.
  0;
}

function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];

  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match) return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });

    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }

  return matches;
}
/**
 * Performs pattern matching on a URL pathname and returns information about
 * the match.
 *
 * @see https://reactrouter.com/docs/en/v6/utils/match-path
 */

function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }

  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    // We need to compute the pathnameBase here using the raw splat value
    // instead of using params["*"] later because it will be decoded then
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }

    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}

function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }

  if (end === void 0) {
    end = true;
  }

  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\"."));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
  .replace(/^\/*/, "/") // Make sure it has a leading /
  .replace(/[\\.*+^$?{}|()[\]]/g, "\\$&") // Escape special regex chars
  .replace(/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });

  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest
    : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
  } else if (end) {
    // When matching to the end, ignore trailing slashes
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    // If our path is non-empty and contains anything beyond an initial slash,
    // then we have _some_ form of path in our regex so we should expect to
    // match only if we find the end of this path segment.  Look for an optional
    // non-captured trailing slash (to match a portion of the URL) or the end
    // of the path (if we've matched to the end).  We used to do this with a
    // word boundary but that gives false positives on routes like
    // /user-preferences since `-` counts as a word boundary.
    regexpSource += "(?:(?=\\/|$))";
  } else ;

  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
  return [matcher, paramNames];
}

function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning(false, "The URL path \"" + value + "\" could not be decoded because it is is a " + "malformed URL segment. This is probably due to a bad percent " + ("encoding (" + error + ")."));
    return value;
  }
}

function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning(false, "The value for the URL param \"" + paramName + "\" will not be decoded because" + (" the string \"" + value + "\" is a malformed URL segment. This is probably") + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
/**
 * @private
 */


function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;

  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  } // We want to leave trailing slash behavior in the user's control, so if they
  // specify a basename with a trailing slash, we should support it


  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);

  if (nextChar && nextChar !== "/") {
    // pathname does not start with basename/
    return null;
  }

  return pathname.slice(startIndex) || "/";
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
/**
 * @private
 */

function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);

    try {
      // Welcome to debugging React Router!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}
/**
 * Returns a resolved path object relative to the given pathname.
 *
 * @see https://reactrouter.com/docs/en/v6/utils/resolve-path
 */

function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }

  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath$1(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}

function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach(segment => {
    if (segment === "..") {
      // Keep the root "" segment so the pathname starts at /
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}

function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + "a string in <Link to=\"...\"> and the router will parse it for you.";
}
/**
 * @private
 *
 * When processing relative navigation we want to ignore ancestor routes that
 * do not contribute to the path, such that index/pathless layout routes don't
 * interfere.
 *
 * For example, when moving a route element into an index route and/or a
 * pathless layout route, relative link behavior contained within should stay
 * the same.  Both of the following examples should link back to the root:
 *
 *   <Route path="/">
 *     <Route path="accounts" element={<Link to=".."}>
 *   </Route>
 *
 *   <Route path="/">
 *     <Route path="accounts">
 *       <Route element={<AccountsLayout />}>       // <-- Does not contribute
 *         <Route index element={<Link to=".."} />  // <-- Does not contribute
 *       </Route
 *     </Route>
 *   </Route>
 */


function getPathContributingMatches(matches) {
  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
}
/**
 * @private
 */

function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }

  let to;

  if (typeof toArg === "string") {
    to = parsePath$1(toArg);
  } else {
    to = _extends$1({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }

  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from; // Routing is relative to the current pathname if explicitly requested.
  //
  // If a pathname is explicitly provided in `to`, it should be relative to the
  // route context. This is explained in `Note on `<Link to>` values` in our
  // migration guide from v5 as a means of disambiguation between `to` values
  // that begin with `/` and those that do not. However, this is problematic for
  // `to` values that do not provide a pathname. `to` can simply be a search or
  // hash string, in which case we should assume that the navigation is relative
  // to the current location's pathname and *not* the route pathname.

  if (isPathRelative || toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;

    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/"); // Each leading .. segment means "go up one route" instead of "go up one
      // URL segment".  This is a key difference from how <a href> works and a
      // major reason we call this a "to" value instead of a "href".

      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }

      to.pathname = toSegments.join("/");
    } // If there are more ".." segments than parent routes, resolve relative to
    // the root / URL.


    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }

  let path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original "to" had one

  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/"); // Or if this was a link to the current path which has a trailing slash

  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");

  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }

  return path;
}
/**
 * @private
 */

const joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");
/**
 * @private
 */

const normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
/**
 * @private
 */

const normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
/**
 * @private
 */

const normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
/**
 * @private
 * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies
 */

class ErrorResponse {
  constructor(status, statusText, data) {
    this.status = status;
    this.statusText = statusText || "";
    this.data = data;
  }

}
/**
 * Check if the given error is an ErrorResponse generated from a 4xx/5xx
 * Response throw from an action/loader
 */

function isRouteErrorResponse(e) {
  return e instanceof ErrorResponse;
}
////////////////////////////////////////////////////////////////////////////////
//#region createStaticHandler
////////////////////////////////////////////////////////////////////////////////

const validActionMethods = new Set(["POST", "PUT", "PATCH", "DELETE"]);
new Set(["GET", "HEAD", ...validActionMethods]);

/**
 * React Router v6.4.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */

function isPolyfill(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

const is = typeof Object.is === "function" ? Object.is : isPolyfill; // Intentionally not using named imports because Rollup uses dynamic
// dispatch for CommonJS interop named imports.

const {
  useState,
  useEffect,
  useLayoutEffect,
  useDebugValue
} = React$1;
// because of a very particular set of implementation details and assumptions
// -- change any one of them and it will break. The most important assumption
// is that updates are always synchronous, because concurrent rendering is
// only available in versions of React that also have a built-in
// useSyncExternalStore API. And we only use this shim when the built-in API
// does not exist.
//
// Do not assume that the clever hacks used by this hook also work in general.
// The point of this shim is to replace the need for hacks by other libraries.

function useSyncExternalStore$2(subscribe, getSnapshot,
// Note: The shim does not use getServerSnapshot, because pre-18 versions of
// React do not expose a way to check if we're hydrating. So users of the shim
// will need to track that themselves and return the correct value
// from `getSnapshot`.
getServerSnapshot) {
  // breaks the rules of React, and only works here because of specific
  // implementation details, most importantly that updates are
  // always synchronous.

  const value = getSnapshot();
  // re-render whenever the subscribed state changes by updating an some
  // arbitrary useState hook. Then, during render, we call getSnapshot to read
  // the current value.
  //
  // Because we don't actually use the state returned by the useState hook, we
  // can save a bit of memory by storing other stuff in that slot.
  //
  // To implement the early bailout, we need to track some things on a mutable
  // object. Usually, we would put that in a useRef hook, but we can stash it in
  // our useState hook instead.
  //
  // To force a re-render, we call forceUpdate({inst}). That works because the
  // new object always fails an equality check.

  const [{
    inst
  }, forceUpdate] = useState({
    inst: {
      value,
      getSnapshot
    }
  }); // Track the latest getSnapshot function with a ref. This needs to be updated
  // in the layout phase so we can access it during the tearing check that
  // happens on subscribe.

  useLayoutEffect(() => {
    inst.value = value;
    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the
    // commit phase if there was an interleaved mutation. In concurrent mode
    // this can happen all the time, but even in synchronous mode, an earlier
    // effect may have mutated the store.

    if (checkIfSnapshotChanged(inst)) {
      // Force a re-render.
      forceUpdate({
        inst
      });
    } // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [subscribe, value, getSnapshot]);
  useEffect(() => {
    // Check for changes right before subscribing. Subsequent changes will be
    // detected in the subscription handler.
    if (checkIfSnapshotChanged(inst)) {
      // Force a re-render.
      forceUpdate({
        inst
      });
    }
    const handleStoreChange = () => {
      // TODO: Because there is no cross-renderer API for batching updates, it's
      // up to the consumer of this library to wrap their subscription event
      // with unstable_batchedUpdates. Should we try to detect when this isn't
      // the case and print a warning in development?
      // The store changed. Check if the snapshot changed since the last time we
      // read from the store.
      if (checkIfSnapshotChanged(inst)) {
        // Force a re-render.
        forceUpdate({
          inst
        });
      }
    }; // Subscribe to the store and return a clean-up function.

    return subscribe(handleStoreChange); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [subscribe]);
  useDebugValue(value);
  return value;
}
function checkIfSnapshotChanged(inst) {
  const latestGetSnapshot = inst.getSnapshot;
  const prevValue = inst.value;
  try {
    const nextValue = latestGetSnapshot();
    return !is(prevValue, nextValue);
  } catch (error) {
    return true;
  }
}

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */
function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
  // Note: The shim does not use getServerSnapshot, because pre-18 versions of
  // React do not expose a way to check if we're hydrating. So users of the shim
  // will need to track that themselves and return the correct value
  // from `getSnapshot`.
  return getSnapshot();
}

/**
 * Inlined into the react-router repo since use-sync-external-store does not
 * provide a UMD-compatible package, so we need this to be able to distribute
 * UMD react-router bundles
 */
const canUseDOM$1 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const isServerEnvironment = !canUseDOM$1;
const shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
"useSyncExternalStore" in React$1 ? (module => module.useSyncExternalStore)(React$1) : shim;

// Contexts for data routers
const DataStaticRouterContext = /*#__PURE__*/react.exports.createContext(null);
const DataRouterContext = /*#__PURE__*/react.exports.createContext(null);
const DataRouterStateContext = /*#__PURE__*/react.exports.createContext(null);
const NavigationContext = /*#__PURE__*/react.exports.createContext(null);
const LocationContext = /*#__PURE__*/react.exports.createContext(null);
const RouteContext = /*#__PURE__*/react.exports.createContext({
  outlet: null,
  matches: []
});
const RouteErrorContext = /*#__PURE__*/react.exports.createContext(null);

/**
 * Returns the full href for the given "to" value. This is useful for building
 * custom links that are also accessible and preserve right-click behavior.
 *
 * @see https://reactrouter.com/docs/en/v6/hooks/use-href
 */

function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator
  } = react.exports.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname; // If we're operating within a basename, prepend it to the pathname prior
  // to creating the href.  If this is a root navigation, then just use the raw
  // basename which allows the basename to have full control over the presence
  // of a trailing slash on root links

  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
/**
 * Returns true if this component is a descendant of a <Router>.
 *
 * @see https://reactrouter.com/docs/en/v6/hooks/use-in-router-context
 */

function useInRouterContext() {
  return react.exports.useContext(LocationContext) != null;
}
/**
 * Returns the current location object, which represents the current URL in web
 * browsers.
 *
 * Note: If you're using this it may mean you're doing some of your own
 * "routing" in your app, and we'd like to know what your use case is. We may
 * be able to provide something higher-level to better suit your needs.
 *
 * @see https://reactrouter.com/docs/en/v6/hooks/use-location
 */

function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return react.exports.useContext(LocationContext).location;
}
/**
 * The interface for the navigate() function returned from useNavigate().
 */

/**
 * Returns an imperative method for changing the location. Used by <Link>s, but
 * may also be used by other elements to change the location.
 *
 * @see https://reactrouter.com/docs/en/v6/hooks/use-navigate
 */
function useNavigate() {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator
  } = react.exports.useContext(NavigationContext);
  let {
    matches
  } = react.exports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map(match => match.pathnameBase));
  let activeRef = react.exports.useRef(false);
  react.exports.useEffect(() => {
    activeRef.current = true;
  });
  let navigate = react.exports.useCallback(function (to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current) return;
    if (typeof to === "number") {
      navigator.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path"); // If we're operating within a basename, prepend it to the pathname prior
    // to handing off to history.  If this is a root navigation, then we
    // navigate to the raw basename which allows the basename to have full
    // control over the presence of a trailing slash on root links

    if (basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);
  }, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}
/**
 * Resolves the pathname of the given `to` value against the current location.
 *
 * @see https://reactrouter.com/docs/en/v6/hooks/use-resolved-path
 */

function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    matches
  } = react.exports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map(match => match.pathnameBase));
  return react.exports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
/**
 * Returns the element of the route that matched the current location, prepared
 * with the correct context to render the remainder of the route tree. Route
 * elements in the tree must render an <Outlet> to render their child route's
 * element.
 *
 * @see https://reactrouter.com/docs/en/v6/hooks/use-routes
 */

function useRoutes(routes, locationArg) {
  !useInRouterContext() ? invariant(false) : void 0;
  let dataRouterStateContext = react.exports.useContext(DataRouterStateContext);
  let {
    matches: parentMatches
  } = react.exports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath$1(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([parentPathnameBase, match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
  })), parentMatches, dataRouterStateContext || undefined); // When a user passes in a `locationArg`, the associated routes need to
  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`
  // to use the scoped location instead of the global location.

  if (locationArg && renderedMatches) {
    return (
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(LocationContext.Provider, {
        value: {
          location: _extends({
            pathname: "/",
            search: "",
            hash: "",
            state: null,
            key: "default"
          }, location),
          navigationType: Action$1.Pop
        },
        children: renderedMatches
      })
    );
  }
  return renderedMatches;
}
function DefaultErrorElement() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsxs(Fragment, {
      children: [/*#__PURE__*/jsx$1("h2", {
        children: "Unhandled Thrown Error!"
      }), /*#__PURE__*/jsx$1("h3", {
        style: {
          fontStyle: "italic"
        },
        children: message
      }), stack ?
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1("pre", {
        style: preStyles,
        children: stack
      }) : null, /*#__PURE__*/jsx$1("p", {
        children: "\uD83D\uDCBF Hey developer \uD83D\uDC4B"
      }), /*#__PURE__*/jsxs("p", {
        children: ["You can provide a way better UX than this when your app throws errors by providing your own\xA0", /*#__PURE__*/jsx$1("code", {
          style: codeStyles,
          children: "errorElement"
        }), " props on\xA0", /*#__PURE__*/jsx$1("code", {
          style: codeStyles,
          children: "<Route>"
        })]
      })]
    })
  );
}
class RenderErrorBoundary extends react.exports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error: error
    };
  }
  static getDerivedStateFromProps(props, state) {
    // When we get into an error state, the user will likely click "back" to the
    // previous page that didn't have an error. Because this wraps the entire
    // application, that will have no effect--the error page continues to display.
    // This gives us a mechanism to recover from the error when the location changes.
    //
    // Whether we're in an error state or not, we update the location in state
    // so that when we are in an error state, it gets reset when a new location
    // comes in and the user recovers from the error.
    if (state.location !== props.location) {
      return {
        error: props.error,
        location: props.location
      };
    } // If we're not changing locations, preserve the location but still surface
    // any new errors that may come through. We retain the existing error, we do
    // this because the error provided from the app state may be cleared without
    // the location changing.

    return {
      error: props.error || state.error,
      location: state.location
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error ?
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    }) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match,
    children
  } = _ref;
  let dataStaticRouterContext = react.exports.useContext(DataStaticRouterContext); // Track how deep we got in our render pass to emulate SSR componentDidCatch
  // in a DataStaticRouter

  if (dataStaticRouterContext && match.route.errorElement) {
    dataStaticRouterContext._deepestRenderedBoundaryId = match.route.id;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(RouteContext.Provider, {
      value: routeContext,
      children: children
    })
  );
}
function _renderMatches(matches, parentMatches, dataRouterState) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null) {
    if (dataRouterState != null && dataRouterState.errors) {
      // Don't bail if we have data router errors so we can render them in the
      // boundary.  Use the pre-matched (or shimmed) matches
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches; // If we have data errors, trim matches to the highest error boundary

  let errors = dataRouterState == null ? void 0 : dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]));
    !(errorIndex >= 0) ? invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match, index) => {
    let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null; // Only data routers handle errors

    let errorElement = dataRouterState ? match.route.errorElement ||
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(DefaultErrorElement, {}) : null;
    let getChildren = () =>
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(RenderedRoute, {
      match: match,
      routeContext: {
        outlet,
        matches: parentMatches.concat(renderedMatches.slice(0, index + 1))
      },
      children: error ? errorElement : match.route.element !== undefined ? match.route.element : outlet
    }); // Only wrap in an error boundary within data router usages when we have an
    // errorElement on this route.  Otherwise let it bubble up to an ancestor
    // errorElement

    return dataRouterState && (match.route.errorElement || index === 0) ?
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(RenderErrorBoundary, {
      location: dataRouterState.location,
      component: errorElement,
      error: error,
      children: getChildren()
    }) : getChildren();
  }, null);
}
var DataRouterHook$1;
(function (DataRouterHook) {
  DataRouterHook["UseRevalidator"] = "useRevalidator";
})(DataRouterHook$1 || (DataRouterHook$1 = {}));
var DataRouterStateHook$1;
(function (DataRouterStateHook) {
  DataRouterStateHook["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook["UseActionData"] = "useActionData";
  DataRouterStateHook["UseRouteError"] = "useRouteError";
  DataRouterStateHook["UseNavigation"] = "useNavigation";
  DataRouterStateHook["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook["UseMatches"] = "useMatches";
  DataRouterStateHook["UseRevalidator"] = "useRevalidator";
})(DataRouterStateHook$1 || (DataRouterStateHook$1 = {}));
function useDataRouterState(hookName) {
  let state = react.exports.useContext(DataRouterStateContext);
  !state ? invariant(false) : void 0;
  return state;
}
/**
 * Returns the nearest ancestor Route error, which could be a loader/action
 * error or a render error.  This is intended to be called from your
 * errorElement to display a proper error message.
 */

function useRouteError() {
  var _state$errors;
  let error = react.exports.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let route = react.exports.useContext(RouteContext);
  let thisRoute = route.matches[route.matches.length - 1]; // If this was a render error, we put it in a RouteError context inside
  // of RenderErrorBoundary

  if (error) {
    return error;
  }
  !route ? invariant(false) : void 0;
  !thisRoute.route.id ? invariant(false) : void 0; // Otherwise look for errors from our data router state

  return (_state$errors = state.errors) == null ? void 0 : _state$errors[thisRoute.route.id];
}

/**
 * Changes the current location.
 *
 * Note: This API is mostly useful in React.Component subclasses that are not
 * able to use hooks. In functional components, we recommend you use the
 * `useNavigate` hook instead.
 *
 * @see https://reactrouter.com/docs/en/v6/components/navigate
 */
function Navigate(_ref3) {
  let {
    to,
    replace,
    state,
    relative
  } = _ref3;
  !useInRouterContext() ? invariant(false) : void 0;
  let dataRouterState = react.exports.useContext(DataRouterStateContext);
  let navigate = useNavigate();
  react.exports.useEffect(() => {
    // Avoid kicking off multiple navigations if we're in the middle of a
    // data-router navigation, since components get re-rendered when we enter
    // a submitting/loading state
    if (dataRouterState && dataRouterState.navigation.state !== "idle") {
      return;
    }
    navigate(to, {
      replace,
      state,
      relative
    });
  });
  return null;
}

/**
 * Declares an element that should be rendered at a certain URL path.
 *
 * @see https://reactrouter.com/docs/en/v6/components/route
 */
function Route(_props) {
  invariant(false);
}

/**
 * Provides location context for the rest of the app.
 *
 * Note: You usually won't render a <Router> directly. Instead, you'll render a
 * router that is more specific to your environment such as a <BrowserRouter>
 * in web browsers or a <StaticRouter> for server rendering.
 *
 * @see https://reactrouter.com/docs/en/v6/routers/router
 */
function Router(_ref4) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action$1.Pop,
    navigator,
    static: staticProp = false
  } = _ref4;
  !!useInRouterContext() ? invariant(false) : void 0; // Preserve trailing slashes on basename, so we can let the user control
  // the enforcement of trailing slashes throughout the app

  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = react.exports.useMemo(() => ({
    basename,
    navigator,
    static: staticProp
  }), [basename, navigator, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath$1(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let location = react.exports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);
  if (location == null) {
    return null;
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(NavigationContext.Provider, {
      value: navigationContext,
      children: /*#__PURE__*/jsx$1(LocationContext.Provider, {
        children: children,
        value: {
          location,
          navigationType
        }
      })
    })
  );
}

/**
 * A container for a nested tree of <Route> elements that renders the branch
 * that best matches the current location.
 *
 * @see https://reactrouter.com/docs/en/v6/components/routes
 */
function Routes(_ref5) {
  let {
    children,
    location
  } = _ref5;
  let dataRouterContext = react.exports.useContext(DataRouterContext); // When in a DataRouterContext _without_ children, we use the router routes
  // directly.  If we have children, then we're in a descendant tree and we
  // need to use child routes.

  let routes = dataRouterContext && !children ? dataRouterContext.router.routes : createRoutesFromChildren(children);
  return useRoutes(routes, location);
}
var AwaitRenderStatus;
(function (AwaitRenderStatus) {
  AwaitRenderStatus[AwaitRenderStatus["pending"] = 0] = "pending";
  AwaitRenderStatus[AwaitRenderStatus["success"] = 1] = "success";
  AwaitRenderStatus[AwaitRenderStatus["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
new Promise(() => {});
// UTILS
///////////////////////////////////////////////////////////////////////////////

/**
 * Creates a route config from a React "children" object, which is usually
 * either a `<Route>` element or an array of them. Used internally by
 * `<Routes>` to create a route config from its children.
 *
 * @see https://reactrouter.com/docs/en/v6/utils/create-routes-from-children
 */

function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  react.exports.Children.forEach(children, (element, index) => {
    if (! /*#__PURE__*/react.exports.isValidElement(element)) {
      // Ignore non-elements. This allows people to more easily inline
      // conditionals in their route config.
      return;
    }
    if (element.type === react.exports.Fragment) {
      // Transparently support React.Fragment and its children.
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, parentPath));
      return;
    }
    !(element.type === Route) ? invariant(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant(false) : void 0;
    let treePath = [...parentPath, index];
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      hasErrorBoundary: element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}

/**
 * React Router DOM v6.4.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && (
  // Ignore everything but left clicks
  !target || target === "_self") &&
  // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event) // Ignore clicks with modifier keys
  ;
}
const _excluded$6 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"],
  _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
/**
 * A `<Router>` for use in web browsers. Provides the cleanest URLs.
 */

function BrowserRouter(_ref) {
  let {
    basename,
    children,
    window
  } = _ref;
  let historyRef = react.exports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory$1({
      window,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setState] = react.exports.useState({
    action: history.action,
    location: history.location
  });
  react.exports.useLayoutEffect(() => history.listen(setState), [history]);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Router, {
      basename: basename,
      children: children,
      location: state.location,
      navigationType: state.action,
      navigator: history
    })
  );
}
/**
 * The public API for rendering a history-aware <a>.
 */

const Link = /*#__PURE__*/react.exports.forwardRef(function LinkWithRef(_ref4, ref) {
  let {
      onClick,
      relative,
      reloadDocument,
      replace,
      state,
      target,
      to,
      preventScrollReset
    } = _ref4,
    rest = _objectWithoutPropertiesLoose(_ref4, _excluded$6);
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event) {
    if (onClick) onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    jsx$1("a", {
      ...rest,
      href: href,
      onClick: reloadDocument ? onClick : handleClick,
      ref: ref,
      target: target
    })
  );
});
/**
 * A <Link> wrapper that knows if it's "active" or not.
 */

const NavLink = /*#__PURE__*/react.exports.forwardRef(function NavLinkWithRef(_ref5, ref) {
  let {
      "aria-current": ariaCurrentProp = "page",
      caseSensitive = false,
      className: classNameProp = "",
      end = false,
      style: styleProp,
      to,
      children
    } = _ref5,
    rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);
  let path = useResolvedPath(to, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = react.exports.useContext(DataRouterStateContext);
  let toPathname = path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let ariaCurrent = isActive ? ariaCurrentProp : undefined;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive,
      isPending
    });
  } else {
    // If the className prop is not a function, we use a default `active`
    // class for <NavLink />s that are active. In v5 `active` was the default
    // value for `activeClassName`, but we are removing that API and can still
    // use the old default behavior for a cleaner upgrade path and keep the
    // simple styling rules working as they currently do.
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp({
    isActive,
    isPending
  }) : styleProp;
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Link, {
      ...rest,
      "aria-current": ariaCurrent,
      className: className,
      ref: ref,
      style: style,
      to: to,
      children: typeof children === "function" ? children({
        isActive,
        isPending
      }) : children
    })
  );
});
////////////////////////////////////////////////////////////////////////////////
//#region Hooks
////////////////////////////////////////////////////////////////////////////////

var DataRouterHook;
(function (DataRouterHook) {
  DataRouterHook["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook["UseSubmitImpl"] = "useSubmitImpl";
  DataRouterHook["UseFetcher"] = "useFetcher";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function (DataRouterStateHook) {
  DataRouterStateHook["UseFetchers"] = "useFetchers";
  DataRouterStateHook["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
/**
 * Handles the click behavior for router `<Link>` components. This is useful if
 * you need to create custom `<Link>` components with the same click behavior we
 * use in our exported `<Link>`.
 */

function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return react.exports.useCallback(event => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of
      // a push, so do the same here unless the replace prop is explicitly set

      let replace = replaceProp !== undefined ? replaceProp : createPath$1(location) === createPath$1(path);
      navigate(to, {
        replace,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);
}

const storageService = {
  get: (key) => localStorage.getItem(key) ?? null,
  set: (key, value) => {
    if (!value) {
      localStorage.removeItem(key);
      return;
    }
    localStorage.setItem(key, value);
  }
};

function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
};

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray: isArray$1} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  const pattern = '[object FormData]';
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) ||
    toString.call(thing) === pattern ||
    (isFunction(thing.toString) && thing.toString() === pattern)
  );
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {void}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray$1(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge$1(/* obj1, obj2, obj3, ... */) {
  const result = {};
  const assignValue = (val, key) => {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge$1(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge$1({}, val);
    } else if (isArray$1(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  };

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray$1(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];

  const iterator = generator.call(obj);

  let result;

  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[_-\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty$1 = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    if (reducer(descriptor, name, obj) !== false) {
      reducedDescriptors[name] = descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not read-only method \'' + name + '\'');
      };
    }
  });
};

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };

  isArray$1(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
};

const noop$1 = () => {};

const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};

const utils = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge: merge$1,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$1,
  hasOwnProp: hasOwnProperty$1, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$1,
  toFiniteNumber
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

const prototype$1 = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

/* eslint-env browser */

var browser = typeof self == 'object' ? self.FormData : window.FormData;

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliant(thing) {
  return thing && utils.isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator];
}

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (browser || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && isSpecCompliant(formData);

  if (!utils.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils.isBlob(value)) {
      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils.isArray(value) && isFlatArray(value)) ||
        (utils.isFileList(value) || utils.endsWith(key, '[]') && (arr = utils.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils.forEach(value, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode$1(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && toFormData(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?object} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode;

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ?
      params.toString() :
      new AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

const URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;

const FormData$1 = FormData;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== 'undefined' && (
    (product = navigator.product) === 'ReactNative' ||
    product === 'NativeScript' ||
    product === 'NS')
  ) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
})();

const platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob
  },
  isStandardBrowserEnv,
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
};

function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};

    utils.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

const cookies = platform.isStandardBrowserEnv ?

// Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        const cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

// Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })();

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

const isURLSameOrigin = platform.isStandardBrowserEnv ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement('a');
    let originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      let href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
          urlParsingNode.pathname :
          '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      const parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
          parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })();

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
const parseHeaders = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};

const $internals = Symbol('internals');
const $defaults = Symbol('defaults');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

function matchHeaderValue(context, value, header, filter) {
  if (utils.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (!utils.isString(value)) return;

  if (utils.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

function AxiosHeaders(headers, defaults) {
  headers && this.set(headers);
  this[$defaults] = defaults || null;
}

Object.assign(AxiosHeaders.prototype, {
  set: function(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = findKey(self, lHeader);

      if (key && _rewrite !== true && (self[key] === false || _rewrite === false)) {
        return;
      }

      self[key || _header] = normalizeValue(_value);
    }

    if (utils.isPlainObject(header)) {
      utils.forEach(header, (_value, _header) => {
        setHeader(_value, _header, valueOrRewrite);
      });
    } else {
      setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  },

  get: function(header, parser) {
    header = normalizeHeader(header);

    if (!header) return undefined;

    const key = findKey(this, header);

    if (key) {
      const value = this[key];

      if (!parser) {
        return value;
      }

      if (parser === true) {
        return parseTokens(value);
      }

      if (utils.isFunction(parser)) {
        return parser.call(this, value, key);
      }

      if (utils.isRegExp(parser)) {
        return parser.exec(value);
      }

      throw new TypeError('parser must be boolean|regexp|function');
    }
  },

  has: function(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = findKey(this, header);

      return !!(key && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  },

  delete: function(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  },

  clear: function() {
    return Object.keys(this).forEach(this.delete.bind(this));
  },

  normalize: function(format) {
    const self = this;
    const headers = {};

    utils.forEach(this, (value, header) => {
      const key = findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  },

  toJSON: function(asStrings) {
    const obj = Object.create(null);

    utils.forEach(Object.assign({}, this[$defaults] || null, this),
      (value, header) => {
        if (value == null || value === false) return;
        obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value;
      });

    return obj;
  }
});

Object.assign(AxiosHeaders, {
  from: function(thing) {
    if (utils.isString(thing)) {
      return new this(parseHeaders(thing));
    }
    return thing instanceof this ? thing : new this(thing);
  },

  accessor: function(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
});

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent']);

utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return  passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);

  return e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined
    };

    data[isDownloadStream ? 'download' : 'upload'] = true;

    listener(data);
  };
}

function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData) && platform.isStandardBrowserEnv) {
      requestHeaders.setContentType(false); // Let the browser set it
    }

    let request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
    }

    const fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = AxiosHeaders.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (platform.isStandardBrowserEnv) {
      // Add xsrf header
      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath))
        && config.xsrfCookieName && cookies.read(config.xsrfCookieName);

      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(fullPath);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
}

const adapters = {
  http: xhrAdapter,
  xhr: xhrAdapter
};

const adapters$1 = {
  getAdapter: (nameOrAdapter) => {
    if(utils.isString(nameOrAdapter)){
      const adapter = adapters[nameOrAdapter];

      if (!nameOrAdapter) {
        throw Error(
          utils.hasOwnProp(nameOrAdapter) ?
            `Adapter '${nameOrAdapter}' is not available in the build` :
            `Can not resolve adapter '${nameOrAdapter}'`
        );
      }

      return adapter
    }

    if (!utils.isFunction(nameOrAdapter)) {
      throw new TypeError('adapter is not a function');
    }

    return nameOrAdapter;
  },
  adapters
};

const DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

/**
 * If the browser has an XMLHttpRequest object, use the XHR adapter, otherwise use the HTTP
 * adapter
 *
 * @returns {Function}
 */
function getDefaultAdapter() {
  let adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = adapters$1.getAdapter('xhr');
  } else if (typeof process !== 'undefined' && utils.kindOf(process) === 'process') {
    // For node use HTTP adapter
    adapter = adapters$1.getAdapter('http');
  }
  return adapter;
}

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: transitionalDefaults,

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils.isObject(data);

    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils.isFormData(data);

    if (isFormData) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }

    if (utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || defaults;
  const context = response || config;
  const headers = AxiosHeaders.from(context.headers);
  let data = context.data;

  utils.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = AxiosHeaders.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  const adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = AxiosHeaders.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  const mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'beforeRedirect': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

const VERSION = "1.1.3";

const validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

const validator = {
  assertOptions,
  validators: validators$1
};

const validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer !== undefined) {
      validator.assertOptions(paramsSerializer, {
        encode: validators.function,
        serialize: validators.function
      }, true);
    }

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    const defaultHeaders = config.headers && utils.merge(
      config.headers.common,
      config.headers[config.method]
    );

    defaultHeaders && utils.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      function cleanHeaderConfig(method) {
        delete config.headers[method];
      }
    );

    config.headers = new AxiosHeaders(config.headers, defaultHeaders);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
}

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new Axios(defaultConfig);
  const instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;

// Expose AxiosError class
axios.AxiosError = AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

axios.formToJSON = thing => {
  return formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
};

const delay = (time) => new Promise((resolve) => {
  setTimeout(resolve, time);
});
const instance = axios.create({
  baseURL: "https://api.notrzr.net/nfa"
});
instance.interceptors.request.use((config) => {
  const token = getUser()?.access_token;
  if (token && config.headers)
    config.headers.Authorization = `Bearer ${token}`;
  return config;
}, (error) => {
  console.log({ error });
});
instance.interceptors.response.use(async (response) => {
  await delay(0);
  return response;
});
const responseBody = (response) => response.data;
const request = {
  get: (url, config) => instance.get(url, config).then(responseBody),
  post: (url, data, config) => instance.post(url, data, config).then(responseBody),
  patch: (url, data, config) => instance.patch(url, data, config).then(responseBody),
  put: (url, data, config) => instance.put(url, data, config).then(responseBody),
  delete: (url, config) => instance.delete(url, config).then(responseBody)
};

const getSharedStateHook = (initial, options = {}) => {
  const current = { state: initial };
  let lastId = 0;
  const getId = () => lastId++;
  const callbacks = {};
  const updateState = (newState) => {
    const nextState = typeof newState === "function" ? newState(current.state) : newState;
    current.state = nextState;
    options?.onChange?.(nextState);
    Object.values(callbacks).forEach((callback) => callback(nextState));
  };
  return Object.assign(
    () => {
      const [state, setState] = react.exports.useState(current.state);
      react.exports.useEffect(() => {
        const id = getId();
        callbacks[id] = setState;
        return () => {
          delete callbacks[id];
        };
      }, []);
      return [state, updateState];
    },
    { getState: () => current.state, updateState }
  );
};

const storageKey$1 = "[StorageKey]: currentAddress";
const useCurrentAddress = getSharedStateHook(storageService.get(storageKey$1), {
  onChange: async (val) => {
    storageService.set(storageKey$1, val);
    if (val) {
      await request.get(`/addresses/${val}`, { headers: { "ngrok-skip-browser-warning": "1" } });
    }
  }
});
useCurrentAddress.getState;
const updateCurrentAddress = useCurrentAddress.updateState;

const storageKey = "[StorageKey]: userId";
const useUser = getSharedStateHook(null, {
  onChange: (val) => {
    const prevUserId = storageService.get(storageKey);
    storageService.set(storageKey, val?.profile.sub ?? null);
    if (prevUserId && val?.profile?.sub !== prevUserId) {
      updateCurrentAddress(null);
    }
  }
});
const getUser = useUser.getState;
const updateUser = useUser.updateState;

var _excluded$5 = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function useStateManager(_ref) {
  var _ref$defaultInputValu = _ref.defaultInputValue,
    defaultInputValue = _ref$defaultInputValu === void 0 ? '' : _ref$defaultInputValu,
    _ref$defaultMenuIsOpe = _ref.defaultMenuIsOpen,
    defaultMenuIsOpen = _ref$defaultMenuIsOpe === void 0 ? false : _ref$defaultMenuIsOpe,
    _ref$defaultValue = _ref.defaultValue,
    defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue,
    propsInputValue = _ref.inputValue,
    propsMenuIsOpen = _ref.menuIsOpen,
    propsOnChange = _ref.onChange,
    propsOnInputChange = _ref.onInputChange,
    propsOnMenuClose = _ref.onMenuClose,
    propsOnMenuOpen = _ref.onMenuOpen,
    propsValue = _ref.value,
    restSelectProps = _objectWithoutProperties(_ref, _excluded$5);
  var _useState = react.exports.useState(propsInputValue !== undefined ? propsInputValue : defaultInputValue),
    _useState2 = _slicedToArray(_useState, 2),
    stateInputValue = _useState2[0],
    setStateInputValue = _useState2[1];
  var _useState3 = react.exports.useState(propsMenuIsOpen !== undefined ? propsMenuIsOpen : defaultMenuIsOpen),
    _useState4 = _slicedToArray(_useState3, 2),
    stateMenuIsOpen = _useState4[0],
    setStateMenuIsOpen = _useState4[1];
  var _useState5 = react.exports.useState(propsValue !== undefined ? propsValue : defaultValue),
    _useState6 = _slicedToArray(_useState5, 2),
    stateValue = _useState6[0],
    setStateValue = _useState6[1];
  var onChange = react.exports.useCallback(function (value, actionMeta) {
    if (typeof propsOnChange === 'function') {
      propsOnChange(value, actionMeta);
    }
    setStateValue(value);
  }, [propsOnChange]);
  var onInputChange = react.exports.useCallback(function (value, actionMeta) {
    var newValue;
    if (typeof propsOnInputChange === 'function') {
      newValue = propsOnInputChange(value, actionMeta);
    }
    setStateInputValue(newValue !== undefined ? newValue : value);
  }, [propsOnInputChange]);
  var onMenuOpen = react.exports.useCallback(function () {
    if (typeof propsOnMenuOpen === 'function') {
      propsOnMenuOpen();
    }
    setStateMenuIsOpen(true);
  }, [propsOnMenuOpen]);
  var onMenuClose = react.exports.useCallback(function () {
    if (typeof propsOnMenuClose === 'function') {
      propsOnMenuClose();
    }
    setStateMenuIsOpen(false);
  }, [propsOnMenuClose]);
  var inputValue = propsInputValue !== undefined ? propsInputValue : stateInputValue;
  var menuIsOpen = propsMenuIsOpen !== undefined ? propsMenuIsOpen : stateMenuIsOpen;
  var value = propsValue !== undefined ? propsValue : stateValue;
  return _objectSpread2$1(_objectSpread2$1({}, restSelectProps), {}, {
    inputValue: inputValue,
    menuIsOpen: menuIsOpen,
    onChange: onChange,
    onInputChange: onInputChange,
    onMenuClose: onMenuClose,
    onMenuOpen: onMenuOpen,
    value: value
  });
}

/*

Based off glamor's StyleSheet, thanks Sunil 

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/
// $FlowFixMe
function sheetForTag(tag) {
  if (tag.sheet) {
    // $FlowFixMe
    return tag.sheet;
  } // this weirdness brought to you by firefox

  /* istanbul ignore next */


  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      // $FlowFixMe
      return document.styleSheets[i];
    }
  }
}

function createStyleElement(options) {
  var tag = document.createElement('style');
  tag.setAttribute('data-emotion', options.key);

  if (options.nonce !== undefined) {
    tag.setAttribute('nonce', options.nonce);
  }

  tag.appendChild(document.createTextNode(''));
  tag.setAttribute('data-s', '');
  return tag;
}

var StyleSheet = /*#__PURE__*/function () {
  // Using Node instead of HTMLElement since container may be a ShadowRoot
  function StyleSheet(options) {
    var _this = this;

    this._insertTag = function (tag) {
      var before;

      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }

      _this.container.insertBefore(tag, before);

      _this.tags.push(tag);
    };

    this.isSpeedy = options.speedy === undefined ? "production" === 'production' : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }

  var _proto = StyleSheet.prototype;

  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };

  _proto.insert = function insert(rule) {
    // the max length is how many rules we have per style tag, it's 65000 in speedy mode
    // it's 1 in dev because we insert source maps that map a single rule to a location
    // and you can only have one source map per style tag
    if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }

    var tag = this.tags[this.tags.length - 1];

    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);

      try {
        // this is the ultrafast version, works across browsers
        // the big drawback is that the css won't be editable in devtools
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }

    this.ctr++;
  };

  _proto.flush = function flush() {
    // $FlowFixMe
    this.tags.forEach(function (tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };

  return StyleSheet;
}();

function memoize(fn) {
  var cache = Object.create(null);
  return function (arg) {
    if (cache[arg] === undefined) cache[arg] = fn(arg);
    return cache[arg];
  };
}

var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
  var previous = 0;
  var character = 0;

  while (true) {
    previous = character;
    character = peek(); // &\f

    if (previous === 38 && character === 12) {
      points[index] = 1;
    }

    if (token(character)) {
      break;
    }

    next();
  }

  return slice(begin, position);
};

var toRules = function toRules(parsed, points) {
  // pretend we've started with a comma
  var index = -1;
  var character = 44;

  do {
    switch (token(character)) {
      case 0:
        // &\f
        if (character === 38 && peek() === 12) {
          // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
          // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
          // and when it should just concatenate the outer and inner selectors
          // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
          points[index] = 1;
        }

        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;

      case 2:
        parsed[index] += delimit(character);
        break;

      case 4:
        // comma
        if (character === 44) {
          // colon
          parsed[++index] = peek() === 58 ? '&\f' : '';
          points[index] = parsed[index].length;
          break;
        }

      // fallthrough

      default:
        parsed[index] += from(character);
    }
  } while (character = next());

  return parsed;
};

var getRules = function getRules(value, points) {
  return dealloc(toRules(alloc(value), points));
}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11


var fixedElements = /* #__PURE__ */new WeakMap();
var compat = function compat(element) {
  if (element.type !== 'rule' || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }

  var value = element.value,
      parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;

  while (parent.type !== 'rule') {
    parent = parent.parent;
    if (!parent) return;
  } // short-circuit for the simplest case


  if (element.props.length === 1 && value.charCodeAt(0) !== 58
  /* colon */
  && !fixedElements.get(parent)) {
    return;
  } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
  // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"


  if (isImplicitRule) {
    return;
  }

  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;

  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel(element) {
  if (element.type === 'decl') {
    var value = element.value;

    if ( // charcode for l
    value.charCodeAt(0) === 108 && // charcode for b
    value.charCodeAt(2) === 98) {
      // this ignores label
      element["return"] = '';
      element.value = '';
    }
  }
};

/* eslint-disable no-fallthrough */

function prefix(value, length) {
  switch (hash(value, length)) {
    // color-adjust
    case 5103:
      return WEBKIT + 'print-' + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust

    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // flex, flex-direction

    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    // order

    case 6165:
      return WEBKIT + value + MS + 'flex-' + value + value;
    // align-items

    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value;
    // align-self

    case 5443:
      return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/, '') + value;
    // align-content

    case 4675:
      return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/, '') + value;
    // flex-shrink

    case 5548:
      return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value;
    // flex-basis

    case 5292:
      return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value;
    // flex-grow

    case 6060:
      return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value;
    // transition

    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value;
    // cursor

    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value;
    // background, background-image

    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + '$1' + '$`$1');
    // justify-content

    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)

    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value;
    // (min|max)?(width|height|inline-size|block-size)

    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      // stretch, max-content, min-content, fill-available
      if (strlen(value) - 1 - length > 6) switch (charat(value, length + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          // -
          if (charat(value, length + 4) !== 45) break;
        // (f)ill-available, (f)it-content

        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
        // (s)tretch

        case 115:
          return ~indexof(value, 'stretch') ? prefix(replace(value, 'stretch', 'fill-available'), length) + value : value;
      }
      break;
    // position: sticky

    case 4949:
      // (s)ticky?
      if (charat(value, length + 1) !== 115) break;
    // display: (flex|inline-flex)

    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, '!important') && 10))) {
        // stic(k)y
        case 107:
          return replace(value, ':', ':' + WEBKIT) + value;
        // (inline-)?fl(e)x

        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + WEBKIT + (charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value;
      }

      break;
    // writing-mode

    case 5936:
      switch (charat(value, length + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
        // vertical-r(l)

        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
        // horizontal(-)tb

        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
      }

      return WEBKIT + value + MS + value + value;
  }

  return value;
}

var prefixer = function prefixer(element, index, children, callback) {
  if (element.length > -1) if (!element["return"]) switch (element.type) {
    case DECLARATION:
      element["return"] = prefix(element.value, element.length);
      break;

    case KEYFRAMES:
      return serialize([copy$1(element, {
        value: replace(element.value, '@', '@' + WEBKIT)
      })], callback);

    case RULESET:
      if (element.length) return combine(element.props, function (value) {
        switch (match$1(value, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ':read-only':
          case ':read-write':
            return serialize([copy$1(element, {
              props: [replace(value, /:(read-\w+)/, ':' + MOZ + '$1')]
            })], callback);
          // :placeholder

          case '::placeholder':
            return serialize([copy$1(element, {
              props: [replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1')]
            }), copy$1(element, {
              props: [replace(value, /:(plac\w+)/, ':' + MOZ + '$1')]
            }), copy$1(element, {
              props: [replace(value, /:(plac\w+)/, MS + 'input-$1')]
            })], callback);
        }

        return '';
      });
  }
};

var defaultStylisPlugins = [prefixer];

var createCache = function createCache(options) {
  var key = options.key;

  if ( key === 'css') {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
    // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
    // note this very very intentionally targets all style elements regardless of the key to ensure
    // that creating a cache works inside of render of a React component

    Array.prototype.forEach.call(ssrStyles, function (node) {
      // we want to only move elements which have a space in the data-emotion attribute value
      // because that indicates that it is an Emotion 11 server-side rendered style elements
      // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
      // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
      // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
      // will not result in the Emotion 10 styles being destroyed
      var dataEmotionAttribute = node.getAttribute('data-emotion');

      if (dataEmotionAttribute.indexOf(' ') === -1) {
        return;
      }
      document.head.appendChild(node);
      node.setAttribute('data-s', '');
    });
  }

  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

  var inserted = {};
  var container;
  var nodesToHydrate = [];

  {
    container = options.container || document.head;
    Array.prototype.forEach.call( // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
      var attrib = node.getAttribute("data-emotion").split(' '); // $FlowFixMe

      for (var i = 1; i < attrib.length; i++) {
        inserted[attrib[i]] = true;
      }

      nodesToHydrate.push(node);
    });
  }

  var _insert;

  var omnipresentPlugins = [compat, removeLabel];

  {
    var currentSheet;
    var finalizingPlugins = [stringify$1, rulesheet(function (rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));

    var stylis = function stylis(styles) {
      return serialize(compile(styles), serializer);
    };

    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;

      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);

      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }

  var cache = {
    key: key,
    sheet: new StyleSheet({
      key: key,
      container: container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted: inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};

var isBrowser = "object" !== 'undefined';
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = '';
  classNames.split(' ').forEach(function (className) {
    if (registered[className] !== undefined) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;

  if ( // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (isStringTag === false || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  isBrowser === false ) && cache.registered[className] === undefined) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;

  if (cache.inserted[serialized.name] === undefined) {
    var current = serialized;

    do {
      cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);

      current = current.next;
    } while (current !== undefined);
  }
};

/* eslint-disable */
// Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
function murmur2(str) {
  // 'm' and 'r' are mixing constants generated offline.
  // They're not really 'magic', they just happen to work well.
  // const m = 0x5bd1e995;
  // const r = 24;
  // Initialize the hash
  var h = 0; // Mix 4 bytes at a time into the hash

  var k,
      i = 0,
      len = str.length;

  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
    k =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
    k ^=
    /* k >>> r: */
    k >>> 24;
    h =
    /* Math.imul(k, m): */
    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
    /* Math.imul(h, m): */
    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Handle the last few bytes of the input array


  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

    case 2:
      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

    case 1:
      h ^= str.charCodeAt(i) & 0xff;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  } // Do a few final mixes of the hash to ensure the last few
  // bytes are well-incorporated.


  h ^= h >>> 13;
  h =
  /* Math.imul(h, m): */
  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}

var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

var isCustomProperty = function isCustomProperty(property) {
  return property.charCodeAt(1) === 45;
};

var isProcessableValue = function isProcessableValue(value) {
  return value != null && typeof value !== 'boolean';
};

var processStyleName = /* #__PURE__ */memoize(function (styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
});

var processStyleValue = function processStyleValue(key, value) {
  switch (key) {
    case 'animation':
    case 'animationName':
      {
        if (typeof value === 'string') {
          return value.replace(animationRegex, function (match, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
  }

  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
    return value + 'px';
  }

  return value;
};

var noComponentSelectorMessage = 'Component selectors can only be used in conjunction with ' + '@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware ' + 'compiler transform.';

function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return '';
  }

  if (interpolation.__emotion_styles !== undefined) {

    return interpolation;
  }

  switch (typeof interpolation) {
    case 'boolean':
      {
        return '';
      }

    case 'object':
      {
        if (interpolation.anim === 1) {
          cursor = {
            name: interpolation.name,
            styles: interpolation.styles,
            next: cursor
          };
          return interpolation.name;
        }

        if (interpolation.styles !== undefined) {
          var next = interpolation.next;

          if (next !== undefined) {
            // not the most efficient thing ever but this is a pretty rare case
            // and there will be very few iterations of this generally
            while (next !== undefined) {
              cursor = {
                name: next.name,
                styles: next.styles,
                next: cursor
              };
              next = next.next;
            }
          }

          var styles = interpolation.styles + ";";

          return styles;
        }

        return createStringFromObject(mergedProps, registered, interpolation);
      }

    case 'function':
      {
        if (mergedProps !== undefined) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        }

        break;
      }
  } // finalize string values (regular strings and functions interpolated into css calls)


  if (registered == null) {
    return interpolation;
  }

  var cached = registered[interpolation];
  return cached !== undefined ? cached : interpolation;
}

function createStringFromObject(mergedProps, registered, obj) {
  var string = '';

  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];

      if (typeof value !== 'object') {
        if (registered != null && registered[value] !== undefined) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === 'NO_COMPONENT_SELECTOR' && "production" !== 'production') {
          throw new Error(noComponentSelectorMessage);
        }

        if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);

          switch (_key) {
            case 'animation':
            case 'animationName':
              {
                string += processStyleName(_key) + ":" + interpolated + ";";
                break;
              }

            default:
              {

                string += _key + "{" + interpolated + "}";
              }
          }
        }
      }
    }
  }

  return string;
}

var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
// keyframes are stored on the SerializedStyles object as a linked list


var cursor;
var serializeStyles = function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
    return args[0];
  }

  var stringMode = true;
  var styles = '';
  cursor = undefined;
  var strings = args[0];

  if (strings == null || strings.raw === undefined) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {

    styles += strings[0];
  } // we start at 1 since we've already handled the first arg


  for (var i = 1; i < args.length; i++) {
    styles += handleInterpolation(mergedProps, registered, args[i]);

    if (stringMode) {

      styles += strings[i];
    }
  }


  labelPattern.lastIndex = 0;
  var identifierName = '';
  var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

  while ((match = labelPattern.exec(styles)) !== null) {
    identifierName += '-' + // $FlowFixMe we know it's not null
    match[1];
  }

  var name = murmur2(styles) + identifierName;

  return {
    name: name,
    styles: styles,
    next: cursor
  };
};

var syncFallback = function syncFallback(create) {
  return create();
};

var useInsertionEffect = React$1['useInsertion' + 'Effect'] ? React$1['useInsertion' + 'Effect'] : false;
var useInsertionEffectAlwaysWithSyncFallback =  useInsertionEffect || syncFallback;

var hasOwnProperty = {}.hasOwnProperty;

var EmotionCacheContext = /* #__PURE__ */react.exports.createContext( // we're doing this to avoid preconstruct's dead code elimination in this one case
// because this module is primarily intended for the browser and node
// but it's also required in react native and similar environments sometimes
// and we could have a special build just for that
// but this is much easier and the native packages
// might use a different theme context in the future anyway
typeof HTMLElement !== 'undefined' ? /* #__PURE__ */createCache({
  key: 'css'
}) : null);

EmotionCacheContext.Provider;

var withEmotionCache = function withEmotionCache(func) {
  // $FlowFixMe
  return /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
    // the cache will never be null in the browser
    var cache = react.exports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};

var ThemeContext = /* #__PURE__ */react.exports.createContext({});

var typePropName = '__EMOTION_TYPE_PLEASE_DO_NOT_USE__';
var createEmotionProps = function createEmotionProps(type, props) {

  var newProps = {};

  for (var key in props) {
    if (hasOwnProperty.call(props, key)) {
      newProps[key] = props[key];
    }
  }

  newProps[typePropName] = type; // For performance, only call getLabelFromStackTrace in development and when

  return newProps;
};

var Insertion$1 = function Insertion(_ref) {
  var cache = _ref.cache,
      serialized = _ref.serialized,
      isStringTag = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function () {
    return insertStyles(cache, serialized, isStringTag);
  });

  return null;
};

var Emotion = /* #__PURE__ */withEmotionCache(function (props, cache, ref) {
  var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works
  // not passing the registered cache to serializeStyles because it would
  // make certain babel optimisations not possible

  if (typeof cssProp === 'string' && cache.registered[cssProp] !== undefined) {
    cssProp = cache.registered[cssProp];
  }

  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = '';

  if (typeof props.className === 'string') {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }

  var serialized = serializeStyles(registeredStyles, undefined, react.exports.useContext(ThemeContext));

  className += cache.key + "-" + serialized.name;
  var newProps = {};

  for (var key in props) {
    if (hasOwnProperty.call(props, key) && key !== 'css' && key !== typePropName && ("production" === 'production' )) {
      newProps[key] = props[key];
    }
  }

  newProps.ref = ref;
  newProps.className = className;
  return /*#__PURE__*/react.exports.createElement(react.exports.Fragment, null, /*#__PURE__*/react.exports.createElement(Insertion$1, {
    cache: cache,
    serialized: serialized,
    isStringTag: typeof WrappedComponent === 'string'
  }), /*#__PURE__*/react.exports.createElement(WrappedComponent, newProps));
});

var jsx = function jsx(type, props) {
  var args = arguments;

  if (props == null || !hasOwnProperty.call(props, 'css')) {
    // $FlowFixMe
    return react.exports.createElement.apply(undefined, args);
  }

  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion;
  createElementArgArray[1] = createEmotionProps(type, props);

  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  } // $FlowFixMe


  return react.exports.createElement.apply(null, createElementArgArray);
};

function css$2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return serializeStyles(args);
}

var keyframes = function keyframes() {
  var insertable = css$2.apply(void 0, arguments);
  var name = "animation-" + insertable.name; // $FlowFixMe

  return {
    name: name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};

var classnames = function classnames(args) {
  var len = args.length;
  var i = 0;
  var cls = '';

  for (; i < len; i++) {
    var arg = args[i];
    if (arg == null) continue;
    var toAdd = void 0;

    switch (typeof arg) {
      case 'boolean':
        break;

      case 'object':
        {
          if (Array.isArray(arg)) {
            toAdd = classnames(arg);
          } else {

            toAdd = '';

            for (var k in arg) {
              if (arg[k] && k) {
                toAdd && (toAdd += ' ');
                toAdd += k;
              }
            }
          }

          break;
        }

      default:
        {
          toAdd = arg;
        }
    }

    if (toAdd) {
      cls && (cls += ' ');
      cls += toAdd;
    }
  }

  return cls;
};

function merge(registered, css, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);

  if (registeredStyles.length < 2) {
    return className;
  }

  return rawClassName + css(registeredStyles);
}

var Insertion = function Insertion(_ref) {
  var cache = _ref.cache,
      serializedArr = _ref.serializedArr;
  useInsertionEffectAlwaysWithSyncFallback(function () {

    for (var i = 0; i < serializedArr.length; i++) {
      insertStyles(cache, serializedArr[i], false);
    }
  });

  return null;
};

var ClassNames = /* #__PURE__ */withEmotionCache(function (props, cache) {
  var hasRendered = false;
  var serializedArr = [];

  var css = function css() {
    if (hasRendered && "production" !== 'production') {
      throw new Error('css can only be used during render');
    }

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var serialized = serializeStyles(args, cache.registered);
    serializedArr.push(serialized); // registration has to happen here as the result of this might get consumed by `cx`

    registerStyles(cache, serialized, false);
    return cache.key + "-" + serialized.name;
  };

  var cx = function cx() {
    if (hasRendered && "production" !== 'production') {
      throw new Error('cx can only be used during render');
    }

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return merge(cache.registered, css, classnames(args));
  };

  var content = {
    css: css,
    cx: cx,
    theme: react.exports.useContext(ThemeContext)
  };
  var ele = props.children(content);
  hasRendered = true;
  return /*#__PURE__*/react.exports.createElement(react.exports.Fragment, null, /*#__PURE__*/react.exports.createElement(Insertion, {
    cache: cache,
    serializedArr: serializedArr
  }), ele);
});

function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}

function isWindow(value) {
  return value && value.document && value.location && value.alert && value.setInterval;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}

function getNodeName(node) {
  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';
}

function getUAString() {
  const uaData = navigator.userAgentData;

  if (uaData != null && uaData.brands) {
    return uaData.brands.map(item => item.brand + "/" + item.version).join(' ');
  }

  return navigator.userAgent;
}

function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  // Browsers without `ShadowRoot` support
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);
}
function isLayoutViewport() {
  // Not Safari
  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways
  //  Always-visible scrollbar or not
  //  Width of <html>, etc.
  // const vV = win.visualViewport;
  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;
}
function isLastTraversableNode(node) {
  return ['html', 'body', '#document'].includes(getNodeName(node));
}
const round$1 = Math.round;

function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;

  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;

  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  const win = isElement(element) ? getWindow(element) : window;
  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;
  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;
  const width = clientRect.width / scaleX;
  const height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}

function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }

  const result = // Step into the shadow DOM of the parent of a slotted node
  node.assignedSlot || // DOM Element detected
  node.parentNode || ( // ShadowRoot detected
  isShadowRoot(node) ? node.host : null) || // Fallback
  getDocumentElement(node);
  return isShadowRoot(result) ? result.host : result;
}

function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);

  if (isLastTraversableNode(parentNode)) {
    // @ts-ignore assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }

  return getNearestOverflowAncestor(parentNode);
}

function getOverflowAncestors(node, list) {
  var _node$ownerDocument;

  if (list === void 0) {
    list = [];
  }

  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
  const updatedList = list.concat(target);
  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here
  updatedList.concat(getOverflowAncestors(target));
}

/**
 * Automatically updates the position of the floating element when necessary.
 * @see https://floating-ui.com/docs/autoUpdate
 */
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }

  const {
    ancestorScroll: _ancestorScroll = true,
    ancestorResize = true,
    elementResize = true,
    animationFrame = false
  } = options;
  const ancestorScroll = _ancestorScroll && !animationFrame;
  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : []), ...getOverflowAncestors(floating)] : [];
  ancestors.forEach(ancestor => {
    ancestorScroll && ancestor.addEventListener('scroll', update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener('resize', update);
  });
  let observer = null;

  if (elementResize) {
    let initialUpdate = true;
    observer = new ResizeObserver(() => {
      if (!initialUpdate) {
        update();
      }

      initialUpdate = false;
    });
    isElement(reference) && !animationFrame && observer.observe(reference);

    if (!isElement(reference) && reference.contextElement && !animationFrame) {
      observer.observe(reference.contextElement);
    }

    observer.observe(floating);
  }

  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;

  if (animationFrame) {
    frameLoop();
  }

  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);

    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }

    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }

  update();
  return () => {
    var _observer;

    ancestors.forEach(ancestor => {
      ancestorScroll && ancestor.removeEventListener('scroll', update);
      ancestorResize && ancestor.removeEventListener('resize', update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;

    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}

var index =  react.exports.useLayoutEffect ;

var _excluded$3 = ["className", "clearValue", "cx", "getStyles", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"];
// ==============================
// NO OP
// ==============================

var noop = function noop() {};

// ==============================
// Class Name Prefixer
// ==============================

/**
 String representation of component state for styling with class names.

 Expects an array of strings OR a string/object pair:
 - className(['comp', 'comp-arg', 'comp-arg-2'])
   @returns 'react-select__comp react-select__comp-arg react-select__comp-arg-2'
 - className('comp', { some: true, state: false })
   @returns 'react-select__comp react-select__comp--some'
*/
function applyPrefixToName(prefix, name) {
  if (!name) {
    return prefix;
  } else if (name[0] === '-') {
    return prefix + name;
  } else {
    return prefix + '__' + name;
  }
}
function classNames(prefix, state, className) {
  var arr = [className];
  if (state && prefix) {
    for (var key in state) {
      if (state.hasOwnProperty(key) && state[key]) {
        arr.push("".concat(applyPrefixToName(prefix, key)));
      }
    }
  }
  return arr.filter(function (i) {
    return i;
  }).map(function (i) {
    return String(i).trim();
  }).join(' ');
}
// ==============================
// Clean Value
// ==============================

var cleanValue = function cleanValue(value) {
  if (isArray(value)) return value.filter(Boolean);
  if (_typeof$1(value) === 'object' && value !== null) return [value];
  return [];
};

// ==============================
// Clean Common Props
// ==============================

var cleanCommonProps = function cleanCommonProps(props) {
  //className
  props.className;
    props.clearValue;
    props.cx;
    props.getStyles;
    props.getValue;
    props.hasValue;
    props.isMulti;
    props.isRtl;
    props.options;
    props.selectOption;
    props.selectProps;
    props.setValue;
    props.theme;
    var innerProps = _objectWithoutProperties(props, _excluded$3);
  return _objectSpread2$1({}, innerProps);
};

// ==============================
// Scroll Helpers
// ==============================

function isDocumentElement(el) {
  return [document.documentElement, document.body, window].indexOf(el) > -1;
}

// Normalized Scroll Top
// ------------------------------

function normalizedHeight(el) {
  if (isDocumentElement(el)) {
    return window.innerHeight;
  }
  return el.clientHeight;
}

// Normalized scrollTo & scrollTop
// ------------------------------

function getScrollTop(el) {
  if (isDocumentElement(el)) {
    return window.pageYOffset;
  }
  return el.scrollTop;
}
function scrollTo(el, top) {
  // with a scroll distance, we perform scroll on the element
  if (isDocumentElement(el)) {
    window.scrollTo(0, top);
    return;
  }
  el.scrollTop = top;
}

// Get Scroll Parent
// ------------------------------

function getScrollParent(element) {
  var style = getComputedStyle(element);
  var excludeStaticParent = style.position === 'absolute';
  var overflowRx = /(auto|scroll)/;
  if (style.position === 'fixed') return document.documentElement;
  for (var parent = element; parent = parent.parentElement;) {
    style = getComputedStyle(parent);
    if (excludeStaticParent && style.position === 'static') {
      continue;
    }
    if (overflowRx.test(style.overflow + style.overflowY + style.overflowX)) {
      return parent;
    }
  }
  return document.documentElement;
}

// Animated Scroll To
// ------------------------------

/**
  @param t: time (elapsed)
  @param b: initial value
  @param c: amount of change
  @param d: duration
*/
function easeOutCubic(t, b, c, d) {
  return c * ((t = t / d - 1) * t * t + 1) + b;
}
function animatedScrollTo(element, to) {
  var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;
  var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;
  var start = getScrollTop(element);
  var change = to - start;
  var increment = 10;
  var currentTime = 0;
  function animateScroll() {
    currentTime += increment;
    var val = easeOutCubic(currentTime, start, change, duration);
    scrollTo(element, val);
    if (currentTime < duration) {
      window.requestAnimationFrame(animateScroll);
    } else {
      callback(element);
    }
  }
  animateScroll();
}

// Scroll Into View
// ------------------------------

function scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect();
  var focusedRect = focusedEl.getBoundingClientRect();
  var overScroll = focusedEl.offsetHeight / 3;
  if (focusedRect.bottom + overScroll > menuRect.bottom) {
    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
  } else if (focusedRect.top - overScroll < menuRect.top) {
    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
  }
}

// ==============================
// Get bounding client object
// ==============================

// cannot get keys using array notation with DOMRect
function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
}

// ==============================
// Touch Capability Detector
// ==============================

function isTouchCapable() {
  try {
    document.createEvent('TouchEvent');
    return true;
  } catch (e) {
    return false;
  }
}

// ==============================
// Mobile Device Detector
// ==============================

function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch (e) {
    return false;
  }
}

// ==============================
// Passive Event Detector
// ==============================

// https://github.com/rafgraph/detect-it/blob/main/src/index.ts#L19-L36
var passiveOptionAccessed = false;
var options = {
  get passive() {
    return passiveOptionAccessed = true;
  }
};
// check for SSR
var w = typeof window !== 'undefined' ? window : {};
if (w.addEventListener && w.removeEventListener) {
  w.addEventListener('p', noop, options);
  w.removeEventListener('p', noop, false);
}
var supportsPassiveEvents = passiveOptionAccessed;
function notNullish(item) {
  return item != null;
}
function isArray(arg) {
  return Array.isArray(arg);
}
function valueTernary(isMulti, multiValue, singleValue) {
  return isMulti ? multiValue : singleValue;
}
function singleValueAsValue(singleValue) {
  return singleValue;
}
function multiValueAsValue(multiValue) {
  return multiValue;
}
var removeProps = function removeProps(propsObj) {
  for (var _len = arguments.length, properties = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    properties[_key - 1] = arguments[_key];
  }
  var propsMap = Object.entries(propsObj).filter(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 1),
      key = _ref2[0];
    return !properties.includes(key);
  });
  return propsMap.reduce(function (newProps, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
      key = _ref4[0],
      val = _ref4[1];
    newProps[key] = val;
    return newProps;
  }, {});
};

function getMenuPlacement(_ref) {
  var preferredMaxHeight = _ref.maxHeight,
    menuEl = _ref.menuEl,
    minHeight = _ref.minHeight,
    preferredPlacement = _ref.placement,
    shouldScroll = _ref.shouldScroll,
    isFixedPosition = _ref.isFixedPosition,
    controlHeight = _ref.controlHeight;
  var scrollParent = getScrollParent(menuEl);
  var defaultState = {
    placement: 'bottom',
    maxHeight: preferredMaxHeight
  };

  // something went wrong, return default state
  if (!menuEl || !menuEl.offsetParent) return defaultState;

  // we can't trust `scrollParent.scrollHeight` --> it may increase when
  // the menu is rendered
  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(),
    scrollHeight = _scrollParent$getBoun.height;
  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(),
    menuBottom = _menuEl$getBoundingCl.bottom,
    menuHeight = _menuEl$getBoundingCl.height,
    menuTop = _menuEl$getBoundingCl.top;
  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(),
    containerTop = _menuEl$offsetParent$.top;
  var viewHeight = isFixedPosition ? window.innerHeight : normalizedHeight(scrollParent);
  var scrollTop = getScrollTop(scrollParent);
  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
  var viewSpaceAbove = containerTop - marginTop;
  var viewSpaceBelow = viewHeight - menuTop;
  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
  var scrollUp = scrollTop + menuTop - marginTop;
  var scrollDuration = 160;
  switch (preferredPlacement) {
    case 'auto':
    case 'bottom':
      // 1: the menu will fit, do nothing
      if (viewSpaceBelow >= menuHeight) {
        return {
          placement: 'bottom',
          maxHeight: preferredMaxHeight
        };
      }

      // 2: the menu will fit, if scrolled
      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        return {
          placement: 'bottom',
          maxHeight: preferredMaxHeight
        };
      }

      // 3: the menu will fit, if constrained
      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }

        // we want to provide as much of the menu as possible to the user,
        // so give them whatever is available below rather than the minHeight.
        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: 'bottom',
          maxHeight: constrainedHeight
        };
      }

      // 4. Forked beviour when there isn't enough space below

      // AUTO: flip the menu, render above
      if (preferredPlacement === 'auto' || isFixedPosition) {
        // may need to be constrained after flipping
        var _constrainedHeight = preferredMaxHeight;
        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
        if (spaceAbove >= minHeight) {
          _constrainedHeight = Math.min(spaceAbove - marginBottom - controlHeight, preferredMaxHeight);
        }
        return {
          placement: 'top',
          maxHeight: _constrainedHeight
        };
      }

      // BOTTOM: allow browser to increase scrollable area and immediately set scroll
      if (preferredPlacement === 'bottom') {
        if (shouldScroll) {
          scrollTo(scrollParent, scrollDown);
        }
        return {
          placement: 'bottom',
          maxHeight: preferredMaxHeight
        };
      }
      break;
    case 'top':
      // 1: the menu will fit, do nothing
      if (viewSpaceAbove >= menuHeight) {
        return {
          placement: 'top',
          maxHeight: preferredMaxHeight
        };
      }

      // 2: the menu will fit, if scrolled
      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: 'top',
          maxHeight: preferredMaxHeight
        };
      }

      // 3: the menu will fit, if constrained
      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = preferredMaxHeight;

        // we want to provide as much of the menu as possible to the user,
        // so give them whatever is available below rather than the minHeight.
        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
        }
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: 'top',
          maxHeight: _constrainedHeight2
        };
      }

      // 4. not enough space, the browser WILL NOT increase scrollable area when
      // absolutely positioned element rendered above the viewport (only below).
      // Flip the menu, render below
      return {
        placement: 'bottom',
        maxHeight: preferredMaxHeight
      };
    default:
      throw new Error("Invalid placement provided \"".concat(preferredPlacement, "\"."));
  }
  return defaultState;
}

// Menu Component
// ------------------------------

function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: 'top',
    top: 'bottom'
  };
  return placement ? placementToCSSProp[placement] : 'bottom';
}
var coercePlacement = function coercePlacement(p) {
  return p === 'auto' ? 'bottom' : p;
};
var menuCSS = function menuCSS(_ref2) {
  var _ref3;
  var placement = _ref2.placement,
    _ref2$theme = _ref2.theme,
    borderRadius = _ref2$theme.borderRadius,
    spacing = _ref2$theme.spacing,
    colors = _ref2$theme.colors;
  return _ref3 = {
    label: 'menu'
  }, _defineProperty$1(_ref3, alignToControl(placement), '100%'), _defineProperty$1(_ref3, "backgroundColor", colors.neutral0), _defineProperty$1(_ref3, "borderRadius", borderRadius), _defineProperty$1(_ref3, "boxShadow", '0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)'), _defineProperty$1(_ref3, "marginBottom", spacing.menuGutter), _defineProperty$1(_ref3, "marginTop", spacing.menuGutter), _defineProperty$1(_ref3, "position", 'absolute'), _defineProperty$1(_ref3, "width", '100%'), _defineProperty$1(_ref3, "zIndex", 1), _ref3;
};
var PortalPlacementContext = /*#__PURE__*/react.exports.createContext(null);

// NOTE: internal only
var MenuPlacer = function MenuPlacer(props) {
  var children = props.children,
    minMenuHeight = props.minMenuHeight,
    maxMenuHeight = props.maxMenuHeight,
    menuPlacement = props.menuPlacement,
    menuPosition = props.menuPosition,
    menuShouldScrollIntoView = props.menuShouldScrollIntoView,
    theme = props.theme;
  var _ref4 = react.exports.useContext(PortalPlacementContext) || {},
    setPortalPlacement = _ref4.setPortalPlacement;
  var ref = react.exports.useRef(null);
  var _useState = react.exports.useState(maxMenuHeight),
    _useState2 = _slicedToArray(_useState, 2),
    maxHeight = _useState2[0],
    setMaxHeight = _useState2[1];
  var _useState3 = react.exports.useState(null),
    _useState4 = _slicedToArray(_useState3, 2),
    placement = _useState4[0],
    setPlacement = _useState4[1];
  var controlHeight = theme.spacing.controlHeight;
  index(function () {
    var menuEl = ref.current;
    if (!menuEl) return;

    // DO NOT scroll if position is fixed
    var isFixedPosition = menuPosition === 'fixed';
    var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
    var state = getMenuPlacement({
      maxHeight: maxMenuHeight,
      menuEl: menuEl,
      minHeight: minMenuHeight,
      placement: menuPlacement,
      shouldScroll: shouldScroll,
      isFixedPosition: isFixedPosition,
      controlHeight: controlHeight
    });
    setMaxHeight(state.maxHeight);
    setPlacement(state.placement);
    setPortalPlacement === null || setPortalPlacement === void 0 ? void 0 : setPortalPlacement(state.placement);
  }, [maxMenuHeight, menuPlacement, menuPosition, menuShouldScrollIntoView, minMenuHeight, setPortalPlacement, controlHeight]);
  return children({
    ref: ref,
    placerProps: _objectSpread2$1(_objectSpread2$1({}, props), {}, {
      placement: placement || coercePlacement(menuPlacement),
      maxHeight: maxHeight
    })
  });
};
var Menu = function Menu(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerRef = props.innerRef,
    innerProps = props.innerProps;
  return jsx("div", _extends$2({
    css: getStyles('menu', props),
    className: cx({
      menu: true
    }, className),
    ref: innerRef
  }, innerProps), children);
};

// ==============================
// Menu List
// ==============================

var menuListCSS = function menuListCSS(_ref5) {
  var maxHeight = _ref5.maxHeight,
    baseUnit = _ref5.theme.spacing.baseUnit;
  return {
    maxHeight: maxHeight,
    overflowY: 'auto',
    paddingBottom: baseUnit,
    paddingTop: baseUnit,
    position: 'relative',
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: 'touch'
  };
};
var MenuList = function MenuList(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps,
    innerRef = props.innerRef,
    isMulti = props.isMulti;
  return jsx("div", _extends$2({
    css: getStyles('menuList', props),
    className: cx({
      'menu-list': true,
      'menu-list--is-multi': isMulti
    }, className),
    ref: innerRef
  }, innerProps), children);
};

// ==============================
// Menu Notices
// ==============================

var noticeCSS = function noticeCSS(_ref6) {
  var _ref6$theme = _ref6.theme,
    baseUnit = _ref6$theme.spacing.baseUnit,
    colors = _ref6$theme.colors;
  return {
    color: colors.neutral40,
    padding: "".concat(baseUnit * 2, "px ").concat(baseUnit * 3, "px"),
    textAlign: 'center'
  };
};
var noOptionsMessageCSS = noticeCSS;
var loadingMessageCSS = noticeCSS;
var NoOptionsMessage = function NoOptionsMessage(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps;
  return jsx("div", _extends$2({
    css: getStyles('noOptionsMessage', props),
    className: cx({
      'menu-notice': true,
      'menu-notice--no-options': true
    }, className)
  }, innerProps), children);
};
NoOptionsMessage.defaultProps = {
  children: 'No options'
};
var LoadingMessage = function LoadingMessage(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps;
  return jsx("div", _extends$2({
    css: getStyles('loadingMessage', props),
    className: cx({
      'menu-notice': true,
      'menu-notice--loading': true
    }, className)
  }, innerProps), children);
};
LoadingMessage.defaultProps = {
  children: 'Loading...'
};

// ==============================
// Menu Portal
// ==============================

var menuPortalCSS = function menuPortalCSS(_ref7) {
  var rect = _ref7.rect,
    offset = _ref7.offset,
    position = _ref7.position;
  return {
    left: rect.left,
    position: position,
    top: offset,
    width: rect.width,
    zIndex: 1
  };
};
var MenuPortal = function MenuPortal(_ref8) {
  var appendTo = _ref8.appendTo,
    children = _ref8.children,
    className = _ref8.className,
    controlElement = _ref8.controlElement,
    cx = _ref8.cx,
    innerProps = _ref8.innerProps,
    menuPlacement = _ref8.menuPlacement,
    menuPosition = _ref8.menuPosition,
    getStyles = _ref8.getStyles;
  var menuPortalRef = react.exports.useRef(null);
  var cleanupRef = react.exports.useRef(null);
  var _useState5 = react.exports.useState(coercePlacement(menuPlacement)),
    _useState6 = _slicedToArray(_useState5, 2),
    placement = _useState6[0],
    setPortalPlacement = _useState6[1];
  var portalPlacementContext = react.exports.useMemo(function () {
    return {
      setPortalPlacement: setPortalPlacement
    };
  }, []);
  var _useState7 = react.exports.useState(null),
    _useState8 = _slicedToArray(_useState7, 2),
    computedPosition = _useState8[0],
    setComputedPosition = _useState8[1];
  var updateComputedPosition = react.exports.useCallback(function () {
    if (!controlElement) return;
    var rect = getBoundingClientObj(controlElement);
    var scrollDistance = menuPosition === 'fixed' ? 0 : window.pageYOffset;
    var offset = rect[placement] + scrollDistance;
    if (offset !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset) || rect.left !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left) || rect.width !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width)) {
      setComputedPosition({
        offset: offset,
        rect: rect
      });
    }
  }, [controlElement, menuPosition, placement, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width]);
  index(function () {
    updateComputedPosition();
  }, [updateComputedPosition]);
  var runAutoUpdate = react.exports.useCallback(function () {
    if (typeof cleanupRef.current === 'function') {
      cleanupRef.current();
      cleanupRef.current = null;
    }
    if (controlElement && menuPortalRef.current) {
      cleanupRef.current = autoUpdate(controlElement, menuPortalRef.current, updateComputedPosition, {
        elementResize: 'ResizeObserver' in window
      });
    }
  }, [controlElement, updateComputedPosition]);
  index(function () {
    runAutoUpdate();
  }, [runAutoUpdate]);
  var setMenuPortalElement = react.exports.useCallback(function (menuPortalElement) {
    menuPortalRef.current = menuPortalElement;
    runAutoUpdate();
  }, [runAutoUpdate]);

  // bail early if required elements aren't present
  if (!appendTo && menuPosition !== 'fixed' || !computedPosition) return null;

  // same wrapper element whether fixed or portalled
  var menuWrapper = jsx("div", _extends$2({
    ref: setMenuPortalElement,
    css: getStyles('menuPortal', {
      offset: computedPosition.offset,
      position: menuPosition,
      rect: computedPosition.rect
    }),
    className: cx({
      'menu-portal': true
    }, className)
  }, innerProps), children);
  return jsx(PortalPlacementContext.Provider, {
    value: portalPlacementContext
  }, appendTo ? /*#__PURE__*/reactDom.exports.createPortal(menuWrapper, appendTo) : menuWrapper);
};

var containerCSS = function containerCSS(_ref) {
  var isDisabled = _ref.isDisabled,
    isRtl = _ref.isRtl;
  return {
    label: 'container',
    direction: isRtl ? 'rtl' : undefined,
    pointerEvents: isDisabled ? 'none' : undefined,
    // cancel mouse events when disabled
    position: 'relative'
  };
};
var SelectContainer = function SelectContainer(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps,
    isDisabled = props.isDisabled,
    isRtl = props.isRtl;
  return jsx("div", _extends$2({
    css: getStyles('container', props),
    className: cx({
      '--is-disabled': isDisabled,
      '--is-rtl': isRtl
    }, className)
  }, innerProps), children);
};

// ==============================
// Value Container
// ==============================

var valueContainerCSS = function valueContainerCSS(_ref2) {
  var spacing = _ref2.theme.spacing,
    isMulti = _ref2.isMulti,
    hasValue = _ref2.hasValue,
    controlShouldRenderValue = _ref2.selectProps.controlShouldRenderValue;
  return {
    alignItems: 'center',
    display: isMulti && hasValue && controlShouldRenderValue ? 'flex' : 'grid',
    flex: 1,
    flexWrap: 'wrap',
    padding: "".concat(spacing.baseUnit / 2, "px ").concat(spacing.baseUnit * 2, "px"),
    WebkitOverflowScrolling: 'touch',
    position: 'relative',
    overflow: 'hidden'
  };
};
var ValueContainer = function ValueContainer(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    innerProps = props.innerProps,
    isMulti = props.isMulti,
    getStyles = props.getStyles,
    hasValue = props.hasValue;
  return jsx("div", _extends$2({
    css: getStyles('valueContainer', props),
    className: cx({
      'value-container': true,
      'value-container--is-multi': isMulti,
      'value-container--has-value': hasValue
    }, className)
  }, innerProps), children);
};

// ==============================
// Indicator Container
// ==============================

var indicatorsContainerCSS = function indicatorsContainerCSS() {
  return {
    alignItems: 'center',
    alignSelf: 'stretch',
    display: 'flex',
    flexShrink: 0
  };
};
var IndicatorsContainer = function IndicatorsContainer(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    innerProps = props.innerProps,
    getStyles = props.getStyles;
  return jsx("div", _extends$2({
    css: getStyles('indicatorsContainer', props),
    className: cx({
      indicators: true
    }, className)
  }, innerProps), children);
};

var _templateObject;
var _excluded$2 = ["size"];
var _ref2$2 = {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
} ;
// ==============================
// Dropdown & Clear Icons
// ==============================

var Svg = function Svg(_ref) {
  var size = _ref.size,
    props = _objectWithoutProperties(_ref, _excluded$2);
  return jsx("svg", _extends$2({
    height: size,
    width: size,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: _ref2$2
  }, props));
};
var CrossIcon = function CrossIcon(props) {
  return jsx(Svg, _extends$2({
    size: 20
  }, props), jsx("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
};
var DownChevron = function DownChevron(props) {
  return jsx(Svg, _extends$2({
    size: 20
  }, props), jsx("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
};

// ==============================
// Dropdown & Clear Buttons
// ==============================

var baseCSS = function baseCSS(_ref3) {
  var isFocused = _ref3.isFocused,
    _ref3$theme = _ref3.theme,
    baseUnit = _ref3$theme.spacing.baseUnit,
    colors = _ref3$theme.colors;
  return {
    label: 'indicatorContainer',
    color: isFocused ? colors.neutral60 : colors.neutral20,
    display: 'flex',
    padding: baseUnit * 2,
    transition: 'color 150ms',
    ':hover': {
      color: isFocused ? colors.neutral80 : colors.neutral40
    }
  };
};
var dropdownIndicatorCSS = baseCSS;
var DropdownIndicator = function DropdownIndicator(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps;
  return jsx("div", _extends$2({
    css: getStyles('dropdownIndicator', props),
    className: cx({
      indicator: true,
      'dropdown-indicator': true
    }, className)
  }, innerProps), children || jsx(DownChevron, null));
};
var clearIndicatorCSS = baseCSS;
var ClearIndicator = function ClearIndicator(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps;
  return jsx("div", _extends$2({
    css: getStyles('clearIndicator', props),
    className: cx({
      indicator: true,
      'clear-indicator': true
    }, className)
  }, innerProps), children || jsx(CrossIcon, null));
};

// ==============================
// Separator
// ==============================

var indicatorSeparatorCSS = function indicatorSeparatorCSS(_ref4) {
  var isDisabled = _ref4.isDisabled,
    _ref4$theme = _ref4.theme,
    baseUnit = _ref4$theme.spacing.baseUnit,
    colors = _ref4$theme.colors;
  return {
    label: 'indicatorSeparator',
    alignSelf: 'stretch',
    backgroundColor: isDisabled ? colors.neutral10 : colors.neutral20,
    marginBottom: baseUnit * 2,
    marginTop: baseUnit * 2,
    width: 1
  };
};
var IndicatorSeparator = function IndicatorSeparator(props) {
  var className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps;
  return jsx("span", _extends$2({}, innerProps, {
    css: getStyles('indicatorSeparator', props),
    className: cx({
      'indicator-separator': true
    }, className)
  }));
};

// ==============================
// Loading
// ==============================

var loadingDotAnimations = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"])));
var loadingIndicatorCSS = function loadingIndicatorCSS(_ref5) {
  var isFocused = _ref5.isFocused,
    size = _ref5.size,
    _ref5$theme = _ref5.theme,
    colors = _ref5$theme.colors,
    baseUnit = _ref5$theme.spacing.baseUnit;
  return {
    label: 'loadingIndicator',
    color: isFocused ? colors.neutral60 : colors.neutral20,
    display: 'flex',
    padding: baseUnit * 2,
    transition: 'color 150ms',
    alignSelf: 'center',
    fontSize: size,
    lineHeight: 1,
    marginRight: size,
    textAlign: 'center',
    verticalAlign: 'middle'
  };
};
var LoadingDot = function LoadingDot(_ref6) {
  var delay = _ref6.delay,
    offset = _ref6.offset;
  return jsx("span", {
    css: /*#__PURE__*/css$2({
      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay, "ms infinite;"),
      backgroundColor: 'currentColor',
      borderRadius: '1em',
      display: 'inline-block',
      marginLeft: offset ? '1em' : undefined,
      height: '1em',
      verticalAlign: 'top',
      width: '1em'
    }, "" , "" )
  });
};
var LoadingIndicator = function LoadingIndicator(props) {
  var className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps,
    isRtl = props.isRtl;
  return jsx("div", _extends$2({
    css: getStyles('loadingIndicator', props),
    className: cx({
      indicator: true,
      'loading-indicator': true
    }, className)
  }, innerProps), jsx(LoadingDot, {
    delay: 0,
    offset: isRtl
  }), jsx(LoadingDot, {
    delay: 160,
    offset: true
  }), jsx(LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
};
LoadingIndicator.defaultProps = {
  size: 4
};

var css$1 = function css(_ref) {
  var isDisabled = _ref.isDisabled,
    isFocused = _ref.isFocused,
    _ref$theme = _ref.theme,
    colors = _ref$theme.colors,
    borderRadius = _ref$theme.borderRadius,
    spacing = _ref$theme.spacing;
  return {
    label: 'control',
    alignItems: 'center',
    backgroundColor: isDisabled ? colors.neutral5 : colors.neutral0,
    borderColor: isDisabled ? colors.neutral10 : isFocused ? colors.primary : colors.neutral20,
    borderRadius: borderRadius,
    borderStyle: 'solid',
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px ".concat(colors.primary) : undefined,
    cursor: 'default',
    display: 'flex',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    minHeight: spacing.controlHeight,
    outline: '0 !important',
    position: 'relative',
    transition: 'all 100ms',
    '&:hover': {
      borderColor: isFocused ? colors.primary : colors.neutral30
    }
  };
};
var Control = function Control(props) {
  var children = props.children,
    cx = props.cx,
    getStyles = props.getStyles,
    className = props.className,
    isDisabled = props.isDisabled,
    isFocused = props.isFocused,
    innerRef = props.innerRef,
    innerProps = props.innerProps,
    menuIsOpen = props.menuIsOpen;
  return jsx("div", _extends$2({
    ref: innerRef,
    css: getStyles('control', props),
    className: cx({
      control: true,
      'control--is-disabled': isDisabled,
      'control--is-focused': isFocused,
      'control--menu-is-open': menuIsOpen
    }, className)
  }, innerProps), children);
};

var _excluded$1 = ["data"];
var groupCSS = function groupCSS(_ref) {
  var spacing = _ref.theme.spacing;
  return {
    paddingBottom: spacing.baseUnit * 2,
    paddingTop: spacing.baseUnit * 2
  };
};
var Group = function Group(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    Heading = props.Heading,
    headingProps = props.headingProps,
    innerProps = props.innerProps,
    label = props.label,
    theme = props.theme,
    selectProps = props.selectProps;
  return jsx("div", _extends$2({
    css: getStyles('group', props),
    className: cx({
      group: true
    }, className)
  }, innerProps), jsx(Heading, _extends$2({}, headingProps, {
    selectProps: selectProps,
    theme: theme,
    getStyles: getStyles,
    cx: cx
  }), label), jsx("div", null, children));
};
var groupHeadingCSS = function groupHeadingCSS(_ref2) {
  var spacing = _ref2.theme.spacing;
  return {
    label: 'group',
    color: '#999',
    cursor: 'default',
    display: 'block',
    fontSize: '75%',
    fontWeight: 500,
    marginBottom: '0.25em',
    paddingLeft: spacing.baseUnit * 3,
    paddingRight: spacing.baseUnit * 3,
    textTransform: 'uppercase'
  };
};
var GroupHeading = function GroupHeading(props) {
  var getStyles = props.getStyles,
    cx = props.cx,
    className = props.className;
  var _cleanCommonProps = cleanCommonProps(props);
    _cleanCommonProps.data;
    var innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$1);
  return jsx("div", _extends$2({
    css: getStyles('groupHeading', props),
    className: cx({
      'group-heading': true
    }, className)
  }, innerProps));
};

var _excluded$4 = ["innerRef", "isDisabled", "isHidden", "inputClassName"];
var inputCSS = function inputCSS(_ref) {
  var isDisabled = _ref.isDisabled,
    value = _ref.value,
    _ref$theme = _ref.theme,
    spacing = _ref$theme.spacing,
    colors = _ref$theme.colors;
  return _objectSpread2$1({
    margin: spacing.baseUnit / 2,
    paddingBottom: spacing.baseUnit / 2,
    paddingTop: spacing.baseUnit / 2,
    visibility: isDisabled ? 'hidden' : 'visible',
    color: colors.neutral80,
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: value ? 'translateZ(0)' : ''
  }, containerStyle);
};
var spacingStyle = {
  gridArea: '1 / 2',
  font: 'inherit',
  minWidth: '2px',
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
};
var containerStyle = {
  flex: '1 1 auto',
  display: 'inline-grid',
  gridArea: '1 / 1 / 2 / 3',
  gridTemplateColumns: '0 min-content',
  '&:after': _objectSpread2$1({
    content: 'attr(data-value) " "',
    visibility: 'hidden',
    whiteSpace: 'pre'
  }, spacingStyle)
};
var inputStyle = function inputStyle(isHidden) {
  return _objectSpread2$1({
    label: 'input',
    color: 'inherit',
    background: 0,
    opacity: isHidden ? 0 : 1,
    width: '100%'
  }, spacingStyle);
};
var Input = function Input(props) {
  var className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    value = props.value;
  var _cleanCommonProps = cleanCommonProps(props),
    innerRef = _cleanCommonProps.innerRef,
    isDisabled = _cleanCommonProps.isDisabled,
    isHidden = _cleanCommonProps.isHidden,
    inputClassName = _cleanCommonProps.inputClassName,
    innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$4);
  return jsx("div", {
    className: cx({
      'input-container': true
    }, className),
    css: getStyles('input', props),
    "data-value": value || ''
  }, jsx("input", _extends$2({
    className: cx({
      input: true
    }, inputClassName),
    ref: innerRef,
    style: inputStyle(isHidden),
    disabled: isDisabled
  }, innerProps)));
};

var multiValueCSS = function multiValueCSS(_ref) {
  var _ref$theme = _ref.theme,
    spacing = _ref$theme.spacing,
    borderRadius = _ref$theme.borderRadius,
    colors = _ref$theme.colors;
  return {
    label: 'multiValue',
    backgroundColor: colors.neutral10,
    borderRadius: borderRadius / 2,
    display: 'flex',
    margin: spacing.baseUnit / 2,
    minWidth: 0 // resolves flex/text-overflow bug
  };
};

var multiValueLabelCSS = function multiValueLabelCSS(_ref2) {
  var _ref2$theme = _ref2.theme,
    borderRadius = _ref2$theme.borderRadius,
    colors = _ref2$theme.colors,
    cropWithEllipsis = _ref2.cropWithEllipsis;
  return {
    borderRadius: borderRadius / 2,
    color: colors.neutral80,
    fontSize: '85%',
    overflow: 'hidden',
    padding: 3,
    paddingLeft: 6,
    textOverflow: cropWithEllipsis || cropWithEllipsis === undefined ? 'ellipsis' : undefined,
    whiteSpace: 'nowrap'
  };
};
var multiValueRemoveCSS = function multiValueRemoveCSS(_ref3) {
  var _ref3$theme = _ref3.theme,
    spacing = _ref3$theme.spacing,
    borderRadius = _ref3$theme.borderRadius,
    colors = _ref3$theme.colors,
    isFocused = _ref3.isFocused;
  return {
    alignItems: 'center',
    borderRadius: borderRadius / 2,
    backgroundColor: isFocused ? colors.dangerLight : undefined,
    display: 'flex',
    paddingLeft: spacing.baseUnit,
    paddingRight: spacing.baseUnit,
    ':hover': {
      backgroundColor: colors.dangerLight,
      color: colors.danger
    }
  };
};
var MultiValueGeneric = function MultiValueGeneric(_ref4) {
  var children = _ref4.children,
    innerProps = _ref4.innerProps;
  return jsx("div", innerProps, children);
};
var MultiValueContainer = MultiValueGeneric;
var MultiValueLabel = MultiValueGeneric;
function MultiValueRemove(_ref5) {
  var children = _ref5.children,
    innerProps = _ref5.innerProps;
  return jsx("div", _extends$2({
    role: "button"
  }, innerProps), children || jsx(CrossIcon, {
    size: 14
  }));
}
var MultiValue = function MultiValue(props) {
  var children = props.children,
    className = props.className,
    components = props.components,
    cx = props.cx,
    data = props.data,
    getStyles = props.getStyles,
    innerProps = props.innerProps,
    isDisabled = props.isDisabled,
    removeProps = props.removeProps,
    selectProps = props.selectProps;
  var Container = components.Container,
    Label = components.Label,
    Remove = components.Remove;
  return jsx(ClassNames, null, function (_ref6) {
    var css = _ref6.css,
      emotionCx = _ref6.cx;
    return jsx(Container, {
      data: data,
      innerProps: _objectSpread2$1({
        className: emotionCx(css(getStyles('multiValue', props)), cx({
          'multi-value': true,
          'multi-value--is-disabled': isDisabled
        }, className))
      }, innerProps),
      selectProps: selectProps
    }, jsx(Label, {
      data: data,
      innerProps: {
        className: emotionCx(css(getStyles('multiValueLabel', props)), cx({
          'multi-value__label': true
        }, className))
      },
      selectProps: selectProps
    }, children), jsx(Remove, {
      data: data,
      innerProps: _objectSpread2$1({
        className: emotionCx(css(getStyles('multiValueRemove', props)), cx({
          'multi-value__remove': true
        }, className)),
        'aria-label': "Remove ".concat(children || 'option')
      }, removeProps),
      selectProps: selectProps
    }));
  });
};

var optionCSS = function optionCSS(_ref) {
  var isDisabled = _ref.isDisabled,
    isFocused = _ref.isFocused,
    isSelected = _ref.isSelected,
    _ref$theme = _ref.theme,
    spacing = _ref$theme.spacing,
    colors = _ref$theme.colors;
  return {
    label: 'option',
    backgroundColor: isSelected ? colors.primary : isFocused ? colors.primary25 : 'transparent',
    color: isDisabled ? colors.neutral20 : isSelected ? colors.neutral0 : 'inherit',
    cursor: 'default',
    display: 'block',
    fontSize: 'inherit',
    padding: "".concat(spacing.baseUnit * 2, "px ").concat(spacing.baseUnit * 3, "px"),
    width: '100%',
    userSelect: 'none',
    WebkitTapHighlightColor: 'rgba(0, 0, 0, 0)',
    // provide some affordance on touch devices
    ':active': {
      backgroundColor: !isDisabled ? isSelected ? colors.primary : colors.primary50 : undefined
    }
  };
};
var Option = function Option(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    isDisabled = props.isDisabled,
    isFocused = props.isFocused,
    isSelected = props.isSelected,
    innerRef = props.innerRef,
    innerProps = props.innerProps;
  return jsx("div", _extends$2({
    css: getStyles('option', props),
    className: cx({
      option: true,
      'option--is-disabled': isDisabled,
      'option--is-focused': isFocused,
      'option--is-selected': isSelected
    }, className),
    ref: innerRef,
    "aria-disabled": isDisabled
  }, innerProps), children);
};

var placeholderCSS = function placeholderCSS(_ref) {
  var _ref$theme = _ref.theme,
    spacing = _ref$theme.spacing,
    colors = _ref$theme.colors;
  return {
    label: 'placeholder',
    color: colors.neutral50,
    gridArea: '1 / 1 / 2 / 3',
    marginLeft: spacing.baseUnit / 2,
    marginRight: spacing.baseUnit / 2
  };
};
var Placeholder = function Placeholder(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    innerProps = props.innerProps;
  return jsx("div", _extends$2({
    css: getStyles('placeholder', props),
    className: cx({
      placeholder: true
    }, className)
  }, innerProps), children);
};

var css = function css(_ref) {
  var isDisabled = _ref.isDisabled,
    _ref$theme = _ref.theme,
    spacing = _ref$theme.spacing,
    colors = _ref$theme.colors;
  return {
    label: 'singleValue',
    color: isDisabled ? colors.neutral40 : colors.neutral80,
    gridArea: '1 / 1 / 2 / 3',
    marginLeft: spacing.baseUnit / 2,
    marginRight: spacing.baseUnit / 2,
    maxWidth: '100%',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap'
  };
};
var SingleValue = function SingleValue(props) {
  var children = props.children,
    className = props.className,
    cx = props.cx,
    getStyles = props.getStyles,
    isDisabled = props.isDisabled,
    innerProps = props.innerProps;
  return jsx("div", _extends$2({
    css: getStyles('singleValue', props),
    className: cx({
      'single-value': true,
      'single-value--is-disabled': isDisabled
    }, className)
  }, innerProps), children);
};

var components = {
  ClearIndicator: ClearIndicator,
  Control: Control,
  DropdownIndicator: DropdownIndicator,
  DownChevron: DownChevron,
  CrossIcon: CrossIcon,
  Group: Group,
  GroupHeading: GroupHeading,
  IndicatorsContainer: IndicatorsContainer,
  IndicatorSeparator: IndicatorSeparator,
  Input: Input,
  LoadingIndicator: LoadingIndicator,
  Menu: Menu,
  MenuList: MenuList,
  MenuPortal: MenuPortal,
  LoadingMessage: LoadingMessage,
  NoOptionsMessage: NoOptionsMessage,
  MultiValue: MultiValue,
  MultiValueContainer: MultiValueContainer,
  MultiValueLabel: MultiValueLabel,
  MultiValueRemove: MultiValueRemove,
  Option: Option,
  Placeholder: Placeholder,
  SelectContainer: SelectContainer,
  SingleValue: SingleValue,
  ValueContainer: ValueContainer
};
var defaultComponents = function defaultComponents(props) {
  return _objectSpread2$1(_objectSpread2$1({}, components), props.components);
};

var safeIsNaN = Number.isNaN ||
    function ponyfill(value) {
        return typeof value === 'number' && value !== value;
    };
function isEqual(first, second) {
    if (first === second) {
        return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
        return true;
    }
    return false;
}
function areInputsEqual(newInputs, lastInputs) {
    if (newInputs.length !== lastInputs.length) {
        return false;
    }
    for (var i = 0; i < newInputs.length; i++) {
        if (!isEqual(newInputs[i], lastInputs[i])) {
            return false;
        }
    }
    return true;
}

function memoizeOne(resultFn, isEqual) {
    if (isEqual === void 0) { isEqual = areInputsEqual; }
    var cache = null;
    function memoized() {
        var newArgs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newArgs[_i] = arguments[_i];
        }
        if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {
            return cache.lastResult;
        }
        var lastResult = resultFn.apply(this, newArgs);
        cache = {
            lastResult: lastResult,
            lastArgs: newArgs,
            lastThis: this,
        };
        return lastResult;
    }
    memoized.clear = function clear() {
        cache = null;
    };
    return memoized;
}

// Assistive text to describe visual elements. Hidden for sighted users.
var _ref = {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
} ;
var A11yText = function A11yText(props) {
  return jsx("span", _extends$2({
    css: _ref
  }, props));
};
var defaultAriaLiveMessages = {
  guidance: function guidance(props) {
    var isSearchable = props.isSearchable,
      isMulti = props.isMulti,
      isDisabled = props.isDisabled,
      tabSelectsValue = props.tabSelectsValue,
      context = props.context;
    switch (context) {
      case 'menu':
        return "Use Up and Down to choose options".concat(isDisabled ? '' : ', press Enter to select the currently focused option', ", press Escape to exit the menu").concat(tabSelectsValue ? ', press Tab to select the option and exit the menu' : '', ".");
      case 'input':
        return "".concat(props['aria-label'] || 'Select', " is focused ").concat(isSearchable ? ',type to refine list' : '', ", press Down to open the menu, ").concat(isMulti ? ' press left to focus selected values' : '');
      case 'value':
        return 'Use left and right to toggle between focused values, press Backspace to remove the currently focused value';
      default:
        return '';
    }
  },
  onChange: function onChange(props) {
    var action = props.action,
      _props$label = props.label,
      label = _props$label === void 0 ? '' : _props$label,
      labels = props.labels,
      isDisabled = props.isDisabled;
    switch (action) {
      case 'deselect-option':
      case 'pop-value':
      case 'remove-value':
        return "option ".concat(label, ", deselected.");
      case 'clear':
        return 'All selected options have been cleared.';
      case 'initial-input-focus':
        return "option".concat(labels.length > 1 ? 's' : '', " ").concat(labels.join(','), ", selected.");
      case 'select-option':
        return isDisabled ? "option ".concat(label, " is disabled. Select another option.") : "option ".concat(label, ", selected.");
      default:
        return '';
    }
  },
  onFocus: function onFocus(props) {
    var context = props.context,
      focused = props.focused,
      options = props.options,
      _props$label2 = props.label,
      label = _props$label2 === void 0 ? '' : _props$label2,
      selectValue = props.selectValue,
      isDisabled = props.isDisabled,
      isSelected = props.isSelected;
    var getArrayIndex = function getArrayIndex(arr, item) {
      return arr && arr.length ? "".concat(arr.indexOf(item) + 1, " of ").concat(arr.length) : '';
    };
    if (context === 'value' && selectValue) {
      return "value ".concat(label, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
    }
    if (context === 'menu') {
      var disabled = isDisabled ? ' disabled' : '';
      var status = "".concat(isSelected ? 'selected' : 'focused').concat(disabled);
      return "option ".concat(label, " ").concat(status, ", ").concat(getArrayIndex(options, focused), ".");
    }
    return '';
  },
  onFilter: function onFilter(props) {
    var inputValue = props.inputValue,
      resultsMessage = props.resultsMessage;
    return "".concat(resultsMessage).concat(inputValue ? ' for search term ' + inputValue : '', ".");
  }
};
var LiveRegion = function LiveRegion(props) {
  var ariaSelection = props.ariaSelection,
    focusedOption = props.focusedOption,
    focusedValue = props.focusedValue,
    focusableOptions = props.focusableOptions,
    isFocused = props.isFocused,
    selectValue = props.selectValue,
    selectProps = props.selectProps,
    id = props.id;
  var ariaLiveMessages = selectProps.ariaLiveMessages,
    getOptionLabel = selectProps.getOptionLabel,
    inputValue = selectProps.inputValue,
    isMulti = selectProps.isMulti,
    isOptionDisabled = selectProps.isOptionDisabled,
    isSearchable = selectProps.isSearchable,
    menuIsOpen = selectProps.menuIsOpen,
    options = selectProps.options,
    screenReaderStatus = selectProps.screenReaderStatus,
    tabSelectsValue = selectProps.tabSelectsValue;
  var ariaLabel = selectProps['aria-label'];
  var ariaLive = selectProps['aria-live'];

  // Update aria live message configuration when prop changes
  var messages = react.exports.useMemo(function () {
    return _objectSpread2$1(_objectSpread2$1({}, defaultAriaLiveMessages), ariaLiveMessages || {});
  }, [ariaLiveMessages]);

  // Update aria live selected option when prop changes
  var ariaSelected = react.exports.useMemo(function () {
    var message = '';
    if (ariaSelection && messages.onChange) {
      var option = ariaSelection.option,
        selectedOptions = ariaSelection.options,
        removedValue = ariaSelection.removedValue,
        removedValues = ariaSelection.removedValues,
        value = ariaSelection.value;
      // select-option when !isMulti does not return option so we assume selected option is value
      var asOption = function asOption(val) {
        return !Array.isArray(val) ? val : null;
      };

      // If there is just one item from the action then get its label
      var selected = removedValue || option || asOption(value);
      var label = selected ? getOptionLabel(selected) : '';

      // If there are multiple items from the action then return an array of labels
      var multiSelected = selectedOptions || removedValues || undefined;
      var labels = multiSelected ? multiSelected.map(getOptionLabel) : [];
      var onChangeProps = _objectSpread2$1({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: selected && isOptionDisabled(selected, selectValue),
        label: label,
        labels: labels
      }, ariaSelection);
      message = messages.onChange(onChangeProps);
    }
    return message;
  }, [ariaSelection, messages, isOptionDisabled, selectValue, getOptionLabel]);
  var ariaFocused = react.exports.useMemo(function () {
    var focusMsg = '';
    var focused = focusedOption || focusedValue;
    var isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));
    if (focused && messages.onFocus) {
      var onFocusProps = {
        focused: focused,
        label: getOptionLabel(focused),
        isDisabled: isOptionDisabled(focused, selectValue),
        isSelected: isSelected,
        options: focusableOptions,
        context: focused === focusedOption ? 'menu' : 'value',
        selectValue: selectValue
      };
      focusMsg = messages.onFocus(onFocusProps);
    }
    return focusMsg;
  }, [focusedOption, focusedValue, getOptionLabel, isOptionDisabled, messages, focusableOptions, selectValue]);
  var ariaResults = react.exports.useMemo(function () {
    var resultsMsg = '';
    if (menuIsOpen && options.length && messages.onFilter) {
      var resultsMessage = screenReaderStatus({
        count: focusableOptions.length
      });
      resultsMsg = messages.onFilter({
        inputValue: inputValue,
        resultsMessage: resultsMessage
      });
    }
    return resultsMsg;
  }, [focusableOptions, inputValue, menuIsOpen, messages, options, screenReaderStatus]);
  var ariaGuidance = react.exports.useMemo(function () {
    var guidanceMsg = '';
    if (messages.guidance) {
      var context = focusedValue ? 'value' : menuIsOpen ? 'menu' : 'input';
      guidanceMsg = messages.guidance({
        'aria-label': ariaLabel,
        context: context,
        isDisabled: focusedOption && isOptionDisabled(focusedOption, selectValue),
        isMulti: isMulti,
        isSearchable: isSearchable,
        tabSelectsValue: tabSelectsValue
      });
    }
    return guidanceMsg;
  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled, isSearchable, menuIsOpen, messages, selectValue, tabSelectsValue]);
  var ariaContext = "".concat(ariaFocused, " ").concat(ariaResults, " ").concat(ariaGuidance);
  var ScreenReaderText = jsx(react.exports.Fragment, null, jsx("span", {
    id: "aria-selection"
  }, ariaSelected), jsx("span", {
    id: "aria-context"
  }, ariaContext));
  var isInitialFocus = (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === 'initial-input-focus';
  return jsx(react.exports.Fragment, null, jsx(A11yText, {
    id: id
  }, isInitialFocus && ScreenReaderText), jsx(A11yText, {
    "aria-live": ariaLive,
    "aria-atomic": "false",
    "aria-relevant": "additions text"
  }, isFocused && !isInitialFocus && ScreenReaderText));
};
var diacritics = [{
  base: 'A',
  letters: "A\u24B6\uFF21\xC0\xC1\xC2\u1EA6\u1EA4\u1EAA\u1EA8\xC3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\xC4\u01DE\u1EA2\xC5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F"
}, {
  base: 'AA',
  letters: "\uA732"
}, {
  base: 'AE',
  letters: "\xC6\u01FC\u01E2"
}, {
  base: 'AO',
  letters: "\uA734"
}, {
  base: 'AU',
  letters: "\uA736"
}, {
  base: 'AV',
  letters: "\uA738\uA73A"
}, {
  base: 'AY',
  letters: "\uA73C"
}, {
  base: 'B',
  letters: "B\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181"
}, {
  base: 'C',
  letters: "C\u24B8\uFF23\u0106\u0108\u010A\u010C\xC7\u1E08\u0187\u023B\uA73E"
}, {
  base: 'D',
  letters: "D\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779"
}, {
  base: 'DZ',
  letters: "\u01F1\u01C4"
}, {
  base: 'Dz',
  letters: "\u01F2\u01C5"
}, {
  base: 'E',
  letters: "E\u24BA\uFF25\xC8\xC9\xCA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\xCB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E"
}, {
  base: 'F',
  letters: "F\u24BB\uFF26\u1E1E\u0191\uA77B"
}, {
  base: 'G',
  letters: "G\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E"
}, {
  base: 'H',
  letters: "H\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D"
}, {
  base: 'I',
  letters: "I\u24BE\uFF29\xCC\xCD\xCE\u0128\u012A\u012C\u0130\xCF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197"
}, {
  base: 'J',
  letters: "J\u24BF\uFF2A\u0134\u0248"
}, {
  base: 'K',
  letters: "K\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2"
}, {
  base: 'L',
  letters: "L\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780"
}, {
  base: 'LJ',
  letters: "\u01C7"
}, {
  base: 'Lj',
  letters: "\u01C8"
}, {
  base: 'M',
  letters: "M\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C"
}, {
  base: 'N',
  letters: "N\u24C3\uFF2E\u01F8\u0143\xD1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4"
}, {
  base: 'NJ',
  letters: "\u01CA"
}, {
  base: 'Nj',
  letters: "\u01CB"
}, {
  base: 'O',
  letters: "O\u24C4\uFF2F\xD2\xD3\xD4\u1ED2\u1ED0\u1ED6\u1ED4\xD5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\xD6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\xD8\u01FE\u0186\u019F\uA74A\uA74C"
}, {
  base: 'OI',
  letters: "\u01A2"
}, {
  base: 'OO',
  letters: "\uA74E"
}, {
  base: 'OU',
  letters: "\u0222"
}, {
  base: 'P',
  letters: "P\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754"
}, {
  base: 'Q',
  letters: "Q\u24C6\uFF31\uA756\uA758\u024A"
}, {
  base: 'R',
  letters: "R\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782"
}, {
  base: 'S',
  letters: "S\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784"
}, {
  base: 'T',
  letters: "T\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786"
}, {
  base: 'TZ',
  letters: "\uA728"
}, {
  base: 'U',
  letters: "U\u24CA\uFF35\xD9\xDA\xDB\u0168\u1E78\u016A\u1E7A\u016C\xDC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244"
}, {
  base: 'V',
  letters: "V\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245"
}, {
  base: 'VY',
  letters: "\uA760"
}, {
  base: 'W',
  letters: "W\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72"
}, {
  base: 'X',
  letters: "X\u24CD\uFF38\u1E8A\u1E8C"
}, {
  base: 'Y',
  letters: "Y\u24CE\uFF39\u1EF2\xDD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE"
}, {
  base: 'Z',
  letters: "Z\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762"
}, {
  base: 'a',
  letters: "a\u24D0\uFF41\u1E9A\xE0\xE1\xE2\u1EA7\u1EA5\u1EAB\u1EA9\xE3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\xE4\u01DF\u1EA3\xE5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250"
}, {
  base: 'aa',
  letters: "\uA733"
}, {
  base: 'ae',
  letters: "\xE6\u01FD\u01E3"
}, {
  base: 'ao',
  letters: "\uA735"
}, {
  base: 'au',
  letters: "\uA737"
}, {
  base: 'av',
  letters: "\uA739\uA73B"
}, {
  base: 'ay',
  letters: "\uA73D"
}, {
  base: 'b',
  letters: "b\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253"
}, {
  base: 'c',
  letters: "c\u24D2\uFF43\u0107\u0109\u010B\u010D\xE7\u1E09\u0188\u023C\uA73F\u2184"
}, {
  base: 'd',
  letters: "d\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A"
}, {
  base: 'dz',
  letters: "\u01F3\u01C6"
}, {
  base: 'e',
  letters: "e\u24D4\uFF45\xE8\xE9\xEA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\xEB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD"
}, {
  base: 'f',
  letters: "f\u24D5\uFF46\u1E1F\u0192\uA77C"
}, {
  base: 'g',
  letters: "g\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F"
}, {
  base: 'h',
  letters: "h\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265"
}, {
  base: 'hv',
  letters: "\u0195"
}, {
  base: 'i',
  letters: "i\u24D8\uFF49\xEC\xED\xEE\u0129\u012B\u012D\xEF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131"
}, {
  base: 'j',
  letters: "j\u24D9\uFF4A\u0135\u01F0\u0249"
}, {
  base: 'k',
  letters: "k\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3"
}, {
  base: 'l',
  letters: "l\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747"
}, {
  base: 'lj',
  letters: "\u01C9"
}, {
  base: 'm',
  letters: "m\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F"
}, {
  base: 'n',
  letters: "n\u24DD\uFF4E\u01F9\u0144\xF1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5"
}, {
  base: 'nj',
  letters: "\u01CC"
}, {
  base: 'o',
  letters: "o\u24DE\uFF4F\xF2\xF3\xF4\u1ED3\u1ED1\u1ED7\u1ED5\xF5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\xF6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\xF8\u01FF\u0254\uA74B\uA74D\u0275"
}, {
  base: 'oi',
  letters: "\u01A3"
}, {
  base: 'ou',
  letters: "\u0223"
}, {
  base: 'oo',
  letters: "\uA74F"
}, {
  base: 'p',
  letters: "p\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755"
}, {
  base: 'q',
  letters: "q\u24E0\uFF51\u024B\uA757\uA759"
}, {
  base: 'r',
  letters: "r\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783"
}, {
  base: 's',
  letters: "s\u24E2\uFF53\xDF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B"
}, {
  base: 't',
  letters: "t\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787"
}, {
  base: 'tz',
  letters: "\uA729"
}, {
  base: 'u',
  letters: "u\u24E4\uFF55\xF9\xFA\xFB\u0169\u1E79\u016B\u1E7B\u016D\xFC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289"
}, {
  base: 'v',
  letters: "v\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C"
}, {
  base: 'vy',
  letters: "\uA761"
}, {
  base: 'w',
  letters: "w\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73"
}, {
  base: 'x',
  letters: "x\u24E7\uFF58\u1E8B\u1E8D"
}, {
  base: 'y',
  letters: "y\u24E8\uFF59\u1EF3\xFD\u0177\u1EF9\u0233\u1E8F\xFF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF"
}, {
  base: 'z',
  letters: "z\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763"
}];
var anyDiacritic = new RegExp('[' + diacritics.map(function (d) {
  return d.letters;
}).join('') + ']', 'g');
var diacriticToBase = {};
for (var i = 0; i < diacritics.length; i++) {
  var diacritic = diacritics[i];
  for (var j = 0; j < diacritic.letters.length; j++) {
    diacriticToBase[diacritic.letters[j]] = diacritic.base;
  }
}
var stripDiacritics = function stripDiacritics(str) {
  return str.replace(anyDiacritic, function (match) {
    return diacriticToBase[match];
  });
};
var memoizedStripDiacriticsForInput = memoizeOne(stripDiacritics);
var trimString = function trimString(str) {
  return str.replace(/^\s+|\s+$/g, '');
};
var defaultStringify = function defaultStringify(option) {
  return "".concat(option.label, " ").concat(option.value);
};
var createFilter = function createFilter(config) {
  return function (option, rawInput) {
    // eslint-disable-next-line no-underscore-dangle
    if (option.data.__isNew__) return true;
    var _ignoreCase$ignoreAcc = _objectSpread2$1({
        ignoreCase: true,
        ignoreAccents: true,
        stringify: defaultStringify,
        trim: true,
        matchFrom: 'any'
      }, config),
      ignoreCase = _ignoreCase$ignoreAcc.ignoreCase,
      ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents,
      stringify = _ignoreCase$ignoreAcc.stringify,
      trim = _ignoreCase$ignoreAcc.trim,
      matchFrom = _ignoreCase$ignoreAcc.matchFrom;
    var input = trim ? trimString(rawInput) : rawInput;
    var candidate = trim ? trimString(stringify(option)) : stringify(option);
    if (ignoreCase) {
      input = input.toLowerCase();
      candidate = candidate.toLowerCase();
    }
    if (ignoreAccents) {
      input = memoizedStripDiacriticsForInput(input);
      candidate = stripDiacritics(candidate);
    }
    return matchFrom === 'start' ? candidate.substr(0, input.length) === input : candidate.indexOf(input) > -1;
  };
};
var _excluded = ["innerRef"];
function DummyInput(_ref) {
  var innerRef = _ref.innerRef,
    props = _objectWithoutProperties(_ref, _excluded);
  // Remove animation props not meant for HTML elements
  var filteredProps = removeProps(props, 'onExited', 'in', 'enter', 'exit', 'appear');
  return jsx("input", _extends$2({
    ref: innerRef
  }, filteredProps, {
    css: /*#__PURE__*/css$2({
      label: 'dummyInput',
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: 'transparent',
      fontSize: 'inherit',
      gridArea: '1 / 1 / 2 / 3',
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: 'transparent',
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: 'relative',
      transform: 'scale(.01)'
    }, "" , "" )
  }));
}
var cancelScroll = function cancelScroll(event) {
  event.preventDefault();
  event.stopPropagation();
};
function useScrollCapture(_ref) {
  var isEnabled = _ref.isEnabled,
    onBottomArrive = _ref.onBottomArrive,
    onBottomLeave = _ref.onBottomLeave,
    onTopArrive = _ref.onTopArrive,
    onTopLeave = _ref.onTopLeave;
  var isBottom = react.exports.useRef(false);
  var isTop = react.exports.useRef(false);
  var touchStart = react.exports.useRef(0);
  var scrollTarget = react.exports.useRef(null);
  var handleEventDelta = react.exports.useCallback(function (event, delta) {
    if (scrollTarget.current === null) return;
    var _scrollTarget$current = scrollTarget.current,
      scrollTop = _scrollTarget$current.scrollTop,
      scrollHeight = _scrollTarget$current.scrollHeight,
      clientHeight = _scrollTarget$current.clientHeight;
    var target = scrollTarget.current;
    var isDeltaPositive = delta > 0;
    var availableScroll = scrollHeight - clientHeight - scrollTop;
    var shouldCancelScroll = false;

    // reset bottom/top flags
    if (availableScroll > delta && isBottom.current) {
      if (onBottomLeave) onBottomLeave(event);
      isBottom.current = false;
    }
    if (isDeltaPositive && isTop.current) {
      if (onTopLeave) onTopLeave(event);
      isTop.current = false;
    }

    // bottom limit
    if (isDeltaPositive && delta > availableScroll) {
      if (onBottomArrive && !isBottom.current) {
        onBottomArrive(event);
      }
      target.scrollTop = scrollHeight;
      shouldCancelScroll = true;
      isBottom.current = true;

      // top limit
    } else if (!isDeltaPositive && -delta > scrollTop) {
      if (onTopArrive && !isTop.current) {
        onTopArrive(event);
      }
      target.scrollTop = 0;
      shouldCancelScroll = true;
      isTop.current = true;
    }

    // cancel scroll
    if (shouldCancelScroll) {
      cancelScroll(event);
    }
  }, [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave]);
  var onWheel = react.exports.useCallback(function (event) {
    handleEventDelta(event, event.deltaY);
  }, [handleEventDelta]);
  var onTouchStart = react.exports.useCallback(function (event) {
    // set touch start so we can calculate touchmove delta
    touchStart.current = event.changedTouches[0].clientY;
  }, []);
  var onTouchMove = react.exports.useCallback(function (event) {
    var deltaY = touchStart.current - event.changedTouches[0].clientY;
    handleEventDelta(event, deltaY);
  }, [handleEventDelta]);
  var startListening = react.exports.useCallback(function (el) {
    // bail early if no element is available to attach to
    if (!el) return;
    var notPassive = supportsPassiveEvents ? {
      passive: false
    } : false;
    el.addEventListener('wheel', onWheel, notPassive);
    el.addEventListener('touchstart', onTouchStart, notPassive);
    el.addEventListener('touchmove', onTouchMove, notPassive);
  }, [onTouchMove, onTouchStart, onWheel]);
  var stopListening = react.exports.useCallback(function (el) {
    // bail early if no element is available to detach from
    if (!el) return;
    el.removeEventListener('wheel', onWheel, false);
    el.removeEventListener('touchstart', onTouchStart, false);
    el.removeEventListener('touchmove', onTouchMove, false);
  }, [onTouchMove, onTouchStart, onWheel]);
  react.exports.useEffect(function () {
    if (!isEnabled) return;
    var element = scrollTarget.current;
    startListening(element);
    return function () {
      stopListening(element);
    };
  }, [isEnabled, startListening, stopListening]);
  return function (element) {
    scrollTarget.current = element;
  };
}
var STYLE_KEYS = ['boxSizing', 'height', 'overflow', 'paddingRight', 'position'];
var LOCK_STYLES = {
  boxSizing: 'border-box',
  // account for possible declaration `width: 100%;` on body
  overflow: 'hidden',
  position: 'relative',
  height: '100%'
};
function preventTouchMove(e) {
  e.preventDefault();
}
function allowTouchMove(e) {
  e.stopPropagation();
}
function preventInertiaScroll() {
  var top = this.scrollTop;
  var totalScroll = this.scrollHeight;
  var currentScroll = top + this.offsetHeight;
  if (top === 0) {
    this.scrollTop = 1;
  } else if (currentScroll === totalScroll) {
    this.scrollTop = top - 1;
  }
}

// `ontouchstart` check works on most browsers
// `maxTouchPoints` works on IE10/11 and Surface
function isTouchDevice() {
  return 'ontouchstart' in window || navigator.maxTouchPoints;
}
var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
var activeScrollLocks = 0;
var listenerOptions = {
  capture: false,
  passive: false
};
function useScrollLock(_ref) {
  var isEnabled = _ref.isEnabled,
    _ref$accountForScroll = _ref.accountForScrollbars,
    accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
  var originalStyles = react.exports.useRef({});
  var scrollTarget = react.exports.useRef(null);
  var addScrollLock = react.exports.useCallback(function (touchScrollTarget) {
    if (!canUseDOM) return;
    var target = document.body;
    var targetStyle = target && target.style;
    if (accountForScrollbars) {
      // store any styles already applied to the body
      STYLE_KEYS.forEach(function (key) {
        var val = targetStyle && targetStyle[key];
        originalStyles.current[key] = val;
      });
    }

    // apply the lock styles and padding if this is the first scroll lock
    if (accountForScrollbars && activeScrollLocks < 1) {
      var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
      var clientWidth = document.body ? document.body.clientWidth : 0;
      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
      Object.keys(LOCK_STYLES).forEach(function (key) {
        var val = LOCK_STYLES[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
      if (targetStyle) {
        targetStyle.paddingRight = "".concat(adjustedPadding, "px");
      }
    }

    // account for touch devices
    if (target && isTouchDevice()) {
      // Mobile Safari ignores { overflow: hidden } declaration on the body.
      target.addEventListener('touchmove', preventTouchMove, listenerOptions);

      // Allow scroll on provided target
      if (touchScrollTarget) {
        touchScrollTarget.addEventListener('touchstart', preventInertiaScroll, listenerOptions);
        touchScrollTarget.addEventListener('touchmove', allowTouchMove, listenerOptions);
      }
    }

    // increment active scroll locks
    activeScrollLocks += 1;
  }, [accountForScrollbars]);
  var removeScrollLock = react.exports.useCallback(function (touchScrollTarget) {
    if (!canUseDOM) return;
    var target = document.body;
    var targetStyle = target && target.style;

    // safely decrement active scroll locks
    activeScrollLocks = Math.max(activeScrollLocks - 1, 0);

    // reapply original body styles, if any
    if (accountForScrollbars && activeScrollLocks < 1) {
      STYLE_KEYS.forEach(function (key) {
        var val = originalStyles.current[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
    }

    // remove touch listeners
    if (target && isTouchDevice()) {
      target.removeEventListener('touchmove', preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.removeEventListener('touchstart', preventInertiaScroll, listenerOptions);
        touchScrollTarget.removeEventListener('touchmove', allowTouchMove, listenerOptions);
      }
    }
  }, [accountForScrollbars]);
  react.exports.useEffect(function () {
    if (!isEnabled) return;
    var element = scrollTarget.current;
    addScrollLock(element);
    return function () {
      removeScrollLock(element);
    };
  }, [isEnabled, addScrollLock, removeScrollLock]);
  return function (element) {
    scrollTarget.current = element;
  };
}
var blurSelectInput = function blurSelectInput() {
  return document.activeElement && document.activeElement.blur();
};
var _ref2$1 = {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
} ;
function ScrollManager(_ref) {
  var children = _ref.children,
    lockEnabled = _ref.lockEnabled,
    _ref$captureEnabled = _ref.captureEnabled,
    captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled,
    onBottomArrive = _ref.onBottomArrive,
    onBottomLeave = _ref.onBottomLeave,
    onTopArrive = _ref.onTopArrive,
    onTopLeave = _ref.onTopLeave;
  var setScrollCaptureTarget = useScrollCapture({
    isEnabled: captureEnabled,
    onBottomArrive: onBottomArrive,
    onBottomLeave: onBottomLeave,
    onTopArrive: onTopArrive,
    onTopLeave: onTopLeave
  });
  var setScrollLockTarget = useScrollLock({
    isEnabled: lockEnabled
  });
  var targetRef = function targetRef(element) {
    setScrollCaptureTarget(element);
    setScrollLockTarget(element);
  };
  return jsx(react.exports.Fragment, null, lockEnabled && jsx("div", {
    onClick: blurSelectInput,
    css: _ref2$1
  }), children(targetRef));
}
var _ref2 = {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
} ;
var RequiredInput = function RequiredInput(_ref) {
  var name = _ref.name,
    onFocus = _ref.onFocus;
  return jsx("input", {
    required: true,
    name: name,
    tabIndex: -1,
    onFocus: onFocus,
    css: _ref2
    // Prevent `Switching from uncontrolled to controlled` error
    ,

    value: "",
    onChange: function onChange() {}
  });
};
var formatGroupLabel = function formatGroupLabel(group) {
  return group.label;
};
var getOptionLabel$1 = function getOptionLabel(option) {
  return option.label;
};
var getOptionValue$1 = function getOptionValue(option) {
  return option.value;
};
var isOptionDisabled = function isOptionDisabled(option) {
  return !!option.isDisabled;
};
var defaultStyles = {
  clearIndicator: clearIndicatorCSS,
  container: containerCSS,
  control: css$1,
  dropdownIndicator: dropdownIndicatorCSS,
  group: groupCSS,
  groupHeading: groupHeadingCSS,
  indicatorsContainer: indicatorsContainerCSS,
  indicatorSeparator: indicatorSeparatorCSS,
  input: inputCSS,
  loadingIndicator: loadingIndicatorCSS,
  loadingMessage: loadingMessageCSS,
  menu: menuCSS,
  menuList: menuListCSS,
  menuPortal: menuPortalCSS,
  multiValue: multiValueCSS,
  multiValueLabel: multiValueLabelCSS,
  multiValueRemove: multiValueRemoveCSS,
  noOptionsMessage: noOptionsMessageCSS,
  option: optionCSS,
  placeholder: placeholderCSS,
  singleValue: css,
  valueContainer: valueContainerCSS
};
var colors = {
  primary: '#2684FF',
  primary75: '#4C9AFF',
  primary50: '#B2D4FF',
  primary25: '#DEEBFF',
  danger: '#DE350B',
  dangerLight: '#FFBDAD',
  neutral0: 'hsl(0, 0%, 100%)',
  neutral5: 'hsl(0, 0%, 95%)',
  neutral10: 'hsl(0, 0%, 90%)',
  neutral20: 'hsl(0, 0%, 80%)',
  neutral30: 'hsl(0, 0%, 70%)',
  neutral40: 'hsl(0, 0%, 60%)',
  neutral50: 'hsl(0, 0%, 50%)',
  neutral60: 'hsl(0, 0%, 40%)',
  neutral70: 'hsl(0, 0%, 30%)',
  neutral80: 'hsl(0, 0%, 20%)',
  neutral90: 'hsl(0, 0%, 10%)'
};
var borderRadius = 4;
// Used to calculate consistent margin/padding on elements
var baseUnit = 4;
// The minimum height of the control
var controlHeight = 38;
// The amount of space between the control and menu */
var menuGutter = baseUnit * 2;
var spacing = {
  baseUnit: baseUnit,
  controlHeight: controlHeight,
  menuGutter: menuGutter
};
var defaultTheme = {
  borderRadius: borderRadius,
  colors: colors,
  spacing: spacing
};
var defaultProps = {
  'aria-live': 'polite',
  backspaceRemovesValue: true,
  blurInputOnSelect: isTouchCapable(),
  captureMenuScroll: !isTouchCapable(),
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: createFilter(),
  formatGroupLabel: formatGroupLabel,
  getOptionLabel: getOptionLabel$1,
  getOptionValue: getOptionValue$1,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled: isOptionDisabled,
  loadingMessage: function loadingMessage() {
    return 'Loading...';
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: 'bottom',
  menuPosition: 'absolute',
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !isMobileDevice(),
  noOptionsMessage: function noOptionsMessage() {
    return 'No options';
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  options: [],
  pageSize: 5,
  placeholder: 'Select...',
  screenReaderStatus: function screenReaderStatus(_ref) {
    var count = _ref.count;
    return "".concat(count, " result").concat(count !== 1 ? 's' : '', " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: true
};
function toCategorizedOption(props, option, selectValue, index) {
  var isDisabled = _isOptionDisabled(props, option, selectValue);
  var isSelected = _isOptionSelected(props, option, selectValue);
  var label = getOptionLabel(props, option);
  var value = getOptionValue(props, option);
  return {
    type: 'option',
    data: option,
    isDisabled: isDisabled,
    isSelected: isSelected,
    label: label,
    value: value,
    index: index
  };
}
function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function (groupOrOption, groupOrOptionIndex) {
    if ('options' in groupOrOption) {
      var categorizedOptions = groupOrOption.options.map(function (option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function (categorizedOption) {
        return isFocusable(props, categorizedOption);
      });
      return categorizedOptions.length > 0 ? {
        type: 'group',
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : undefined;
    }
    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable(props, categorizedOption) ? categorizedOption : undefined;
  }).filter(notNullish);
}
function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function (optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === 'group') {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function (option) {
        return option.data;
      })));
    } else {
      optionsAccumulator.push(categorizedOption.data);
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}
function isFocusable(props, categorizedOption) {
  var _props$inputValue = props.inputValue,
    inputValue = _props$inputValue === void 0 ? '' : _props$inputValue;
  var data = categorizedOption.data,
    isSelected = categorizedOption.isSelected,
    label = categorizedOption.label,
    value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label: label,
    value: value,
    data: data
  }, inputValue);
}
function getNextFocusedValue(state, nextSelectValue) {
  var focusedValue = state.focusedValue,
    lastSelectValue = state.selectValue;
  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
    if (nextFocusedIndex > -1) {
      // the focused value is still in the selectValue, return it
      return focusedValue;
    } else if (lastFocusedIndex < nextSelectValue.length) {
      // the focusedValue is not present in the next selectValue array by
      // reference, so return the new value at the same index
      return nextSelectValue[lastFocusedIndex];
    }
  }
  return null;
}
function getNextFocusedOption(state, options) {
  var lastFocusedOption = state.focusedOption;
  return lastFocusedOption && options.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options[0];
}
var getOptionLabel = function getOptionLabel(props, data) {
  return props.getOptionLabel(data);
};
var getOptionValue = function getOptionValue(props, data) {
  return props.getOptionValue(data);
};
function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled === 'function' ? props.isOptionDisabled(option, selectValue) : false;
}
function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1) return true;
  if (typeof props.isOptionSelected === 'function') {
    return props.isOptionSelected(option, selectValue);
  }
  var candidate = getOptionValue(props, option);
  return selectValue.some(function (i) {
    return getOptionValue(props, i) === candidate;
  });
}
function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : true;
}
var shouldHideSelectedOptions = function shouldHideSelectedOptions(props) {
  var hideSelectedOptions = props.hideSelectedOptions,
    isMulti = props.isMulti;
  if (hideSelectedOptions === undefined) return isMulti;
  return hideSelectedOptions;
};
var instanceId = 1;
var Select$1 = /*#__PURE__*/function (_Component) {
  _inherits(Select, _Component);
  var _super = _createSuper(Select);
  // Misc. Instance Properties
  // ------------------------------

  // TODO

  // Refs
  // ------------------------------

  // Lifecycle
  // ------------------------------

  function Select(_props) {
    var _this;
    _classCallCheck(this, Select);
    _this = _super.call(this, _props);
    _this.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedValue: null,
      inputIsHidden: false,
      isFocused: false,
      selectValue: [],
      clearFocusValueOnUpdate: false,
      prevWasFocused: false,
      inputIsHiddenAfterUpdate: undefined,
      prevProps: undefined
    };
    _this.blockOptionHover = false;
    _this.isComposing = false;
    _this.commonProps = void 0;
    _this.initialTouchX = 0;
    _this.initialTouchY = 0;
    _this.instancePrefix = '';
    _this.openAfterFocus = false;
    _this.scrollToFocusedOptionOnUpdate = false;
    _this.userIsDragging = void 0;
    _this.controlRef = null;
    _this.getControlRef = function (ref) {
      _this.controlRef = ref;
    };
    _this.focusedOptionRef = null;
    _this.getFocusedOptionRef = function (ref) {
      _this.focusedOptionRef = ref;
    };
    _this.menuListRef = null;
    _this.getMenuListRef = function (ref) {
      _this.menuListRef = ref;
    };
    _this.inputRef = null;
    _this.getInputRef = function (ref) {
      _this.inputRef = ref;
    };
    _this.focus = _this.focusInput;
    _this.blur = _this.blurInput;
    _this.onChange = function (newValue, actionMeta) {
      var _this$props = _this.props,
        onChange = _this$props.onChange,
        name = _this$props.name;
      actionMeta.name = name;
      _this.ariaOnChange(newValue, actionMeta);
      onChange(newValue, actionMeta);
    };
    _this.setValue = function (newValue, action, option) {
      var _this$props2 = _this.props,
        closeMenuOnSelect = _this$props2.closeMenuOnSelect,
        isMulti = _this$props2.isMulti,
        inputValue = _this$props2.inputValue;
      _this.onInputChange('', {
        action: 'set-value',
        prevInputValue: inputValue
      });
      if (closeMenuOnSelect) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      }
      // when the select value should change, we should reset focusedValue
      _this.setState({
        clearFocusValueOnUpdate: true
      });
      _this.onChange(newValue, {
        action: action,
        option: option
      });
    };
    _this.selectOption = function (newValue) {
      var _this$props3 = _this.props,
        blurInputOnSelect = _this$props3.blurInputOnSelect,
        isMulti = _this$props3.isMulti,
        name = _this$props3.name;
      var selectValue = _this.state.selectValue;
      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);
      var isDisabled = _this.isOptionDisabled(newValue, selectValue);
      if (deselected) {
        var candidate = _this.getOptionValue(newValue);
        _this.setValue(multiValueAsValue(selectValue.filter(function (i) {
          return _this.getOptionValue(i) !== candidate;
        })), 'deselect-option', newValue);
      } else if (!isDisabled) {
        // Select option if option is not disabled
        if (isMulti) {
          _this.setValue(multiValueAsValue([].concat(_toConsumableArray(selectValue), [newValue])), 'select-option', newValue);
        } else {
          _this.setValue(singleValueAsValue(newValue), 'select-option');
        }
      } else {
        _this.ariaOnChange(singleValueAsValue(newValue), {
          action: 'select-option',
          option: newValue,
          name: name
        });
        return;
      }
      if (blurInputOnSelect) {
        _this.blurInput();
      }
    };
    _this.removeValue = function (removedValue) {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var candidate = _this.getOptionValue(removedValue);
      var newValueArray = selectValue.filter(function (i) {
        return _this.getOptionValue(i) !== candidate;
      });
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: 'remove-value',
        removedValue: removedValue
      });
      _this.focusInput();
    };
    _this.clearValue = function () {
      var selectValue = _this.state.selectValue;
      _this.onChange(valueTernary(_this.props.isMulti, [], null), {
        action: 'clear',
        removedValues: selectValue
      });
    };
    _this.popValue = function () {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var lastSelectedValue = selectValue[selectValue.length - 1];
      var newValueArray = selectValue.slice(0, selectValue.length - 1);
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: 'pop-value',
        removedValue: lastSelectedValue
      });
    };
    _this.getValue = function () {
      return _this.state.selectValue;
    };
    _this.cx = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args));
    };
    _this.getOptionLabel = function (data) {
      return getOptionLabel(_this.props, data);
    };
    _this.getOptionValue = function (data) {
      return getOptionValue(_this.props, data);
    };
    _this.getStyles = function (key, props) {
      var base = defaultStyles[key](props);
      base.boxSizing = 'border-box';
      var custom = _this.props.styles[key];
      return custom ? custom(base, props) : base;
    };
    _this.getElementId = function (element) {
      return "".concat(_this.instancePrefix, "-").concat(element);
    };
    _this.getComponents = function () {
      return defaultComponents(_this.props);
    };
    _this.buildCategorizedOptions = function () {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    };
    _this.getCategorizedOptions = function () {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    };
    _this.buildFocusableOptions = function () {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    };
    _this.getFocusableOptions = function () {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    };
    _this.ariaOnChange = function (value, actionMeta) {
      _this.setState({
        ariaSelection: _objectSpread2$1({
          value: value
        }, actionMeta)
      });
    };
    _this.onMenuMouseDown = function (event) {
      if (event.button !== 0) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      _this.focusInput();
    };
    _this.onMenuMouseMove = function (event) {
      _this.blockOptionHover = false;
    };
    _this.onControlMouseDown = function (event) {
      // Event captured by dropdown indicator
      if (event.defaultPrevented) {
        return;
      }
      var openMenuOnClick = _this.props.openMenuOnClick;
      if (!_this.state.isFocused) {
        if (openMenuOnClick) {
          _this.openAfterFocus = true;
        }
        _this.focusInput();
      } else if (!_this.props.menuIsOpen) {
        if (openMenuOnClick) {
          _this.openMenu('first');
        }
      } else {
        if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
          _this.onMenuClose();
        }
      }
      if (event.target.tagName !== 'INPUT' && event.target.tagName !== 'TEXTAREA') {
        event.preventDefault();
      }
    };
    _this.onDropdownIndicatorMouseDown = function (event) {
      // ignore mouse events that weren't triggered by the primary button
      if (event && event.type === 'mousedown' && event.button !== 0) {
        return;
      }
      if (_this.props.isDisabled) return;
      var _this$props4 = _this.props,
        isMulti = _this$props4.isMulti,
        menuIsOpen = _this$props4.menuIsOpen;
      _this.focusInput();
      if (menuIsOpen) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      } else {
        _this.openMenu('first');
      }
      event.preventDefault();
    };
    _this.onClearIndicatorMouseDown = function (event) {
      // ignore mouse events that weren't triggered by the primary button
      if (event && event.type === 'mousedown' && event.button !== 0) {
        return;
      }
      _this.clearValue();
      event.preventDefault();
      _this.openAfterFocus = false;
      if (event.type === 'touchend') {
        _this.focusInput();
      } else {
        setTimeout(function () {
          return _this.focusInput();
        });
      }
    };
    _this.onScroll = function (event) {
      if (typeof _this.props.closeMenuOnScroll === 'boolean') {
        if (event.target instanceof HTMLElement && isDocumentElement(event.target)) {
          _this.props.onMenuClose();
        }
      } else if (typeof _this.props.closeMenuOnScroll === 'function') {
        if (_this.props.closeMenuOnScroll(event)) {
          _this.props.onMenuClose();
        }
      }
    };
    _this.onCompositionStart = function () {
      _this.isComposing = true;
    };
    _this.onCompositionEnd = function () {
      _this.isComposing = false;
    };
    _this.onTouchStart = function (_ref2) {
      var touches = _ref2.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      _this.initialTouchX = touch.clientX;
      _this.initialTouchY = touch.clientY;
      _this.userIsDragging = false;
    };
    _this.onTouchMove = function (_ref3) {
      var touches = _ref3.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
      var moveThreshold = 5;
      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
    };
    _this.onTouchEnd = function (event) {
      if (_this.userIsDragging) return;

      // close the menu if the user taps outside
      // we're checking on event.target here instead of event.currentTarget, because we want to assert information
      // on events on child elements, not the document (which we've attached this handler to).
      if (_this.controlRef && !_this.controlRef.contains(event.target) && _this.menuListRef && !_this.menuListRef.contains(event.target)) {
        _this.blurInput();
      }

      // reset move vars
      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
    };
    _this.onControlTouchEnd = function (event) {
      if (_this.userIsDragging) return;
      _this.onControlMouseDown(event);
    };
    _this.onClearIndicatorTouchEnd = function (event) {
      if (_this.userIsDragging) return;
      _this.onClearIndicatorMouseDown(event);
    };
    _this.onDropdownIndicatorTouchEnd = function (event) {
      if (_this.userIsDragging) return;
      _this.onDropdownIndicatorMouseDown(event);
    };
    _this.handleInputChange = function (event) {
      var prevInputValue = _this.props.inputValue;
      var inputValue = event.currentTarget.value;
      _this.setState({
        inputIsHiddenAfterUpdate: false
      });
      _this.onInputChange(inputValue, {
        action: 'input-change',
        prevInputValue: prevInputValue
      });
      if (!_this.props.menuIsOpen) {
        _this.onMenuOpen();
      }
    };
    _this.onInputFocus = function (event) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
      _this.setState({
        inputIsHiddenAfterUpdate: false,
        isFocused: true
      });
      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
        _this.openMenu('first');
      }
      _this.openAfterFocus = false;
    };
    _this.onInputBlur = function (event) {
      var prevInputValue = _this.props.inputValue;
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();
        return;
      }
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
      _this.onInputChange('', {
        action: 'input-blur',
        prevInputValue: prevInputValue
      });
      _this.onMenuClose();
      _this.setState({
        focusedValue: null,
        isFocused: false
      });
    };
    _this.onOptionHover = function (focusedOption) {
      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
        return;
      }
      _this.setState({
        focusedOption: focusedOption
      });
    };
    _this.shouldHideSelectedOptions = function () {
      return shouldHideSelectedOptions(_this.props);
    };
    _this.onValueInputFocus = function (e) {
      e.preventDefault();
      e.stopPropagation();
      _this.focus();
    };
    _this.onKeyDown = function (event) {
      var _this$props5 = _this.props,
        isMulti = _this$props5.isMulti,
        backspaceRemovesValue = _this$props5.backspaceRemovesValue,
        escapeClearsValue = _this$props5.escapeClearsValue,
        inputValue = _this$props5.inputValue,
        isClearable = _this$props5.isClearable,
        isDisabled = _this$props5.isDisabled,
        menuIsOpen = _this$props5.menuIsOpen,
        onKeyDown = _this$props5.onKeyDown,
        tabSelectsValue = _this$props5.tabSelectsValue,
        openMenuOnFocus = _this$props5.openMenuOnFocus;
      var _this$state = _this.state,
        focusedOption = _this$state.focusedOption,
        focusedValue = _this$state.focusedValue,
        selectValue = _this$state.selectValue;
      if (isDisabled) return;
      if (typeof onKeyDown === 'function') {
        onKeyDown(event);
        if (event.defaultPrevented) {
          return;
        }
      }

      // Block option hover events when the user has just pressed a key
      _this.blockOptionHover = true;
      switch (event.key) {
        case 'ArrowLeft':
          if (!isMulti || inputValue) return;
          _this.focusValue('previous');
          break;
        case 'ArrowRight':
          if (!isMulti || inputValue) return;
          _this.focusValue('next');
          break;
        case 'Delete':
        case 'Backspace':
          if (inputValue) return;
          if (focusedValue) {
            _this.removeValue(focusedValue);
          } else {
            if (!backspaceRemovesValue) return;
            if (isMulti) {
              _this.popValue();
            } else if (isClearable) {
              _this.clearValue();
            }
          }
          break;
        case 'Tab':
          if (_this.isComposing) return;
          if (event.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption ||
          // don't capture the event if the menu opens on focus and the focused
          // option is already selected; it breaks the flow of navigation
          openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
            return;
          }
          _this.selectOption(focusedOption);
          break;
        case 'Enter':
          if (event.keyCode === 229) {
            // ignore the keydown event from an Input Method Editor(IME)
            // ref. https://www.w3.org/TR/uievents/#determine-keydown-keyup-keyCode
            break;
          }
          if (menuIsOpen) {
            if (!focusedOption) return;
            if (_this.isComposing) return;
            _this.selectOption(focusedOption);
            break;
          }
          return;
        case 'Escape':
          if (menuIsOpen) {
            _this.setState({
              inputIsHiddenAfterUpdate: false
            });
            _this.onInputChange('', {
              action: 'menu-close',
              prevInputValue: inputValue
            });
            _this.onMenuClose();
          } else if (isClearable && escapeClearsValue) {
            _this.clearValue();
          }
          break;
        case ' ':
          // space
          if (inputValue) {
            return;
          }
          if (!menuIsOpen) {
            _this.openMenu('first');
            break;
          }
          if (!focusedOption) return;
          _this.selectOption(focusedOption);
          break;
        case 'ArrowUp':
          if (menuIsOpen) {
            _this.focusOption('up');
          } else {
            _this.openMenu('last');
          }
          break;
        case 'ArrowDown':
          if (menuIsOpen) {
            _this.focusOption('down');
          } else {
            _this.openMenu('first');
          }
          break;
        case 'PageUp':
          if (!menuIsOpen) return;
          _this.focusOption('pageup');
          break;
        case 'PageDown':
          if (!menuIsOpen) return;
          _this.focusOption('pagedown');
          break;
        case 'Home':
          if (!menuIsOpen) return;
          _this.focusOption('first');
          break;
        case 'End':
          if (!menuIsOpen) return;
          _this.focusOption('last');
          break;
        default:
          return;
      }
      event.preventDefault();
    };
    _this.instancePrefix = 'react-select-' + (_this.props.instanceId || ++instanceId);
    _this.state.selectValue = cleanValue(_props.value);

    // Set focusedOption if menuIsOpen is set on init (e.g. defaultMenuIsOpen)
    if (_props.menuIsOpen && _this.state.selectValue.length) {
      var focusableOptions = _this.buildFocusableOptions();
      var optionIndex = focusableOptions.indexOf(_this.state.selectValue[0]);
      _this.state.focusedOption = focusableOptions[optionIndex];
    }
    return _this;
  }
  _createClass(Select, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startListeningComposition();
      this.startListeningToTouch();
      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
        // Listen to all scroll events, and filter them out inside of 'onScroll'
        document.addEventListener('scroll', this.onScroll, true);
      }
      if (this.props.autoFocus) {
        this.focusInput();
      }

      // Scroll focusedOption into view if menuIsOpen is set on mount (e.g. defaultMenuIsOpen)
      if (this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props,
        isDisabled = _this$props6.isDisabled,
        menuIsOpen = _this$props6.menuIsOpen;
      var isFocused = this.state.isFocused;
      if (
      // ensure focus is restored correctly when the control becomes enabled
      isFocused && !isDisabled && prevProps.isDisabled ||
      // ensure focus is on the Input when the menu opens
      isFocused && menuIsOpen && !prevProps.menuIsOpen) {
        this.focusInput();
      }
      if (isFocused && isDisabled && !prevProps.isDisabled) {
        // ensure select state gets blurred in case Select is programmatically disabled while focused
        // eslint-disable-next-line react/no-did-update-set-state
        this.setState({
          isFocused: false
        }, this.onMenuClose);
      } else if (!isFocused && !isDisabled && prevProps.isDisabled && this.inputRef === document.activeElement) {
        // ensure select state gets focused in case Select is programatically re-enabled while focused (Firefox)
        // eslint-disable-next-line react/no-did-update-set-state
        this.setState({
          isFocused: true
        });
      }

      // scroll the focused option into view if necessary
      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
        this.scrollToFocusedOptionOnUpdate = false;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopListeningComposition();
      this.stopListeningToTouch();
      document.removeEventListener('scroll', this.onScroll, true);
    }

    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function onMenuOpen() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function onMenuClose() {
      this.onInputChange('', {
        action: 'menu-close',
        prevInputValue: this.props.inputValue
      });
      this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    }

    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function focusInput() {
      if (!this.inputRef) return;
      this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function blurInput() {
      if (!this.inputRef) return;
      this.inputRef.blur();
    }

    // aliased for consumers
  }, {
    key: "openMenu",
    value: function openMenu(focusOption) {
      var _this2 = this;
      var _this$state2 = this.state,
        selectValue = _this$state2.selectValue,
        isFocused = _this$state2.isFocused;
      var focusableOptions = this.buildFocusableOptions();
      var openAtIndex = focusOption === 'first' ? 0 : focusableOptions.length - 1;
      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
        if (selectedIndex > -1) {
          openAtIndex = selectedIndex;
        }
      }

      // only scroll if the menu isn't already open
      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
      this.setState({
        inputIsHiddenAfterUpdate: false,
        focusedValue: null,
        focusedOption: focusableOptions[openAtIndex]
      }, function () {
        return _this2.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function focusValue(direction) {
      var _this$state3 = this.state,
        selectValue = _this$state3.selectValue,
        focusedValue = _this$state3.focusedValue;

      // Only multiselects support value focusing
      if (!this.props.isMulti) return;
      this.setState({
        focusedOption: null
      });
      var focusedIndex = selectValue.indexOf(focusedValue);
      if (!focusedValue) {
        focusedIndex = -1;
      }
      var lastIndex = selectValue.length - 1;
      var nextFocus = -1;
      if (!selectValue.length) return;
      switch (direction) {
        case 'previous':
          if (focusedIndex === 0) {
            // don't cycle from the start to the end
            nextFocus = 0;
          } else if (focusedIndex === -1) {
            // if nothing is focused, focus the last value first
            nextFocus = lastIndex;
          } else {
            nextFocus = focusedIndex - 1;
          }
          break;
        case 'next':
          if (focusedIndex > -1 && focusedIndex < lastIndex) {
            nextFocus = focusedIndex + 1;
          }
          break;
      }
      this.setState({
        inputIsHidden: nextFocus !== -1,
        focusedValue: selectValue[nextFocus]
      });
    }
  }, {
    key: "focusOption",
    value: function focusOption() {
      var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'first';
      var pageSize = this.props.pageSize;
      var focusedOption = this.state.focusedOption;
      var options = this.getFocusableOptions();
      if (!options.length) return;
      var nextFocus = 0; // handles 'first'
      var focusedIndex = options.indexOf(focusedOption);
      if (!focusedOption) {
        focusedIndex = -1;
      }
      if (direction === 'up') {
        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options.length - 1;
      } else if (direction === 'down') {
        nextFocus = (focusedIndex + 1) % options.length;
      } else if (direction === 'pageup') {
        nextFocus = focusedIndex - pageSize;
        if (nextFocus < 0) nextFocus = 0;
      } else if (direction === 'pagedown') {
        nextFocus = focusedIndex + pageSize;
        if (nextFocus > options.length - 1) nextFocus = options.length - 1;
      } else if (direction === 'last') {
        nextFocus = options.length - 1;
      }
      this.scrollToFocusedOptionOnUpdate = true;
      this.setState({
        focusedOption: options[nextFocus],
        focusedValue: null
      });
    }
  }, {
    key: "getTheme",
    value:
    // ==============================
    // Getters
    // ==============================

    function getTheme() {
      // Use the default theme if there are no customisations.
      if (!this.props.theme) {
        return defaultTheme;
      }
      // If the theme prop is a function, assume the function
      // knows how to merge the passed-in default theme with
      // its own modifications.
      if (typeof this.props.theme === 'function') {
        return this.props.theme(defaultTheme);
      }
      // Otherwise, if a plain theme object was passed in,
      // overlay it with the default theme.
      return _objectSpread2$1(_objectSpread2$1({}, defaultTheme), this.props.theme);
    }
  }, {
    key: "getCommonProps",
    value: function getCommonProps() {
      var clearValue = this.clearValue,
        cx = this.cx,
        getStyles = this.getStyles,
        getValue = this.getValue,
        selectOption = this.selectOption,
        setValue = this.setValue,
        props = this.props;
      var isMulti = props.isMulti,
        isRtl = props.isRtl,
        options = props.options;
      var hasValue = this.hasValue();
      return {
        clearValue: clearValue,
        cx: cx,
        getStyles: getStyles,
        getValue: getValue,
        hasValue: hasValue,
        isMulti: isMulti,
        isRtl: isRtl,
        options: options,
        selectOption: selectOption,
        selectProps: props,
        setValue: setValue,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function hasValue() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function hasOptions() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function isClearable() {
      var _this$props7 = this.props,
        isClearable = _this$props7.isClearable,
        isMulti = _this$props7.isMulti;

      // single select, by default, IS NOT clearable
      // multi select, by default, IS clearable
      if (isClearable === undefined) return isMulti;
      return isClearable;
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }
  }, {
    key: "isOptionSelected",
    value: function isOptionSelected(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }
  }, {
    key: "filterOption",
    value: function filterOption(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }
  }, {
    key: "formatOptionLabel",
    value: function formatOptionLabel(data, context) {
      if (typeof this.props.formatOptionLabel === 'function') {
        var _inputValue = this.props.inputValue;
        var _selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data, {
          context: context,
          inputValue: _inputValue,
          selectValue: _selectValue
        });
      } else {
        return this.getOptionLabel(data);
      }
    }
  }, {
    key: "formatGroupLabel",
    value: function formatGroupLabel(data) {
      return this.props.formatGroupLabel(data);
    }

    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value:
    // ==============================
    // Composition Handlers
    // ==============================

    function startListeningComposition() {
      if (document && document.addEventListener) {
        document.addEventListener('compositionstart', this.onCompositionStart, false);
        document.addEventListener('compositionend', this.onCompositionEnd, false);
      }
    }
  }, {
    key: "stopListeningComposition",
    value: function stopListeningComposition() {
      if (document && document.removeEventListener) {
        document.removeEventListener('compositionstart', this.onCompositionStart);
        document.removeEventListener('compositionend', this.onCompositionEnd);
      }
    }
  }, {
    key: "startListeningToTouch",
    value:
    // ==============================
    // Touch Handlers
    // ==============================

    function startListeningToTouch() {
      if (document && document.addEventListener) {
        document.addEventListener('touchstart', this.onTouchStart, false);
        document.addEventListener('touchmove', this.onTouchMove, false);
        document.addEventListener('touchend', this.onTouchEnd, false);
      }
    }
  }, {
    key: "stopListeningToTouch",
    value: function stopListeningToTouch() {
      if (document && document.removeEventListener) {
        document.removeEventListener('touchstart', this.onTouchStart);
        document.removeEventListener('touchmove', this.onTouchMove);
        document.removeEventListener('touchend', this.onTouchEnd);
      }
    }
  }, {
    key: "renderInput",
    value:
    // ==============================
    // Renderers
    // ==============================
    function renderInput() {
      var _this$props8 = this.props,
        isDisabled = _this$props8.isDisabled,
        isSearchable = _this$props8.isSearchable,
        inputId = _this$props8.inputId,
        inputValue = _this$props8.inputValue,
        tabIndex = _this$props8.tabIndex,
        form = _this$props8.form,
        menuIsOpen = _this$props8.menuIsOpen,
        required = _this$props8.required;
      var _this$getComponents = this.getComponents(),
        Input = _this$getComponents.Input;
      var _this$state4 = this.state,
        inputIsHidden = _this$state4.inputIsHidden,
        ariaSelection = _this$state4.ariaSelection;
      var commonProps = this.commonProps;
      var id = inputId || this.getElementId('input');

      // aria attributes makes the JSX "noisy", separated for clarity
      var ariaAttributes = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        'aria-autocomplete': 'list',
        'aria-expanded': menuIsOpen,
        'aria-haspopup': true,
        'aria-errormessage': this.props['aria-errormessage'],
        'aria-invalid': this.props['aria-invalid'],
        'aria-label': this.props['aria-label'],
        'aria-labelledby': this.props['aria-labelledby'],
        'aria-required': required,
        role: 'combobox'
      }, menuIsOpen && {
        'aria-controls': this.getElementId('listbox'),
        'aria-owns': this.getElementId('listbox')
      }), !isSearchable && {
        'aria-readonly': true
      }), this.hasValue() ? (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === 'initial-input-focus' && {
        'aria-describedby': this.getElementId('live-region')
      } : {
        'aria-describedby': this.getElementId('placeholder')
      });
      if (!isSearchable) {
        // use a dummy input to maintain focus/blur functionality
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(DummyInput, {
            id: id,
            innerRef: this.getInputRef,
            onBlur: this.onInputBlur,
            onChange: noop,
            onFocus: this.onInputFocus,
            disabled: isDisabled,
            tabIndex: tabIndex,
            inputMode: "none",
            form: form,
            value: "",
            ...ariaAttributes
          })
        );
      }
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(Input, {
          ...commonProps,
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: id,
          innerRef: this.getInputRef,
          isDisabled: isDisabled,
          isHidden: inputIsHidden,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex: tabIndex,
          form: form,
          type: "text",
          value: inputValue,
          ...ariaAttributes
        })
      );
    }
  }, {
    key: "renderPlaceholderOrValue",
    value: function renderPlaceholderOrValue() {
      var _this3 = this;
      var _this$getComponents2 = this.getComponents(),
        MultiValue = _this$getComponents2.MultiValue,
        MultiValueContainer = _this$getComponents2.MultiValueContainer,
        MultiValueLabel = _this$getComponents2.MultiValueLabel,
        MultiValueRemove = _this$getComponents2.MultiValueRemove,
        SingleValue = _this$getComponents2.SingleValue,
        Placeholder = _this$getComponents2.Placeholder;
      var commonProps = this.commonProps;
      var _this$props9 = this.props,
        controlShouldRenderValue = _this$props9.controlShouldRenderValue,
        isDisabled = _this$props9.isDisabled,
        isMulti = _this$props9.isMulti,
        inputValue = _this$props9.inputValue,
        placeholder = _this$props9.placeholder;
      var _this$state5 = this.state,
        selectValue = _this$state5.selectValue,
        focusedValue = _this$state5.focusedValue,
        isFocused = _this$state5.isFocused;
      if (!this.hasValue() || !controlShouldRenderValue) {
        return inputValue ? null :
        /*#__PURE__*/
        /*#__PURE__*/
        react.exports.createElement(Placeholder, {
          ...commonProps,
          key: "placeholder",
          isDisabled: isDisabled,
          isFocused: isFocused,
          innerProps: {
            id: this.getElementId('placeholder')
          }
        }, placeholder);
      }
      if (isMulti) {
        return selectValue.map(function (opt, index) {
          var isOptionFocused = opt === focusedValue;
          var key = "".concat(_this3.getOptionLabel(opt), "-").concat(_this3.getOptionValue(opt));
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            react.exports.createElement(MultiValue, {
              ...commonProps,
              components: {
                Container: MultiValueContainer,
                Label: MultiValueLabel,
                Remove: MultiValueRemove
              },
              isFocused: isOptionFocused,
              isDisabled: isDisabled,
              key: key,
              index: index,
              removeProps: {
                onClick: function onClick() {
                  return _this3.removeValue(opt);
                },
                onTouchEnd: function onTouchEnd() {
                  return _this3.removeValue(opt);
                },
                onMouseDown: function onMouseDown(e) {
                  e.preventDefault();
                }
              },
              data: opt
            }, _this3.formatOptionLabel(opt, 'value'))
          );
        });
      }
      if (inputValue) {
        return null;
      }
      var singleValue = selectValue[0];
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(SingleValue, {
          ...commonProps,
          data: singleValue,
          isDisabled: isDisabled,
          children: this.formatOptionLabel(singleValue, 'value')
        })
      );
    }
  }, {
    key: "renderClearIndicator",
    value: function renderClearIndicator() {
      var _this$getComponents3 = this.getComponents(),
        ClearIndicator = _this$getComponents3.ClearIndicator;
      var commonProps = this.commonProps;
      var _this$props10 = this.props,
        isDisabled = _this$props10.isDisabled,
        isLoading = _this$props10.isLoading;
      var isFocused = this.state.isFocused;
      if (!this.isClearable() || !ClearIndicator || isDisabled || !this.hasValue() || isLoading) {
        return null;
      }
      var innerProps = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        'aria-hidden': 'true'
      };
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(ClearIndicator, {
          ...commonProps,
          innerProps: innerProps,
          isFocused: isFocused
        })
      );
    }
  }, {
    key: "renderLoadingIndicator",
    value: function renderLoadingIndicator() {
      var _this$getComponents4 = this.getComponents(),
        LoadingIndicator = _this$getComponents4.LoadingIndicator;
      var commonProps = this.commonProps;
      var _this$props11 = this.props,
        isDisabled = _this$props11.isDisabled,
        isLoading = _this$props11.isLoading;
      var isFocused = this.state.isFocused;
      if (!LoadingIndicator || !isLoading) return null;
      var innerProps = {
        'aria-hidden': 'true'
      };
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(LoadingIndicator, {
          ...commonProps,
          innerProps: innerProps,
          isDisabled: isDisabled,
          isFocused: isFocused
        })
      );
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function renderIndicatorSeparator() {
      var _this$getComponents5 = this.getComponents(),
        DropdownIndicator = _this$getComponents5.DropdownIndicator,
        IndicatorSeparator = _this$getComponents5.IndicatorSeparator;

      // separator doesn't make sense without the dropdown indicator
      if (!DropdownIndicator || !IndicatorSeparator) return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(IndicatorSeparator, {
          ...commonProps,
          isDisabled: isDisabled,
          isFocused: isFocused
        })
      );
    }
  }, {
    key: "renderDropdownIndicator",
    value: function renderDropdownIndicator() {
      var _this$getComponents6 = this.getComponents(),
        DropdownIndicator = _this$getComponents6.DropdownIndicator;
      if (!DropdownIndicator) return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      var innerProps = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        'aria-hidden': 'true'
      };
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(DropdownIndicator, {
          ...commonProps,
          innerProps: innerProps,
          isDisabled: isDisabled,
          isFocused: isFocused
        })
      );
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;
      var _this$getComponents7 = this.getComponents(),
        Group = _this$getComponents7.Group,
        GroupHeading = _this$getComponents7.GroupHeading,
        Menu = _this$getComponents7.Menu,
        MenuList = _this$getComponents7.MenuList,
        MenuPortal = _this$getComponents7.MenuPortal,
        LoadingMessage = _this$getComponents7.LoadingMessage,
        NoOptionsMessage = _this$getComponents7.NoOptionsMessage,
        Option = _this$getComponents7.Option;
      var commonProps = this.commonProps;
      var focusedOption = this.state.focusedOption;
      var _this$props12 = this.props,
        captureMenuScroll = _this$props12.captureMenuScroll,
        inputValue = _this$props12.inputValue,
        isLoading = _this$props12.isLoading,
        loadingMessage = _this$props12.loadingMessage,
        minMenuHeight = _this$props12.minMenuHeight,
        maxMenuHeight = _this$props12.maxMenuHeight,
        menuIsOpen = _this$props12.menuIsOpen,
        menuPlacement = _this$props12.menuPlacement,
        menuPosition = _this$props12.menuPosition,
        menuPortalTarget = _this$props12.menuPortalTarget,
        menuShouldBlockScroll = _this$props12.menuShouldBlockScroll,
        menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView,
        noOptionsMessage = _this$props12.noOptionsMessage,
        onMenuScrollToTop = _this$props12.onMenuScrollToTop,
        onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
      if (!menuIsOpen) return null;

      // TODO: Internal Option Type here
      var render = function render(props, id) {
        var type = props.type,
          data = props.data,
          isDisabled = props.isDisabled,
          isSelected = props.isSelected,
          label = props.label,
          value = props.value;
        var isFocused = focusedOption === data;
        var onHover = isDisabled ? undefined : function () {
          return _this4.onOptionHover(data);
        };
        var onSelect = isDisabled ? undefined : function () {
          return _this4.selectOption(data);
        };
        var optionId = "".concat(_this4.getElementId('option'), "-").concat(id);
        var innerProps = {
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          tabIndex: -1
        };
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          react.exports.createElement(Option, {
            ...commonProps,
            innerProps: innerProps,
            data: data,
            isDisabled: isDisabled,
            isSelected: isSelected,
            key: optionId,
            label: label,
            type: type,
            value: value,
            isFocused: isFocused,
            innerRef: isFocused ? _this4.getFocusedOptionRef : undefined
          }, _this4.formatOptionLabel(props.data, 'menu'))
        );
      };
      var menuUI;
      if (this.hasOptions()) {
        menuUI = this.getCategorizedOptions().map(function (item) {
          if (item.type === 'group') {
            var _data = item.data,
              options = item.options,
              groupIndex = item.index;
            var groupId = "".concat(_this4.getElementId('group'), "-").concat(groupIndex);
            var headingId = "".concat(groupId, "-heading");
            return (
              /*#__PURE__*/
              /*#__PURE__*/
              react.exports.createElement(Group, {
                ...commonProps,
                key: groupId,
                data: _data,
                options: options,
                Heading: GroupHeading,
                headingProps: {
                  id: headingId,
                  data: item.data
                },
                label: _this4.formatGroupLabel(item.data)
              }, item.options.map(function (option) {
                return render(option, "".concat(groupIndex, "-").concat(option.index));
              }))
            );
          } else if (item.type === 'option') {
            return render(item, "".concat(item.index));
          }
        });
      } else if (isLoading) {
        var message = loadingMessage({
          inputValue: inputValue
        });
        if (message === null) return null;
        menuUI =
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(LoadingMessage, {
          ...commonProps,
          children: message
        });
      } else {
        var _message = noOptionsMessage({
          inputValue: inputValue
        });
        if (_message === null) return null;
        menuUI =
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(NoOptionsMessage, {
          ...commonProps,
          children: _message
        });
      }
      var menuPlacementProps = {
        minMenuHeight: minMenuHeight,
        maxMenuHeight: maxMenuHeight,
        menuPlacement: menuPlacement,
        menuPosition: menuPosition,
        menuShouldScrollIntoView: menuShouldScrollIntoView
      };
      var menuElement =
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(MenuPlacer, {
        ...commonProps,
        ...menuPlacementProps,
        children: function (_ref4) {
          var ref = _ref4.ref,
            _ref4$placerProps = _ref4.placerProps,
            placement = _ref4$placerProps.placement,
            maxHeight = _ref4$placerProps.maxHeight;
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1(Menu, {
              ...commonProps,
              ...menuPlacementProps,
              innerRef: ref,
              innerProps: {
                onMouseDown: _this4.onMenuMouseDown,
                onMouseMove: _this4.onMenuMouseMove,
                id: _this4.getElementId('listbox')
              },
              isLoading: isLoading,
              placement: placement,
              children: /*#__PURE__*/jsx$1(ScrollManager, {
                captureEnabled: captureMenuScroll,
                onTopArrive: onMenuScrollToTop,
                onBottomArrive: onMenuScrollToBottom,
                lockEnabled: menuShouldBlockScroll,
                children: function (scrollTargetRef) {
                  return (
                    /*#__PURE__*/
                    /*#__PURE__*/
                    jsx$1(MenuList, {
                      ...commonProps,
                      innerRef: function innerRef(instance) {
                        _this4.getMenuListRef(instance);
                        scrollTargetRef(instance);
                      },
                      isLoading: isLoading,
                      maxHeight: maxHeight,
                      focusedOption: focusedOption,
                      children: menuUI
                    })
                  );
                }
              })
            })
          );
        }
      });

      // positioning behaviour is almost identical for portalled and fixed,
      // so we use the same component. the actual portalling logic is forked
      // within the component based on `menuPosition`
      return menuPortalTarget || menuPosition === 'fixed' ?
      /*#__PURE__*/
      /*#__PURE__*/
      jsx$1(MenuPortal, {
        ...commonProps,
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement: menuPlacement,
        menuPosition: menuPosition,
        children: menuElement
      }) : menuElement;
    }
  }, {
    key: "renderFormField",
    value: function renderFormField() {
      var _this5 = this;
      var _this$props13 = this.props,
        delimiter = _this$props13.delimiter,
        isDisabled = _this$props13.isDisabled,
        isMulti = _this$props13.isMulti,
        name = _this$props13.name,
        required = _this$props13.required;
      var selectValue = this.state.selectValue;
      if (!name || isDisabled) return;
      if (required && !this.hasValue()) {
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1(RequiredInput, {
            name: name,
            onFocus: this.onValueInputFocus
          })
        );
      }
      if (isMulti) {
        if (delimiter) {
          var value = selectValue.map(function (opt) {
            return _this5.getOptionValue(opt);
          }).join(delimiter);
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1("input", {
              name: name,
              type: "hidden",
              value: value
            })
          );
        } else {
          var input = selectValue.length > 0 ? selectValue.map(function (opt, i) {
            return (
              /*#__PURE__*/
              /*#__PURE__*/
              jsx$1("input", {
                name: name,
                type: "hidden",
                value: _this5.getOptionValue(opt)
              }, "i-".concat(i))
            );
          }) :
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("input", {
            name: name,
            type: "hidden",
            value: ""
          });
          return (
            /*#__PURE__*/
            /*#__PURE__*/
            jsx$1("div", {
              children: input
            })
          );
        }
      } else {
        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : '';
        return (
          /*#__PURE__*/
          /*#__PURE__*/
          jsx$1("input", {
            name: name,
            type: "hidden",
            value: _value
          })
        );
      }
    }
  }, {
    key: "renderLiveRegion",
    value: function renderLiveRegion() {
      var commonProps = this.commonProps;
      var _this$state6 = this.state,
        ariaSelection = _this$state6.ariaSelection,
        focusedOption = _this$state6.focusedOption,
        focusedValue = _this$state6.focusedValue,
        isFocused = _this$state6.isFocused,
        selectValue = _this$state6.selectValue;
      var focusableOptions = this.getFocusableOptions();
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsx$1(LiveRegion, {
          ...commonProps,
          id: this.getElementId('live-region'),
          ariaSelection: ariaSelection,
          focusedOption: focusedOption,
          focusedValue: focusedValue,
          isFocused: isFocused,
          selectValue: selectValue,
          focusableOptions: focusableOptions
        })
      );
    }
  }, {
    key: "render",
    value: function render() {
      var _this$getComponents8 = this.getComponents(),
        Control = _this$getComponents8.Control,
        IndicatorsContainer = _this$getComponents8.IndicatorsContainer,
        SelectContainer = _this$getComponents8.SelectContainer,
        ValueContainer = _this$getComponents8.ValueContainer;
      var _this$props14 = this.props,
        className = _this$props14.className,
        id = _this$props14.id,
        isDisabled = _this$props14.isDisabled,
        menuIsOpen = _this$props14.menuIsOpen;
      var isFocused = this.state.isFocused;
      var commonProps = this.commonProps = this.getCommonProps();
      return (
        /*#__PURE__*/
        /*#__PURE__*/
        jsxs(SelectContainer, {
          ...commonProps,
          className: className,
          innerProps: {
            id: id,
            onKeyDown: this.onKeyDown
          },
          isDisabled: isDisabled,
          isFocused: isFocused,
          children: [this.renderLiveRegion(), /*#__PURE__*/jsxs(Control, {
            ...commonProps,
            innerRef: this.getControlRef,
            innerProps: {
              onMouseDown: this.onControlMouseDown,
              onTouchEnd: this.onControlTouchEnd
            },
            isDisabled: isDisabled,
            isFocused: isFocused,
            menuIsOpen: menuIsOpen,
            children: [/*#__PURE__*/jsxs(ValueContainer, {
              ...commonProps,
              isDisabled: isDisabled,
              children: [this.renderPlaceholderOrValue(), this.renderInput()]
            }), /*#__PURE__*/jsxs(IndicatorsContainer, {
              ...commonProps,
              isDisabled: isDisabled,
              children: [this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator()]
            })]
          }), this.renderMenu(), this.renderFormField()]
        })
      );
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      var prevProps = state.prevProps,
        clearFocusValueOnUpdate = state.clearFocusValueOnUpdate,
        inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate,
        ariaSelection = state.ariaSelection,
        isFocused = state.isFocused,
        prevWasFocused = state.prevWasFocused;
      var options = props.options,
        value = props.value,
        menuIsOpen = props.menuIsOpen,
        inputValue = props.inputValue,
        isMulti = props.isMulti;
      var selectValue = cleanValue(value);
      var newMenuOptionsState = {};
      if (prevProps && (value !== prevProps.value || options !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null;
        var focusedOption = getNextFocusedOption(state, focusableOptions);
        newMenuOptionsState = {
          selectValue: selectValue,
          focusedOption: focusedOption,
          focusedValue: focusedValue,
          clearFocusValueOnUpdate: false
        };
      }
      // some updates should toggle the state of the input visibility
      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: undefined
      } : {};
      var newAriaSelection = ariaSelection;
      var hasKeptFocus = isFocused && prevWasFocused;
      if (isFocused && !hasKeptFocus) {
        // If `value` or `defaultValue` props are not empty then announce them
        // when the Select is initially focused
        newAriaSelection = {
          value: valueTernary(isMulti, selectValue, selectValue[0] || null),
          options: selectValue,
          action: 'initial-input-focus'
        };
        hasKeptFocus = !prevWasFocused;
      }

      // If the 'initial-input-focus' action has been set already
      // then reset the ariaSelection to null
      if ((ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === 'initial-input-focus') {
        newAriaSelection = null;
      }
      return _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props,
        ariaSelection: newAriaSelection,
        prevWasFocused: hasKeptFocus
      });
    }
  }]);
  return Select;
}(react.exports.Component);
Select$1.defaultProps = defaultProps;

var StateManagedSelect = /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
  var baseSelectProps = useStateManager(props);
  return (
    /*#__PURE__*/
    /*#__PURE__*/
    jsx$1(Select$1, {
      ref: ref,
      ...baseSelectProps
    })
  );
});
const Select = StateManagedSelect;

const name = "nfa-web";
const version$1 = "0.1.1";
const type = "module";
const scripts = {
	dev: "vite",
	build: "tsc && vite build",
	preview: "vite preview"
};
const dependencies = {
	"@ant-design/icons": "^4.8.0",
	antd: "^5.1.0",
	axios: "^1.1.3",
	dayjs: "^1.11.7",
	"decimal.js": "^10.4.3",
	ethers: "^5.7.2",
	history: "^5.3.0",
	"odata-query": "^7.0.3",
	"oidc-client": "^1.11.5",
	"qrcode.react": "^3.1.0",
	react: "^18.2.0",
	"react-dom": "^18.2.0",
	"react-highlight-words": "^0.18.0",
	"react-intl": "^6.2.4",
	"react-router-dom": "^6.4.3",
	"react-select": "^5.6.1",
	"resize-observer-polyfill": "^1.5.1"
};
const devDependencies = {
	"@types/react": "^18.0.24",
	"@types/react-dom": "^18.0.8",
	"@types/react-highlight-words": "^0.16.4",
	"@typescript-eslint/eslint-plugin": "^5.40.0",
	"@typescript-eslint/eslint-plugin-tslint": "^5.40.0",
	"@typescript-eslint/parser": "^5.40.0",
	"@vitejs/plugin-react": "^2.2.0",
	eslint: "^8.25.0",
	"eslint-config-airbnb": "^19.0.4",
	"eslint-config-prettier": "^8.5.0",
	"eslint-import-resolver-alias": "^1.1.2",
	"eslint-plugin-ft-flow": "^2.0.1",
	"eslint-plugin-import": "^2.24.0",
	"eslint-plugin-jest": "^27.1.0",
	"eslint-plugin-jsx-a11y": "^6.4.1",
	"eslint-plugin-prettier": "^4.2.1",
	"eslint-plugin-react": "^7.24.0",
	"eslint-plugin-react-hooks": "^4.6.0",
	prettier: "^2.7.1",
	sass: "^1.56.1",
	tslint: "^6.1.3",
	typescript: "^4.6.4",
	vite: "^3.2.3",
	"vite-aliases": "^0.9.7",
	"vite-plugin-top-level-await": "^1.2.2",
	"vite-plugin-eslint": "^1.8.1"
};
const appJson = {
	name: name,
	"private": true,
	version: version$1,
	type: type,
	scripts: scripts,
	dependencies: dependencies,
	devDependencies: devDependencies
};

var oidcClient_min = {exports: {}};

(function (module, exports) {
	!function t(e,r){module.exports=r();}(commonjsGlobal,(function(){return function(t){var e={};function r(n){if(e[n])return e[n].exports;var i=e[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=t,r.c=e,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n});},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0});},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)r.d(n,i,function(e){return t[e]}.bind(null,i));return n},r.n=function(t){var e=t&&t.__esModule?function e(){return t.default}:function e(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=22)}([function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}();var i={debug:function t(){},info:function t(){},warn:function t(){},error:function t(){}},o=void 0,s=void 0;(e.Log=function(){function t(){!function e(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}(this,t);}return t.reset=function t(){s=3,o=i;},t.debug=function t(){if(s>=4){for(var e=arguments.length,r=Array(e),n=0;n<e;n++)r[n]=arguments[n];o.debug.apply(o,Array.from(r));}},t.info=function t(){if(s>=3){for(var e=arguments.length,r=Array(e),n=0;n<e;n++)r[n]=arguments[n];o.info.apply(o,Array.from(r));}},t.warn=function t(){if(s>=2){for(var e=arguments.length,r=Array(e),n=0;n<e;n++)r[n]=arguments[n];o.warn.apply(o,Array.from(r));}},t.error=function t(){if(s>=1){for(var e=arguments.length,r=Array(e),n=0;n<e;n++)r[n]=arguments[n];o.error.apply(o,Array.from(r));}},n(t,null,[{key:"NONE",get:function t(){return 0}},{key:"ERROR",get:function t(){return 1}},{key:"WARN",get:function t(){return 2}},{key:"INFO",get:function t(){return 3}},{key:"DEBUG",get:function t(){return 4}},{key:"level",get:function t(){return s},set:function t(e){if(!(0<=e&&e<=4))throw new Error("Invalid log level");s=e;}},{key:"logger",get:function t(){return o},set:function t(e){if(!e.debug&&e.info&&(e.debug=e.info),!(e.debug&&e.info&&e.warn&&e.error))throw new Error("Invalid logger");o=e;}}]),t}()).reset();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}();var i={setInterval:function(t){function e(e,r){return t.apply(this,arguments)}return e.toString=function(){return t.toString()},e}((function(t,e){return setInterval(t,e)})),clearInterval:function(t){function e(e){return t.apply(this,arguments)}return e.toString=function(){return t.toString()},e}((function(t){return clearInterval(t)}))},o=!1,s=null;e.Global=function(){function t(){!function e(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}(this,t);}return t._testing=function t(){o=!0;},t.setXMLHttpRequest=function t(e){s=e;},n(t,null,[{key:"location",get:function t(){if(!o)return location}},{key:"localStorage",get:function t(){if(!o&&"undefined"!=typeof window)return localStorage}},{key:"sessionStorage",get:function t(){if(!o&&"undefined"!=typeof window)return sessionStorage}},{key:"XMLHttpRequest",get:function t(){if(!o&&"undefined"!=typeof window)return s||XMLHttpRequest}},{key:"timer",get:function t(){if(!o)return i}}]),t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.MetadataService=void 0;var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),i=r(0),o=r(7);function s(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a=".well-known/openid-configuration";e.MetadataService=function(){function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.JsonService;if(s(this,t),!e)throw i.Log.error("MetadataService: No settings passed to MetadataService"),new Error("settings");this._settings=e,this._jsonService=new r(["application/jwk-set+json"]);}return t.prototype.resetSigningKeys=function t(){this._settings=this._settings||{},this._settings.signingKeys=void 0;},t.prototype.getMetadata=function t(){var e=this;return this._settings.metadata?(i.Log.debug("MetadataService.getMetadata: Returning metadata from settings"),Promise.resolve(this._settings.metadata)):this.metadataUrl?(i.Log.debug("MetadataService.getMetadata: getting metadata from",this.metadataUrl),this._jsonService.getJson(this.metadataUrl).then((function(t){i.Log.debug("MetadataService.getMetadata: json received");var r=e._settings.metadataSeed||{};return e._settings.metadata=Object.assign({},r,t),e._settings.metadata}))):(i.Log.error("MetadataService.getMetadata: No authority or metadataUrl configured on settings"),Promise.reject(new Error("No authority or metadataUrl configured on settings")))},t.prototype.getIssuer=function t(){return this._getMetadataProperty("issuer")},t.prototype.getAuthorizationEndpoint=function t(){return this._getMetadataProperty("authorization_endpoint")},t.prototype.getUserInfoEndpoint=function t(){return this._getMetadataProperty("userinfo_endpoint")},t.prototype.getTokenEndpoint=function t(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return this._getMetadataProperty("token_endpoint",e)},t.prototype.getCheckSessionIframe=function t(){return this._getMetadataProperty("check_session_iframe",!0)},t.prototype.getEndSessionEndpoint=function t(){return this._getMetadataProperty("end_session_endpoint",!0)},t.prototype.getRevocationEndpoint=function t(){return this._getMetadataProperty("revocation_endpoint",!0)},t.prototype.getKeysEndpoint=function t(){return this._getMetadataProperty("jwks_uri",!0)},t.prototype._getMetadataProperty=function t(e){var r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return i.Log.debug("MetadataService.getMetadataProperty for: "+e),this.getMetadata().then((function(t){if(i.Log.debug("MetadataService.getMetadataProperty: metadata recieved"),void 0===t[e]){if(!0===r)return void i.Log.warn("MetadataService.getMetadataProperty: Metadata does not contain optional property "+e);throw i.Log.error("MetadataService.getMetadataProperty: Metadata does not contain property "+e),new Error("Metadata does not contain property "+e)}return t[e]}))},t.prototype.getSigningKeys=function t(){var e=this;return this._settings.signingKeys?(i.Log.debug("MetadataService.getSigningKeys: Returning signingKeys from settings"),Promise.resolve(this._settings.signingKeys)):this._getMetadataProperty("jwks_uri").then((function(t){return i.Log.debug("MetadataService.getSigningKeys: jwks_uri received",t),e._jsonService.getJson(t).then((function(t){if(i.Log.debug("MetadataService.getSigningKeys: key set received",t),!t.keys)throw i.Log.error("MetadataService.getSigningKeys: Missing keys on keyset"),new Error("Missing keys on keyset");return e._settings.signingKeys=t.keys,e._settings.signingKeys}))}))},n(t,[{key:"metadataUrl",get:function t(){return this._metadataUrl||(this._settings.metadataUrl?this._metadataUrl=this._settings.metadataUrl:(this._metadataUrl=this._settings.authority,this._metadataUrl&&this._metadataUrl.indexOf(a)<0&&("/"!==this._metadataUrl[this._metadataUrl.length-1]&&(this._metadataUrl+="/"),this._metadataUrl+=a))),this._metadataUrl}}]),t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.UrlUtility=void 0;var n=r(0),i=r(1);e.UrlUtility=function(){function t(){!function e(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}(this,t);}return t.addQueryParam=function t(e,r,n){return e.indexOf("?")<0&&(e+="?"),"?"!==e[e.length-1]&&(e+="&"),e+=encodeURIComponent(r),e+="=",e+=encodeURIComponent(n)},t.parseUrlFragment=function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#",o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:i.Global;"string"!=typeof e&&(e=o.location.href);var s=e.lastIndexOf(r);s>=0&&(e=e.substr(s+1)),"?"===r&&(s=e.indexOf("#"))>=0&&(e=e.substr(0,s));for(var a,u={},c=/([^&=]+)=([^&]*)/g,h=0;a=c.exec(e);)if(u[decodeURIComponent(a[1])]=decodeURIComponent(a[2].replace(/\+/g," ")),h++>50)return n.Log.error("UrlUtility.parseUrlFragment: response exceeded expected number of parameters",e),{error:"Response exceeded expected number of parameters"};for(var l in u)return u;return {}},t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.JoseUtil=void 0;var n=r(26),i=function o(t){return t&&t.__esModule?t:{default:t}}(r(33));e.JoseUtil=(0, i.default)({jws:n.jws,KeyUtil:n.KeyUtil,X509:n.X509,crypto:n.crypto,hextob64u:n.hextob64u,b64tohex:n.b64tohex,AllowedSigningAlgs:n.AllowedSigningAlgs});},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.OidcClientSettings=void 0;var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),o=r(0),s=r(23),a=r(6),u=r(24),c=r(2);function h(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var l=".well-known/openid-configuration",f="id_token",g="openid",d="client_secret_post";e.OidcClientSettings=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=e.authority,i=e.metadataUrl,o=e.metadata,l=e.signingKeys,p=e.metadataSeed,v=e.client_id,y=e.client_secret,m=e.response_type,_=void 0===m?f:m,S=e.scope,b=void 0===S?g:S,w=e.redirect_uri,F=e.post_logout_redirect_uri,E=e.client_authentication,x=void 0===E?d:E,A=e.prompt,k=e.display,P=e.max_age,C=e.ui_locales,T=e.acr_values,R=e.resource,I=e.response_mode,D=e.filterProtocolClaims,L=void 0===D||D,N=e.loadUserInfo,U=void 0===N||N,B=e.staleStateAge,O=void 0===B?900:B,j=e.clockSkew,M=void 0===j?300:j,H=e.clockService,V=void 0===H?new s.ClockService:H,K=e.userInfoJwtIssuer,q=void 0===K?"OP":K,J=e.mergeClaims,W=void 0!==J&&J,z=e.stateStore,Y=void 0===z?new a.WebStorageStateStore:z,G=e.ResponseValidatorCtor,X=void 0===G?u.ResponseValidator:G,$=e.MetadataServiceCtor,Q=void 0===$?c.MetadataService:$,Z=e.extraQueryParams,tt=void 0===Z?{}:Z,et=e.extraTokenParams,rt=void 0===et?{}:et;h(this,t),this._authority=r,this._metadataUrl=i,this._metadata=o,this._metadataSeed=p,this._signingKeys=l,this._client_id=v,this._client_secret=y,this._response_type=_,this._scope=b,this._redirect_uri=w,this._post_logout_redirect_uri=F,this._client_authentication=x,this._prompt=A,this._display=k,this._max_age=P,this._ui_locales=C,this._acr_values=T,this._resource=R,this._response_mode=I,this._filterProtocolClaims=!!L,this._loadUserInfo=!!U,this._staleStateAge=O,this._clockSkew=M,this._clockService=V,this._userInfoJwtIssuer=q,this._mergeClaims=!!W,this._stateStore=Y,this._validator=new X(this),this._metadataService=new Q(this),this._extraQueryParams="object"===(void 0===tt?"undefined":n(tt))?tt:{},this._extraTokenParams="object"===(void 0===rt?"undefined":n(rt))?rt:{};}return t.prototype.getEpochTime=function t(){return this._clockService.getEpochTime()},i(t,[{key:"client_id",get:function t(){return this._client_id},set:function t(e){if(this._client_id)throw o.Log.error("OidcClientSettings.set_client_id: client_id has already been assigned."),new Error("client_id has already been assigned.");this._client_id=e;}},{key:"client_secret",get:function t(){return this._client_secret}},{key:"response_type",get:function t(){return this._response_type}},{key:"scope",get:function t(){return this._scope}},{key:"redirect_uri",get:function t(){return this._redirect_uri}},{key:"post_logout_redirect_uri",get:function t(){return this._post_logout_redirect_uri}},{key:"client_authentication",get:function t(){return this._client_authentication}},{key:"prompt",get:function t(){return this._prompt}},{key:"display",get:function t(){return this._display}},{key:"max_age",get:function t(){return this._max_age}},{key:"ui_locales",get:function t(){return this._ui_locales}},{key:"acr_values",get:function t(){return this._acr_values}},{key:"resource",get:function t(){return this._resource}},{key:"response_mode",get:function t(){return this._response_mode}},{key:"authority",get:function t(){return this._authority},set:function t(e){if(this._authority)throw o.Log.error("OidcClientSettings.set_authority: authority has already been assigned."),new Error("authority has already been assigned.");this._authority=e;}},{key:"metadataUrl",get:function t(){return this._metadataUrl||(this._metadataUrl=this.authority,this._metadataUrl&&this._metadataUrl.indexOf(l)<0&&("/"!==this._metadataUrl[this._metadataUrl.length-1]&&(this._metadataUrl+="/"),this._metadataUrl+=l)),this._metadataUrl}},{key:"metadata",get:function t(){return this._metadata},set:function t(e){this._metadata=e;}},{key:"metadataSeed",get:function t(){return this._metadataSeed},set:function t(e){this._metadataSeed=e;}},{key:"signingKeys",get:function t(){return this._signingKeys},set:function t(e){this._signingKeys=e;}},{key:"filterProtocolClaims",get:function t(){return this._filterProtocolClaims}},{key:"loadUserInfo",get:function t(){return this._loadUserInfo}},{key:"staleStateAge",get:function t(){return this._staleStateAge}},{key:"clockSkew",get:function t(){return this._clockSkew}},{key:"userInfoJwtIssuer",get:function t(){return this._userInfoJwtIssuer}},{key:"mergeClaims",get:function t(){return this._mergeClaims}},{key:"stateStore",get:function t(){return this._stateStore}},{key:"validator",get:function t(){return this._validator}},{key:"metadataService",get:function t(){return this._metadataService}},{key:"extraQueryParams",get:function t(){return this._extraQueryParams},set:function t(e){"object"===(void 0===e?"undefined":n(e))?this._extraQueryParams=e:this._extraQueryParams={};}},{key:"extraTokenParams",get:function t(){return this._extraTokenParams},set:function t(e){"object"===(void 0===e?"undefined":n(e))?this._extraTokenParams=e:this._extraTokenParams={};}}]),t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.WebStorageStateStore=void 0;var n=r(0),i=r(1);function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}e.WebStorageStateStore=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=e.prefix,n=void 0===r?"oidc.":r,s=e.store,a=void 0===s?i.Global.localStorage:s;o(this,t),this._store=a,this._prefix=n;}return t.prototype.set=function t(e,r){return n.Log.debug("WebStorageStateStore.set",e),e=this._prefix+e,this._store.setItem(e,r),Promise.resolve()},t.prototype.get=function t(e){n.Log.debug("WebStorageStateStore.get",e),e=this._prefix+e;var r=this._store.getItem(e);return Promise.resolve(r)},t.prototype.remove=function t(e){n.Log.debug("WebStorageStateStore.remove",e),e=this._prefix+e;var r=this._store.getItem(e);return this._store.removeItem(e),Promise.resolve(r)},t.prototype.getAllKeys=function t(){n.Log.debug("WebStorageStateStore.getAllKeys");for(var e=[],r=0;r<this._store.length;r++){var i=this._store.key(r);0===i.indexOf(this._prefix)&&e.push(i.substr(this._prefix.length));}return Promise.resolve(e)},t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.JsonService=void 0;var n=r(0),i=r(1);function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}e.JsonService=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:i.Global.XMLHttpRequest,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;o(this,t),e&&Array.isArray(e)?this._contentTypes=e.slice():this._contentTypes=[],this._contentTypes.push("application/json"),n&&this._contentTypes.push("application/jwt"),this._XMLHttpRequest=r,this._jwtHandler=n;}return t.prototype.getJson=function t(e,r){var i=this;if(!e)throw n.Log.error("JsonService.getJson: No url passed"),new Error("url");return n.Log.debug("JsonService.getJson, url: ",e),new Promise((function(t,o){var s=new i._XMLHttpRequest;s.open("GET",e);var a=i._contentTypes,u=i._jwtHandler;s.onload=function(){if(n.Log.debug("JsonService.getJson: HTTP response received, status",s.status),200===s.status){var r=s.getResponseHeader("Content-Type");if(r){var i=a.find((function(t){if(r.startsWith(t))return !0}));if("application/jwt"==i)return void u(s).then(t,o);if(i)try{return void t(JSON.parse(s.responseText))}catch(t){return n.Log.error("JsonService.getJson: Error parsing JSON response",t.message),void o(t)}}o(Error("Invalid response Content-Type: "+r+", from URL: "+e));}else o(Error(s.statusText+" ("+s.status+")"));},s.onerror=function(){n.Log.error("JsonService.getJson: network error"),o(Error("Network Error"));},r&&(n.Log.debug("JsonService.getJson: token passed, setting Authorization header"),s.setRequestHeader("Authorization","Bearer "+r)),s.send();}))},t.prototype.postForm=function t(e,r,i){var o=this;if(!e)throw n.Log.error("JsonService.postForm: No url passed"),new Error("url");return n.Log.debug("JsonService.postForm, url: ",e),new Promise((function(t,s){var a=new o._XMLHttpRequest;a.open("POST",e);var u=o._contentTypes;a.onload=function(){if(n.Log.debug("JsonService.postForm: HTTP response received, status",a.status),200!==a.status){if(400===a.status)if(i=a.getResponseHeader("Content-Type"))if(u.find((function(t){if(i.startsWith(t))return !0})))try{var r=JSON.parse(a.responseText);if(r&&r.error)return n.Log.error("JsonService.postForm: Error from server: ",r.error),void s(new Error(r.error))}catch(t){return n.Log.error("JsonService.postForm: Error parsing JSON response",t.message),void s(t)}s(Error(a.statusText+" ("+a.status+")"));}else {var i;if((i=a.getResponseHeader("Content-Type"))&&u.find((function(t){if(i.startsWith(t))return !0})))try{return void t(JSON.parse(a.responseText))}catch(t){return n.Log.error("JsonService.postForm: Error parsing JSON response",t.message),void s(t)}s(Error("Invalid response Content-Type: "+i+", from URL: "+e));}},a.onerror=function(){n.Log.error("JsonService.postForm: network error"),s(Error("Network Error"));};var c="";for(var h in r){var l=r[h];l&&(c.length>0&&(c+="&"),c+=encodeURIComponent(h),c+="=",c+=encodeURIComponent(l));}a.setRequestHeader("Content-Type","application/x-www-form-urlencoded"),void 0!==i&&a.setRequestHeader("Authorization","Basic "+btoa(i)),a.send(c);}))},t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.SigninRequest=void 0;var n=r(0),i=r(3),o=r(13);e.SigninRequest=function(){function t(e){var r=e.url,s=e.client_id,a=e.redirect_uri,u=e.response_type,c=e.scope,h=e.authority,l=e.data,f=e.prompt,g=e.display,d=e.max_age,p=e.ui_locales,v=e.id_token_hint,y=e.login_hint,m=e.acr_values,_=e.resource,S=e.response_mode,b=e.request,w=e.request_uri,F=e.extraQueryParams,E=e.request_type,x=e.client_secret,A=e.extraTokenParams,k=e.skipUserInfo;if(function P(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),!r)throw n.Log.error("SigninRequest.ctor: No url passed"),new Error("url");if(!s)throw n.Log.error("SigninRequest.ctor: No client_id passed"),new Error("client_id");if(!a)throw n.Log.error("SigninRequest.ctor: No redirect_uri passed"),new Error("redirect_uri");if(!u)throw n.Log.error("SigninRequest.ctor: No response_type passed"),new Error("response_type");if(!c)throw n.Log.error("SigninRequest.ctor: No scope passed"),new Error("scope");if(!h)throw n.Log.error("SigninRequest.ctor: No authority passed"),new Error("authority");var C=t.isOidc(u),T=t.isCode(u);S||(S=t.isCode(u)?"query":null),this.state=new o.SigninState({nonce:C,data:l,client_id:s,authority:h,redirect_uri:a,code_verifier:T,request_type:E,response_mode:S,client_secret:x,scope:c,extraTokenParams:A,skipUserInfo:k}),r=i.UrlUtility.addQueryParam(r,"client_id",s),r=i.UrlUtility.addQueryParam(r,"redirect_uri",a),r=i.UrlUtility.addQueryParam(r,"response_type",u),r=i.UrlUtility.addQueryParam(r,"scope",c),r=i.UrlUtility.addQueryParam(r,"state",this.state.id),C&&(r=i.UrlUtility.addQueryParam(r,"nonce",this.state.nonce)),T&&(r=i.UrlUtility.addQueryParam(r,"code_challenge",this.state.code_challenge),r=i.UrlUtility.addQueryParam(r,"code_challenge_method","S256"));var R={prompt:f,display:g,max_age:d,ui_locales:p,id_token_hint:v,login_hint:y,acr_values:m,resource:_,request:b,request_uri:w,response_mode:S};for(var I in R)R[I]&&(r=i.UrlUtility.addQueryParam(r,I,R[I]));for(var D in F)r=i.UrlUtility.addQueryParam(r,D,F[D]);this.url=r;}return t.isOidc=function t(e){return !!e.split(/\s+/g).filter((function(t){return "id_token"===t}))[0]},t.isOAuth=function t(e){return !!e.split(/\s+/g).filter((function(t){return "token"===t}))[0]},t.isCode=function t(e){return !!e.split(/\s+/g).filter((function(t){return "code"===t}))[0]},t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.State=void 0;var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),i=r(0),o=function s(t){return t&&t.__esModule?t:{default:t}}(r(14));function a(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}e.State=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=e.id,n=e.data,i=e.created,s=e.request_type;a(this,t),this._id=r||(0, o.default)(),this._data=n,this._created="number"==typeof i&&i>0?i:parseInt(Date.now()/1e3),this._request_type=s;}return t.prototype.toStorageString=function t(){return i.Log.debug("State.toStorageString"),JSON.stringify({id:this.id,data:this.data,created:this.created,request_type:this.request_type})},t.fromStorageString=function e(r){return i.Log.debug("State.fromStorageString"),new t(JSON.parse(r))},t.clearStaleState=function e(r,n){var o=Date.now()/1e3-n;return r.getAllKeys().then((function(e){i.Log.debug("State.clearStaleState: got keys",e);for(var n=[],s=function s(a){var c=e[a];u=r.get(c).then((function(e){var n=!1;if(e)try{var s=t.fromStorageString(e);i.Log.debug("State.clearStaleState: got item from key: ",c,s.created),s.created<=o&&(n=!0);}catch(t){i.Log.error("State.clearStaleState: Error parsing state for key",c,t.message),n=!0;}else i.Log.debug("State.clearStaleState: no item in storage for key: ",c),n=!0;if(n)return i.Log.debug("State.clearStaleState: removed item for key: ",c),r.remove(c)})),n.push(u);},a=0;a<e.length;a++){var u;s(a);}return i.Log.debug("State.clearStaleState: waiting on promise count:",n.length),Promise.all(n)}))},n(t,[{key:"id",get:function t(){return this._id}},{key:"data",get:function t(){return this._data}},{key:"created",get:function t(){return this._created}},{key:"request_type",get:function t(){return this._request_type}}]),t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.OidcClient=void 0;var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),i=r(0),o=r(5),s=r(12),a=r(8),u=r(34),c=r(35),h=r(36),l=r(13),f=r(9);function g(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}e.OidcClient=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};g(this,t),e instanceof o.OidcClientSettings?this._settings=e:this._settings=new o.OidcClientSettings(e);}return t.prototype.createSigninRequest=function t(){var e=this,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=r.response_type,o=r.scope,s=r.redirect_uri,u=r.data,c=r.state,h=r.prompt,l=r.display,f=r.max_age,g=r.ui_locales,d=r.id_token_hint,p=r.login_hint,v=r.acr_values,y=r.resource,m=r.request,_=r.request_uri,S=r.response_mode,b=r.extraQueryParams,w=r.extraTokenParams,F=r.request_type,E=r.skipUserInfo,x=arguments[1];i.Log.debug("OidcClient.createSigninRequest");var A=this._settings.client_id;n=n||this._settings.response_type,o=o||this._settings.scope,s=s||this._settings.redirect_uri,h=h||this._settings.prompt,l=l||this._settings.display,f=f||this._settings.max_age,g=g||this._settings.ui_locales,v=v||this._settings.acr_values,y=y||this._settings.resource,S=S||this._settings.response_mode,b=b||this._settings.extraQueryParams,w=w||this._settings.extraTokenParams;var k=this._settings.authority;return a.SigninRequest.isCode(n)&&"code"!==n?Promise.reject(new Error("OpenID Connect hybrid flow is not supported")):this._metadataService.getAuthorizationEndpoint().then((function(t){i.Log.debug("OidcClient.createSigninRequest: Received authorization endpoint",t);var r=new a.SigninRequest({url:t,client_id:A,redirect_uri:s,response_type:n,scope:o,data:u||c,authority:k,prompt:h,display:l,max_age:f,ui_locales:g,id_token_hint:d,login_hint:p,acr_values:v,resource:y,request:m,request_uri:_,extraQueryParams:b,extraTokenParams:w,request_type:F,response_mode:S,client_secret:e._settings.client_secret,skipUserInfo:E}),P=r.state;return (x=x||e._stateStore).set(P.id,P.toStorageString()).then((function(){return r}))}))},t.prototype.readSigninResponseState=function t(e,r){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];i.Log.debug("OidcClient.readSigninResponseState");var o="query"===this._settings.response_mode||!this._settings.response_mode&&a.SigninRequest.isCode(this._settings.response_type),s=o?"?":"#",c=new u.SigninResponse(e,s);if(!c.state)return i.Log.error("OidcClient.readSigninResponseState: No state in response"),Promise.reject(new Error("No state in response"));r=r||this._stateStore;var h=n?r.remove.bind(r):r.get.bind(r);return h(c.state).then((function(t){if(!t)throw i.Log.error("OidcClient.readSigninResponseState: No matching state found in storage"),new Error("No matching state found in storage");return {state:l.SigninState.fromStorageString(t),response:c}}))},t.prototype.processSigninResponse=function t(e,r){var n=this;return i.Log.debug("OidcClient.processSigninResponse"),this.readSigninResponseState(e,r,!0).then((function(t){var e=t.state,r=t.response;return i.Log.debug("OidcClient.processSigninResponse: Received state from storage; validating response"),n._validator.validateSigninResponse(e,r)}))},t.prototype.createSignoutRequest=function t(){var e=this,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=r.id_token_hint,o=r.data,s=r.state,a=r.post_logout_redirect_uri,u=r.extraQueryParams,h=r.request_type,l=arguments[1];return i.Log.debug("OidcClient.createSignoutRequest"),a=a||this._settings.post_logout_redirect_uri,u=u||this._settings.extraQueryParams,this._metadataService.getEndSessionEndpoint().then((function(t){if(!t)throw i.Log.error("OidcClient.createSignoutRequest: No end session endpoint url returned"),new Error("no end session endpoint");i.Log.debug("OidcClient.createSignoutRequest: Received end session endpoint",t);var r=new c.SignoutRequest({url:t,id_token_hint:n,post_logout_redirect_uri:a,data:o||s,extraQueryParams:u,request_type:h}),f=r.state;return f&&(i.Log.debug("OidcClient.createSignoutRequest: Signout request has state to persist"),(l=l||e._stateStore).set(f.id,f.toStorageString())),r}))},t.prototype.readSignoutResponseState=function t(e,r){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];i.Log.debug("OidcClient.readSignoutResponseState");var o=new h.SignoutResponse(e);if(!o.state)return i.Log.debug("OidcClient.readSignoutResponseState: No state in response"),o.error?(i.Log.warn("OidcClient.readSignoutResponseState: Response was error: ",o.error),Promise.reject(new s.ErrorResponse(o))):Promise.resolve({state:void 0,response:o});var a=o.state;r=r||this._stateStore;var u=n?r.remove.bind(r):r.get.bind(r);return u(a).then((function(t){if(!t)throw i.Log.error("OidcClient.readSignoutResponseState: No matching state found in storage"),new Error("No matching state found in storage");return {state:f.State.fromStorageString(t),response:o}}))},t.prototype.processSignoutResponse=function t(e,r){var n=this;return i.Log.debug("OidcClient.processSignoutResponse"),this.readSignoutResponseState(e,r,!0).then((function(t){var e=t.state,r=t.response;return e?(i.Log.debug("OidcClient.processSignoutResponse: Received state from storage; validating response"),n._validator.validateSignoutResponse(e,r)):(i.Log.debug("OidcClient.processSignoutResponse: No state from storage; skipping validating response"),r)}))},t.prototype.clearStaleState=function t(e){return i.Log.debug("OidcClient.clearStaleState"),e=e||this._stateStore,f.State.clearStaleState(e,this.settings.staleStateAge)},n(t,[{key:"_stateStore",get:function t(){return this.settings.stateStore}},{key:"_validator",get:function t(){return this.settings.validator}},{key:"_metadataService",get:function t(){return this.settings.metadataService}},{key:"settings",get:function t(){return this._settings}},{key:"metadataService",get:function t(){return this._metadataService}}]),t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.TokenClient=void 0;var n=r(7),i=r(2),o=r(0);function s(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}e.TokenClient=function(){function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.JsonService,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:i.MetadataService;if(s(this,t),!e)throw o.Log.error("TokenClient.ctor: No settings passed"),new Error("settings");this._settings=e,this._jsonService=new r,this._metadataService=new a(this._settings);}return t.prototype.exchangeCode=function t(){var e=this,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};(r=Object.assign({},r)).grant_type=r.grant_type||"authorization_code",r.client_id=r.client_id||this._settings.client_id,r.client_secret=r.client_secret||this._settings.client_secret,r.redirect_uri=r.redirect_uri||this._settings.redirect_uri;var n=void 0,i=r._client_authentication||this._settings._client_authentication;return delete r._client_authentication,r.code?r.redirect_uri?r.code_verifier?r.client_id?r.client_secret||"client_secret_basic"!=i?("client_secret_basic"==i&&(n=r.client_id+":"+r.client_secret,delete r.client_id,delete r.client_secret),this._metadataService.getTokenEndpoint(!1).then((function(t){return o.Log.debug("TokenClient.exchangeCode: Received token endpoint"),e._jsonService.postForm(t,r,n).then((function(t){return o.Log.debug("TokenClient.exchangeCode: response received"),t}))}))):(o.Log.error("TokenClient.exchangeCode: No client_secret passed"),Promise.reject(new Error("A client_secret is required"))):(o.Log.error("TokenClient.exchangeCode: No client_id passed"),Promise.reject(new Error("A client_id is required"))):(o.Log.error("TokenClient.exchangeCode: No code_verifier passed"),Promise.reject(new Error("A code_verifier is required"))):(o.Log.error("TokenClient.exchangeCode: No redirect_uri passed"),Promise.reject(new Error("A redirect_uri is required"))):(o.Log.error("TokenClient.exchangeCode: No code passed"),Promise.reject(new Error("A code is required")))},t.prototype.exchangeRefreshToken=function t(){var e=this,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};(r=Object.assign({},r)).grant_type=r.grant_type||"refresh_token",r.client_id=r.client_id||this._settings.client_id,r.client_secret=r.client_secret||this._settings.client_secret;var n=void 0,i=r._client_authentication||this._settings._client_authentication;return delete r._client_authentication,r.refresh_token?r.client_id?("client_secret_basic"==i&&(n=r.client_id+":"+r.client_secret,delete r.client_id,delete r.client_secret),this._metadataService.getTokenEndpoint(!1).then((function(t){return o.Log.debug("TokenClient.exchangeRefreshToken: Received token endpoint"),e._jsonService.postForm(t,r,n).then((function(t){return o.Log.debug("TokenClient.exchangeRefreshToken: response received"),t}))}))):(o.Log.error("TokenClient.exchangeRefreshToken: No client_id passed"),Promise.reject(new Error("A client_id is required"))):(o.Log.error("TokenClient.exchangeRefreshToken: No refresh_token passed"),Promise.reject(new Error("A refresh_token is required")))},t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.ErrorResponse=void 0;var n=r(0);function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !e||"object"!=typeof e&&"function"!=typeof e?t:e}e.ErrorResponse=function(t){function e(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},s=r.error,a=r.error_description,u=r.error_uri,c=r.state,h=r.session_state;if(i(this,e),!s)throw n.Log.error("No error passed to ErrorResponse"),new Error("error");var l=o(this,t.call(this,a||s));return l.name="ErrorResponse",l.error=s,l.error_description=a,l.error_uri=u,l.state=c,l.session_state=h,l}return function r(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}(e,t),e}(Error);},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.SigninState=void 0;var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),i=r(0),o=r(9),s=r(4),a=function u(t){return t&&t.__esModule?t:{default:t}}(r(14));function c(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function h(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !e||"object"!=typeof e&&"function"!=typeof e?t:e}e.SigninState=function(t){function e(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=r.nonce,i=r.authority,o=r.client_id,u=r.redirect_uri,l=r.code_verifier,f=r.response_mode,g=r.client_secret,d=r.scope,p=r.extraTokenParams,v=r.skipUserInfo;c(this,e);var y=h(this,t.call(this,arguments[0]));if(!0===n?y._nonce=(0, a.default)():n&&(y._nonce=n),!0===l?y._code_verifier=(0, a.default)()+(0, a.default)()+(0, a.default)():l&&(y._code_verifier=l),y.code_verifier){var m=s.JoseUtil.hashString(y.code_verifier,"SHA256");y._code_challenge=s.JoseUtil.hexToBase64Url(m);}return y._redirect_uri=u,y._authority=i,y._client_id=o,y._response_mode=f,y._client_secret=g,y._scope=d,y._extraTokenParams=p,y._skipUserInfo=v,y}return function r(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}(e,t),e.prototype.toStorageString=function t(){return i.Log.debug("SigninState.toStorageString"),JSON.stringify({id:this.id,data:this.data,created:this.created,request_type:this.request_type,nonce:this.nonce,code_verifier:this.code_verifier,redirect_uri:this.redirect_uri,authority:this.authority,client_id:this.client_id,response_mode:this.response_mode,client_secret:this.client_secret,scope:this.scope,extraTokenParams:this.extraTokenParams,skipUserInfo:this.skipUserInfo})},e.fromStorageString=function t(r){return i.Log.debug("SigninState.fromStorageString"),new e(JSON.parse(r))},n(e,[{key:"nonce",get:function t(){return this._nonce}},{key:"authority",get:function t(){return this._authority}},{key:"client_id",get:function t(){return this._client_id}},{key:"redirect_uri",get:function t(){return this._redirect_uri}},{key:"code_verifier",get:function t(){return this._code_verifier}},{key:"code_challenge",get:function t(){return this._code_challenge}},{key:"response_mode",get:function t(){return this._response_mode}},{key:"client_secret",get:function t(){return this._client_secret}},{key:"scope",get:function t(){return this._scope}},{key:"extraTokenParams",get:function t(){return this._extraTokenParams}},{key:"skipUserInfo",get:function t(){return this._skipUserInfo}}]),e}(o.State);},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.default=function n(){return ("undefined"!=i&&null!==i&&void 0!==i.getRandomValues?o:s)().replace(/-/g,"")};var i="undefined"!=typeof window?window.crypto||window.msCrypto:null;function o(){return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,(function(t){return (t^i.getRandomValues(new Uint8Array(1))[0]&15>>t/4).toString(16)}))}function s(){return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,(function(t){return (t^16*Math.random()>>t/4).toString(16)}))}t.exports=e.default;},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.User=void 0;var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),i=r(0);e.User=function(){function t(e){var r=e.id_token,n=e.session_state,i=e.access_token,o=e.refresh_token,s=e.token_type,a=e.scope,u=e.profile,c=e.expires_at,h=e.state;!function l(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.id_token=r,this.session_state=n,this.access_token=i,this.refresh_token=o,this.token_type=s,this.scope=a,this.profile=u,this.expires_at=c,this.state=h;}return t.prototype.toStorageString=function t(){return i.Log.debug("User.toStorageString"),JSON.stringify({id_token:this.id_token,session_state:this.session_state,access_token:this.access_token,refresh_token:this.refresh_token,token_type:this.token_type,scope:this.scope,profile:this.profile,expires_at:this.expires_at})},t.fromStorageString=function e(r){return i.Log.debug("User.fromStorageString"),new t(JSON.parse(r))},n(t,[{key:"expires_in",get:function t(){if(this.expires_at){var e=parseInt(Date.now()/1e3);return this.expires_at-e}},set:function t(e){var r=parseInt(e);if("number"==typeof r&&r>0){var n=parseInt(Date.now()/1e3);this.expires_at=n+r;}}},{key:"expired",get:function t(){var e=this.expires_in;if(void 0!==e)return e<=0}},{key:"scopes",get:function t(){return (this.scope||"").split(" ")}}]),t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.AccessTokenEvents=void 0;var n=r(0),i=r(46);function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}e.AccessTokenEvents=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=e.accessTokenExpiringNotificationTime,n=void 0===r?60:r,s=e.accessTokenExpiringTimer,a=void 0===s?new i.Timer("Access token expiring"):s,u=e.accessTokenExpiredTimer,c=void 0===u?new i.Timer("Access token expired"):u;o(this,t),this._accessTokenExpiringNotificationTime=n,this._accessTokenExpiring=a,this._accessTokenExpired=c;}return t.prototype.load=function t(e){if(e.access_token&&void 0!==e.expires_in){var r=e.expires_in;if(n.Log.debug("AccessTokenEvents.load: access token present, remaining duration:",r),r>0){var i=r-this._accessTokenExpiringNotificationTime;i<=0&&(i=1),n.Log.debug("AccessTokenEvents.load: registering expiring timer in:",i),this._accessTokenExpiring.init(i);}else n.Log.debug("AccessTokenEvents.load: canceling existing expiring timer becase we're past expiration."),this._accessTokenExpiring.cancel();var o=r+1;n.Log.debug("AccessTokenEvents.load: registering expired timer in:",o),this._accessTokenExpired.init(o);}else this._accessTokenExpiring.cancel(),this._accessTokenExpired.cancel();},t.prototype.unload=function t(){n.Log.debug("AccessTokenEvents.unload: canceling existing access token timers"),this._accessTokenExpiring.cancel(),this._accessTokenExpired.cancel();},t.prototype.addAccessTokenExpiring=function t(e){this._accessTokenExpiring.addHandler(e);},t.prototype.removeAccessTokenExpiring=function t(e){this._accessTokenExpiring.removeHandler(e);},t.prototype.addAccessTokenExpired=function t(e){this._accessTokenExpired.addHandler(e);},t.prototype.removeAccessTokenExpired=function t(e){this._accessTokenExpired.removeHandler(e);},t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.Event=void 0;var n=r(0);e.Event=function(){function t(e){!function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this._name=e,this._callbacks=[];}return t.prototype.addHandler=function t(e){this._callbacks.push(e);},t.prototype.removeHandler=function t(e){var r=this._callbacks.findIndex((function(t){return t===e}));r>=0&&this._callbacks.splice(r,1);},t.prototype.raise=function t(){n.Log.debug("Event: Raising event: "+this._name);for(var e=0;e<this._callbacks.length;e++){var r;(r=this._callbacks)[e].apply(r,arguments);}},t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.SessionMonitor=void 0;var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),i=r(0),o=r(19),s=r(1);function a(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}e.SessionMonitor=function(){function t(e){var r=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.CheckSessionIFrame,u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:s.Global.timer;if(a(this,t),!e)throw i.Log.error("SessionMonitor.ctor: No user manager passed to SessionMonitor"),new Error("userManager");this._userManager=e,this._CheckSessionIFrameCtor=n,this._timer=u,this._userManager.events.addUserLoaded(this._start.bind(this)),this._userManager.events.addUserUnloaded(this._stop.bind(this)),Promise.resolve(this._userManager.getUser().then((function(t){t?r._start(t):r._settings.monitorAnonymousSession&&r._userManager.querySessionStatus().then((function(t){var e={session_state:t.session_state};t.sub&&t.sid&&(e.profile={sub:t.sub,sid:t.sid}),r._start(e);})).catch((function(t){i.Log.error("SessionMonitor ctor: error from querySessionStatus:",t.message);}));})).catch((function(t){i.Log.error("SessionMonitor ctor: error from getUser:",t.message);})));}return t.prototype._start=function t(e){var r=this,n=e.session_state;n&&(e.profile?(this._sub=e.profile.sub,this._sid=e.profile.sid,i.Log.debug("SessionMonitor._start: session_state:",n,", sub:",this._sub)):(this._sub=void 0,this._sid=void 0,i.Log.debug("SessionMonitor._start: session_state:",n,", anonymous user")),this._checkSessionIFrame?this._checkSessionIFrame.start(n):this._metadataService.getCheckSessionIframe().then((function(t){if(t){i.Log.debug("SessionMonitor._start: Initializing check session iframe");var e=r._client_id,o=r._checkSessionInterval,s=r._stopCheckSessionOnError;r._checkSessionIFrame=new r._CheckSessionIFrameCtor(r._callback.bind(r),e,t,o,s),r._checkSessionIFrame.load().then((function(){r._checkSessionIFrame.start(n);}));}else i.Log.warn("SessionMonitor._start: No check session iframe found in the metadata");})).catch((function(t){i.Log.error("SessionMonitor._start: Error from getCheckSessionIframe:",t.message);})));},t.prototype._stop=function t(){var e=this;if(this._sub=void 0,this._sid=void 0,this._checkSessionIFrame&&(i.Log.debug("SessionMonitor._stop"),this._checkSessionIFrame.stop()),this._settings.monitorAnonymousSession)var r=this._timer.setInterval((function(){e._timer.clearInterval(r),e._userManager.querySessionStatus().then((function(t){var r={session_state:t.session_state};t.sub&&t.sid&&(r.profile={sub:t.sub,sid:t.sid}),e._start(r);})).catch((function(t){i.Log.error("SessionMonitor: error from querySessionStatus:",t.message);}));}),1e3);},t.prototype._callback=function t(){var e=this;this._userManager.querySessionStatus().then((function(t){var r=!0;t?t.sub===e._sub?(r=!1,e._checkSessionIFrame.start(t.session_state),t.sid===e._sid?i.Log.debug("SessionMonitor._callback: Same sub still logged in at OP, restarting check session iframe; session_state:",t.session_state):(i.Log.debug("SessionMonitor._callback: Same sub still logged in at OP, session state has changed, restarting check session iframe; session_state:",t.session_state),e._userManager.events._raiseUserSessionChanged())):i.Log.debug("SessionMonitor._callback: Different subject signed into OP:",t.sub):i.Log.debug("SessionMonitor._callback: Subject no longer signed into OP"),r&&(e._sub?(i.Log.debug("SessionMonitor._callback: SessionMonitor._callback; raising signed out event"),e._userManager.events._raiseUserSignedOut()):(i.Log.debug("SessionMonitor._callback: SessionMonitor._callback; raising signed in event"),e._userManager.events._raiseUserSignedIn()));})).catch((function(t){e._sub&&(i.Log.debug("SessionMonitor._callback: Error calling queryCurrentSigninSession; raising signed out event",t.message),e._userManager.events._raiseUserSignedOut());}));},n(t,[{key:"_settings",get:function t(){return this._userManager.settings}},{key:"_metadataService",get:function t(){return this._userManager.metadataService}},{key:"_client_id",get:function t(){return this._settings.client_id}},{key:"_checkSessionInterval",get:function t(){return this._settings.checkSessionInterval}},{key:"_stopCheckSessionOnError",get:function t(){return this._settings.stopCheckSessionOnError}}]),t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.CheckSessionIFrame=void 0;var n=r(0);function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}e.CheckSessionIFrame=function(){function t(e,r,n,o){var s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];i(this,t),this._callback=e,this._client_id=r,this._url=n,this._interval=o||2e3,this._stopOnError=s;var a=n.indexOf("/",n.indexOf("//")+2);this._frame_origin=n.substr(0,a),this._frame=window.document.createElement("iframe"),this._frame.style.visibility="hidden",this._frame.style.position="absolute",this._frame.style.display="none",this._frame.width=0,this._frame.height=0,this._frame.src=n;}return t.prototype.load=function t(){var e=this;return new Promise((function(t){e._frame.onload=function(){t();},window.document.body.appendChild(e._frame),e._boundMessageEvent=e._message.bind(e),window.addEventListener("message",e._boundMessageEvent,!1);}))},t.prototype._message=function t(e){e.origin===this._frame_origin&&e.source===this._frame.contentWindow&&("error"===e.data?(n.Log.error("CheckSessionIFrame: error message from check session op iframe"),this._stopOnError&&this.stop()):"changed"===e.data?(n.Log.debug("CheckSessionIFrame: changed message from check session op iframe"),this.stop(),this._callback()):n.Log.debug("CheckSessionIFrame: "+e.data+" message from check session op iframe"));},t.prototype.start=function t(e){var r=this;if(this._session_state!==e){n.Log.debug("CheckSessionIFrame.start"),this.stop(),this._session_state=e;var i=function t(){r._frame.contentWindow.postMessage(r._client_id+" "+r._session_state,r._frame_origin);};i(),this._timer=window.setInterval(i,this._interval);}},t.prototype.stop=function t(){this._session_state=null,this._timer&&(n.Log.debug("CheckSessionIFrame.stop"),window.clearInterval(this._timer),this._timer=null);},t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.TokenRevocationClient=void 0;var n=r(0),i=r(2),o=r(1);function s(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var a="access_token",u="refresh_token";e.TokenRevocationClient=function(){function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.Global.XMLHttpRequest,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:i.MetadataService;if(s(this,t),!e)throw n.Log.error("TokenRevocationClient.ctor: No settings provided"),new Error("No settings provided.");this._settings=e,this._XMLHttpRequestCtor=r,this._metadataService=new a(this._settings);}return t.prototype.revoke=function t(e,r){var i=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"access_token";if(!e)throw n.Log.error("TokenRevocationClient.revoke: No token provided"),new Error("No token provided.");if(o!==a&&o!=u)throw n.Log.error("TokenRevocationClient.revoke: Invalid token type"),new Error("Invalid token type.");return this._metadataService.getRevocationEndpoint().then((function(t){if(t){n.Log.debug("TokenRevocationClient.revoke: Revoking "+o);var s=i._settings.client_id,a=i._settings.client_secret;return i._revoke(t,s,a,e,o)}if(r)throw n.Log.error("TokenRevocationClient.revoke: Revocation not supported"),new Error("Revocation not supported")}))},t.prototype._revoke=function t(e,r,i,o,s){var a=this;return new Promise((function(t,u){var c=new a._XMLHttpRequestCtor;c.open("POST",e),c.onload=function(){n.Log.debug("TokenRevocationClient.revoke: HTTP response received, status",c.status),200===c.status?t():u(Error(c.statusText+" ("+c.status+")"));},c.onerror=function(){n.Log.debug("TokenRevocationClient.revoke: Network Error."),u("Network Error");};var h="client_id="+encodeURIComponent(r);i&&(h+="&client_secret="+encodeURIComponent(i)),h+="&token_type_hint="+encodeURIComponent(s),h+="&token="+encodeURIComponent(o),c.setRequestHeader("Content-Type","application/x-www-form-urlencoded"),c.send(h);}))},t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.CordovaPopupWindow=void 0;var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),i=r(0);e.CordovaPopupWindow=function(){function t(e){var r=this;!function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this._promise=new Promise((function(t,e){r._resolve=t,r._reject=e;})),this.features=e.popupWindowFeatures||"location=no,toolbar=no,zoom=no",this.target=e.popupWindowTarget||"_blank",this.redirect_uri=e.startUrl,i.Log.debug("CordovaPopupWindow.ctor: redirect_uri: "+this.redirect_uri);}return t.prototype._isInAppBrowserInstalled=function t(e){return ["cordova-plugin-inappbrowser","cordova-plugin-inappbrowser.inappbrowser","org.apache.cordova.inappbrowser"].some((function(t){return e.hasOwnProperty(t)}))},t.prototype.navigate=function t(e){if(e&&e.url){if(!window.cordova)return this._error("cordova is undefined");var r=window.cordova.require("cordova/plugin_list").metadata;if(!1===this._isInAppBrowserInstalled(r))return this._error("InAppBrowser plugin not found");this._popup=cordova.InAppBrowser.open(e.url,this.target,this.features),this._popup?(i.Log.debug("CordovaPopupWindow.navigate: popup successfully created"),this._exitCallbackEvent=this._exitCallback.bind(this),this._loadStartCallbackEvent=this._loadStartCallback.bind(this),this._popup.addEventListener("exit",this._exitCallbackEvent,!1),this._popup.addEventListener("loadstart",this._loadStartCallbackEvent,!1)):this._error("Error opening popup window");}else this._error("No url provided");return this.promise},t.prototype._loadStartCallback=function t(e){0===e.url.indexOf(this.redirect_uri)&&this._success({url:e.url});},t.prototype._exitCallback=function t(e){this._error(e);},t.prototype._success=function t(e){this._cleanup(),i.Log.debug("CordovaPopupWindow: Successful response from cordova popup window"),this._resolve(e);},t.prototype._error=function t(e){this._cleanup(),i.Log.error(e),this._reject(new Error(e));},t.prototype.close=function t(){this._cleanup();},t.prototype._cleanup=function t(){this._popup&&(i.Log.debug("CordovaPopupWindow: cleaning up popup"),this._popup.removeEventListener("exit",this._exitCallbackEvent,!1),this._popup.removeEventListener("loadstart",this._loadStartCallbackEvent,!1),this._popup.close()),this._popup=null;},n(t,[{key:"promise",get:function t(){return this._promise}}]),t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});var n=r(0),i=r(10),o=r(5),s=r(6),a=r(37),u=r(38),c=r(16),h=r(2),l=r(48),f=r(49),g=r(19),d=r(20),p=r(18),v=r(1),y=r(15),m=r(50);e.default={Version:m.Version,Log:n.Log,OidcClient:i.OidcClient,OidcClientSettings:o.OidcClientSettings,WebStorageStateStore:s.WebStorageStateStore,InMemoryWebStorage:a.InMemoryWebStorage,UserManager:u.UserManager,AccessTokenEvents:c.AccessTokenEvents,MetadataService:h.MetadataService,CordovaPopupNavigator:l.CordovaPopupNavigator,CordovaIFrameNavigator:f.CordovaIFrameNavigator,CheckSessionIFrame:g.CheckSessionIFrame,TokenRevocationClient:d.TokenRevocationClient,SessionMonitor:p.SessionMonitor,Global:v.Global,User:y.User},t.exports=e.default;},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});e.ClockService=function(){function t(){!function e(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}(this,t);}return t.prototype.getEpochTime=function t(){return Promise.resolve(Date.now()/1e3|0)},t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.ResponseValidator=void 0;var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},i=r(0),o=r(2),s=r(25),a=r(11),u=r(12),c=r(4);function h(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var l=["nonce","at_hash","iat","nbf","exp","aud","iss","c_hash"];e.ResponseValidator=function(){function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.MetadataService,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:s.UserInfoService,u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:c.JoseUtil,l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:a.TokenClient;if(h(this,t),!e)throw i.Log.error("ResponseValidator.ctor: No settings passed to ResponseValidator"),new Error("settings");this._settings=e,this._metadataService=new r(this._settings),this._userInfoService=new n(this._settings),this._joseUtil=u,this._tokenClient=new l(this._settings);}return t.prototype.validateSigninResponse=function t(e,r){var n=this;return i.Log.debug("ResponseValidator.validateSigninResponse"),this._processSigninParams(e,r).then((function(t){return i.Log.debug("ResponseValidator.validateSigninResponse: state processed"),n._validateTokens(e,t).then((function(t){return i.Log.debug("ResponseValidator.validateSigninResponse: tokens validated"),n._processClaims(e,t).then((function(t){return i.Log.debug("ResponseValidator.validateSigninResponse: claims processed"),t}))}))}))},t.prototype.validateSignoutResponse=function t(e,r){return e.id!==r.state?(i.Log.error("ResponseValidator.validateSignoutResponse: State does not match"),Promise.reject(new Error("State does not match"))):(i.Log.debug("ResponseValidator.validateSignoutResponse: state validated"),r.state=e.data,r.error?(i.Log.warn("ResponseValidator.validateSignoutResponse: Response was error",r.error),Promise.reject(new u.ErrorResponse(r))):Promise.resolve(r))},t.prototype._processSigninParams=function t(e,r){if(e.id!==r.state)return i.Log.error("ResponseValidator._processSigninParams: State does not match"),Promise.reject(new Error("State does not match"));if(!e.client_id)return i.Log.error("ResponseValidator._processSigninParams: No client_id on state"),Promise.reject(new Error("No client_id on state"));if(!e.authority)return i.Log.error("ResponseValidator._processSigninParams: No authority on state"),Promise.reject(new Error("No authority on state"));if(this._settings.authority){if(this._settings.authority&&this._settings.authority!==e.authority)return i.Log.error("ResponseValidator._processSigninParams: authority mismatch on settings vs. signin state"),Promise.reject(new Error("authority mismatch on settings vs. signin state"))}else this._settings.authority=e.authority;if(this._settings.client_id){if(this._settings.client_id&&this._settings.client_id!==e.client_id)return i.Log.error("ResponseValidator._processSigninParams: client_id mismatch on settings vs. signin state"),Promise.reject(new Error("client_id mismatch on settings vs. signin state"))}else this._settings.client_id=e.client_id;return i.Log.debug("ResponseValidator._processSigninParams: state validated"),r.state=e.data,r.error?(i.Log.warn("ResponseValidator._processSigninParams: Response was error",r.error),Promise.reject(new u.ErrorResponse(r))):e.nonce&&!r.id_token?(i.Log.error("ResponseValidator._processSigninParams: Expecting id_token in response"),Promise.reject(new Error("No id_token in response"))):!e.nonce&&r.id_token?(i.Log.error("ResponseValidator._processSigninParams: Not expecting id_token in response"),Promise.reject(new Error("Unexpected id_token in response"))):e.code_verifier&&!r.code?(i.Log.error("ResponseValidator._processSigninParams: Expecting code in response"),Promise.reject(new Error("No code in response"))):!e.code_verifier&&r.code?(i.Log.error("ResponseValidator._processSigninParams: Not expecting code in response"),Promise.reject(new Error("Unexpected code in response"))):(r.scope||(r.scope=e.scope),Promise.resolve(r))},t.prototype._processClaims=function t(e,r){var n=this;if(r.isOpenIdConnect){if(i.Log.debug("ResponseValidator._processClaims: response is OIDC, processing claims"),r.profile=this._filterProtocolClaims(r.profile),!0!==e.skipUserInfo&&this._settings.loadUserInfo&&r.access_token)return i.Log.debug("ResponseValidator._processClaims: loading user info"),this._userInfoService.getClaims(r.access_token).then((function(t){return i.Log.debug("ResponseValidator._processClaims: user info claims received from user info endpoint"),t.sub!==r.profile.sub?(i.Log.error("ResponseValidator._processClaims: sub from user info endpoint does not match sub in id_token"),Promise.reject(new Error("sub from user info endpoint does not match sub in id_token"))):(r.profile=n._mergeClaims(r.profile,t),i.Log.debug("ResponseValidator._processClaims: user info claims received, updated profile:",r.profile),r)}));i.Log.debug("ResponseValidator._processClaims: not loading user info");}else i.Log.debug("ResponseValidator._processClaims: response is not OIDC, not processing claims");return Promise.resolve(r)},t.prototype._mergeClaims=function t(e,r){var i=Object.assign({},e);for(var o in r){var s=r[o];Array.isArray(s)||(s=[s]);for(var a=0;a<s.length;a++){var u=s[a];i[o]?Array.isArray(i[o])?i[o].indexOf(u)<0&&i[o].push(u):i[o]!==u&&("object"===(void 0===u?"undefined":n(u))&&this._settings.mergeClaims?i[o]=this._mergeClaims(i[o],u):i[o]=[i[o],u]):i[o]=u;}}return i},t.prototype._filterProtocolClaims=function t(e){i.Log.debug("ResponseValidator._filterProtocolClaims, incoming claims:",e);var r=Object.assign({},e);return this._settings._filterProtocolClaims?(l.forEach((function(t){delete r[t];})),i.Log.debug("ResponseValidator._filterProtocolClaims: protocol claims filtered",r)):i.Log.debug("ResponseValidator._filterProtocolClaims: protocol claims not filtered"),r},t.prototype._validateTokens=function t(e,r){return r.code?(i.Log.debug("ResponseValidator._validateTokens: Validating code"),this._processCode(e,r)):r.id_token?r.access_token?(i.Log.debug("ResponseValidator._validateTokens: Validating id_token and access_token"),this._validateIdTokenAndAccessToken(e,r)):(i.Log.debug("ResponseValidator._validateTokens: Validating id_token"),this._validateIdToken(e,r)):(i.Log.debug("ResponseValidator._validateTokens: No code to process or id_token to validate"),Promise.resolve(r))},t.prototype._processCode=function t(e,r){var o=this,s={client_id:e.client_id,client_secret:e.client_secret,code:r.code,redirect_uri:e.redirect_uri,code_verifier:e.code_verifier};return e.extraTokenParams&&"object"===n(e.extraTokenParams)&&Object.assign(s,e.extraTokenParams),this._tokenClient.exchangeCode(s).then((function(t){for(var n in t)r[n]=t[n];return r.id_token?(i.Log.debug("ResponseValidator._processCode: token response successful, processing id_token"),o._validateIdTokenAttributes(e,r)):(i.Log.debug("ResponseValidator._processCode: token response successful, returning response"),r)}))},t.prototype._validateIdTokenAttributes=function t(e,r){var n=this;return this._metadataService.getIssuer().then((function(t){var o=e.client_id,s=n._settings.clockSkew;return i.Log.debug("ResponseValidator._validateIdTokenAttributes: Validaing JWT attributes; using clock skew (in seconds) of: ",s),n._settings.getEpochTime().then((function(a){return n._joseUtil.validateJwtAttributes(r.id_token,t,o,s,a).then((function(t){return e.nonce&&e.nonce!==t.nonce?(i.Log.error("ResponseValidator._validateIdTokenAttributes: Invalid nonce in id_token"),Promise.reject(new Error("Invalid nonce in id_token"))):t.sub?(r.profile=t,r):(i.Log.error("ResponseValidator._validateIdTokenAttributes: No sub present in id_token"),Promise.reject(new Error("No sub present in id_token")))}))}))}))},t.prototype._validateIdTokenAndAccessToken=function t(e,r){var n=this;return this._validateIdToken(e,r).then((function(t){return n._validateAccessToken(t)}))},t.prototype._getSigningKeyForJwt=function t(e){var r=this;return this._metadataService.getSigningKeys().then((function(t){var n=e.header.kid;if(!t)return i.Log.error("ResponseValidator._validateIdToken: No signing keys from metadata"),Promise.reject(new Error("No signing keys from metadata"));i.Log.debug("ResponseValidator._validateIdToken: Received signing keys");var o=void 0;if(n)o=t.filter((function(t){return t.kid===n}))[0];else {if((t=r._filterByAlg(t,e.header.alg)).length>1)return i.Log.error("ResponseValidator._validateIdToken: No kid found in id_token and more than one key found in metadata"),Promise.reject(new Error("No kid found in id_token and more than one key found in metadata"));o=t[0];}return Promise.resolve(o)}))},t.prototype._getSigningKeyForJwtWithSingleRetry=function t(e){var r=this;return this._getSigningKeyForJwt(e).then((function(t){return t?Promise.resolve(t):(r._metadataService.resetSigningKeys(),r._getSigningKeyForJwt(e))}))},t.prototype._validateIdToken=function t(e,r){var n=this;if(!e.nonce)return i.Log.error("ResponseValidator._validateIdToken: No nonce on state"),Promise.reject(new Error("No nonce on state"));var o=this._joseUtil.parseJwt(r.id_token);return o&&o.header&&o.payload?e.nonce!==o.payload.nonce?(i.Log.error("ResponseValidator._validateIdToken: Invalid nonce in id_token"),Promise.reject(new Error("Invalid nonce in id_token"))):this._metadataService.getIssuer().then((function(t){return i.Log.debug("ResponseValidator._validateIdToken: Received issuer"),n._getSigningKeyForJwtWithSingleRetry(o).then((function(s){if(!s)return i.Log.error("ResponseValidator._validateIdToken: No key matching kid or alg found in signing keys"),Promise.reject(new Error("No key matching kid or alg found in signing keys"));var a=e.client_id,u=n._settings.clockSkew;return i.Log.debug("ResponseValidator._validateIdToken: Validaing JWT; using clock skew (in seconds) of: ",u),n._joseUtil.validateJwt(r.id_token,s,t,a,u).then((function(){return i.Log.debug("ResponseValidator._validateIdToken: JWT validation successful"),o.payload.sub?(r.profile=o.payload,r):(i.Log.error("ResponseValidator._validateIdToken: No sub present in id_token"),Promise.reject(new Error("No sub present in id_token")))}))}))})):(i.Log.error("ResponseValidator._validateIdToken: Failed to parse id_token",o),Promise.reject(new Error("Failed to parse id_token")))},t.prototype._filterByAlg=function t(e,r){var n=null;if(r.startsWith("RS"))n="RSA";else if(r.startsWith("PS"))n="PS";else {if(!r.startsWith("ES"))return i.Log.debug("ResponseValidator._filterByAlg: alg not supported: ",r),[];n="EC";}return i.Log.debug("ResponseValidator._filterByAlg: Looking for keys that match kty: ",n),e=e.filter((function(t){return t.kty===n})),i.Log.debug("ResponseValidator._filterByAlg: Number of keys that match kty: ",n,e.length),e},t.prototype._validateAccessToken=function t(e){if(!e.profile)return i.Log.error("ResponseValidator._validateAccessToken: No profile loaded from id_token"),Promise.reject(new Error("No profile loaded from id_token"));if(!e.profile.at_hash)return i.Log.error("ResponseValidator._validateAccessToken: No at_hash in id_token"),Promise.reject(new Error("No at_hash in id_token"));if(!e.id_token)return i.Log.error("ResponseValidator._validateAccessToken: No id_token"),Promise.reject(new Error("No id_token"));var r=this._joseUtil.parseJwt(e.id_token);if(!r||!r.header)return i.Log.error("ResponseValidator._validateAccessToken: Failed to parse id_token",r),Promise.reject(new Error("Failed to parse id_token"));var n=r.header.alg;if(!n||5!==n.length)return i.Log.error("ResponseValidator._validateAccessToken: Unsupported alg:",n),Promise.reject(new Error("Unsupported alg: "+n));var o=n.substr(2,3);if(!o)return i.Log.error("ResponseValidator._validateAccessToken: Unsupported alg:",n,o),Promise.reject(new Error("Unsupported alg: "+n));if(256!==(o=parseInt(o))&&384!==o&&512!==o)return i.Log.error("ResponseValidator._validateAccessToken: Unsupported alg:",n,o),Promise.reject(new Error("Unsupported alg: "+n));var s="sha"+o,a=this._joseUtil.hashString(e.access_token,s);if(!a)return i.Log.error("ResponseValidator._validateAccessToken: access_token hash failed:",s),Promise.reject(new Error("Failed to validate at_hash"));var u=a.substr(0,a.length/2),c=this._joseUtil.hexToBase64Url(u);return c!==e.profile.at_hash?(i.Log.error("ResponseValidator._validateAccessToken: Failed to validate at_hash",c,e.profile.at_hash),Promise.reject(new Error("Failed to validate at_hash"))):(i.Log.debug("ResponseValidator._validateAccessToken: success"),Promise.resolve(e))},t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.UserInfoService=void 0;var n=r(7),i=r(2),o=r(0),s=r(4);function a(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}e.UserInfoService=function(){function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.JsonService,u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:i.MetadataService,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:s.JoseUtil;if(a(this,t),!e)throw o.Log.error("UserInfoService.ctor: No settings passed"),new Error("settings");this._settings=e,this._jsonService=new r(void 0,void 0,this._getClaimsFromJwt.bind(this)),this._metadataService=new u(this._settings),this._joseUtil=c;}return t.prototype.getClaims=function t(e){var r=this;return e?this._metadataService.getUserInfoEndpoint().then((function(t){return o.Log.debug("UserInfoService.getClaims: received userinfo url",t),r._jsonService.getJson(t,e).then((function(t){return o.Log.debug("UserInfoService.getClaims: claims received",t),t}))})):(o.Log.error("UserInfoService.getClaims: No token passed"),Promise.reject(new Error("A token is required")))},t.prototype._getClaimsFromJwt=function t(e){var r=this;try{var n=this._joseUtil.parseJwt(e.responseText);if(!n||!n.header||!n.payload)return o.Log.error("UserInfoService._getClaimsFromJwt: Failed to parse JWT",n),Promise.reject(new Error("Failed to parse id_token"));var i=n.header.kid,s=void 0;switch(this._settings.userInfoJwtIssuer){case"OP":s=this._metadataService.getIssuer();break;case"ANY":s=Promise.resolve(n.payload.iss);break;default:s=Promise.resolve(this._settings.userInfoJwtIssuer);}return s.then((function(t){return o.Log.debug("UserInfoService._getClaimsFromJwt: Received issuer:"+t),r._metadataService.getSigningKeys().then((function(s){if(!s)return o.Log.error("UserInfoService._getClaimsFromJwt: No signing keys from metadata"),Promise.reject(new Error("No signing keys from metadata"));o.Log.debug("UserInfoService._getClaimsFromJwt: Received signing keys");var a=void 0;if(i)a=s.filter((function(t){return t.kid===i}))[0];else {if((s=r._filterByAlg(s,n.header.alg)).length>1)return o.Log.error("UserInfoService._getClaimsFromJwt: No kid found in id_token and more than one key found in metadata"),Promise.reject(new Error("No kid found in id_token and more than one key found in metadata"));a=s[0];}if(!a)return o.Log.error("UserInfoService._getClaimsFromJwt: No key matching kid or alg found in signing keys"),Promise.reject(new Error("No key matching kid or alg found in signing keys"));var u=r._settings.client_id,c=r._settings.clockSkew;return o.Log.debug("UserInfoService._getClaimsFromJwt: Validaing JWT; using clock skew (in seconds) of: ",c),r._joseUtil.validateJwt(e.responseText,a,t,u,c,void 0,!0).then((function(){return o.Log.debug("UserInfoService._getClaimsFromJwt: JWT validation successful"),n.payload}))}))}))}catch(t){return o.Log.error("UserInfoService._getClaimsFromJwt: Error parsing JWT response",t.message),void reject(t)}},t.prototype._filterByAlg=function t(e,r){var n=null;if(r.startsWith("RS"))n="RSA";else if(r.startsWith("PS"))n="PS";else {if(!r.startsWith("ES"))return o.Log.debug("UserInfoService._filterByAlg: alg not supported: ",r),[];n="EC";}return o.Log.debug("UserInfoService._filterByAlg: Looking for keys that match kty: ",n),e=e.filter((function(t){return t.kty===n})),o.Log.debug("UserInfoService._filterByAlg: Number of keys that match kty: ",n,e.length),e},t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.AllowedSigningAlgs=e.b64tohex=e.hextob64u=e.crypto=e.X509=e.KeyUtil=e.jws=void 0;var n=r(27);e.jws=n.jws,e.KeyUtil=n.KEYUTIL,e.X509=n.X509,e.crypto=n.crypto,e.hextob64u=n.hextob64u,e.b64tohex=n.b64tohex,e.AllowedSigningAlgs=["RS256","RS384","RS512","PS256","PS384","PS512","ES256","ES384","ES512"];},function(t,e,r){(function(t){Object.defineProperty(e,"__esModule",{value:!0});var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n={userAgent:!1},i={};
	/*!
	Copyright (c) 2011, Yahoo! Inc. All rights reserved.
	Code licensed under the BSD License:
	http://developer.yahoo.com/yui/license.html
	version: 2.9.0
	*/
	if(void 0===o)var o={};o.lang={extend:function t(e,r,i){if(!r||!e)throw new Error("YAHOO.lang.extend failed, please check that all dependencies are included.");var o=function t(){};if(o.prototype=r.prototype,e.prototype=new o,e.prototype.constructor=e,e.superclass=r.prototype,r.prototype.constructor==Object.prototype.constructor&&(r.prototype.constructor=r),i){var s;for(s in i)e.prototype[s]=i[s];var a=function t(){},u=["toString","valueOf"];try{/MSIE/.test(n.userAgent)&&(a=function t(e,r){for(s=0;s<u.length;s+=1){var n=u[s],i=r[n];"function"==typeof i&&i!=Object.prototype[n]&&(e[n]=i);}});}catch(t){}a(e.prototype,i);}}};
	/*! CryptoJS v3.1.2 core-fix.js
	 * code.google.com/p/crypto-js
	 * (c) 2009-2013 by Jeff Mott. All rights reserved.
	 * code.google.com/p/crypto-js/wiki/License
	 * THIS IS FIX of 'core.js' to fix Hmac issue.
	 * https://code.google.com/p/crypto-js/issues/detail?id=84
	 * https://crypto-js.googlecode.com/svn-history/r667/branches/3.x/src/core.js
	 */
	var s,a,u,c,h,l,f,g,d,p,v,y=y||(s=Math,u=(a={}).lib={},c=u.Base=function(){function t(){}return {extend:function e(r){t.prototype=this;var n=new t;return r&&n.mixIn(r),n.hasOwnProperty("init")||(n.init=function(){n.$super.init.apply(this,arguments);}),n.init.prototype=n,n.$super=this,n},create:function t(){var e=this.extend();return e.init.apply(e,arguments),e},init:function t(){},mixIn:function t(e){for(var r in e)e.hasOwnProperty(r)&&(this[r]=e[r]);e.hasOwnProperty("toString")&&(this.toString=e.toString);},clone:function t(){return this.init.prototype.extend(this)}}}(),h=u.WordArray=c.extend({init:function t(e,r){e=this.words=e||[],this.sigBytes=null!=r?r:4*e.length;},toString:function t(e){return (e||f).stringify(this)},concat:function t(e){var r=this.words,n=e.words,i=this.sigBytes,o=e.sigBytes;if(this.clamp(),i%4)for(var s=0;s<o;s++){var a=n[s>>>2]>>>24-s%4*8&255;r[i+s>>>2]|=a<<24-(i+s)%4*8;}else for(s=0;s<o;s+=4)r[i+s>>>2]=n[s>>>2];return this.sigBytes+=o,this},clamp:function t(){var e=this.words,r=this.sigBytes;e[r>>>2]&=4294967295<<32-r%4*8,e.length=s.ceil(r/4);},clone:function t(){var e=c.clone.call(this);return e.words=this.words.slice(0),e},random:function t(e){for(var r=[],n=0;n<e;n+=4)r.push(4294967296*s.random()|0);return new h.init(r,e)}}),l=a.enc={},f=l.Hex={stringify:function t(e){for(var r=e.words,n=e.sigBytes,i=[],o=0;o<n;o++){var s=r[o>>>2]>>>24-o%4*8&255;i.push((s>>>4).toString(16)),i.push((15&s).toString(16));}return i.join("")},parse:function t(e){for(var r=e.length,n=[],i=0;i<r;i+=2)n[i>>>3]|=parseInt(e.substr(i,2),16)<<24-i%8*4;return new h.init(n,r/2)}},g=l.Latin1={stringify:function t(e){for(var r=e.words,n=e.sigBytes,i=[],o=0;o<n;o++){var s=r[o>>>2]>>>24-o%4*8&255;i.push(String.fromCharCode(s));}return i.join("")},parse:function t(e){for(var r=e.length,n=[],i=0;i<r;i++)n[i>>>2]|=(255&e.charCodeAt(i))<<24-i%4*8;return new h.init(n,r)}},d=l.Utf8={stringify:function t(e){try{return decodeURIComponent(escape(g.stringify(e)))}catch(t){throw new Error("Malformed UTF-8 data")}},parse:function t(e){return g.parse(unescape(encodeURIComponent(e)))}},p=u.BufferedBlockAlgorithm=c.extend({reset:function t(){this._data=new h.init,this._nDataBytes=0;},_append:function t(e){"string"==typeof e&&(e=d.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes;},_process:function t(e){var r=this._data,n=r.words,i=r.sigBytes,o=this.blockSize,a=i/(4*o),u=(a=e?s.ceil(a):s.max((0|a)-this._minBufferSize,0))*o,c=s.min(4*u,i);if(u){for(var l=0;l<u;l+=o)this._doProcessBlock(n,l);var f=n.splice(0,u);r.sigBytes-=c;}return new h.init(f,c)},clone:function t(){var e=c.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0}),u.Hasher=p.extend({cfg:c.extend(),init:function t(e){this.cfg=this.cfg.extend(e),this.reset();},reset:function t(){p.reset.call(this),this._doReset();},update:function t(e){return this._append(e),this._process(),this},finalize:function t(e){return e&&this._append(e),this._doFinalize()},blockSize:16,_createHelper:function t(e){return function(t,r){return new e.init(r).finalize(t)}},_createHmacHelper:function t(e){return function(t,r){return new v.HMAC.init(e,r).finalize(t)}}}),v=a.algo={},a);!function(t){var e,r=(e=y).lib,n=r.Base,i=r.WordArray;(e=e.x64={}).Word=n.extend({init:function t(e,r){this.high=e,this.low=r;}}),e.WordArray=n.extend({init:function t(e,r){e=this.words=e||[],this.sigBytes=null!=r?r:8*e.length;},toX32:function t(){for(var e=this.words,r=e.length,n=[],o=0;o<r;o++){var s=e[o];n.push(s.high),n.push(s.low);}return i.create(n,this.sigBytes)},clone:function t(){for(var e=n.clone.call(this),r=e.words=this.words.slice(0),i=r.length,o=0;o<i;o++)r[o]=r[o].clone();return e}});}(),function(){var t=y,e=t.lib.WordArray;t.enc.Base64={stringify:function t(e){var r=e.words,n=e.sigBytes,i=this._map;e.clamp(),e=[];for(var o=0;o<n;o+=3)for(var s=(r[o>>>2]>>>24-o%4*8&255)<<16|(r[o+1>>>2]>>>24-(o+1)%4*8&255)<<8|r[o+2>>>2]>>>24-(o+2)%4*8&255,a=0;4>a&&o+.75*a<n;a++)e.push(i.charAt(s>>>6*(3-a)&63));if(r=i.charAt(64))for(;e.length%4;)e.push(r);return e.join("")},parse:function t(r){var n=r.length,i=this._map;(o=i.charAt(64))&&(-1!=(o=r.indexOf(o))&&(n=o));for(var o=[],s=0,a=0;a<n;a++)if(a%4){var u=i.indexOf(r.charAt(a-1))<<a%4*2,c=i.indexOf(r.charAt(a))>>>6-a%4*2;o[s>>>2]|=(u|c)<<24-s%4*8,s++;}return e.create(o,s)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="};}(),function(t){for(var e=y,r=(i=e.lib).WordArray,n=i.Hasher,i=e.algo,o=[],s=[],a=function t(e){return 4294967296*(e-(0|e))|0},u=2,c=0;64>c;){var h;t:{h=u;for(var l=t.sqrt(h),f=2;f<=l;f++)if(!(h%f)){h=!1;break t}h=!0;}h&&(8>c&&(o[c]=a(t.pow(u,.5))),s[c]=a(t.pow(u,1/3)),c++),u++;}var g=[];i=i.SHA256=n.extend({_doReset:function t(){this._hash=new r.init(o.slice(0));},_doProcessBlock:function t(e,r){for(var n=this._hash.words,i=n[0],o=n[1],a=n[2],u=n[3],c=n[4],h=n[5],l=n[6],f=n[7],d=0;64>d;d++){if(16>d)g[d]=0|e[r+d];else {var p=g[d-15],v=g[d-2];g[d]=((p<<25|p>>>7)^(p<<14|p>>>18)^p>>>3)+g[d-7]+((v<<15|v>>>17)^(v<<13|v>>>19)^v>>>10)+g[d-16];}p=f+((c<<26|c>>>6)^(c<<21|c>>>11)^(c<<7|c>>>25))+(c&h^~c&l)+s[d]+g[d],v=((i<<30|i>>>2)^(i<<19|i>>>13)^(i<<10|i>>>22))+(i&o^i&a^o&a),f=l,l=h,h=c,c=u+p|0,u=a,a=o,o=i,i=p+v|0;}n[0]=n[0]+i|0,n[1]=n[1]+o|0,n[2]=n[2]+a|0,n[3]=n[3]+u|0,n[4]=n[4]+c|0,n[5]=n[5]+h|0,n[6]=n[6]+l|0,n[7]=n[7]+f|0;},_doFinalize:function e(){var r=this._data,n=r.words,i=8*this._nDataBytes,o=8*r.sigBytes;return n[o>>>5]|=128<<24-o%32,n[14+(o+64>>>9<<4)]=t.floor(i/4294967296),n[15+(o+64>>>9<<4)]=i,r.sigBytes=4*n.length,this._process(),this._hash},clone:function t(){var e=n.clone.call(this);return e._hash=this._hash.clone(),e}});e.SHA256=n._createHelper(i),e.HmacSHA256=n._createHmacHelper(i);}(Math),function(){function t(){return n.create.apply(n,arguments)}for(var e=y,r=e.lib.Hasher,n=(o=e.x64).Word,i=o.WordArray,o=e.algo,s=[t(1116352408,3609767458),t(1899447441,602891725),t(3049323471,3964484399),t(3921009573,2173295548),t(961987163,4081628472),t(1508970993,3053834265),t(2453635748,2937671579),t(2870763221,3664609560),t(3624381080,2734883394),t(310598401,1164996542),t(607225278,1323610764),t(1426881987,3590304994),t(1925078388,4068182383),t(2162078206,991336113),t(2614888103,633803317),t(3248222580,3479774868),t(3835390401,2666613458),t(4022224774,944711139),t(264347078,2341262773),t(604807628,2007800933),t(770255983,1495990901),t(1249150122,1856431235),t(1555081692,3175218132),t(1996064986,2198950837),t(2554220882,3999719339),t(2821834349,766784016),t(2952996808,2566594879),t(3210313671,3203337956),t(3336571891,1034457026),t(3584528711,2466948901),t(113926993,3758326383),t(338241895,168717936),t(666307205,1188179964),t(773529912,1546045734),t(1294757372,1522805485),t(1396182291,2643833823),t(1695183700,2343527390),t(1986661051,1014477480),t(2177026350,1206759142),t(2456956037,344077627),t(2730485921,1290863460),t(2820302411,3158454273),t(3259730800,3505952657),t(3345764771,106217008),t(3516065817,3606008344),t(3600352804,1432725776),t(4094571909,1467031594),t(275423344,851169720),t(430227734,3100823752),t(506948616,1363258195),t(659060556,3750685593),t(883997877,3785050280),t(958139571,3318307427),t(1322822218,3812723403),t(1537002063,2003034995),t(1747873779,3602036899),t(1955562222,1575990012),t(2024104815,1125592928),t(2227730452,2716904306),t(2361852424,442776044),t(2428436474,593698344),t(2756734187,3733110249),t(3204031479,2999351573),t(3329325298,3815920427),t(3391569614,3928383900),t(3515267271,566280711),t(3940187606,3454069534),t(4118630271,4000239992),t(116418474,1914138554),t(174292421,2731055270),t(289380356,3203993006),t(460393269,320620315),t(685471733,587496836),t(852142971,1086792851),t(1017036298,365543100),t(1126000580,2618297676),t(1288033470,3409855158),t(1501505948,4234509866),t(1607167915,987167468),t(1816402316,1246189591)],a=[],u=0;80>u;u++)a[u]=t();o=o.SHA512=r.extend({_doReset:function t(){this._hash=new i.init([new n.init(1779033703,4089235720),new n.init(3144134277,2227873595),new n.init(1013904242,4271175723),new n.init(2773480762,1595750129),new n.init(1359893119,2917565137),new n.init(2600822924,725511199),new n.init(528734635,4215389547),new n.init(1541459225,327033209)]);},_doProcessBlock:function t(e,r){for(var n=(f=this._hash.words)[0],i=f[1],o=f[2],u=f[3],c=f[4],h=f[5],l=f[6],f=f[7],g=n.high,d=n.low,p=i.high,v=i.low,y=o.high,m=o.low,_=u.high,S=u.low,b=c.high,w=c.low,F=h.high,E=h.low,x=l.high,A=l.low,k=f.high,P=f.low,C=g,T=d,R=p,I=v,D=y,L=m,N=_,U=S,B=b,O=w,j=F,M=E,H=x,V=A,K=k,q=P,J=0;80>J;J++){var W=a[J];if(16>J)var z=W.high=0|e[r+2*J],Y=W.low=0|e[r+2*J+1];else {z=((Y=(z=a[J-15]).high)>>>1|(G=z.low)<<31)^(Y>>>8|G<<24)^Y>>>7;var G=(G>>>1|Y<<31)^(G>>>8|Y<<24)^(G>>>7|Y<<25),X=((Y=(X=a[J-2]).high)>>>19|($=X.low)<<13)^(Y<<3|$>>>29)^Y>>>6,$=($>>>19|Y<<13)^($<<3|Y>>>29)^($>>>6|Y<<26),Q=(Y=a[J-7]).high,Z=(tt=a[J-16]).high,tt=tt.low;z=(z=(z=z+Q+((Y=G+Y.low)>>>0<G>>>0?1:0))+X+((Y=Y+$)>>>0<$>>>0?1:0))+Z+((Y=Y+tt)>>>0<tt>>>0?1:0);W.high=z,W.low=Y;}Q=B&j^~B&H,tt=O&M^~O&V,W=C&R^C&D^R&D;var et=T&I^T&L^I&L,rt=(G=(C>>>28|T<<4)^(C<<30|T>>>2)^(C<<25|T>>>7),X=(T>>>28|C<<4)^(T<<30|C>>>2)^(T<<25|C>>>7),($=s[J]).high),nt=$.low;Z=K+((B>>>14|O<<18)^(B>>>18|O<<14)^(B<<23|O>>>9))+(($=q+((O>>>14|B<<18)^(O>>>18|B<<14)^(O<<23|B>>>9)))>>>0<q>>>0?1:0),K=H,q=V,H=j,V=M,j=B,M=O,B=N+(Z=(Z=(Z=Z+Q+(($=$+tt)>>>0<tt>>>0?1:0))+rt+(($=$+nt)>>>0<nt>>>0?1:0))+z+(($=$+Y)>>>0<Y>>>0?1:0))+((O=U+$|0)>>>0<U>>>0?1:0)|0,N=D,U=L,D=R,L=I,R=C,I=T,C=Z+(W=G+W+((Y=X+et)>>>0<X>>>0?1:0))+((T=$+Y|0)>>>0<$>>>0?1:0)|0;}d=n.low=d+T,n.high=g+C+(d>>>0<T>>>0?1:0),v=i.low=v+I,i.high=p+R+(v>>>0<I>>>0?1:0),m=o.low=m+L,o.high=y+D+(m>>>0<L>>>0?1:0),S=u.low=S+U,u.high=_+N+(S>>>0<U>>>0?1:0),w=c.low=w+O,c.high=b+B+(w>>>0<O>>>0?1:0),E=h.low=E+M,h.high=F+j+(E>>>0<M>>>0?1:0),A=l.low=A+V,l.high=x+H+(A>>>0<V>>>0?1:0),P=f.low=P+q,f.high=k+K+(P>>>0<q>>>0?1:0);},_doFinalize:function t(){var e=this._data,r=e.words,n=8*this._nDataBytes,i=8*e.sigBytes;return r[i>>>5]|=128<<24-i%32,r[30+(i+128>>>10<<5)]=Math.floor(n/4294967296),r[31+(i+128>>>10<<5)]=n,e.sigBytes=4*r.length,this._process(),this._hash.toX32()},clone:function t(){var e=r.clone.call(this);return e._hash=this._hash.clone(),e},blockSize:32}),e.SHA512=r._createHelper(o),e.HmacSHA512=r._createHmacHelper(o);}(),function(){var t=y,e=(i=t.x64).Word,r=i.WordArray,n=(i=t.algo).SHA512,i=i.SHA384=n.extend({_doReset:function t(){this._hash=new r.init([new e.init(3418070365,3238371032),new e.init(1654270250,914150663),new e.init(2438529370,812702999),new e.init(355462360,4144912697),new e.init(1731405415,4290775857),new e.init(2394180231,1750603025),new e.init(3675008525,1694076839),new e.init(1203062813,3204075428)]);},_doFinalize:function t(){var e=n._doFinalize.call(this);return e.sigBytes-=16,e}});t.SHA384=n._createHelper(i),t.HmacSHA384=n._createHmacHelper(i);}();
	/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
	 */
	var m,_="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";function S(t){var e,r,n="";for(e=0;e+3<=t.length;e+=3)r=parseInt(t.substring(e,e+3),16),n+=_.charAt(r>>6)+_.charAt(63&r);for(e+1==t.length?(r=parseInt(t.substring(e,e+1),16),n+=_.charAt(r<<2)):e+2==t.length&&(r=parseInt(t.substring(e,e+2),16),n+=_.charAt(r>>2)+_.charAt((3&r)<<4)),"=";(3&n.length)>0;)n+="=";return n}function b(t){var e,r,n,i="",o=0;for(e=0;e<t.length&&"="!=t.charAt(e);++e)(n=_.indexOf(t.charAt(e)))<0||(0==o?(i+=R(n>>2),r=3&n,o=1):1==o?(i+=R(r<<2|n>>4),r=15&n,o=2):2==o?(i+=R(r),i+=R(n>>2),r=3&n,o=3):(i+=R(r<<2|n>>4),i+=R(15&n),o=0));return 1==o&&(i+=R(r<<2)),i}function w(t){var e,r=b(t),n=new Array;for(e=0;2*e<r.length;++e)n[e]=parseInt(r.substring(2*e,2*e+2),16);return n}function F(t,e,r){null!=t&&("number"==typeof t?this.fromNumber(t,e,r):null==e&&"string"!=typeof t?this.fromString(t,256):this.fromString(t,e));}function E(){return new F(null)}"Microsoft Internet Explorer"==n.appName?(F.prototype.am=function x(t,e,r,n,i,o){for(var s=32767&e,a=e>>15;--o>=0;){var u=32767&this[t],c=this[t++]>>15,h=a*u+c*s;i=((u=s*u+((32767&h)<<15)+r[n]+(1073741823&i))>>>30)+(h>>>15)+a*c+(i>>>30),r[n++]=1073741823&u;}return i},m=30):"Netscape"!=n.appName?(F.prototype.am=function A(t,e,r,n,i,o){for(;--o>=0;){var s=e*this[t++]+r[n]+i;i=Math.floor(s/67108864),r[n++]=67108863&s;}return i},m=26):(F.prototype.am=function k(t,e,r,n,i,o){for(var s=16383&e,a=e>>14;--o>=0;){var u=16383&this[t],c=this[t++]>>14,h=a*u+c*s;i=((u=s*u+((16383&h)<<14)+r[n]+i)>>28)+(h>>14)+a*c,r[n++]=268435455&u;}return i},m=28),F.prototype.DB=m,F.prototype.DM=(1<<m)-1,F.prototype.DV=1<<m;F.prototype.FV=Math.pow(2,52),F.prototype.F1=52-m,F.prototype.F2=2*m-52;var P,C,T=new Array;for(P="0".charCodeAt(0),C=0;C<=9;++C)T[P++]=C;for(P="a".charCodeAt(0),C=10;C<36;++C)T[P++]=C;for(P="A".charCodeAt(0),C=10;C<36;++C)T[P++]=C;function R(t){return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(t)}function I(t,e){var r=T[t.charCodeAt(e)];return null==r?-1:r}function D(t){var e=E();return e.fromInt(t),e}function L(t){var e,r=1;return 0!=(e=t>>>16)&&(t=e,r+=16),0!=(e=t>>8)&&(t=e,r+=8),0!=(e=t>>4)&&(t=e,r+=4),0!=(e=t>>2)&&(t=e,r+=2),0!=(e=t>>1)&&(t=e,r+=1),r}function N(t){this.m=t;}function U(t){this.m=t,this.mp=t.invDigit(),this.mpl=32767&this.mp,this.mph=this.mp>>15,this.um=(1<<t.DB-15)-1,this.mt2=2*t.t;}function B(t,e){return t&e}function O(t,e){return t|e}function j(t,e){return t^e}function M(t,e){return t&~e}function H(t){if(0==t)return -1;var e=0;return 0==(65535&t)&&(t>>=16,e+=16),0==(255&t)&&(t>>=8,e+=8),0==(15&t)&&(t>>=4,e+=4),0==(3&t)&&(t>>=2,e+=2),0==(1&t)&&++e,e}function V(t){for(var e=0;0!=t;)t&=t-1,++e;return e}function K(){}function q(t){return t}function J(t){this.r2=E(),this.q3=E(),F.ONE.dlShiftTo(2*t.t,this.r2),this.mu=this.r2.divide(t),this.m=t;}N.prototype.convert=function W(t){return t.s<0||t.compareTo(this.m)>=0?t.mod(this.m):t},N.prototype.revert=function z(t){return t},N.prototype.reduce=function Y(t){t.divRemTo(this.m,null,t);},N.prototype.mulTo=function G(t,e,r){t.multiplyTo(e,r),this.reduce(r);},N.prototype.sqrTo=function X(t,e){t.squareTo(e),this.reduce(e);},U.prototype.convert=function $(t){var e=E();return t.abs().dlShiftTo(this.m.t,e),e.divRemTo(this.m,null,e),t.s<0&&e.compareTo(F.ZERO)>0&&this.m.subTo(e,e),e},U.prototype.revert=function Q(t){var e=E();return t.copyTo(e),this.reduce(e),e},U.prototype.reduce=function Z(t){for(;t.t<=this.mt2;)t[t.t++]=0;for(var e=0;e<this.m.t;++e){var r=32767&t[e],n=r*this.mpl+((r*this.mph+(t[e]>>15)*this.mpl&this.um)<<15)&t.DM;for(t[r=e+this.m.t]+=this.m.am(0,n,t,e,0,this.m.t);t[r]>=t.DV;)t[r]-=t.DV,t[++r]++;}t.clamp(),t.drShiftTo(this.m.t,t),t.compareTo(this.m)>=0&&t.subTo(this.m,t);},U.prototype.mulTo=function tt(t,e,r){t.multiplyTo(e,r),this.reduce(r);},U.prototype.sqrTo=function et(t,e){t.squareTo(e),this.reduce(e);},F.prototype.copyTo=function rt(t){for(var e=this.t-1;e>=0;--e)t[e]=this[e];t.t=this.t,t.s=this.s;},F.prototype.fromInt=function nt(t){this.t=1,this.s=t<0?-1:0,t>0?this[0]=t:t<-1?this[0]=t+this.DV:this.t=0;},F.prototype.fromString=function it(t,e){var r;if(16==e)r=4;else if(8==e)r=3;else if(256==e)r=8;else if(2==e)r=1;else if(32==e)r=5;else {if(4!=e)return void this.fromRadix(t,e);r=2;}this.t=0,this.s=0;for(var n=t.length,i=!1,o=0;--n>=0;){var s=8==r?255&t[n]:I(t,n);s<0?"-"==t.charAt(n)&&(i=!0):(i=!1,0==o?this[this.t++]=s:o+r>this.DB?(this[this.t-1]|=(s&(1<<this.DB-o)-1)<<o,this[this.t++]=s>>this.DB-o):this[this.t-1]|=s<<o,(o+=r)>=this.DB&&(o-=this.DB));}8==r&&0!=(128&t[0])&&(this.s=-1,o>0&&(this[this.t-1]|=(1<<this.DB-o)-1<<o)),this.clamp(),i&&F.ZERO.subTo(this,this);},F.prototype.clamp=function ot(){for(var t=this.s&this.DM;this.t>0&&this[this.t-1]==t;)--this.t;},F.prototype.dlShiftTo=function st(t,e){var r;for(r=this.t-1;r>=0;--r)e[r+t]=this[r];for(r=t-1;r>=0;--r)e[r]=0;e.t=this.t+t,e.s=this.s;},F.prototype.drShiftTo=function at(t,e){for(var r=t;r<this.t;++r)e[r-t]=this[r];e.t=Math.max(this.t-t,0),e.s=this.s;},F.prototype.lShiftTo=function ut(t,e){var r,n=t%this.DB,i=this.DB-n,o=(1<<i)-1,s=Math.floor(t/this.DB),a=this.s<<n&this.DM;for(r=this.t-1;r>=0;--r)e[r+s+1]=this[r]>>i|a,a=(this[r]&o)<<n;for(r=s-1;r>=0;--r)e[r]=0;e[s]=a,e.t=this.t+s+1,e.s=this.s,e.clamp();},F.prototype.rShiftTo=function ct(t,e){e.s=this.s;var r=Math.floor(t/this.DB);if(r>=this.t)e.t=0;else {var n=t%this.DB,i=this.DB-n,o=(1<<n)-1;e[0]=this[r]>>n;for(var s=r+1;s<this.t;++s)e[s-r-1]|=(this[s]&o)<<i,e[s-r]=this[s]>>n;n>0&&(e[this.t-r-1]|=(this.s&o)<<i),e.t=this.t-r,e.clamp();}},F.prototype.subTo=function ht(t,e){for(var r=0,n=0,i=Math.min(t.t,this.t);r<i;)n+=this[r]-t[r],e[r++]=n&this.DM,n>>=this.DB;if(t.t<this.t){for(n-=t.s;r<this.t;)n+=this[r],e[r++]=n&this.DM,n>>=this.DB;n+=this.s;}else {for(n+=this.s;r<t.t;)n-=t[r],e[r++]=n&this.DM,n>>=this.DB;n-=t.s;}e.s=n<0?-1:0,n<-1?e[r++]=this.DV+n:n>0&&(e[r++]=n),e.t=r,e.clamp();},F.prototype.multiplyTo=function lt(t,e){var r=this.abs(),n=t.abs(),i=r.t;for(e.t=i+n.t;--i>=0;)e[i]=0;for(i=0;i<n.t;++i)e[i+r.t]=r.am(0,n[i],e,i,0,r.t);e.s=0,e.clamp(),this.s!=t.s&&F.ZERO.subTo(e,e);},F.prototype.squareTo=function ft(t){for(var e=this.abs(),r=t.t=2*e.t;--r>=0;)t[r]=0;for(r=0;r<e.t-1;++r){var n=e.am(r,e[r],t,2*r,0,1);(t[r+e.t]+=e.am(r+1,2*e[r],t,2*r+1,n,e.t-r-1))>=e.DV&&(t[r+e.t]-=e.DV,t[r+e.t+1]=1);}t.t>0&&(t[t.t-1]+=e.am(r,e[r],t,2*r,0,1)),t.s=0,t.clamp();},F.prototype.divRemTo=function gt(t,e,r){var n=t.abs();if(!(n.t<=0)){var i=this.abs();if(i.t<n.t)return null!=e&&e.fromInt(0),void(null!=r&&this.copyTo(r));null==r&&(r=E());var o=E(),s=this.s,a=t.s,u=this.DB-L(n[n.t-1]);u>0?(n.lShiftTo(u,o),i.lShiftTo(u,r)):(n.copyTo(o),i.copyTo(r));var c=o.t,h=o[c-1];if(0!=h){var l=h*(1<<this.F1)+(c>1?o[c-2]>>this.F2:0),f=this.FV/l,g=(1<<this.F1)/l,d=1<<this.F2,p=r.t,v=p-c,y=null==e?E():e;for(o.dlShiftTo(v,y),r.compareTo(y)>=0&&(r[r.t++]=1,r.subTo(y,r)),F.ONE.dlShiftTo(c,y),y.subTo(o,o);o.t<c;)o[o.t++]=0;for(;--v>=0;){var m=r[--p]==h?this.DM:Math.floor(r[p]*f+(r[p-1]+d)*g);if((r[p]+=o.am(0,m,r,v,0,c))<m)for(o.dlShiftTo(v,y),r.subTo(y,r);r[p]<--m;)r.subTo(y,r);}null!=e&&(r.drShiftTo(c,e),s!=a&&F.ZERO.subTo(e,e)),r.t=c,r.clamp(),u>0&&r.rShiftTo(u,r),s<0&&F.ZERO.subTo(r,r);}}},F.prototype.invDigit=function dt(){if(this.t<1)return 0;var t=this[0];if(0==(1&t))return 0;var e=3&t;return (e=(e=(e=(e=e*(2-(15&t)*e)&15)*(2-(255&t)*e)&255)*(2-((65535&t)*e&65535))&65535)*(2-t*e%this.DV)%this.DV)>0?this.DV-e:-e},F.prototype.isEven=function pt(){return 0==(this.t>0?1&this[0]:this.s)},F.prototype.exp=function vt(t,e){if(t>4294967295||t<1)return F.ONE;var r=E(),n=E(),i=e.convert(this),o=L(t)-1;for(i.copyTo(r);--o>=0;)if(e.sqrTo(r,n),(t&1<<o)>0)e.mulTo(n,i,r);else {var s=r;r=n,n=s;}return e.revert(r)},F.prototype.toString=function yt(t){if(this.s<0)return "-"+this.negate().toString(t);var e;if(16==t)e=4;else if(8==t)e=3;else if(2==t)e=1;else if(32==t)e=5;else {if(4!=t)return this.toRadix(t);e=2;}var r,n=(1<<e)-1,i=!1,o="",s=this.t,a=this.DB-s*this.DB%e;if(s-- >0)for(a<this.DB&&(r=this[s]>>a)>0&&(i=!0,o=R(r));s>=0;)a<e?(r=(this[s]&(1<<a)-1)<<e-a,r|=this[--s]>>(a+=this.DB-e)):(r=this[s]>>(a-=e)&n,a<=0&&(a+=this.DB,--s)),r>0&&(i=!0),i&&(o+=R(r));return i?o:"0"},F.prototype.negate=function mt(){var t=E();return F.ZERO.subTo(this,t),t},F.prototype.abs=function _t(){return this.s<0?this.negate():this},F.prototype.compareTo=function St(t){var e=this.s-t.s;if(0!=e)return e;var r=this.t;if(0!=(e=r-t.t))return this.s<0?-e:e;for(;--r>=0;)if(0!=(e=this[r]-t[r]))return e;return 0},F.prototype.bitLength=function bt(){return this.t<=0?0:this.DB*(this.t-1)+L(this[this.t-1]^this.s&this.DM)},F.prototype.mod=function wt(t){var e=E();return this.abs().divRemTo(t,null,e),this.s<0&&e.compareTo(F.ZERO)>0&&t.subTo(e,e),e},F.prototype.modPowInt=function Ft(t,e){var r;return r=t<256||e.isEven()?new N(e):new U(e),this.exp(t,r)},F.ZERO=D(0),F.ONE=D(1),K.prototype.convert=q,K.prototype.revert=q,K.prototype.mulTo=function Et(t,e,r){t.multiplyTo(e,r);},K.prototype.sqrTo=function xt(t,e){t.squareTo(e);},J.prototype.convert=function At(t){if(t.s<0||t.t>2*this.m.t)return t.mod(this.m);if(t.compareTo(this.m)<0)return t;var e=E();return t.copyTo(e),this.reduce(e),e},J.prototype.revert=function kt(t){return t},J.prototype.reduce=function Pt(t){for(t.drShiftTo(this.m.t-1,this.r2),t.t>this.m.t+1&&(t.t=this.m.t+1,t.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);t.compareTo(this.r2)<0;)t.dAddOffset(1,this.m.t+1);for(t.subTo(this.r2,t);t.compareTo(this.m)>=0;)t.subTo(this.m,t);},J.prototype.mulTo=function Ct(t,e,r){t.multiplyTo(e,r),this.reduce(r);},J.prototype.sqrTo=function Tt(t,e){t.squareTo(e),this.reduce(e);};var Rt=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997],It=(1<<26)/Rt[Rt.length-1];
	/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
	 */
	function Dt(){this.i=0,this.j=0,this.S=new Array;}F.prototype.chunkSize=function Lt(t){return Math.floor(Math.LN2*this.DB/Math.log(t))},F.prototype.toRadix=function Nt(t){if(null==t&&(t=10),0==this.signum()||t<2||t>36)return "0";var e=this.chunkSize(t),r=Math.pow(t,e),n=D(r),i=E(),o=E(),s="";for(this.divRemTo(n,i,o);i.signum()>0;)s=(r+o.intValue()).toString(t).substr(1)+s,i.divRemTo(n,i,o);return o.intValue().toString(t)+s},F.prototype.fromRadix=function Ut(t,e){this.fromInt(0),null==e&&(e=10);for(var r=this.chunkSize(e),n=Math.pow(e,r),i=!1,o=0,s=0,a=0;a<t.length;++a){var u=I(t,a);u<0?"-"==t.charAt(a)&&0==this.signum()&&(i=!0):(s=e*s+u,++o>=r&&(this.dMultiply(n),this.dAddOffset(s,0),o=0,s=0));}o>0&&(this.dMultiply(Math.pow(e,o)),this.dAddOffset(s,0)),i&&F.ZERO.subTo(this,this);},F.prototype.fromNumber=function Bt(t,e,r){if("number"==typeof e)if(t<2)this.fromInt(1);else for(this.fromNumber(t,r),this.testBit(t-1)||this.bitwiseTo(F.ONE.shiftLeft(t-1),O,this),this.isEven()&&this.dAddOffset(1,0);!this.isProbablePrime(e);)this.dAddOffset(2,0),this.bitLength()>t&&this.subTo(F.ONE.shiftLeft(t-1),this);else {var n=new Array,i=7&t;n.length=1+(t>>3),e.nextBytes(n),i>0?n[0]&=(1<<i)-1:n[0]=0,this.fromString(n,256);}},F.prototype.bitwiseTo=function Ot(t,e,r){var n,i,o=Math.min(t.t,this.t);for(n=0;n<o;++n)r[n]=e(this[n],t[n]);if(t.t<this.t){for(i=t.s&this.DM,n=o;n<this.t;++n)r[n]=e(this[n],i);r.t=this.t;}else {for(i=this.s&this.DM,n=o;n<t.t;++n)r[n]=e(i,t[n]);r.t=t.t;}r.s=e(this.s,t.s),r.clamp();},F.prototype.changeBit=function jt(t,e){var r=F.ONE.shiftLeft(t);return this.bitwiseTo(r,e,r),r},F.prototype.addTo=function Mt(t,e){for(var r=0,n=0,i=Math.min(t.t,this.t);r<i;)n+=this[r]+t[r],e[r++]=n&this.DM,n>>=this.DB;if(t.t<this.t){for(n+=t.s;r<this.t;)n+=this[r],e[r++]=n&this.DM,n>>=this.DB;n+=this.s;}else {for(n+=this.s;r<t.t;)n+=t[r],e[r++]=n&this.DM,n>>=this.DB;n+=t.s;}e.s=n<0?-1:0,n>0?e[r++]=n:n<-1&&(e[r++]=this.DV+n),e.t=r,e.clamp();},F.prototype.dMultiply=function Ht(t){this[this.t]=this.am(0,t-1,this,0,0,this.t),++this.t,this.clamp();},F.prototype.dAddOffset=function Vt(t,e){if(0!=t){for(;this.t<=e;)this[this.t++]=0;for(this[e]+=t;this[e]>=this.DV;)this[e]-=this.DV,++e>=this.t&&(this[this.t++]=0),++this[e];}},F.prototype.multiplyLowerTo=function Kt(t,e,r){var n,i=Math.min(this.t+t.t,e);for(r.s=0,r.t=i;i>0;)r[--i]=0;for(n=r.t-this.t;i<n;++i)r[i+this.t]=this.am(0,t[i],r,i,0,this.t);for(n=Math.min(t.t,e);i<n;++i)this.am(0,t[i],r,i,0,e-i);r.clamp();},F.prototype.multiplyUpperTo=function qt(t,e,r){--e;var n=r.t=this.t+t.t-e;for(r.s=0;--n>=0;)r[n]=0;for(n=Math.max(e-this.t,0);n<t.t;++n)r[this.t+n-e]=this.am(e-n,t[n],r,0,0,this.t+n-e);r.clamp(),r.drShiftTo(1,r);},F.prototype.modInt=function Jt(t){if(t<=0)return 0;var e=this.DV%t,r=this.s<0?t-1:0;if(this.t>0)if(0==e)r=this[0]%t;else for(var n=this.t-1;n>=0;--n)r=(e*r+this[n])%t;return r},F.prototype.millerRabin=function Wt(t){var e=this.subtract(F.ONE),r=e.getLowestSetBit();if(r<=0)return !1;var n=e.shiftRight(r);(t=t+1>>1)>Rt.length&&(t=Rt.length);for(var i=E(),o=0;o<t;++o){i.fromInt(Rt[Math.floor(Math.random()*Rt.length)]);var s=i.modPow(n,this);if(0!=s.compareTo(F.ONE)&&0!=s.compareTo(e)){for(var a=1;a++<r&&0!=s.compareTo(e);)if(0==(s=s.modPowInt(2,this)).compareTo(F.ONE))return !1;if(0!=s.compareTo(e))return !1}}return !0},F.prototype.clone=
	/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
	 */
	function zt(){var t=E();return this.copyTo(t),t},F.prototype.intValue=function Yt(){if(this.s<0){if(1==this.t)return this[0]-this.DV;if(0==this.t)return -1}else {if(1==this.t)return this[0];if(0==this.t)return 0}return (this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]},F.prototype.byteValue=function Gt(){return 0==this.t?this.s:this[0]<<24>>24},F.prototype.shortValue=function Xt(){return 0==this.t?this.s:this[0]<<16>>16},F.prototype.signum=function $t(){return this.s<0?-1:this.t<=0||1==this.t&&this[0]<=0?0:1},F.prototype.toByteArray=function Qt(){var t=this.t,e=new Array;e[0]=this.s;var r,n=this.DB-t*this.DB%8,i=0;if(t-- >0)for(n<this.DB&&(r=this[t]>>n)!=(this.s&this.DM)>>n&&(e[i++]=r|this.s<<this.DB-n);t>=0;)n<8?(r=(this[t]&(1<<n)-1)<<8-n,r|=this[--t]>>(n+=this.DB-8)):(r=this[t]>>(n-=8)&255,n<=0&&(n+=this.DB,--t)),0!=(128&r)&&(r|=-256),0==i&&(128&this.s)!=(128&r)&&++i,(i>0||r!=this.s)&&(e[i++]=r);return e},F.prototype.equals=function Zt(t){return 0==this.compareTo(t)},F.prototype.min=function te(t){return this.compareTo(t)<0?this:t},F.prototype.max=function ee(t){return this.compareTo(t)>0?this:t},F.prototype.and=function re(t){var e=E();return this.bitwiseTo(t,B,e),e},F.prototype.or=function ne(t){var e=E();return this.bitwiseTo(t,O,e),e},F.prototype.xor=function ie(t){var e=E();return this.bitwiseTo(t,j,e),e},F.prototype.andNot=function oe(t){var e=E();return this.bitwiseTo(t,M,e),e},F.prototype.not=function se(){for(var t=E(),e=0;e<this.t;++e)t[e]=this.DM&~this[e];return t.t=this.t,t.s=~this.s,t},F.prototype.shiftLeft=function ae(t){var e=E();return t<0?this.rShiftTo(-t,e):this.lShiftTo(t,e),e},F.prototype.shiftRight=function ue(t){var e=E();return t<0?this.lShiftTo(-t,e):this.rShiftTo(t,e),e},F.prototype.getLowestSetBit=function ce(){for(var t=0;t<this.t;++t)if(0!=this[t])return t*this.DB+H(this[t]);return this.s<0?this.t*this.DB:-1},F.prototype.bitCount=function he(){for(var t=0,e=this.s&this.DM,r=0;r<this.t;++r)t+=V(this[r]^e);return t},F.prototype.testBit=function le(t){var e=Math.floor(t/this.DB);return e>=this.t?0!=this.s:0!=(this[e]&1<<t%this.DB)},F.prototype.setBit=function fe(t){return this.changeBit(t,O)},F.prototype.clearBit=function ge(t){return this.changeBit(t,M)},F.prototype.flipBit=function de(t){return this.changeBit(t,j)},F.prototype.add=function pe(t){var e=E();return this.addTo(t,e),e},F.prototype.subtract=function ve(t){var e=E();return this.subTo(t,e),e},F.prototype.multiply=function ye(t){var e=E();return this.multiplyTo(t,e),e},F.prototype.divide=function me(t){var e=E();return this.divRemTo(t,e,null),e},F.prototype.remainder=function _e(t){var e=E();return this.divRemTo(t,null,e),e},F.prototype.divideAndRemainder=function Se(t){var e=E(),r=E();return this.divRemTo(t,e,r),new Array(e,r)},F.prototype.modPow=function be(t,e){var r,n,i=t.bitLength(),o=D(1);if(i<=0)return o;r=i<18?1:i<48?3:i<144?4:i<768?5:6,n=i<8?new N(e):e.isEven()?new J(e):new U(e);var s=new Array,a=3,u=r-1,c=(1<<r)-1;if(s[1]=n.convert(this),r>1){var h=E();for(n.sqrTo(s[1],h);a<=c;)s[a]=E(),n.mulTo(h,s[a-2],s[a]),a+=2;}var l,f,g=t.t-1,d=!0,p=E();for(i=L(t[g])-1;g>=0;){for(i>=u?l=t[g]>>i-u&c:(l=(t[g]&(1<<i+1)-1)<<u-i,g>0&&(l|=t[g-1]>>this.DB+i-u)),a=r;0==(1&l);)l>>=1,--a;if((i-=a)<0&&(i+=this.DB,--g),d)s[l].copyTo(o),d=!1;else {for(;a>1;)n.sqrTo(o,p),n.sqrTo(p,o),a-=2;a>0?n.sqrTo(o,p):(f=o,o=p,p=f),n.mulTo(p,s[l],o);}for(;g>=0&&0==(t[g]&1<<i);)n.sqrTo(o,p),f=o,o=p,p=f,--i<0&&(i=this.DB-1,--g);}return n.revert(o)},F.prototype.modInverse=function we(t){var e=t.isEven();if(this.isEven()&&e||0==t.signum())return F.ZERO;for(var r=t.clone(),n=this.clone(),i=D(1),o=D(0),s=D(0),a=D(1);0!=r.signum();){for(;r.isEven();)r.rShiftTo(1,r),e?(i.isEven()&&o.isEven()||(i.addTo(this,i),o.subTo(t,o)),i.rShiftTo(1,i)):o.isEven()||o.subTo(t,o),o.rShiftTo(1,o);for(;n.isEven();)n.rShiftTo(1,n),e?(s.isEven()&&a.isEven()||(s.addTo(this,s),a.subTo(t,a)),s.rShiftTo(1,s)):a.isEven()||a.subTo(t,a),a.rShiftTo(1,a);r.compareTo(n)>=0?(r.subTo(n,r),e&&i.subTo(s,i),o.subTo(a,o)):(n.subTo(r,n),e&&s.subTo(i,s),a.subTo(o,a));}return 0!=n.compareTo(F.ONE)?F.ZERO:a.compareTo(t)>=0?a.subtract(t):a.signum()<0?(a.addTo(t,a),a.signum()<0?a.add(t):a):a},F.prototype.pow=function Fe(t){return this.exp(t,new K)},F.prototype.gcd=function Ee(t){var e=this.s<0?this.negate():this.clone(),r=t.s<0?t.negate():t.clone();if(e.compareTo(r)<0){var n=e;e=r,r=n;}var i=e.getLowestSetBit(),o=r.getLowestSetBit();if(o<0)return e;for(i<o&&(o=i),o>0&&(e.rShiftTo(o,e),r.rShiftTo(o,r));e.signum()>0;)(i=e.getLowestSetBit())>0&&e.rShiftTo(i,e),(i=r.getLowestSetBit())>0&&r.rShiftTo(i,r),e.compareTo(r)>=0?(e.subTo(r,e),e.rShiftTo(1,e)):(r.subTo(e,r),r.rShiftTo(1,r));return o>0&&r.lShiftTo(o,r),r},F.prototype.isProbablePrime=function xe(t){var e,r=this.abs();if(1==r.t&&r[0]<=Rt[Rt.length-1]){for(e=0;e<Rt.length;++e)if(r[0]==Rt[e])return !0;return !1}if(r.isEven())return !1;for(e=1;e<Rt.length;){for(var n=Rt[e],i=e+1;i<Rt.length&&n<It;)n*=Rt[i++];for(n=r.modInt(n);e<i;)if(n%Rt[e++]==0)return !1}return r.millerRabin(t)},F.prototype.square=function Ae(){var t=E();return this.squareTo(t),t},Dt.prototype.init=function ke(t){var e,r,n;for(e=0;e<256;++e)this.S[e]=e;for(r=0,e=0;e<256;++e)r=r+this.S[e]+t[e%t.length]&255,n=this.S[e],this.S[e]=this.S[r],this.S[r]=n;this.i=0,this.j=0;},Dt.prototype.next=function Pe(){var t;return this.i=this.i+1&255,this.j=this.j+this.S[this.i]&255,t=this.S[this.i],this.S[this.i]=this.S[this.j],this.S[this.j]=t,this.S[t+this.S[this.i]&255]};var Ce,Te,Re;
	/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
	 */function Ie(){!function t(e){Te[Re++]^=255&e,Te[Re++]^=e>>8&255,Te[Re++]^=e>>16&255,Te[Re++]^=e>>24&255,Re>=256&&(Re-=256);}((new Date).getTime());}if(null==Te){var De;if(Te=new Array,Re=0,void 0!==i&&(void 0!==i.crypto||void 0!==i.msCrypto)){var Le=i.crypto||i.msCrypto;if(Le.getRandomValues){var Ne=new Uint8Array(32);for(Le.getRandomValues(Ne),De=0;De<32;++De)Te[Re++]=Ne[De];}else if("Netscape"==n.appName&&n.appVersion<"5"){var Ue=i.crypto.random(32);for(De=0;De<Ue.length;++De)Te[Re++]=255&Ue.charCodeAt(De);}}for(;Re<256;)De=Math.floor(65536*Math.random()),Te[Re++]=De>>>8,Te[Re++]=255&De;Re=0,Ie();}function Be(){if(null==Ce){for(Ie(),(Ce=function t(){return new Dt}()).init(Te),Re=0;Re<Te.length;++Re)Te[Re]=0;Re=0;}return Ce.next()}function Oe(){}
	/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
	 */
	function je(t,e){return new F(t,e)}function Me(t,e,r){for(var n="",i=0;n.length<e;)n+=r(String.fromCharCode.apply(String,t.concat([(4278190080&i)>>24,(16711680&i)>>16,(65280&i)>>8,255&i]))),i+=1;return n}function He(){this.n=null,this.e=0,this.d=null,this.p=null,this.q=null,this.dmp1=null,this.dmq1=null,this.coeff=null;}
	/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
	 */
	function Ve(t,e){this.x=e,this.q=t;}function Ke(t,e,r,n){this.curve=t,this.x=e,this.y=r,this.z=null==n?F.ONE:n,this.zinv=null;}function qe(t,e,r){this.q=t,this.a=this.fromBigInteger(e),this.b=this.fromBigInteger(r),this.infinity=new Ke(this,null,null);}Oe.prototype.nextBytes=function Je(t){var e;for(e=0;e<t.length;++e)t[e]=Be();},He.prototype.doPublic=function We(t){return t.modPowInt(this.e,this.n)},He.prototype.setPublic=function ze(t,e){if(this.isPublic=!0,this.isPrivate=!1,"string"!=typeof t)this.n=t,this.e=e;else {if(!(null!=t&&null!=e&&t.length>0&&e.length>0))throw "Invalid RSA public key";this.n=je(t,16),this.e=parseInt(e,16);}},He.prototype.encrypt=function Ye(t){var e=function r(t,e){if(e<t.length+11)throw "Message too long for RSA";for(var r=new Array,n=t.length-1;n>=0&&e>0;){var i=t.charCodeAt(n--);i<128?r[--e]=i:i>127&&i<2048?(r[--e]=63&i|128,r[--e]=i>>6|192):(r[--e]=63&i|128,r[--e]=i>>6&63|128,r[--e]=i>>12|224);}r[--e]=0;for(var o=new Oe,s=new Array;e>2;){for(s[0]=0;0==s[0];)o.nextBytes(s);r[--e]=s[0];}return r[--e]=2,r[--e]=0,new F(r)}(t,this.n.bitLength()+7>>3);if(null==e)return null;var n=this.doPublic(e);if(null==n)return null;var i=n.toString(16);return 0==(1&i.length)?i:"0"+i},He.prototype.encryptOAEP=function Ge(t,e,r){var n=function i(t,e,r,n){var i=br.crypto.MessageDigest,o=br.crypto.Util,s=null;if(r||(r="sha1"),"string"==typeof r&&(s=i.getCanonicalAlgName(r),n=i.getHashLength(s),r=function t(e){return Nr(o.hashHex(Ur(e),s))}),t.length+2*n+2>e)throw "Message too long for RSA";var a,u="";for(a=0;a<e-t.length-2*n-2;a+=1)u+="\0";var c=r("")+u+""+t,h=new Array(n);(new Oe).nextBytes(h);var l=Me(h,c.length,r),f=[];for(a=0;a<c.length;a+=1)f[a]=c.charCodeAt(a)^l.charCodeAt(a);var g=Me(f,h.length,r),d=[0];for(a=0;a<h.length;a+=1)d[a+1]=h[a]^g.charCodeAt(a);return new F(d.concat(f))}(t,this.n.bitLength()+7>>3,e,r);if(null==n)return null;var o=this.doPublic(n);if(null==o)return null;var s=o.toString(16);return 0==(1&s.length)?s:"0"+s},He.prototype.type="RSA",Ve.prototype.equals=function Xe(t){return t==this||this.q.equals(t.q)&&this.x.equals(t.x)},Ve.prototype.toBigInteger=function $e(){return this.x},Ve.prototype.negate=function Qe(){return new Ve(this.q,this.x.negate().mod(this.q))},Ve.prototype.add=function Ze(t){return new Ve(this.q,this.x.add(t.toBigInteger()).mod(this.q))},Ve.prototype.subtract=function tr(t){return new Ve(this.q,this.x.subtract(t.toBigInteger()).mod(this.q))},Ve.prototype.multiply=function er(t){return new Ve(this.q,this.x.multiply(t.toBigInteger()).mod(this.q))},Ve.prototype.square=function rr(){return new Ve(this.q,this.x.square().mod(this.q))},Ve.prototype.divide=function nr(t){return new Ve(this.q,this.x.multiply(t.toBigInteger().modInverse(this.q)).mod(this.q))},Ke.prototype.getX=function ir(){return null==this.zinv&&(this.zinv=this.z.modInverse(this.curve.q)),this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q))},Ke.prototype.getY=function or(){return null==this.zinv&&(this.zinv=this.z.modInverse(this.curve.q)),this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q))},Ke.prototype.equals=function sr(t){return t==this||(this.isInfinity()?t.isInfinity():t.isInfinity()?this.isInfinity():!!t.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(t.z)).mod(this.curve.q).equals(F.ZERO)&&t.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(t.z)).mod(this.curve.q).equals(F.ZERO))},Ke.prototype.isInfinity=function ar(){return null==this.x&&null==this.y||this.z.equals(F.ZERO)&&!this.y.toBigInteger().equals(F.ZERO)},Ke.prototype.negate=function ur(){return new Ke(this.curve,this.x,this.y.negate(),this.z)},Ke.prototype.add=function cr(t){if(this.isInfinity())return t;if(t.isInfinity())return this;var e=t.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(t.z)).mod(this.curve.q),r=t.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(t.z)).mod(this.curve.q);if(F.ZERO.equals(r))return F.ZERO.equals(e)?this.twice():this.curve.getInfinity();var n=new F("3"),i=this.x.toBigInteger(),o=this.y.toBigInteger(),s=(t.x.toBigInteger(),t.y.toBigInteger(),r.square()),a=s.multiply(r),u=i.multiply(s),c=e.square().multiply(this.z),h=c.subtract(u.shiftLeft(1)).multiply(t.z).subtract(a).multiply(r).mod(this.curve.q),l=u.multiply(n).multiply(e).subtract(o.multiply(a)).subtract(c.multiply(e)).multiply(t.z).add(e.multiply(a)).mod(this.curve.q),f=a.multiply(this.z).multiply(t.z).mod(this.curve.q);return new Ke(this.curve,this.curve.fromBigInteger(h),this.curve.fromBigInteger(l),f)},Ke.prototype.twice=function hr(){if(this.isInfinity())return this;if(0==this.y.toBigInteger().signum())return this.curve.getInfinity();var t=new F("3"),e=this.x.toBigInteger(),r=this.y.toBigInteger(),n=r.multiply(this.z),i=n.multiply(r).mod(this.curve.q),o=this.curve.a.toBigInteger(),s=e.square().multiply(t);F.ZERO.equals(o)||(s=s.add(this.z.square().multiply(o)));var a=(s=s.mod(this.curve.q)).square().subtract(e.shiftLeft(3).multiply(i)).shiftLeft(1).multiply(n).mod(this.curve.q),u=s.multiply(t).multiply(e).subtract(i.shiftLeft(1)).shiftLeft(2).multiply(i).subtract(s.square().multiply(s)).mod(this.curve.q),c=n.square().multiply(n).shiftLeft(3).mod(this.curve.q);return new Ke(this.curve,this.curve.fromBigInteger(a),this.curve.fromBigInteger(u),c)},Ke.prototype.multiply=function lr(t){if(this.isInfinity())return this;if(0==t.signum())return this.curve.getInfinity();var e,r=t,n=r.multiply(new F("3")),i=this.negate(),o=this,s=this.curve.q.subtract(t),a=s.multiply(new F("3")),u=new Ke(this.curve,this.x,this.y),c=u.negate();for(e=n.bitLength()-2;e>0;--e){o=o.twice();var h=n.testBit(e);h!=r.testBit(e)&&(o=o.add(h?this:i));}for(e=a.bitLength()-2;e>0;--e){u=u.twice();var l=a.testBit(e);l!=s.testBit(e)&&(u=u.add(l?u:c));}return o},Ke.prototype.multiplyTwo=function fr(t,e,r){var n;n=t.bitLength()>r.bitLength()?t.bitLength()-1:r.bitLength()-1;for(var i=this.curve.getInfinity(),o=this.add(e);n>=0;)i=i.twice(),t.testBit(n)?i=r.testBit(n)?i.add(o):i.add(this):r.testBit(n)&&(i=i.add(e)),--n;return i},qe.prototype.getQ=function gr(){return this.q},qe.prototype.getA=function dr(){return this.a},qe.prototype.getB=function pr(){return this.b},qe.prototype.equals=function vr(t){return t==this||this.q.equals(t.q)&&this.a.equals(t.a)&&this.b.equals(t.b)},qe.prototype.getInfinity=function yr(){return this.infinity},qe.prototype.fromBigInteger=function mr(t){return new Ve(this.q,t)},qe.prototype.decodePointHex=function _r(t){switch(parseInt(t.substr(0,2),16)){case 0:return this.infinity;case 2:case 3:return null;case 4:case 6:case 7:var e=(t.length-2)/2,r=t.substr(2,e),n=t.substr(e+2,e);return new Ke(this,this.fromBigInteger(new F(r,16)),this.fromBigInteger(new F(n,16)));default:return null}},
	/*! (c) Stefan Thomas | https://github.com/bitcoinjs/bitcoinjs-lib
	 */
	Ve.prototype.getByteLength=function(){return Math.floor((this.toBigInteger().bitLength()+7)/8)},Ke.prototype.getEncoded=function(t){var e=function t(e,r){var n=e.toByteArrayUnsigned();if(r<n.length)n=n.slice(n.length-r);else for(;r>n.length;)n.unshift(0);return n},r=this.getX().toBigInteger(),n=this.getY().toBigInteger(),i=e(r,32);return t?n.isEven()?i.unshift(2):i.unshift(3):(i.unshift(4),i=i.concat(e(n,32))),i},Ke.decodeFrom=function(t,e){e[0];var r=e.length-1,n=e.slice(1,1+r/2),i=e.slice(1+r/2,1+r);n.unshift(0),i.unshift(0);var o=new F(n),s=new F(i);return new Ke(t,t.fromBigInteger(o),t.fromBigInteger(s))},Ke.decodeFromHex=function(t,e){e.substr(0,2);var r=e.length-2,n=e.substr(2,r/2),i=e.substr(2+r/2,r/2),o=new F(n,16),s=new F(i,16);return new Ke(t,t.fromBigInteger(o),t.fromBigInteger(s))},Ke.prototype.add2D=function(t){if(this.isInfinity())return t;if(t.isInfinity())return this;if(this.x.equals(t.x))return this.y.equals(t.y)?this.twice():this.curve.getInfinity();var e=t.x.subtract(this.x),r=t.y.subtract(this.y).divide(e),n=r.square().subtract(this.x).subtract(t.x),i=r.multiply(this.x.subtract(n)).subtract(this.y);return new Ke(this.curve,n,i)},Ke.prototype.twice2D=function(){if(this.isInfinity())return this;if(0==this.y.toBigInteger().signum())return this.curve.getInfinity();var t=this.curve.fromBigInteger(F.valueOf(2)),e=this.curve.fromBigInteger(F.valueOf(3)),r=this.x.square().multiply(e).add(this.curve.a).divide(this.y.multiply(t)),n=r.square().subtract(this.x.multiply(t)),i=r.multiply(this.x.subtract(n)).subtract(this.y);return new Ke(this.curve,n,i)},Ke.prototype.multiply2D=function(t){if(this.isInfinity())return this;if(0==t.signum())return this.curve.getInfinity();var e,r=t,n=r.multiply(new F("3")),i=this.negate(),o=this;for(e=n.bitLength()-2;e>0;--e){o=o.twice();var s=n.testBit(e);s!=r.testBit(e)&&(o=o.add2D(s?this:i));}return o},Ke.prototype.isOnCurve=function(){var t=this.getX().toBigInteger(),e=this.getY().toBigInteger(),r=this.curve.getA().toBigInteger(),n=this.curve.getB().toBigInteger(),i=this.curve.getQ(),o=e.multiply(e).mod(i),s=t.multiply(t).multiply(t).add(r.multiply(t)).add(n).mod(i);return o.equals(s)},Ke.prototype.toString=function(){return "("+this.getX().toBigInteger().toString()+","+this.getY().toBigInteger().toString()+")"},Ke.prototype.validate=function(){var t=this.curve.getQ();if(this.isInfinity())throw new Error("Point is at infinity.");var e=this.getX().toBigInteger(),r=this.getY().toBigInteger();if(e.compareTo(F.ONE)<0||e.compareTo(t.subtract(F.ONE))>0)throw new Error("x coordinate out of bounds");if(r.compareTo(F.ONE)<0||r.compareTo(t.subtract(F.ONE))>0)throw new Error("y coordinate out of bounds");if(!this.isOnCurve())throw new Error("Point is not on the curve.");if(this.multiply(t).isInfinity())throw new Error("Point is not a scalar multiple of G.");return !0};
	/*! Mike Samuel (c) 2009 | code.google.com/p/json-sans-eval
	 */
	var Sr=function(){var t=new RegExp('(?:false|true|null|[\\{\\}\\[\\]]|(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)|(?:"(?:[^\\0-\\x08\\x0a-\\x1f"\\\\]|\\\\(?:["/\\\\bfnrt]|u[0-9A-Fa-f]{4}))*"))',"g"),e=new RegExp("\\\\(?:([^u])|u(.{4}))","g"),n={'"':'"',"/":"/","\\":"\\",b:"\b",f:"\f",n:"\n",r:"\r",t:"\t"};function i(t,e,r){return e?n[e]:String.fromCharCode(parseInt(r,16))}var o=new String(""),s=Object.hasOwnProperty;return function(n,a){var u,c,h=n.match(t),l=h[0],f=!1;"{"===l?u={}:"["===l?u=[]:(u=[],f=!0);for(var g=[u],d=1-f,p=h.length;d<p;++d){var v;switch((l=h[d]).charCodeAt(0)){default:(v=g[0])[c||v.length]=+l,c=void 0;break;case 34:if(-1!==(l=l.substring(1,l.length-1)).indexOf("\\")&&(l=l.replace(e,i)),v=g[0],!c){if(!(v instanceof Array)){c=l||o;break}c=v.length;}v[c]=l,c=void 0;break;case 91:v=g[0],g.unshift(v[c||v.length]=[]),c=void 0;break;case 93:g.shift();break;case 102:(v=g[0])[c||v.length]=!1,c=void 0;break;case 110:(v=g[0])[c||v.length]=null,c=void 0;break;case 116:(v=g[0])[c||v.length]=!0,c=void 0;break;case 123:v=g[0],g.unshift(v[c||v.length]={}),c=void 0;break;case 125:g.shift();}}if(f){if(1!==g.length)throw new Error;u=u[0];}else if(g.length)throw new Error;if(a){u=function t(e,n){var i=e[n];if(i&&"object"===(void 0===i?"undefined":r(i))){var o=null;for(var u in i)if(s.call(i,u)&&i!==e){var c=t(i,u);void 0!==c?i[u]=c:(o||(o=[]),o.push(u));}if(o)for(var h=o.length;--h>=0;)delete i[o[h]];}return a.call(e,n,i)}({"":u},"");}return u}}();void 0!==br&&br||(e.KJUR=br={}),void 0!==br.asn1&&br.asn1||(br.asn1={}),br.asn1.ASN1Util=new function(){this.integerToByteHex=function(t){var e=t.toString(16);return e.length%2==1&&(e="0"+e),e},this.bigIntToMinTwosComplementsHex=function(t){var e=t.toString(16);if("-"!=e.substr(0,1))e.length%2==1?e="0"+e:e.match(/^[0-7]/)||(e="00"+e);else {var r=e.substr(1).length;r%2==1?r+=1:e.match(/^[0-7]/)||(r+=2);for(var n="",i=0;i<r;i++)n+="f";e=new F(n,16).xor(t).add(F.ONE).toString(16).replace(/^-/,"");}return e},this.getPEMStringFromHex=function(t,e){return Mr(t,e)},this.newObject=function(t){var e=br.asn1,r=e.ASN1Object,n=e.DERBoolean,i=e.DERInteger,o=e.DERBitString,s=e.DEROctetString,a=e.DERNull,u=e.DERObjectIdentifier,c=e.DEREnumerated,h=e.DERUTF8String,l=e.DERNumericString,f=e.DERPrintableString,g=e.DERTeletexString,d=e.DERIA5String,p=e.DERUTCTime,v=e.DERGeneralizedTime,y=e.DERVisibleString,m=e.DERBMPString,_=e.DERSequence,S=e.DERSet,b=e.DERTaggedObject,w=e.ASN1Util.newObject;if(t instanceof e.ASN1Object)return t;var F=Object.keys(t);if(1!=F.length)throw new Error("key of param shall be only one.");var E=F[0];if(-1==":asn1:bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:visstr:bmpstr:seq:set:tag:".indexOf(":"+E+":"))throw new Error("undefined key: "+E);if("bool"==E)return new n(t[E]);if("int"==E)return new i(t[E]);if("bitstr"==E)return new o(t[E]);if("octstr"==E)return new s(t[E]);if("null"==E)return new a(t[E]);if("oid"==E)return new u(t[E]);if("enum"==E)return new c(t[E]);if("utf8str"==E)return new h(t[E]);if("numstr"==E)return new l(t[E]);if("prnstr"==E)return new f(t[E]);if("telstr"==E)return new g(t[E]);if("ia5str"==E)return new d(t[E]);if("utctime"==E)return new p(t[E]);if("gentime"==E)return new v(t[E]);if("visstr"==E)return new y(t[E]);if("bmpstr"==E)return new m(t[E]);if("asn1"==E)return new r(t[E]);if("seq"==E){for(var x=t[E],A=[],k=0;k<x.length;k++){var P=w(x[k]);A.push(P);}return new _({array:A})}if("set"==E){for(x=t[E],A=[],k=0;k<x.length;k++){P=w(x[k]);A.push(P);}return new S({array:A})}if("tag"==E){var C=t[E];if("[object Array]"===Object.prototype.toString.call(C)&&3==C.length){var T=w(C[2]);return new b({tag:C[0],explicit:C[1],obj:T})}return new b(C)}},this.jsonToASN1HEX=function(t){return this.newObject(t).getEncodedHex()};},br.asn1.ASN1Util.oidHexToInt=function(t){for(var e="",r=parseInt(t.substr(0,2),16),n=(e=Math.floor(r/40)+"."+r%40,""),i=2;i<t.length;i+=2){var o=("00000000"+parseInt(t.substr(i,2),16).toString(2)).slice(-8);if(n+=o.substr(1,7),"0"==o.substr(0,1))e=e+"."+new F(n,2).toString(10),n="";}return e},br.asn1.ASN1Util.oidIntToHex=function(t){var e=function t(e){var r=e.toString(16);return 1==r.length&&(r="0"+r),r},r=function t(r){var n="",i=new F(r,10).toString(2),o=7-i.length%7;7==o&&(o=0);for(var s="",a=0;a<o;a++)s+="0";i=s+i;for(a=0;a<i.length-1;a+=7){var u=i.substr(a,7);a!=i.length-7&&(u="1"+u),n+=e(parseInt(u,2));}return n};if(!t.match(/^[0-9.]+$/))throw "malformed oid string: "+t;var n="",i=t.split("."),o=40*parseInt(i[0])+parseInt(i[1]);n+=e(o),i.splice(0,2);for(var s=0;s<i.length;s++)n+=r(i[s]);return n},br.asn1.ASN1Object=function(t){this.params=null,this.getLengthHexFromValue=function(){if(void 0===this.hV||null==this.hV)throw new Error("this.hV is null or undefined");if(this.hV.length%2==1)throw new Error("value hex must be even length: n="+"".length+",v="+this.hV);var t=this.hV.length/2,e=t.toString(16);if(e.length%2==1&&(e="0"+e),t<128)return e;var r=e.length/2;if(r>15)throw "ASN.1 length too long to represent by 8x: n = "+t.toString(16);return (128+r).toString(16)+e},this.getEncodedHex=function(){return (null==this.hTLV||this.isModified)&&(this.hV=this.getFreshValueHex(),this.hL=this.getLengthHexFromValue(),this.hTLV=this.hT+this.hL+this.hV,this.isModified=!1),this.hTLV},this.getValueHex=function(){return this.getEncodedHex(),this.hV},this.getFreshValueHex=function(){return ""},this.setByParam=function(t){this.params=t;},null!=t&&null!=t.tlv&&(this.hTLV=t.tlv,this.isModified=!1);},br.asn1.DERAbstractString=function(t){br.asn1.DERAbstractString.superclass.constructor.call(this);this.getString=function(){return this.s},this.setString=function(t){this.hTLV=null,this.isModified=!0,this.s=t,this.hV=Dr(this.s).toLowerCase();},this.setStringHex=function(t){this.hTLV=null,this.isModified=!0,this.s=null,this.hV=t;},this.getFreshValueHex=function(){return this.hV},void 0!==t&&("string"==typeof t?this.setString(t):void 0!==t.str?this.setString(t.str):void 0!==t.hex&&this.setStringHex(t.hex));},o.lang.extend(br.asn1.DERAbstractString,br.asn1.ASN1Object),br.asn1.DERAbstractTime=function(t){br.asn1.DERAbstractTime.superclass.constructor.call(this);this.localDateToUTC=function(t){var e=t.getTime()+6e4*t.getTimezoneOffset();return new Date(e)},this.formatDate=function(t,e,r){var n=this.zeroPadding,i=this.localDateToUTC(t),o=String(i.getFullYear());"utc"==e&&(o=o.substr(2,2));var s=o+n(String(i.getMonth()+1),2)+n(String(i.getDate()),2)+n(String(i.getHours()),2)+n(String(i.getMinutes()),2)+n(String(i.getSeconds()),2);if(!0===r){var a=i.getMilliseconds();if(0!=a){var u=n(String(a),3);s=s+"."+(u=u.replace(/[0]+$/,""));}}return s+"Z"},this.zeroPadding=function(t,e){return t.length>=e?t:new Array(e-t.length+1).join("0")+t},this.getString=function(){return this.s},this.setString=function(t){this.hTLV=null,this.isModified=!0,this.s=t,this.hV=Pr(t);},this.setByDateValue=function(t,e,r,n,i,o){var s=new Date(Date.UTC(t,e-1,r,n,i,o,0));this.setByDate(s);},this.getFreshValueHex=function(){return this.hV};},o.lang.extend(br.asn1.DERAbstractTime,br.asn1.ASN1Object),br.asn1.DERAbstractStructured=function(t){br.asn1.DERAbstractString.superclass.constructor.call(this);this.setByASN1ObjectArray=function(t){this.hTLV=null,this.isModified=!0,this.asn1Array=t;},this.appendASN1Object=function(t){this.hTLV=null,this.isModified=!0,this.asn1Array.push(t);},this.asn1Array=new Array,void 0!==t&&void 0!==t.array&&(this.asn1Array=t.array);},o.lang.extend(br.asn1.DERAbstractStructured,br.asn1.ASN1Object),br.asn1.DERBoolean=function(t){br.asn1.DERBoolean.superclass.constructor.call(this),this.hT="01",this.hTLV=0==t?"010100":"0101ff";},o.lang.extend(br.asn1.DERBoolean,br.asn1.ASN1Object),br.asn1.DERInteger=function(t){br.asn1.DERInteger.superclass.constructor.call(this),this.hT="02",this.setByBigInteger=function(t){this.hTLV=null,this.isModified=!0,this.hV=br.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t);},this.setByInteger=function(t){var e=new F(String(t),10);this.setByBigInteger(e);},this.setValueHex=function(t){this.hV=t;},this.getFreshValueHex=function(){return this.hV},void 0!==t&&(void 0!==t.bigint?this.setByBigInteger(t.bigint):void 0!==t.int?this.setByInteger(t.int):"number"==typeof t?this.setByInteger(t):void 0!==t.hex&&this.setValueHex(t.hex));},o.lang.extend(br.asn1.DERInteger,br.asn1.ASN1Object),br.asn1.DERBitString=function(t){if(void 0!==t&&void 0!==t.obj){var e=br.asn1.ASN1Util.newObject(t.obj);t.hex="00"+e.getEncodedHex();}br.asn1.DERBitString.superclass.constructor.call(this),this.hT="03",this.setHexValueIncludingUnusedBits=function(t){this.hTLV=null,this.isModified=!0,this.hV=t;},this.setUnusedBitsAndHexValue=function(t,e){if(t<0||7<t)throw "unused bits shall be from 0 to 7: u = "+t;var r="0"+t;this.hTLV=null,this.isModified=!0,this.hV=r+e;},this.setByBinaryString=function(t){var e=8-(t=t.replace(/0+$/,"")).length%8;8==e&&(e=0);for(var r=0;r<=e;r++)t+="0";var n="";for(r=0;r<t.length-1;r+=8){var i=t.substr(r,8),o=parseInt(i,2).toString(16);1==o.length&&(o="0"+o),n+=o;}this.hTLV=null,this.isModified=!0,this.hV="0"+e+n;},this.setByBooleanArray=function(t){for(var e="",r=0;r<t.length;r++)1==t[r]?e+="1":e+="0";this.setByBinaryString(e);},this.newFalseArray=function(t){for(var e=new Array(t),r=0;r<t;r++)e[r]=!1;return e},this.getFreshValueHex=function(){return this.hV},void 0!==t&&("string"==typeof t&&t.toLowerCase().match(/^[0-9a-f]+$/)?this.setHexValueIncludingUnusedBits(t):void 0!==t.hex?this.setHexValueIncludingUnusedBits(t.hex):void 0!==t.bin?this.setByBinaryString(t.bin):void 0!==t.array&&this.setByBooleanArray(t.array));},o.lang.extend(br.asn1.DERBitString,br.asn1.ASN1Object),br.asn1.DEROctetString=function(t){if(void 0!==t&&void 0!==t.obj){var e=br.asn1.ASN1Util.newObject(t.obj);t.hex=e.getEncodedHex();}br.asn1.DEROctetString.superclass.constructor.call(this,t),this.hT="04";},o.lang.extend(br.asn1.DEROctetString,br.asn1.DERAbstractString),br.asn1.DERNull=function(){br.asn1.DERNull.superclass.constructor.call(this),this.hT="05",this.hTLV="0500";},o.lang.extend(br.asn1.DERNull,br.asn1.ASN1Object),br.asn1.DERObjectIdentifier=function(t){br.asn1.DERObjectIdentifier.superclass.constructor.call(this),this.hT="06",this.setValueHex=function(t){this.hTLV=null,this.isModified=!0,this.s=null,this.hV=t;},this.setValueOidString=function(t){var e=function r(t){var e=function t(e){var r=e.toString(16);return 1==r.length&&(r="0"+r),r},r=function t(r){var n="",i=parseInt(r,10).toString(2),o=7-i.length%7;7==o&&(o=0);for(var s="",a=0;a<o;a++)s+="0";i=s+i;for(a=0;a<i.length-1;a+=7){var u=i.substr(a,7);a!=i.length-7&&(u="1"+u),n+=e(parseInt(u,2));}return n};try{if(!t.match(/^[0-9.]+$/))return null;var n="",i=t.split("."),o=40*parseInt(i[0],10)+parseInt(i[1],10);n+=e(o),i.splice(0,2);for(var s=0;s<i.length;s++)n+=r(i[s]);return n}catch(t){return null}}(t);if(null==e)throw new Error("malformed oid string: "+t);this.hTLV=null,this.isModified=!0,this.s=null,this.hV=e;},this.setValueName=function(t){var e=br.asn1.x509.OID.name2oid(t);if(""===e)throw new Error("DERObjectIdentifier oidName undefined: "+t);this.setValueOidString(e);},this.setValueNameOrOid=function(t){t.match(/^[0-2].[0-9.]+$/)?this.setValueOidString(t):this.setValueName(t);},this.getFreshValueHex=function(){return this.hV},this.setByParam=function(t){"string"==typeof t?this.setValueNameOrOid(t):void 0!==t.oid?this.setValueNameOrOid(t.oid):void 0!==t.name?this.setValueNameOrOid(t.name):void 0!==t.hex&&this.setValueHex(t.hex);},void 0!==t&&this.setByParam(t);},o.lang.extend(br.asn1.DERObjectIdentifier,br.asn1.ASN1Object),br.asn1.DEREnumerated=function(t){br.asn1.DEREnumerated.superclass.constructor.call(this),this.hT="0a",this.setByBigInteger=function(t){this.hTLV=null,this.isModified=!0,this.hV=br.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t);},this.setByInteger=function(t){var e=new F(String(t),10);this.setByBigInteger(e);},this.setValueHex=function(t){this.hV=t;},this.getFreshValueHex=function(){return this.hV},void 0!==t&&(void 0!==t.int?this.setByInteger(t.int):"number"==typeof t?this.setByInteger(t):void 0!==t.hex&&this.setValueHex(t.hex));},o.lang.extend(br.asn1.DEREnumerated,br.asn1.ASN1Object),br.asn1.DERUTF8String=function(t){br.asn1.DERUTF8String.superclass.constructor.call(this,t),this.hT="0c";},o.lang.extend(br.asn1.DERUTF8String,br.asn1.DERAbstractString),br.asn1.DERNumericString=function(t){br.asn1.DERNumericString.superclass.constructor.call(this,t),this.hT="12";},o.lang.extend(br.asn1.DERNumericString,br.asn1.DERAbstractString),br.asn1.DERPrintableString=function(t){br.asn1.DERPrintableString.superclass.constructor.call(this,t),this.hT="13";},o.lang.extend(br.asn1.DERPrintableString,br.asn1.DERAbstractString),br.asn1.DERTeletexString=function(t){br.asn1.DERTeletexString.superclass.constructor.call(this,t),this.hT="14";},o.lang.extend(br.asn1.DERTeletexString,br.asn1.DERAbstractString),br.asn1.DERIA5String=function(t){br.asn1.DERIA5String.superclass.constructor.call(this,t),this.hT="16";},o.lang.extend(br.asn1.DERIA5String,br.asn1.DERAbstractString),br.asn1.DERVisibleString=function(t){br.asn1.DERIA5String.superclass.constructor.call(this,t),this.hT="1a";},o.lang.extend(br.asn1.DERVisibleString,br.asn1.DERAbstractString),br.asn1.DERBMPString=function(t){br.asn1.DERBMPString.superclass.constructor.call(this,t),this.hT="1e";},o.lang.extend(br.asn1.DERBMPString,br.asn1.DERAbstractString),br.asn1.DERUTCTime=function(t){br.asn1.DERUTCTime.superclass.constructor.call(this,t),this.hT="17",this.setByDate=function(t){this.hTLV=null,this.isModified=!0,this.date=t,this.s=this.formatDate(this.date,"utc"),this.hV=Pr(this.s);},this.getFreshValueHex=function(){return void 0===this.date&&void 0===this.s&&(this.date=new Date,this.s=this.formatDate(this.date,"utc"),this.hV=Pr(this.s)),this.hV},void 0!==t&&(void 0!==t.str?this.setString(t.str):"string"==typeof t&&t.match(/^[0-9]{12}Z$/)?this.setString(t):void 0!==t.hex?this.setStringHex(t.hex):void 0!==t.date&&this.setByDate(t.date));},o.lang.extend(br.asn1.DERUTCTime,br.asn1.DERAbstractTime),br.asn1.DERGeneralizedTime=function(t){br.asn1.DERGeneralizedTime.superclass.constructor.call(this,t),this.hT="18",this.withMillis=!1,this.setByDate=function(t){this.hTLV=null,this.isModified=!0,this.date=t,this.s=this.formatDate(this.date,"gen",this.withMillis),this.hV=Pr(this.s);},this.getFreshValueHex=function(){return void 0===this.date&&void 0===this.s&&(this.date=new Date,this.s=this.formatDate(this.date,"gen",this.withMillis),this.hV=Pr(this.s)),this.hV},void 0!==t&&(void 0!==t.str?this.setString(t.str):"string"==typeof t&&t.match(/^[0-9]{14}Z$/)?this.setString(t):void 0!==t.hex?this.setStringHex(t.hex):void 0!==t.date&&this.setByDate(t.date),!0===t.millis&&(this.withMillis=!0));},o.lang.extend(br.asn1.DERGeneralizedTime,br.asn1.DERAbstractTime),br.asn1.DERSequence=function(t){br.asn1.DERSequence.superclass.constructor.call(this,t),this.hT="30",this.getFreshValueHex=function(){for(var t="",e=0;e<this.asn1Array.length;e++){t+=this.asn1Array[e].getEncodedHex();}return this.hV=t,this.hV};},o.lang.extend(br.asn1.DERSequence,br.asn1.DERAbstractStructured),br.asn1.DERSet=function(t){br.asn1.DERSet.superclass.constructor.call(this,t),this.hT="31",this.sortFlag=!0,this.getFreshValueHex=function(){for(var t=new Array,e=0;e<this.asn1Array.length;e++){var r=this.asn1Array[e];t.push(r.getEncodedHex());}return 1==this.sortFlag&&t.sort(),this.hV=t.join(""),this.hV},void 0!==t&&void 0!==t.sortflag&&0==t.sortflag&&(this.sortFlag=!1);},o.lang.extend(br.asn1.DERSet,br.asn1.DERAbstractStructured),br.asn1.DERTaggedObject=function(t){br.asn1.DERTaggedObject.superclass.constructor.call(this);var e=br.asn1;this.hT="a0",this.hV="",this.isExplicit=!0,this.asn1Object=null,this.setASN1Object=function(t,e,r){this.hT=e,this.isExplicit=t,this.asn1Object=r,this.isExplicit?(this.hV=this.asn1Object.getEncodedHex(),this.hTLV=null,this.isModified=!0):(this.hV=null,this.hTLV=r.getEncodedHex(),this.hTLV=this.hTLV.replace(/^../,e),this.isModified=!1);},this.getFreshValueHex=function(){return this.hV},this.setByParam=function(t){null!=t.tag&&(this.hT=t.tag),null!=t.explicit&&(this.isExplicit=t.explicit),null!=t.tage&&(this.hT=t.tage,this.isExplicit=!0),null!=t.tagi&&(this.hT=t.tagi,this.isExplicit=!1),null!=t.obj&&(t.obj instanceof e.ASN1Object?(this.asn1Object=t.obj,this.setASN1Object(this.isExplicit,this.hT,this.asn1Object)):"object"==r(t.obj)&&(this.asn1Object=e.ASN1Util.newObject(t.obj),this.setASN1Object(this.isExplicit,this.hT,this.asn1Object)));},null!=t&&this.setByParam(t);},o.lang.extend(br.asn1.DERTaggedObject,br.asn1.ASN1Object);var br,wr,Fr,Er=new function(){};function xr(t){for(var e=new Array,r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e}function Ar(t){for(var e="",r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e}function kr(t){for(var e="",r=0;r<t.length;r++){var n=t[r].toString(16);1==n.length&&(n="0"+n),e+=n;}return e}function Pr(t){return kr(xr(t))}function Cr(t){return t=(t=(t=t.replace(/\=/g,"")).replace(/\+/g,"-")).replace(/\//g,"_")}function Tr(t){return t.length%4==2?t+="==":t.length%4==3&&(t+="="),t=(t=t.replace(/-/g,"+")).replace(/_/g,"/")}function Rr(t){return t.length%2==1&&(t="0"+t),Cr(S(t))}function Ir(t){return b(Tr(t))}function Dr(t){return qr(Gr(t))}function Lr(t){return decodeURIComponent(Jr(t))}function Nr(t){for(var e="",r=0;r<t.length-1;r+=2)e+=String.fromCharCode(parseInt(t.substr(r,2),16));return e}function Ur(t){for(var e="",r=0;r<t.length;r++)e+=("0"+t.charCodeAt(r).toString(16)).slice(-2);return e}function Br(t){return S(t)}function Or(t){var e=Br(t).replace(/(.{64})/g,"$1\r\n");return e=e.replace(/\r\n$/,"")}function jr(t){return b(t.replace(/[^0-9A-Za-z\/+=]*/g,""))}function Mr(t,e){return "-----BEGIN "+e+"-----\r\n"+Or(t)+"\r\n-----END "+e+"-----\r\n"}function Hr(t,e){if(-1==t.indexOf("-----BEGIN "))throw "can't find PEM header: "+e;return jr(t=void 0!==e?(t=t.replace(new RegExp("^[^]*-----BEGIN "+e+"-----"),"")).replace(new RegExp("-----END "+e+"-----[^]*$"),""):(t=t.replace(/^[^]*-----BEGIN [^-]+-----/,"")).replace(/-----END [^-]+-----[^]*$/,""))}function Vr(t){var e,r,n,i,o,s,a,u,c,h,l;if(l=t.match(/^(\d{2}|\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(|\.\d+)Z$/))return u=l[1],e=parseInt(u),2===u.length&&(50<=e&&e<100?e=1900+e:0<=e&&e<50&&(e=2e3+e)),r=parseInt(l[2])-1,n=parseInt(l[3]),i=parseInt(l[4]),o=parseInt(l[5]),s=parseInt(l[6]),a=0,""!==(c=l[7])&&(h=(c.substr(1)+"00").substr(0,3),a=parseInt(h)),Date.UTC(e,r,n,i,o,s,a);throw "unsupported zulu format: "+t}function Kr(t){return ~~(Vr(t)/1e3)}function qr(t){return t.replace(/%/g,"")}function Jr(t){return t.replace(/(..)/g,"%$1")}function Wr(t){var e="malformed IPv6 address";if(!t.match(/^[0-9A-Fa-f:]+$/))throw e;var r=(t=t.toLowerCase()).split(":").length-1;if(r<2)throw e;var n=":".repeat(7-r+2),i=(t=t.replace("::",n)).split(":");if(8!=i.length)throw e;for(var o=0;o<8;o++)i[o]=("0000"+i[o]).slice(-4);return i.join("")}function zr(t){if(!t.match(/^[0-9A-Fa-f]{32}$/))throw "malformed IPv6 address octet";for(var e=(t=t.toLowerCase()).match(/.{1,4}/g),r=0;r<8;r++)e[r]=e[r].replace(/^0+/,""),""==e[r]&&(e[r]="0");var n=(t=":"+e.join(":")+":").match(/:(0:){2,}/g);if(null===n)return t.slice(1,-1);var i="";for(r=0;r<n.length;r++)n[r].length>i.length&&(i=n[r]);return (t=t.replace(i,"::")).slice(1,-1)}function Yr(t){var e="malformed hex value";if(!t.match(/^([0-9A-Fa-f][0-9A-Fa-f]){1,}$/))throw e;if(8!=t.length)return 32==t.length?zr(t):t;try{return parseInt(t.substr(0,2),16)+"."+parseInt(t.substr(2,2),16)+"."+parseInt(t.substr(4,2),16)+"."+parseInt(t.substr(6,2),16)}catch(t){throw e}}function Gr(t){for(var e=encodeURIComponent(t),r="",n=0;n<e.length;n++)"%"==e[n]?(r+=e.substr(n,3),n+=2):r=r+"%"+Pr(e[n]);return r}function Xr(t){return !(t.length%2!=0||!t.match(/^[0-9a-f]+$/)&&!t.match(/^[0-9A-F]+$/))}function $r(t){return t.length%2==1?"0"+t:t.substr(0,1)>"7"?"00"+t:t}Er.getLblen=function(t,e){if("8"!=t.substr(e+2,1))return 1;var r=parseInt(t.substr(e+3,1));return 0==r?-1:0<r&&r<10?r+1:-2},Er.getL=function(t,e){var r=Er.getLblen(t,e);return r<1?"":t.substr(e+2,2*r)},Er.getVblen=function(t,e){var r;return ""==(r=Er.getL(t,e))?-1:("8"===r.substr(0,1)?new F(r.substr(2),16):new F(r,16)).intValue()},Er.getVidx=function(t,e){var r=Er.getLblen(t,e);return r<0?r:e+2*(r+1)},Er.getV=function(t,e){var r=Er.getVidx(t,e),n=Er.getVblen(t,e);return t.substr(r,2*n)},Er.getTLV=function(t,e){return t.substr(e,2)+Er.getL(t,e)+Er.getV(t,e)},Er.getTLVblen=function(t,e){return 2+2*Er.getLblen(t,e)+2*Er.getVblen(t,e)},Er.getNextSiblingIdx=function(t,e){return Er.getVidx(t,e)+2*Er.getVblen(t,e)},Er.getChildIdx=function(t,e){var r,n,i,o=Er,s=[];r=o.getVidx(t,e),n=2*o.getVblen(t,e),"03"==t.substr(e,2)&&(r+=2,n-=2),i=0;for(var a=r;i<=n;){var u=o.getTLVblen(t,a);if((i+=u)<=n&&s.push(a),a+=u,i>=n)break}return s},Er.getNthChildIdx=function(t,e,r){return Er.getChildIdx(t,e)[r]},Er.getIdxbyList=function(t,e,r,n){var i,o,s=Er;return 0==r.length?void 0!==n&&t.substr(e,2)!==n?-1:e:(i=r.shift())>=(o=s.getChildIdx(t,e)).length?-1:s.getIdxbyList(t,o[i],r,n)},Er.getIdxbyListEx=function(t,e,r,n){var i,o,s=Er;if(0==r.length)return void 0!==n&&t.substr(e,2)!==n?-1:e;i=r.shift(),o=s.getChildIdx(t,e);for(var a=0,u=0;u<o.length;u++){var c=t.substr(o[u],2);if("number"==typeof i&&!s.isContextTag(c)&&a==i||"string"==typeof i&&s.isContextTag(c,i))return s.getIdxbyListEx(t,o[u],r,n);s.isContextTag(c)||a++;}return -1},Er.getTLVbyList=function(t,e,r,n){var i=Er,o=i.getIdxbyList(t,e,r,n);return -1==o||o>=t.length?null:i.getTLV(t,o)},Er.getTLVbyListEx=function(t,e,r,n){var i=Er,o=i.getIdxbyListEx(t,e,r,n);return -1==o?null:i.getTLV(t,o)},Er.getVbyList=function(t,e,r,n,i){var o,s,a=Er;return -1==(o=a.getIdxbyList(t,e,r,n))||o>=t.length?null:(s=a.getV(t,o),!0===i&&(s=s.substr(2)),s)},Er.getVbyListEx=function(t,e,r,n,i){var o,s,a=Er;return -1==(o=a.getIdxbyListEx(t,e,r,n))?null:(s=a.getV(t,o),"03"==t.substr(o,2)&&!1!==i&&(s=s.substr(2)),s)},Er.getInt=function(t,e,r){null==r&&(r=-1);try{var n=t.substr(e,2);if("02"!=n&&"03"!=n)return r;var i=Er.getV(t,e);return "02"==n?parseInt(i,16):function o(t){try{var e=t.substr(0,2);if("00"==e)return parseInt(t.substr(2),16);var r=parseInt(e,16),n=t.substr(2),i=parseInt(n,16).toString(2);return "0"==i&&(i="00000000"),i=i.slice(0,0-r),parseInt(i,2)}catch(t){return -1}}(i)}catch(t){return r}},Er.getOID=function(t,e,r){null==r&&(r=null);try{return "06"!=t.substr(e,2)?r:function n(t){if(!Xr(t))return null;try{var e=[],r=t.substr(0,2),n=parseInt(r,16);e[0]=new String(Math.floor(n/40)),e[1]=new String(n%40);for(var i=t.substr(2),o=[],s=0;s<i.length/2;s++)o.push(parseInt(i.substr(2*s,2),16));var a=[],u="";for(s=0;s<o.length;s++)128&o[s]?u+=Qr((127&o[s]).toString(2),7):(u+=Qr((127&o[s]).toString(2),7),a.push(new String(parseInt(u,2))),u="");var c=e.join(".");return a.length>0&&(c=c+"."+a.join(".")),c}catch(t){return null}}(Er.getV(t,e))}catch(t){return r}},Er.getOIDName=function(t,e,r){null==r&&(r=null);try{var n=Er.getOID(t,e,r);if(n==r)return r;var i=br.asn1.x509.OID.oid2name(n);return ""==i?n:i}catch(t){return r}},Er.getString=function(t,e,r){null==r&&(r=null);try{return Nr(Er.getV(t,e))}catch(t){return r}},Er.hextooidstr=function(t){var e=function t(e,r){return e.length>=r?e:new Array(r-e.length+1).join("0")+e},r=[],n=t.substr(0,2),i=parseInt(n,16);r[0]=new String(Math.floor(i/40)),r[1]=new String(i%40);for(var o=t.substr(2),s=[],a=0;a<o.length/2;a++)s.push(parseInt(o.substr(2*a,2),16));var u=[],c="";for(a=0;a<s.length;a++)128&s[a]?c+=e((127&s[a]).toString(2),7):(c+=e((127&s[a]).toString(2),7),u.push(new String(parseInt(c,2))),c="");var h=r.join(".");return u.length>0&&(h=h+"."+u.join(".")),h},Er.dump=function(t,e,r,n){var i=Er,o=i.getV,s=i.dump,a=i.getChildIdx,u=t;t instanceof br.asn1.ASN1Object&&(u=t.getEncodedHex());var c=function t(e,r){return e.length<=2*r?e:e.substr(0,r)+"..(total "+e.length/2+"bytes).."+e.substr(e.length-r,r)};void 0===e&&(e={ommit_long_octet:32}),void 0===r&&(r=0),void 0===n&&(n="");var h,l=e.ommit_long_octet;if("01"==(h=u.substr(r,2)))return "00"==(f=o(u,r))?n+"BOOLEAN FALSE\n":n+"BOOLEAN TRUE\n";if("02"==h)return n+"INTEGER "+c(f=o(u,r),l)+"\n";if("03"==h){var f=o(u,r);if(i.isASN1HEX(f.substr(2))){var g=n+"BITSTRING, encapsulates\n";return g+=s(f.substr(2),e,0,n+"  ")}return n+"BITSTRING "+c(f,l)+"\n"}if("04"==h){f=o(u,r);if(i.isASN1HEX(f)){g=n+"OCTETSTRING, encapsulates\n";return g+=s(f,e,0,n+"  ")}return n+"OCTETSTRING "+c(f,l)+"\n"}if("05"==h)return n+"NULL\n";if("06"==h){var d=o(u,r),p=br.asn1.ASN1Util.oidHexToInt(d),v=br.asn1.x509.OID.oid2name(p),y=p.replace(/\./g," ");return ""!=v?n+"ObjectIdentifier "+v+" ("+y+")\n":n+"ObjectIdentifier ("+y+")\n"}if("0a"==h)return n+"ENUMERATED "+parseInt(o(u,r))+"\n";if("0c"==h)return n+"UTF8String '"+Lr(o(u,r))+"'\n";if("13"==h)return n+"PrintableString '"+Lr(o(u,r))+"'\n";if("14"==h)return n+"TeletexString '"+Lr(o(u,r))+"'\n";if("16"==h)return n+"IA5String '"+Lr(o(u,r))+"'\n";if("17"==h)return n+"UTCTime "+Lr(o(u,r))+"\n";if("18"==h)return n+"GeneralizedTime "+Lr(o(u,r))+"\n";if("1a"==h)return n+"VisualString '"+Lr(o(u,r))+"'\n";if("1e"==h)return n+"BMPString '"+Lr(o(u,r))+"'\n";if("30"==h){if("3000"==u.substr(r,4))return n+"SEQUENCE {}\n";g=n+"SEQUENCE\n";var m=e;if((2==(b=a(u,r)).length||3==b.length)&&"06"==u.substr(b[0],2)&&"04"==u.substr(b[b.length-1],2)){v=i.oidname(o(u,b[0]));var _=JSON.parse(JSON.stringify(e));_.x509ExtName=v,m=_;}for(var S=0;S<b.length;S++)g+=s(u,m,b[S],n+"  ");return g}if("31"==h){g=n+"SET\n";var b=a(u,r);for(S=0;S<b.length;S++)g+=s(u,e,b[S],n+"  ");return g}if(0!=(128&(h=parseInt(h,16)))){var w=31&h;if(0!=(32&h)){for(g=n+"["+w+"]\n",b=a(u,r),S=0;S<b.length;S++)g+=s(u,e,b[S],n+"  ");return g}f=o(u,r);if(Er.isASN1HEX(f)){var g=n+"["+w+"]\n";return g+=s(f,e,0,n+"  ")}return ("68747470"==f.substr(0,8)||"subjectAltName"===e.x509ExtName&&2==w)&&(f=Lr(f)),g=n+"["+w+"] "+f+"\n"}return n+"UNKNOWN("+h+") "+o(u,r)+"\n"},Er.isContextTag=function(t,e){var r,n;t=t.toLowerCase();try{r=parseInt(t,16);}catch(t){return -1}if(void 0===e)return 128==(192&r);try{return null!=e.match(/^\[[0-9]+\]$/)&&(!((n=parseInt(e.substr(1,e.length-1),10))>31)&&(128==(192&r)&&(31&r)==n))}catch(t){return !1}},Er.isASN1HEX=function(t){var e=Er;if(t.length%2==1)return !1;var r=e.getVblen(t,0),n=t.substr(0,2),i=e.getL(t,0);return t.length-n.length-i.length==2*r},Er.checkStrictDER=function(t,e,r,n,i){var o=Er;if(void 0===r){if("string"!=typeof t)throw new Error("not hex string");if(t=t.toLowerCase(),!br.lang.String.isHex(t))throw new Error("not hex string");r=t.length,i=(n=t.length/2)<128?1:Math.ceil(n.toString(16))+1;}if(o.getL(t,e).length>2*i)throw new Error("L of TLV too long: idx="+e);var s=o.getVblen(t,e);if(s>n)throw new Error("value of L too long than hex: idx="+e);var a=o.getTLV(t,e),u=a.length-2-o.getL(t,e).length;if(u!==2*s)throw new Error("V string length and L's value not the same:"+u+"/"+2*s);if(0===e&&t.length!=a.length)throw new Error("total length and TLV length unmatch:"+t.length+"!="+a.length);var c=t.substr(e,2);if("02"===c){var h=o.getVidx(t,e);if("00"==t.substr(h,2)&&t.charCodeAt(h+2)<56)throw new Error("not least zeros for DER INTEGER")}if(32&parseInt(c,16)){for(var l=o.getVblen(t,e),f=0,g=o.getChildIdx(t,e),d=0;d<g.length;d++){f+=o.getTLV(t,g[d]).length,o.checkStrictDER(t,g[d],r,n,i);}if(2*l!=f)throw new Error("sum of children's TLV length and L unmatch: "+2*l+"!="+f)}},Er.oidname=function(t){var e=br.asn1;br.lang.String.isHex(t)&&(t=e.ASN1Util.oidHexToInt(t));var r=e.x509.OID.oid2name(t);return ""===r&&(r=t),r},void 0!==br&&br||(e.KJUR=br={}),void 0!==br.lang&&br.lang||(br.lang={}),br.lang.String=function(){},"function"==typeof t?(e.utf8tob64u=wr=function e(r){return Cr(t.from(r,"utf8").toString("base64"))},e.b64utoutf8=Fr=function e(r){return t.from(Tr(r),"base64").toString("utf8")}):(e.utf8tob64u=wr=function t(e){return Rr(qr(Gr(e)))},e.b64utoutf8=Fr=function t(e){return decodeURIComponent(Jr(Ir(e)))}),br.lang.String.isInteger=function(t){return !!t.match(/^[0-9]+$/)||!!t.match(/^-[0-9]+$/)},br.lang.String.isHex=function(t){return Xr(t)},br.lang.String.isBase64=function(t){return !(!(t=t.replace(/\s+/g,"")).match(/^[0-9A-Za-z+\/]+={0,3}$/)||t.length%4!=0)},br.lang.String.isBase64URL=function(t){return !t.match(/[+/=]/)&&(t=Tr(t),br.lang.String.isBase64(t))},br.lang.String.isIntegerArray=function(t){return !!(t=t.replace(/\s+/g,"")).match(/^\[[0-9,]+\]$/)},br.lang.String.isPrintable=function(t){return null!==t.match(/^[0-9A-Za-z '()+,-./:=?]*$/)},br.lang.String.isIA5=function(t){return null!==t.match(/^[\x20-\x21\x23-\x7f]*$/)},br.lang.String.isMail=function(t){return null!==t.match(/^[A-Za-z0-9]{1}[A-Za-z0-9_.-]*@{1}[A-Za-z0-9_.-]{1,}\.[A-Za-z0-9]{1,}$/)};var Qr=function t(e,r,n){return null==n&&(n="0"),e.length>=r?e:new Array(r-e.length+1).join(n)+e};void 0!==br&&br||(e.KJUR=br={}),void 0!==br.crypto&&br.crypto||(br.crypto={}),br.crypto.Util=new function(){this.DIGESTINFOHEAD={sha1:"3021300906052b0e03021a05000414",sha224:"302d300d06096086480165030402040500041c",sha256:"3031300d060960864801650304020105000420",sha384:"3041300d060960864801650304020205000430",sha512:"3051300d060960864801650304020305000440",md2:"3020300c06082a864886f70d020205000410",md5:"3020300c06082a864886f70d020505000410",ripemd160:"3021300906052b2403020105000414"},this.DEFAULTPROVIDER={md5:"cryptojs",sha1:"cryptojs",sha224:"cryptojs",sha256:"cryptojs",sha384:"cryptojs",sha512:"cryptojs",ripemd160:"cryptojs",hmacmd5:"cryptojs",hmacsha1:"cryptojs",hmacsha224:"cryptojs",hmacsha256:"cryptojs",hmacsha384:"cryptojs",hmacsha512:"cryptojs",hmacripemd160:"cryptojs",MD5withRSA:"cryptojs/jsrsa",SHA1withRSA:"cryptojs/jsrsa",SHA224withRSA:"cryptojs/jsrsa",SHA256withRSA:"cryptojs/jsrsa",SHA384withRSA:"cryptojs/jsrsa",SHA512withRSA:"cryptojs/jsrsa",RIPEMD160withRSA:"cryptojs/jsrsa",MD5withECDSA:"cryptojs/jsrsa",SHA1withECDSA:"cryptojs/jsrsa",SHA224withECDSA:"cryptojs/jsrsa",SHA256withECDSA:"cryptojs/jsrsa",SHA384withECDSA:"cryptojs/jsrsa",SHA512withECDSA:"cryptojs/jsrsa",RIPEMD160withECDSA:"cryptojs/jsrsa",SHA1withDSA:"cryptojs/jsrsa",SHA224withDSA:"cryptojs/jsrsa",SHA256withDSA:"cryptojs/jsrsa",MD5withRSAandMGF1:"cryptojs/jsrsa",SHAwithRSAandMGF1:"cryptojs/jsrsa",SHA1withRSAandMGF1:"cryptojs/jsrsa",SHA224withRSAandMGF1:"cryptojs/jsrsa",SHA256withRSAandMGF1:"cryptojs/jsrsa",SHA384withRSAandMGF1:"cryptojs/jsrsa",SHA512withRSAandMGF1:"cryptojs/jsrsa",RIPEMD160withRSAandMGF1:"cryptojs/jsrsa"},this.CRYPTOJSMESSAGEDIGESTNAME={md5:y.algo.MD5,sha1:y.algo.SHA1,sha224:y.algo.SHA224,sha256:y.algo.SHA256,sha384:y.algo.SHA384,sha512:y.algo.SHA512,ripemd160:y.algo.RIPEMD160},this.getDigestInfoHex=function(t,e){if(void 0===this.DIGESTINFOHEAD[e])throw "alg not supported in Util.DIGESTINFOHEAD: "+e;return this.DIGESTINFOHEAD[e]+t},this.getPaddedDigestInfoHex=function(t,e,r){var n=this.getDigestInfoHex(t,e),i=r/4;if(n.length+22>i)throw "key is too short for SigAlg: keylen="+r+","+e;for(var o="0001",s="00"+n,a="",u=i-o.length-s.length,c=0;c<u;c+=2)a+="ff";return o+a+s},this.hashString=function(t,e){return new br.crypto.MessageDigest({alg:e}).digestString(t)},this.hashHex=function(t,e){return new br.crypto.MessageDigest({alg:e}).digestHex(t)},this.sha1=function(t){return this.hashString(t,"sha1")},this.sha256=function(t){return this.hashString(t,"sha256")},this.sha256Hex=function(t){return this.hashHex(t,"sha256")},this.sha512=function(t){return this.hashString(t,"sha512")},this.sha512Hex=function(t){return this.hashHex(t,"sha512")},this.isKey=function(t){return t instanceof He||t instanceof br.crypto.DSA||t instanceof br.crypto.ECDSA};},br.crypto.Util.md5=function(t){return new br.crypto.MessageDigest({alg:"md5",prov:"cryptojs"}).digestString(t)},br.crypto.Util.ripemd160=function(t){return new br.crypto.MessageDigest({alg:"ripemd160",prov:"cryptojs"}).digestString(t)},br.crypto.Util.SECURERANDOMGEN=new Oe,br.crypto.Util.getRandomHexOfNbytes=function(t){var e=new Array(t);return br.crypto.Util.SECURERANDOMGEN.nextBytes(e),kr(e)},br.crypto.Util.getRandomBigIntegerOfNbytes=function(t){return new F(br.crypto.Util.getRandomHexOfNbytes(t),16)},br.crypto.Util.getRandomHexOfNbits=function(t){var e=t%8,r=new Array((t-e)/8+1);return br.crypto.Util.SECURERANDOMGEN.nextBytes(r),r[0]=(255<<e&255^255)&r[0],kr(r)},br.crypto.Util.getRandomBigIntegerOfNbits=function(t){return new F(br.crypto.Util.getRandomHexOfNbits(t),16)},br.crypto.Util.getRandomBigIntegerZeroToMax=function(t){for(var e=t.bitLength();;){var r=br.crypto.Util.getRandomBigIntegerOfNbits(e);if(-1!=t.compareTo(r))return r}},br.crypto.Util.getRandomBigIntegerMinToMax=function(t,e){var r=t.compareTo(e);if(1==r)throw "biMin is greater than biMax";if(0==r)return t;var n=e.subtract(t);return br.crypto.Util.getRandomBigIntegerZeroToMax(n).add(t)},br.crypto.MessageDigest=function(t){this.setAlgAndProvider=function(t,e){if(null!==(t=br.crypto.MessageDigest.getCanonicalAlgName(t))&&void 0===e&&(e=br.crypto.Util.DEFAULTPROVIDER[t]),-1!=":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(t)&&"cryptojs"==e){try{this.md=br.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[t].create();}catch(e){throw "setAlgAndProvider hash alg set fail alg="+t+"/"+e}this.updateString=function(t){this.md.update(t);},this.updateHex=function(t){var e=y.enc.Hex.parse(t);this.md.update(e);},this.digest=function(){return this.md.finalize().toString(y.enc.Hex)},this.digestString=function(t){return this.updateString(t),this.digest()},this.digestHex=function(t){return this.updateHex(t),this.digest()};}if(-1!=":sha256:".indexOf(t)&&"sjcl"==e){try{this.md=new sjcl.hash.sha256;}catch(e){throw "setAlgAndProvider hash alg set fail alg="+t+"/"+e}this.updateString=function(t){this.md.update(t);},this.updateHex=function(t){var e=sjcl.codec.hex.toBits(t);this.md.update(e);},this.digest=function(){var t=this.md.finalize();return sjcl.codec.hex.fromBits(t)},this.digestString=function(t){return this.updateString(t),this.digest()},this.digestHex=function(t){return this.updateHex(t),this.digest()};}},this.updateString=function(t){throw "updateString(str) not supported for this alg/prov: "+this.algName+"/"+this.provName},this.updateHex=function(t){throw "updateHex(hex) not supported for this alg/prov: "+this.algName+"/"+this.provName},this.digest=function(){throw "digest() not supported for this alg/prov: "+this.algName+"/"+this.provName},this.digestString=function(t){throw "digestString(str) not supported for this alg/prov: "+this.algName+"/"+this.provName},this.digestHex=function(t){throw "digestHex(hex) not supported for this alg/prov: "+this.algName+"/"+this.provName},void 0!==t&&void 0!==t.alg&&(this.algName=t.alg,void 0===t.prov&&(this.provName=br.crypto.Util.DEFAULTPROVIDER[this.algName]),this.setAlgAndProvider(this.algName,this.provName));},br.crypto.MessageDigest.getCanonicalAlgName=function(t){return "string"==typeof t&&(t=(t=t.toLowerCase()).replace(/-/,"")),t},br.crypto.MessageDigest.getHashLength=function(t){var e=br.crypto.MessageDigest,r=e.getCanonicalAlgName(t);if(void 0===e.HASHLENGTH[r])throw "not supported algorithm: "+t;return e.HASHLENGTH[r]},br.crypto.MessageDigest.HASHLENGTH={md5:16,sha1:20,sha224:28,sha256:32,sha384:48,sha512:64,ripemd160:20},br.crypto.Mac=function(t){this.setAlgAndProvider=function(t,e){if(null==(t=t.toLowerCase())&&(t="hmacsha1"),"hmac"!=(t=t.toLowerCase()).substr(0,4))throw "setAlgAndProvider unsupported HMAC alg: "+t;void 0===e&&(e=br.crypto.Util.DEFAULTPROVIDER[t]),this.algProv=t+"/"+e;var r=t.substr(4);if(-1!=":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(r)&&"cryptojs"==e){try{var n=br.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[r];this.mac=y.algo.HMAC.create(n,this.pass);}catch(t){throw "setAlgAndProvider hash alg set fail hashAlg="+r+"/"+t}this.updateString=function(t){this.mac.update(t);},this.updateHex=function(t){var e=y.enc.Hex.parse(t);this.mac.update(e);},this.doFinal=function(){return this.mac.finalize().toString(y.enc.Hex)},this.doFinalString=function(t){return this.updateString(t),this.doFinal()},this.doFinalHex=function(t){return this.updateHex(t),this.doFinal()};}},this.updateString=function(t){throw "updateString(str) not supported for this alg/prov: "+this.algProv},this.updateHex=function(t){throw "updateHex(hex) not supported for this alg/prov: "+this.algProv},this.doFinal=function(){throw "digest() not supported for this alg/prov: "+this.algProv},this.doFinalString=function(t){throw "digestString(str) not supported for this alg/prov: "+this.algProv},this.doFinalHex=function(t){throw "digestHex(hex) not supported for this alg/prov: "+this.algProv},this.setPassword=function(t){if("string"==typeof t){var e=t;return t.length%2!=1&&t.match(/^[0-9A-Fa-f]+$/)||(e=Ur(t)),void(this.pass=y.enc.Hex.parse(e))}if("object"!=(void 0===t?"undefined":r(t)))throw "KJUR.crypto.Mac unsupported password type: "+t;e=null;if(void 0!==t.hex){if(t.hex.length%2!=0||!t.hex.match(/^[0-9A-Fa-f]+$/))throw "Mac: wrong hex password: "+t.hex;e=t.hex;}if(void 0!==t.utf8&&(e=Dr(t.utf8)),void 0!==t.rstr&&(e=Ur(t.rstr)),void 0!==t.b64&&(e=b(t.b64)),void 0!==t.b64u&&(e=Ir(t.b64u)),null==e)throw "KJUR.crypto.Mac unsupported password type: "+t;this.pass=y.enc.Hex.parse(e);},void 0!==t&&(void 0!==t.pass&&this.setPassword(t.pass),void 0!==t.alg&&(this.algName=t.alg,void 0===t.prov&&(this.provName=br.crypto.Util.DEFAULTPROVIDER[this.algName]),this.setAlgAndProvider(this.algName,this.provName)));},br.crypto.Signature=function(t){var e=null;if(this._setAlgNames=function(){var t=this.algName.match(/^(.+)with(.+)$/);t&&(this.mdAlgName=t[1].toLowerCase(),this.pubkeyAlgName=t[2].toLowerCase(),"rsaandmgf1"==this.pubkeyAlgName&&"sha"==this.mdAlgName&&(this.mdAlgName="sha1"));},this._zeroPaddingOfSignature=function(t,e){for(var r="",n=e/4-t.length,i=0;i<n;i++)r+="0";return r+t},this.setAlgAndProvider=function(t,e){if(this._setAlgNames(),"cryptojs/jsrsa"!=e)throw new Error("provider not supported: "+e);if(-1!=":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(this.mdAlgName)){try{this.md=new br.crypto.MessageDigest({alg:this.mdAlgName});}catch(t){throw new Error("setAlgAndProvider hash alg set fail alg="+this.mdAlgName+"/"+t)}this.init=function(t,e){var r=null;try{r=void 0===e?Zr.getKey(t):Zr.getKey(t,e);}catch(t){throw "init failed:"+t}if(!0===r.isPrivate)this.prvKey=r,this.state="SIGN";else {if(!0!==r.isPublic)throw "init failed.:"+r;this.pubKey=r,this.state="VERIFY";}},this.updateString=function(t){this.md.updateString(t);},this.updateHex=function(t){this.md.updateHex(t);},this.sign=function(){if(this.sHashHex=this.md.digest(),void 0===this.prvKey&&void 0!==this.ecprvhex&&void 0!==this.eccurvename&&void 0!==br.crypto.ECDSA&&(this.prvKey=new br.crypto.ECDSA({curve:this.eccurvename,prv:this.ecprvhex})),this.prvKey instanceof He&&"rsaandmgf1"===this.pubkeyAlgName)this.hSign=this.prvKey.signWithMessageHashPSS(this.sHashHex,this.mdAlgName,this.pssSaltLen);else if(this.prvKey instanceof He&&"rsa"===this.pubkeyAlgName)this.hSign=this.prvKey.signWithMessageHash(this.sHashHex,this.mdAlgName);else if(this.prvKey instanceof br.crypto.ECDSA)this.hSign=this.prvKey.signWithMessageHash(this.sHashHex);else {if(!(this.prvKey instanceof br.crypto.DSA))throw "Signature: unsupported private key alg: "+this.pubkeyAlgName;this.hSign=this.prvKey.signWithMessageHash(this.sHashHex);}return this.hSign},this.signString=function(t){return this.updateString(t),this.sign()},this.signHex=function(t){return this.updateHex(t),this.sign()},this.verify=function(t){if(this.sHashHex=this.md.digest(),void 0===this.pubKey&&void 0!==this.ecpubhex&&void 0!==this.eccurvename&&void 0!==br.crypto.ECDSA&&(this.pubKey=new br.crypto.ECDSA({curve:this.eccurvename,pub:this.ecpubhex})),this.pubKey instanceof He&&"rsaandmgf1"===this.pubkeyAlgName)return this.pubKey.verifyWithMessageHashPSS(this.sHashHex,t,this.mdAlgName,this.pssSaltLen);if(this.pubKey instanceof He&&"rsa"===this.pubkeyAlgName)return this.pubKey.verifyWithMessageHash(this.sHashHex,t);if(void 0!==br.crypto.ECDSA&&this.pubKey instanceof br.crypto.ECDSA)return this.pubKey.verifyWithMessageHash(this.sHashHex,t);if(void 0!==br.crypto.DSA&&this.pubKey instanceof br.crypto.DSA)return this.pubKey.verifyWithMessageHash(this.sHashHex,t);throw "Signature: unsupported public key alg: "+this.pubkeyAlgName};}},this.init=function(t,e){throw "init(key, pass) not supported for this alg:prov="+this.algProvName},this.updateString=function(t){throw "updateString(str) not supported for this alg:prov="+this.algProvName},this.updateHex=function(t){throw "updateHex(hex) not supported for this alg:prov="+this.algProvName},this.sign=function(){throw "sign() not supported for this alg:prov="+this.algProvName},this.signString=function(t){throw "digestString(str) not supported for this alg:prov="+this.algProvName},this.signHex=function(t){throw "digestHex(hex) not supported for this alg:prov="+this.algProvName},this.verify=function(t){throw "verify(hSigVal) not supported for this alg:prov="+this.algProvName},this.initParams=t,void 0!==t&&(void 0!==t.alg&&(this.algName=t.alg,void 0===t.prov?this.provName=br.crypto.Util.DEFAULTPROVIDER[this.algName]:this.provName=t.prov,this.algProvName=this.algName+":"+this.provName,this.setAlgAndProvider(this.algName,this.provName),this._setAlgNames()),void 0!==t.psssaltlen&&(this.pssSaltLen=t.psssaltlen),void 0!==t.prvkeypem)){if(void 0!==t.prvkeypas)throw "both prvkeypem and prvkeypas parameters not supported";try{e=Zr.getKey(t.prvkeypem);this.init(e);}catch(t){throw "fatal error to load pem private key: "+t}}},br.crypto.Cipher=function(t){},br.crypto.Cipher.encrypt=function(t,e,r){if(e instanceof He&&e.isPublic){var n=br.crypto.Cipher.getAlgByKeyAndName(e,r);if("RSA"===n)return e.encrypt(t);if("RSAOAEP"===n)return e.encryptOAEP(t,"sha1");var i=n.match(/^RSAOAEP(\d+)$/);if(null!==i)return e.encryptOAEP(t,"sha"+i[1]);throw "Cipher.encrypt: unsupported algorithm for RSAKey: "+r}throw "Cipher.encrypt: unsupported key or algorithm"},br.crypto.Cipher.decrypt=function(t,e,r){if(e instanceof He&&e.isPrivate){var n=br.crypto.Cipher.getAlgByKeyAndName(e,r);if("RSA"===n)return e.decrypt(t);if("RSAOAEP"===n)return e.decryptOAEP(t,"sha1");var i=n.match(/^RSAOAEP(\d+)$/);if(null!==i)return e.decryptOAEP(t,"sha"+i[1]);throw "Cipher.decrypt: unsupported algorithm for RSAKey: "+r}throw "Cipher.decrypt: unsupported key or algorithm"},br.crypto.Cipher.getAlgByKeyAndName=function(t,e){if(t instanceof He){if(-1!=":RSA:RSAOAEP:RSAOAEP224:RSAOAEP256:RSAOAEP384:RSAOAEP512:".indexOf(e))return e;if(null==e)return "RSA";throw "getAlgByKeyAndName: not supported algorithm name for RSAKey: "+e}throw "getAlgByKeyAndName: not supported algorithm name: "+e},br.crypto.OID=new function(){this.oidhex2name={"2a864886f70d010101":"rsaEncryption","2a8648ce3d0201":"ecPublicKey","2a8648ce380401":"dsa","2a8648ce3d030107":"secp256r1","2b8104001f":"secp192k1","2b81040021":"secp224r1","2b8104000a":"secp256k1","2b81040023":"secp521r1","2b81040022":"secp384r1","2a8648ce380403":"SHA1withDSA","608648016503040301":"SHA224withDSA","608648016503040302":"SHA256withDSA"};},void 0!==br&&br||(e.KJUR=br={}),void 0!==br.crypto&&br.crypto||(br.crypto={}),br.crypto.ECDSA=function(t){var e=Error,n=F,i=Ke,o=br.crypto.ECDSA,s=br.crypto.ECParameterDB,a=o.getName,u=Er,c=u.getVbyListEx,h=u.isASN1HEX,l=new Oe;this.type="EC",this.isPrivate=!1,this.isPublic=!1,this.getBigRandom=function(t){return new n(t.bitLength(),l).mod(t.subtract(n.ONE)).add(n.ONE)},this.setNamedCurve=function(t){this.ecparams=s.getByName(t),this.prvKeyHex=null,this.pubKeyHex=null,this.curveName=t;},this.setPrivateKeyHex=function(t){this.isPrivate=!0,this.prvKeyHex=t;},this.setPublicKeyHex=function(t){this.isPublic=!0,this.pubKeyHex=t;},this.getPublicKeyXYHex=function(){var t=this.pubKeyHex;if("04"!==t.substr(0,2))throw "this method supports uncompressed format(04) only";var e=this.ecparams.keylen/4;if(t.length!==2+2*e)throw "malformed public key hex length";var r={};return r.x=t.substr(2,e),r.y=t.substr(2+e),r},this.getShortNISTPCurveName=function(){var t=this.curveName;return "secp256r1"===t||"NIST P-256"===t||"P-256"===t||"prime256v1"===t?"P-256":"secp384r1"===t||"NIST P-384"===t||"P-384"===t?"P-384":null},this.generateKeyPairHex=function(){var t=this.ecparams.n,e=this.getBigRandom(t),r=this.ecparams.G.multiply(e),n=r.getX().toBigInteger(),i=r.getY().toBigInteger(),o=this.ecparams.keylen/4,s=("0000000000"+e.toString(16)).slice(-o),a="04"+("0000000000"+n.toString(16)).slice(-o)+("0000000000"+i.toString(16)).slice(-o);return this.setPrivateKeyHex(s),this.setPublicKeyHex(a),{ecprvhex:s,ecpubhex:a}},this.signWithMessageHash=function(t){return this.signHex(t,this.prvKeyHex)},this.signHex=function(t,e){var r=new n(e,16),i=this.ecparams.n,s=new n(t.substring(0,this.ecparams.keylen/4),16);do{var a=this.getBigRandom(i),u=this.ecparams.G.multiply(a).getX().toBigInteger().mod(i);}while(u.compareTo(n.ZERO)<=0);var c=a.modInverse(i).multiply(s.add(r.multiply(u))).mod(i);return o.biRSSigToASN1Sig(u,c)},this.sign=function(t,e){var r=e,i=this.ecparams.n,o=n.fromByteArrayUnsigned(t);do{var s=this.getBigRandom(i),a=this.ecparams.G.multiply(s).getX().toBigInteger().mod(i);}while(a.compareTo(F.ZERO)<=0);var u=s.modInverse(i).multiply(o.add(r.multiply(a))).mod(i);return this.serializeSig(a,u)},this.verifyWithMessageHash=function(t,e){return this.verifyHex(t,e,this.pubKeyHex)},this.verifyHex=function(t,e,r){try{var s,a,u=o.parseSigHex(e);s=u.r,a=u.s;var c=i.decodeFromHex(this.ecparams.curve,r),h=new n(t.substring(0,this.ecparams.keylen/4),16);return this.verifyRaw(h,s,a,c)}catch(t){return !1}},this.verify=function(t,e,o){var s,a,u;if(Bitcoin.Util.isArray(e)){var c=this.parseSig(e);s=c.r,a=c.s;}else {if("object"!==(void 0===e?"undefined":r(e))||!e.r||!e.s)throw "Invalid value for signature";s=e.r,a=e.s;}if(o instanceof Ke)u=o;else {if(!Bitcoin.Util.isArray(o))throw "Invalid format for pubkey value, must be byte array or ECPointFp";u=i.decodeFrom(this.ecparams.curve,o);}var h=n.fromByteArrayUnsigned(t);return this.verifyRaw(h,s,a,u)},this.verifyRaw=function(t,e,r,i){var o=this.ecparams.n,s=this.ecparams.G;if(e.compareTo(n.ONE)<0||e.compareTo(o)>=0)return !1;if(r.compareTo(n.ONE)<0||r.compareTo(o)>=0)return !1;var a=r.modInverse(o),u=t.multiply(a).mod(o),c=e.multiply(a).mod(o);return s.multiply(u).add(i.multiply(c)).getX().toBigInteger().mod(o).equals(e)},this.serializeSig=function(t,e){var r=t.toByteArraySigned(),n=e.toByteArraySigned(),i=[];return i.push(2),i.push(r.length),(i=i.concat(r)).push(2),i.push(n.length),(i=i.concat(n)).unshift(i.length),i.unshift(48),i},this.parseSig=function(t){var e;if(48!=t[0])throw new Error("Signature not a valid DERSequence");if(2!=t[e=2])throw new Error("First element in signature must be a DERInteger");var r=t.slice(e+2,e+2+t[e+1]);if(2!=t[e+=2+t[e+1]])throw new Error("Second element in signature must be a DERInteger");var i=t.slice(e+2,e+2+t[e+1]);return e+=2+t[e+1],{r:n.fromByteArrayUnsigned(r),s:n.fromByteArrayUnsigned(i)}},this.parseSigCompact=function(t){if(65!==t.length)throw "Signature has the wrong length";var e=t[0]-27;if(e<0||e>7)throw "Invalid signature type";var r=this.ecparams.n;return {r:n.fromByteArrayUnsigned(t.slice(1,33)).mod(r),s:n.fromByteArrayUnsigned(t.slice(33,65)).mod(r),i:e}},this.readPKCS5PrvKeyHex=function(t){if(!1===h(t))throw new Error("not ASN.1 hex string");var e,r,n;try{e=c(t,0,["[0]",0],"06"),r=c(t,0,[1],"04");try{n=c(t,0,["[1]",0],"03");}catch(t){}}catch(t){throw new Error("malformed PKCS#1/5 plain ECC private key")}if(this.curveName=a(e),void 0===this.curveName)throw "unsupported curve name";this.setNamedCurve(this.curveName),this.setPublicKeyHex(n),this.setPrivateKeyHex(r),this.isPublic=!1;},this.readPKCS8PrvKeyHex=function(t){if(!1===h(t))throw new e("not ASN.1 hex string");var r,n,i;try{c(t,0,[1,0],"06"),r=c(t,0,[1,1],"06"),n=c(t,0,[2,0,1],"04");try{i=c(t,0,[2,0,"[1]",0],"03");}catch(t){}}catch(t){throw new e("malformed PKCS#8 plain ECC private key")}if(this.curveName=a(r),void 0===this.curveName)throw new e("unsupported curve name");this.setNamedCurve(this.curveName),this.setPublicKeyHex(i),this.setPrivateKeyHex(n),this.isPublic=!1;},this.readPKCS8PubKeyHex=function(t){if(!1===h(t))throw new e("not ASN.1 hex string");var r,n;try{c(t,0,[0,0],"06"),r=c(t,0,[0,1],"06"),n=c(t,0,[1],"03");}catch(t){throw new e("malformed PKCS#8 ECC public key")}if(this.curveName=a(r),null===this.curveName)throw new e("unsupported curve name");this.setNamedCurve(this.curveName),this.setPublicKeyHex(n);},this.readCertPubKeyHex=function(t,r){if(!1===h(t))throw new e("not ASN.1 hex string");var n,i;try{n=c(t,0,[0,5,0,1],"06"),i=c(t,0,[0,5,1],"03");}catch(t){throw new e("malformed X.509 certificate ECC public key")}if(this.curveName=a(n),null===this.curveName)throw new e("unsupported curve name");this.setNamedCurve(this.curveName),this.setPublicKeyHex(i);},void 0!==t&&void 0!==t.curve&&(this.curveName=t.curve),void 0===this.curveName&&(this.curveName="secp256r1"),this.setNamedCurve(this.curveName),void 0!==t&&(void 0!==t.prv&&this.setPrivateKeyHex(t.prv),void 0!==t.pub&&this.setPublicKeyHex(t.pub));},br.crypto.ECDSA.parseSigHex=function(t){var e=br.crypto.ECDSA.parseSigHexInHexRS(t);return {r:new F(e.r,16),s:new F(e.s,16)}},br.crypto.ECDSA.parseSigHexInHexRS=function(t){var e=Er,r=e.getChildIdx,n=e.getV;if(e.checkStrictDER(t,0),"30"!=t.substr(0,2))throw new Error("signature is not a ASN.1 sequence");var i=r(t,0);if(2!=i.length)throw new Error("signature shall have two elements");var o=i[0],s=i[1];if("02"!=t.substr(o,2))throw new Error("1st item not ASN.1 integer");if("02"!=t.substr(s,2))throw new Error("2nd item not ASN.1 integer");return {r:n(t,o),s:n(t,s)}},br.crypto.ECDSA.asn1SigToConcatSig=function(t){var e=br.crypto.ECDSA.parseSigHexInHexRS(t),r=e.r,n=e.s;if("00"==r.substr(0,2)&&r.length%32==2&&(r=r.substr(2)),"00"==n.substr(0,2)&&n.length%32==2&&(n=n.substr(2)),r.length%32==30&&(r="00"+r),n.length%32==30&&(n="00"+n),r.length%32!=0)throw "unknown ECDSA sig r length error";if(n.length%32!=0)throw "unknown ECDSA sig s length error";return r+n},br.crypto.ECDSA.concatSigToASN1Sig=function(t){if(t.length/2*8%128!=0)throw "unknown ECDSA concatinated r-s sig  length error";var e=t.substr(0,t.length/2),r=t.substr(t.length/2);return br.crypto.ECDSA.hexRSSigToASN1Sig(e,r)},br.crypto.ECDSA.hexRSSigToASN1Sig=function(t,e){var r=new F(t,16),n=new F(e,16);return br.crypto.ECDSA.biRSSigToASN1Sig(r,n)},br.crypto.ECDSA.biRSSigToASN1Sig=function(t,e){var r=br.asn1,n=new r.DERInteger({bigint:t}),i=new r.DERInteger({bigint:e});return new r.DERSequence({array:[n,i]}).getEncodedHex()},br.crypto.ECDSA.getName=function(t){return "2b8104001f"===t?"secp192k1":"2a8648ce3d030107"===t?"secp256r1":"2b8104000a"===t?"secp256k1":"2b81040021"===t?"secp224r1":"2b81040022"===t?"secp384r1":-1!=="|secp256r1|NIST P-256|P-256|prime256v1|".indexOf(t)?"secp256r1":-1!=="|secp256k1|".indexOf(t)?"secp256k1":-1!=="|secp224r1|NIST P-224|P-224|".indexOf(t)?"secp224r1":-1!=="|secp384r1|NIST P-384|P-384|".indexOf(t)?"secp384r1":null},void 0!==br&&br||(e.KJUR=br={}),void 0!==br.crypto&&br.crypto||(br.crypto={}),br.crypto.ECParameterDB=new function(){var t={},e={};function r(t){return new F(t,16)}this.getByName=function(r){var n=r;if(void 0!==e[n]&&(n=e[r]),void 0!==t[n])return t[n];throw "unregistered EC curve name: "+n},this.regist=function(n,i,o,s,a,u,c,h,l,f,g,d){t[n]={};var p=r(o),v=r(s),y=r(a),m=r(u),_=r(c),S=new qe(p,v,y),b=S.decodePointHex("04"+h+l);t[n].name=n,t[n].keylen=i,t[n].curve=S,t[n].G=b,t[n].n=m,t[n].h=_,t[n].oid=g,t[n].info=d;for(var w=0;w<f.length;w++)e[f[w]]=n;};},br.crypto.ECParameterDB.regist("secp128r1",128,"FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF","FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC","E87579C11079F43DD824993C2CEE5ED3","FFFFFFFE0000000075A30D1B9038A115","1","161FF7528B899B2D0C28607CA52C5B86","CF5AC8395BAFEB13C02DA292DDED7A83",[],"","secp128r1 : SECG curve over a 128 bit prime field"),br.crypto.ECParameterDB.regist("secp160k1",160,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73","0","7","0100000000000000000001B8FA16DFAB9ACA16B6B3","1","3B4C382CE37AA192A4019E763036F4F5DD4D7EBB","938CF935318FDCED6BC28286531733C3F03C4FEE",[],"","secp160k1 : SECG curve over a 160 bit prime field"),br.crypto.ECParameterDB.regist("secp160r1",160,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC","1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45","0100000000000000000001F4C8F927AED3CA752257","1","4A96B5688EF573284664698968C38BB913CBFC82","23A628553168947D59DCC912042351377AC5FB32",[],"","secp160r1 : SECG curve over a 160 bit prime field"),br.crypto.ECParameterDB.regist("secp192k1",192,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37","0","3","FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D","1","DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D","9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D",[]),br.crypto.ECParameterDB.regist("secp192r1",192,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC","64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1","FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831","1","188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012","07192B95FFC8DA78631011ED6B24CDD573F977A11E794811",[]),br.crypto.ECParameterDB.regist("secp224r1",224,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE","B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4","FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D","1","B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21","BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34",[]),br.crypto.ECParameterDB.regist("secp256k1",256,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F","0","7","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141","1","79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798","483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8",[]),br.crypto.ECParameterDB.regist("secp256r1",256,"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF","FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC","5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B","FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551","1","6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296","4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5",["NIST P-256","P-256","prime256v1"]),br.crypto.ECParameterDB.regist("secp384r1",384,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC","B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973","1","AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7","3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f",["NIST P-384","P-384"]),br.crypto.ECParameterDB.regist("secp521r1",521,"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF","1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC","051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00","1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409","1","C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66","011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650",["NIST P-521","P-521"]);var Zr=function(){var t=function t(r,n,i){return e(y.AES,r,n,i)},e=function t(e,r,n,i){var o=y.enc.Hex.parse(r),s=y.enc.Hex.parse(n),a=y.enc.Hex.parse(i),u={};u.key=s,u.iv=a,u.ciphertext=o;var c=e.decrypt(u,s,{iv:a});return y.enc.Hex.stringify(c)},r=function t(e,r,i){return n(y.AES,e,r,i)},n=function t(e,r,n,i){var o=y.enc.Hex.parse(r),s=y.enc.Hex.parse(n),a=y.enc.Hex.parse(i),u=e.encrypt(o,s,{iv:a}),c=y.enc.Hex.parse(u.toString());return y.enc.Base64.stringify(c)},i={"AES-256-CBC":{proc:t,eproc:r,keylen:32,ivlen:16},"AES-192-CBC":{proc:t,eproc:r,keylen:24,ivlen:16},"AES-128-CBC":{proc:t,eproc:r,keylen:16,ivlen:16},"DES-EDE3-CBC":{proc:function t(r,n,i){return e(y.TripleDES,r,n,i)},eproc:function t(e,r,i){return n(y.TripleDES,e,r,i)},keylen:24,ivlen:8},"DES-CBC":{proc:function t(r,n,i){return e(y.DES,r,n,i)},eproc:function t(e,r,i){return n(y.DES,e,r,i)},keylen:8,ivlen:8}},o=function t(e){var r={},n=e.match(new RegExp("DEK-Info: ([^,]+),([0-9A-Fa-f]+)","m"));n&&(r.cipher=n[1],r.ivsalt=n[2]);var i=e.match(new RegExp("-----BEGIN ([A-Z]+) PRIVATE KEY-----"));i&&(r.type=i[1]);var o=-1,s=0;-1!=e.indexOf("\r\n\r\n")&&(o=e.indexOf("\r\n\r\n"),s=2),-1!=e.indexOf("\n\n")&&(o=e.indexOf("\n\n"),s=1);var a=e.indexOf("-----END");if(-1!=o&&-1!=a){var u=e.substring(o+2*s,a-s);u=u.replace(/\s+/g,""),r.data=u;}return r},s=function t(e,r,n){for(var o=n.substring(0,16),s=y.enc.Hex.parse(o),a=y.enc.Utf8.parse(r),u=i[e].keylen+i[e].ivlen,c="",h=null;;){var l=y.algo.MD5.create();if(null!=h&&l.update(h),l.update(a),l.update(s),h=l.finalize(),(c+=y.enc.Hex.stringify(h)).length>=2*u)break}var f={};return f.keyhex=c.substr(0,2*i[e].keylen),f.ivhex=c.substr(2*i[e].keylen,2*i[e].ivlen),f},a=function t(e,r,n,o){var s=y.enc.Base64.parse(e),a=y.enc.Hex.stringify(s);return (0, i[r].proc)(a,n,o)};return {version:"1.0.0",parsePKCS5PEM:function t(e){return o(e)},getKeyAndUnusedIvByPasscodeAndIvsalt:function t(e,r,n){return s(e,r,n)},decryptKeyB64:function t(e,r,n,i){return a(e,r,n,i)},getDecryptedKeyHex:function t(e,r){var n=o(e),i=(n.cipher),u=n.ivsalt,c=n.data,h=s(i,r,u).keyhex;return a(c,i,h,u)},getEncryptedPKCS5PEMFromPrvKeyHex:function t(e,r,n,o,a){var u="";if(void 0!==o&&null!=o||(o="AES-256-CBC"),void 0===i[o])throw "KEYUTIL unsupported algorithm: "+o;void 0!==a&&null!=a||(a=function t(e){var r=y.lib.WordArray.random(e);return y.enc.Hex.stringify(r)}(i[o].ivlen).toUpperCase());var c=function t(e,r,n,o){return (0, i[r].eproc)(e,n,o)}(r,o,s(o,n,a).keyhex,a);u="-----BEGIN "+e+" PRIVATE KEY-----\r\n";return u+="Proc-Type: 4,ENCRYPTED\r\n",u+="DEK-Info: "+o+","+a+"\r\n",u+="\r\n",u+=c.replace(/(.{64})/g,"$1\r\n"),u+="\r\n-----END "+e+" PRIVATE KEY-----\r\n"},parseHexOfEncryptedPKCS8:function t(e){var r=Er,n=r.getChildIdx,i=r.getV,o={},s=n(e,0);if(2!=s.length)throw "malformed format: SEQUENCE(0).items != 2: "+s.length;o.ciphertext=i(e,s[1]);var a=n(e,s[0]);if(2!=a.length)throw "malformed format: SEQUENCE(0.0).items != 2: "+a.length;if("2a864886f70d01050d"!=i(e,a[0]))throw "this only supports pkcs5PBES2";var u=n(e,a[1]);if(2!=a.length)throw "malformed format: SEQUENCE(0.0.1).items != 2: "+u.length;var c=n(e,u[1]);if(2!=c.length)throw "malformed format: SEQUENCE(0.0.1.1).items != 2: "+c.length;if("2a864886f70d0307"!=i(e,c[0]))throw "this only supports TripleDES";o.encryptionSchemeAlg="TripleDES",o.encryptionSchemeIV=i(e,c[1]);var h=n(e,u[0]);if(2!=h.length)throw "malformed format: SEQUENCE(0.0.1.0).items != 2: "+h.length;if("2a864886f70d01050c"!=i(e,h[0]))throw "this only supports pkcs5PBKDF2";var l=n(e,h[1]);if(l.length<2)throw "malformed format: SEQUENCE(0.0.1.0.1).items < 2: "+l.length;o.pbkdf2Salt=i(e,l[0]);var f=i(e,l[1]);try{o.pbkdf2Iter=parseInt(f,16);}catch(t){throw "malformed format pbkdf2Iter: "+f}return o},getPBKDF2KeyHexFromParam:function t(e,r){var n=y.enc.Hex.parse(e.pbkdf2Salt),i=e.pbkdf2Iter,o=y.PBKDF2(r,n,{keySize:6,iterations:i});return y.enc.Hex.stringify(o)},_getPlainPKCS8HexFromEncryptedPKCS8PEM:function t(e,r){var n=Hr(e,"ENCRYPTED PRIVATE KEY"),i=this.parseHexOfEncryptedPKCS8(n),o=Zr.getPBKDF2KeyHexFromParam(i,r),s={};s.ciphertext=y.enc.Hex.parse(i.ciphertext);var a=y.enc.Hex.parse(o),u=y.enc.Hex.parse(i.encryptionSchemeIV),c=y.TripleDES.decrypt(s,a,{iv:u});return y.enc.Hex.stringify(c)},getKeyFromEncryptedPKCS8PEM:function t(e,r){var n=this._getPlainPKCS8HexFromEncryptedPKCS8PEM(e,r);return this.getKeyFromPlainPrivatePKCS8Hex(n)},parsePlainPrivatePKCS8Hex:function t(e){var r=Er,n=r.getChildIdx,i=r.getV,o={algparam:null};if("30"!=e.substr(0,2))throw "malformed plain PKCS8 private key(code:001)";var s=n(e,0);if(3!=s.length)throw "malformed plain PKCS8 private key(code:002)";if("30"!=e.substr(s[1],2))throw "malformed PKCS8 private key(code:003)";var a=n(e,s[1]);if(2!=a.length)throw "malformed PKCS8 private key(code:004)";if("06"!=e.substr(a[0],2))throw "malformed PKCS8 private key(code:005)";if(o.algoid=i(e,a[0]),"06"==e.substr(a[1],2)&&(o.algparam=i(e,a[1])),"04"!=e.substr(s[2],2))throw "malformed PKCS8 private key(code:006)";return o.keyidx=r.getVidx(e,s[2]),o},getKeyFromPlainPrivatePKCS8PEM:function t(e){var r=Hr(e,"PRIVATE KEY");return this.getKeyFromPlainPrivatePKCS8Hex(r)},getKeyFromPlainPrivatePKCS8Hex:function t(e){var r,n=this.parsePlainPrivatePKCS8Hex(e);if("2a864886f70d010101"==n.algoid)r=new He;else if("2a8648ce380401"==n.algoid)r=new br.crypto.DSA;else {if("2a8648ce3d0201"!=n.algoid)throw "unsupported private key algorithm";r=new br.crypto.ECDSA;}return r.readPKCS8PrvKeyHex(e),r},_getKeyFromPublicPKCS8Hex:function t(e){var r,n=Er.getVbyList(e,0,[0,0],"06");if("2a864886f70d010101"===n)r=new He;else if("2a8648ce380401"===n)r=new br.crypto.DSA;else {if("2a8648ce3d0201"!==n)throw "unsupported PKCS#8 public key hex";r=new br.crypto.ECDSA;}return r.readPKCS8PubKeyHex(e),r},parsePublicRawRSAKeyHex:function t(e){var r=Er,n=r.getChildIdx,i=r.getV,o={};if("30"!=e.substr(0,2))throw "malformed RSA key(code:001)";var s=n(e,0);if(2!=s.length)throw "malformed RSA key(code:002)";if("02"!=e.substr(s[0],2))throw "malformed RSA key(code:003)";if(o.n=i(e,s[0]),"02"!=e.substr(s[1],2))throw "malformed RSA key(code:004)";return o.e=i(e,s[1]),o},parsePublicPKCS8Hex:function t(e){var r=Er,n=r.getChildIdx,i=r.getV,o={algparam:null},s=n(e,0);if(2!=s.length)throw "outer DERSequence shall have 2 elements: "+s.length;var a=s[0];if("30"!=e.substr(a,2))throw "malformed PKCS8 public key(code:001)";var u=n(e,a);if(2!=u.length)throw "malformed PKCS8 public key(code:002)";if("06"!=e.substr(u[0],2))throw "malformed PKCS8 public key(code:003)";if(o.algoid=i(e,u[0]),"06"==e.substr(u[1],2)?o.algparam=i(e,u[1]):"30"==e.substr(u[1],2)&&(o.algparam={},o.algparam.p=r.getVbyList(e,u[1],[0],"02"),o.algparam.q=r.getVbyList(e,u[1],[1],"02"),o.algparam.g=r.getVbyList(e,u[1],[2],"02")),"03"!=e.substr(s[1],2))throw "malformed PKCS8 public key(code:004)";return o.key=i(e,s[1]).substr(2),o}}}();Zr.getKey=function(t,e,r){var n=(v=Er).getChildIdx,i=(v.getV,v.getVbyList),o=br.crypto,s=o.ECDSA,a=o.DSA,u=He,c=Hr,h=Zr;if(void 0!==u&&t instanceof u)return t;if(void 0!==s&&t instanceof s)return t;if(void 0!==a&&t instanceof a)return t;if(void 0!==t.curve&&void 0!==t.xy&&void 0===t.d)return new s({pub:t.xy,curve:t.curve});if(void 0!==t.curve&&void 0!==t.d)return new s({prv:t.d,curve:t.curve});if(void 0===t.kty&&void 0!==t.n&&void 0!==t.e&&void 0===t.d)return (P=new u).setPublic(t.n,t.e),P;if(void 0===t.kty&&void 0!==t.n&&void 0!==t.e&&void 0!==t.d&&void 0!==t.p&&void 0!==t.q&&void 0!==t.dp&&void 0!==t.dq&&void 0!==t.co&&void 0===t.qi)return (P=new u).setPrivateEx(t.n,t.e,t.d,t.p,t.q,t.dp,t.dq,t.co),P;if(void 0===t.kty&&void 0!==t.n&&void 0!==t.e&&void 0!==t.d&&void 0===t.p)return (P=new u).setPrivate(t.n,t.e,t.d),P;if(void 0!==t.p&&void 0!==t.q&&void 0!==t.g&&void 0!==t.y&&void 0===t.x)return (P=new a).setPublic(t.p,t.q,t.g,t.y),P;if(void 0!==t.p&&void 0!==t.q&&void 0!==t.g&&void 0!==t.y&&void 0!==t.x)return (P=new a).setPrivate(t.p,t.q,t.g,t.y,t.x),P;if("RSA"===t.kty&&void 0!==t.n&&void 0!==t.e&&void 0===t.d)return (P=new u).setPublic(Ir(t.n),Ir(t.e)),P;if("RSA"===t.kty&&void 0!==t.n&&void 0!==t.e&&void 0!==t.d&&void 0!==t.p&&void 0!==t.q&&void 0!==t.dp&&void 0!==t.dq&&void 0!==t.qi)return (P=new u).setPrivateEx(Ir(t.n),Ir(t.e),Ir(t.d),Ir(t.p),Ir(t.q),Ir(t.dp),Ir(t.dq),Ir(t.qi)),P;if("RSA"===t.kty&&void 0!==t.n&&void 0!==t.e&&void 0!==t.d)return (P=new u).setPrivate(Ir(t.n),Ir(t.e),Ir(t.d)),P;if("EC"===t.kty&&void 0!==t.crv&&void 0!==t.x&&void 0!==t.y&&void 0===t.d){var l=(k=new s({curve:t.crv})).ecparams.keylen/4,f="04"+("0000000000"+Ir(t.x)).slice(-l)+("0000000000"+Ir(t.y)).slice(-l);return k.setPublicKeyHex(f),k}if("EC"===t.kty&&void 0!==t.crv&&void 0!==t.x&&void 0!==t.y&&void 0!==t.d){l=(k=new s({curve:t.crv})).ecparams.keylen/4,f="04"+("0000000000"+Ir(t.x)).slice(-l)+("0000000000"+Ir(t.y)).slice(-l);var g=("0000000000"+Ir(t.d)).slice(-l);return k.setPublicKeyHex(f),k.setPrivateKeyHex(g),k}if("pkcs5prv"===r){var d,p=t,v=Er;if(9===(d=n(p,0)).length)(P=new u).readPKCS5PrvKeyHex(p);else if(6===d.length)(P=new a).readPKCS5PrvKeyHex(p);else {if(!(d.length>2&&"04"===p.substr(d[1],2)))throw "unsupported PKCS#1/5 hexadecimal key";(P=new s).readPKCS5PrvKeyHex(p);}return P}if("pkcs8prv"===r)return P=h.getKeyFromPlainPrivatePKCS8Hex(t);if("pkcs8pub"===r)return h._getKeyFromPublicPKCS8Hex(t);if("x509pub"===r)return on.getPublicKeyFromCertHex(t);if(-1!=t.indexOf("-END CERTIFICATE-",0)||-1!=t.indexOf("-END X509 CERTIFICATE-",0)||-1!=t.indexOf("-END TRUSTED CERTIFICATE-",0))return on.getPublicKeyFromCertPEM(t);if(-1!=t.indexOf("-END PUBLIC KEY-")){var y=Hr(t,"PUBLIC KEY");return h._getKeyFromPublicPKCS8Hex(y)}if(-1!=t.indexOf("-END RSA PRIVATE KEY-")&&-1==t.indexOf("4,ENCRYPTED")){var m=c(t,"RSA PRIVATE KEY");return h.getKey(m,null,"pkcs5prv")}if(-1!=t.indexOf("-END DSA PRIVATE KEY-")&&-1==t.indexOf("4,ENCRYPTED")){var _=i(R=c(t,"DSA PRIVATE KEY"),0,[1],"02"),S=i(R,0,[2],"02"),b=i(R,0,[3],"02"),w=i(R,0,[4],"02"),E=i(R,0,[5],"02");return (P=new a).setPrivate(new F(_,16),new F(S,16),new F(b,16),new F(w,16),new F(E,16)),P}if(-1!=t.indexOf("-END EC PRIVATE KEY-")&&-1==t.indexOf("4,ENCRYPTED")){m=c(t,"EC PRIVATE KEY");return h.getKey(m,null,"pkcs5prv")}if(-1!=t.indexOf("-END PRIVATE KEY-"))return h.getKeyFromPlainPrivatePKCS8PEM(t);if(-1!=t.indexOf("-END RSA PRIVATE KEY-")&&-1!=t.indexOf("4,ENCRYPTED")){var x=h.getDecryptedKeyHex(t,e),A=new He;return A.readPKCS5PrvKeyHex(x),A}if(-1!=t.indexOf("-END EC PRIVATE KEY-")&&-1!=t.indexOf("4,ENCRYPTED")){var k,P=i(R=h.getDecryptedKeyHex(t,e),0,[1],"04"),C=i(R,0,[2,0],"06"),T=i(R,0,[3,0],"03").substr(2);if(void 0===br.crypto.OID.oidhex2name[C])throw "undefined OID(hex) in KJUR.crypto.OID: "+C;return (k=new s({curve:br.crypto.OID.oidhex2name[C]})).setPublicKeyHex(T),k.setPrivateKeyHex(P),k.isPublic=!1,k}if(-1!=t.indexOf("-END DSA PRIVATE KEY-")&&-1!=t.indexOf("4,ENCRYPTED")){var R;_=i(R=h.getDecryptedKeyHex(t,e),0,[1],"02"),S=i(R,0,[2],"02"),b=i(R,0,[3],"02"),w=i(R,0,[4],"02"),E=i(R,0,[5],"02");return (P=new a).setPrivate(new F(_,16),new F(S,16),new F(b,16),new F(w,16),new F(E,16)),P}if(-1!=t.indexOf("-END ENCRYPTED PRIVATE KEY-"))return h.getKeyFromEncryptedPKCS8PEM(t,e);throw new Error("not supported argument")},Zr.generateKeypair=function(t,e){if("RSA"==t){var r=e;(s=new He).generate(r,"10001"),s.isPrivate=!0,s.isPublic=!0;var n=new He,i=s.n.toString(16),o=s.e.toString(16);return n.setPublic(i,o),n.isPrivate=!1,n.isPublic=!0,(a={}).prvKeyObj=s,a.pubKeyObj=n,a}if("EC"==t){var s,a,u=e,c=new br.crypto.ECDSA({curve:u}).generateKeyPairHex();return (s=new br.crypto.ECDSA({curve:u})).setPublicKeyHex(c.ecpubhex),s.setPrivateKeyHex(c.ecprvhex),s.isPrivate=!0,s.isPublic=!1,(n=new br.crypto.ECDSA({curve:u})).setPublicKeyHex(c.ecpubhex),n.isPrivate=!1,n.isPublic=!0,(a={}).prvKeyObj=s,a.pubKeyObj=n,a}throw "unknown algorithm: "+t},Zr.getPEM=function(t,e,r,n,i,o){var s=br,a=s.asn1,u=a.DERObjectIdentifier,c=a.DERInteger,h=a.ASN1Util.newObject,l=a.x509.SubjectPublicKeyInfo,f=s.crypto,g=f.DSA,d=f.ECDSA,p=He;function v(t){return h({seq:[{int:0},{int:{bigint:t.n}},{int:t.e},{int:{bigint:t.d}},{int:{bigint:t.p}},{int:{bigint:t.q}},{int:{bigint:t.dmp1}},{int:{bigint:t.dmq1}},{int:{bigint:t.coeff}}]})}function m(t){return h({seq:[{int:1},{octstr:{hex:t.prvKeyHex}},{tag:["a0",!0,{oid:{name:t.curveName}}]},{tag:["a1",!0,{bitstr:{hex:"00"+t.pubKeyHex}}]}]})}function _(t){return h({seq:[{int:0},{int:{bigint:t.p}},{int:{bigint:t.q}},{int:{bigint:t.g}},{int:{bigint:t.y}},{int:{bigint:t.x}}]})}if((void 0!==p&&t instanceof p||void 0!==g&&t instanceof g||void 0!==d&&t instanceof d)&&1==t.isPublic&&(void 0===e||"PKCS8PUB"==e))return Mr(F=new l(t).getEncodedHex(),"PUBLIC KEY");if("PKCS1PRV"==e&&void 0!==p&&t instanceof p&&(void 0===r||null==r)&&1==t.isPrivate)return Mr(F=v(t).getEncodedHex(),"RSA PRIVATE KEY");if("PKCS1PRV"==e&&void 0!==d&&t instanceof d&&(void 0===r||null==r)&&1==t.isPrivate){var S=new u({name:t.curveName}).getEncodedHex(),b=m(t).getEncodedHex(),w="";return w+=Mr(S,"EC PARAMETERS"),w+=Mr(b,"EC PRIVATE KEY")}if("PKCS1PRV"==e&&void 0!==g&&t instanceof g&&(void 0===r||null==r)&&1==t.isPrivate)return Mr(F=_(t).getEncodedHex(),"DSA PRIVATE KEY");if("PKCS5PRV"==e&&void 0!==p&&t instanceof p&&void 0!==r&&null!=r&&1==t.isPrivate){var F=v(t).getEncodedHex();return void 0===n&&(n="DES-EDE3-CBC"),this.getEncryptedPKCS5PEMFromPrvKeyHex("RSA",F,r,n,o)}if("PKCS5PRV"==e&&void 0!==d&&t instanceof d&&void 0!==r&&null!=r&&1==t.isPrivate){F=m(t).getEncodedHex();return void 0===n&&(n="DES-EDE3-CBC"),this.getEncryptedPKCS5PEMFromPrvKeyHex("EC",F,r,n,o)}if("PKCS5PRV"==e&&void 0!==g&&t instanceof g&&void 0!==r&&null!=r&&1==t.isPrivate){F=_(t).getEncodedHex();return void 0===n&&(n="DES-EDE3-CBC"),this.getEncryptedPKCS5PEMFromPrvKeyHex("DSA",F,r,n,o)}var E=function t(e,r){var n=x(e,r);return new h({seq:[{seq:[{oid:{name:"pkcs5PBES2"}},{seq:[{seq:[{oid:{name:"pkcs5PBKDF2"}},{seq:[{octstr:{hex:n.pbkdf2Salt}},{int:n.pbkdf2Iter}]}]},{seq:[{oid:{name:"des-EDE3-CBC"}},{octstr:{hex:n.encryptionSchemeIV}}]}]}]},{octstr:{hex:n.ciphertext}}]}).getEncodedHex()},x=function t(e,r){var n=y.lib.WordArray.random(8),i=y.lib.WordArray.random(8),o=y.PBKDF2(r,n,{keySize:6,iterations:100}),s=y.enc.Hex.parse(e),a=y.TripleDES.encrypt(s,o,{iv:i})+"",u={};return u.ciphertext=a,u.pbkdf2Salt=y.enc.Hex.stringify(n),u.pbkdf2Iter=100,u.encryptionSchemeAlg="DES-EDE3-CBC",u.encryptionSchemeIV=y.enc.Hex.stringify(i),u};if("PKCS8PRV"==e&&null!=p&&t instanceof p&&1==t.isPrivate){var A=v(t).getEncodedHex();F=h({seq:[{int:0},{seq:[{oid:{name:"rsaEncryption"}},{null:!0}]},{octstr:{hex:A}}]}).getEncodedHex();return void 0===r||null==r?Mr(F,"PRIVATE KEY"):Mr(b=E(F,r),"ENCRYPTED PRIVATE KEY")}if("PKCS8PRV"==e&&void 0!==d&&t instanceof d&&1==t.isPrivate){A=new h({seq:[{int:1},{octstr:{hex:t.prvKeyHex}},{tag:["a1",!0,{bitstr:{hex:"00"+t.pubKeyHex}}]}]}).getEncodedHex(),F=h({seq:[{int:0},{seq:[{oid:{name:"ecPublicKey"}},{oid:{name:t.curveName}}]},{octstr:{hex:A}}]}).getEncodedHex();return void 0===r||null==r?Mr(F,"PRIVATE KEY"):Mr(b=E(F,r),"ENCRYPTED PRIVATE KEY")}if("PKCS8PRV"==e&&void 0!==g&&t instanceof g&&1==t.isPrivate){A=new c({bigint:t.x}).getEncodedHex(),F=h({seq:[{int:0},{seq:[{oid:{name:"dsa"}},{seq:[{int:{bigint:t.p}},{int:{bigint:t.q}},{int:{bigint:t.g}}]}]},{octstr:{hex:A}}]}).getEncodedHex();return void 0===r||null==r?Mr(F,"PRIVATE KEY"):Mr(b=E(F,r),"ENCRYPTED PRIVATE KEY")}throw new Error("unsupported object nor format")},Zr.getKeyFromCSRPEM=function(t){var e=Hr(t,"CERTIFICATE REQUEST");return Zr.getKeyFromCSRHex(e)},Zr.getKeyFromCSRHex=function(t){var e=Zr.parseCSRHex(t);return Zr.getKey(e.p8pubkeyhex,null,"pkcs8pub")},Zr.parseCSRHex=function(t){var e=Er,r=e.getChildIdx,n=e.getTLV,i={},o=t;if("30"!=o.substr(0,2))throw "malformed CSR(code:001)";var s=r(o,0);if(s.length<1)throw "malformed CSR(code:002)";if("30"!=o.substr(s[0],2))throw "malformed CSR(code:003)";var a=r(o,s[0]);if(a.length<3)throw "malformed CSR(code:004)";return i.p8pubkeyhex=n(o,a[2]),i},Zr.getKeyID=function(t){var e=Zr,r=Er;"string"==typeof t&&-1!=t.indexOf("BEGIN ")&&(t=e.getKey(t));var n=Hr(e.getPEM(t)),i=r.getIdxbyList(n,0,[1]),o=r.getV(n,i).substring(2);return br.crypto.Util.hashHex(o,"sha1")},Zr.getJWKFromKey=function(t){var e={};if(t instanceof He&&t.isPrivate)return e.kty="RSA",e.n=Rr(t.n.toString(16)),e.e=Rr(t.e.toString(16)),e.d=Rr(t.d.toString(16)),e.p=Rr(t.p.toString(16)),e.q=Rr(t.q.toString(16)),e.dp=Rr(t.dmp1.toString(16)),e.dq=Rr(t.dmq1.toString(16)),e.qi=Rr(t.coeff.toString(16)),e;if(t instanceof He&&t.isPublic)return e.kty="RSA",e.n=Rr(t.n.toString(16)),e.e=Rr(t.e.toString(16)),e;if(t instanceof br.crypto.ECDSA&&t.isPrivate){if("P-256"!==(n=t.getShortNISTPCurveName())&&"P-384"!==n)throw "unsupported curve name for JWT: "+n;var r=t.getPublicKeyXYHex();return e.kty="EC",e.crv=n,e.x=Rr(r.x),e.y=Rr(r.y),e.d=Rr(t.prvKeyHex),e}if(t instanceof br.crypto.ECDSA&&t.isPublic){var n;if("P-256"!==(n=t.getShortNISTPCurveName())&&"P-384"!==n)throw "unsupported curve name for JWT: "+n;r=t.getPublicKeyXYHex();return e.kty="EC",e.crv=n,e.x=Rr(r.x),e.y=Rr(r.y),e}throw "not supported key object"},He.getPosArrayOfChildrenFromHex=function(t){return Er.getChildIdx(t,0)},He.getHexValueArrayOfChildrenFromHex=function(t){var e,r=Er.getV,n=r(t,(e=He.getPosArrayOfChildrenFromHex(t))[0]),i=r(t,e[1]),o=r(t,e[2]),s=r(t,e[3]),a=r(t,e[4]),u=r(t,e[5]),c=r(t,e[6]),h=r(t,e[7]),l=r(t,e[8]);return (e=new Array).push(n,i,o,s,a,u,c,h,l),e},He.prototype.readPrivateKeyFromPEMString=function(t){var e=Hr(t),r=He.getHexValueArrayOfChildrenFromHex(e);this.setPrivateEx(r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8]);},He.prototype.readPKCS5PrvKeyHex=function(t){var e=He.getHexValueArrayOfChildrenFromHex(t);this.setPrivateEx(e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8]);},He.prototype.readPKCS8PrvKeyHex=function(t){var e,r,n,i,o,s,a,u,c=Er,h=c.getVbyListEx;if(!1===c.isASN1HEX(t))throw new Error("not ASN.1 hex string");try{e=h(t,0,[2,0,1],"02"),r=h(t,0,[2,0,2],"02"),n=h(t,0,[2,0,3],"02"),i=h(t,0,[2,0,4],"02"),o=h(t,0,[2,0,5],"02"),s=h(t,0,[2,0,6],"02"),a=h(t,0,[2,0,7],"02"),u=h(t,0,[2,0,8],"02");}catch(t){throw new Error("malformed PKCS#8 plain RSA private key")}this.setPrivateEx(e,r,n,i,o,s,a,u);},He.prototype.readPKCS5PubKeyHex=function(t){var e=Er,r=e.getV;if(!1===e.isASN1HEX(t))throw new Error("keyHex is not ASN.1 hex string");var n=e.getChildIdx(t,0);if(2!==n.length||"02"!==t.substr(n[0],2)||"02"!==t.substr(n[1],2))throw new Error("wrong hex for PKCS#5 public key");var i=r(t,n[0]),o=r(t,n[1]);this.setPublic(i,o);},He.prototype.readPKCS8PubKeyHex=function(t){var e=Er;if(!1===e.isASN1HEX(t))throw new Error("not ASN.1 hex string");if("06092a864886f70d010101"!==e.getTLVbyListEx(t,0,[0,0]))throw new Error("not PKCS8 RSA public key");var r=e.getTLVbyListEx(t,0,[1,0]);this.readPKCS5PubKeyHex(r);},He.prototype.readCertPubKeyHex=function(t,e){var r,n;(r=new on).readCertHex(t),n=r.getPublicKeyHex(),this.readPKCS8PubKeyHex(n);};var tn=new RegExp("[^0-9a-f]","gi");function en(t,e){for(var r="",n=e/4-t.length,i=0;i<n;i++)r+="0";return r+t}function rn(t,e,r){for(var n="",i=0;n.length<e;)n+=Nr(r(Ur(t+String.fromCharCode.apply(String,[(4278190080&i)>>24,(16711680&i)>>16,(65280&i)>>8,255&i])))),i+=1;return n}function nn(t){for(var e in br.crypto.Util.DIGESTINFOHEAD){var r=br.crypto.Util.DIGESTINFOHEAD[e],n=r.length;if(t.substring(0,n)==r)return [e,t.substring(n)]}return []}function on(t){var e,r=Er,n=r.getChildIdx,i=r.getV,o=r.getTLV,s=r.getVbyList,a=r.getVbyListEx,u=r.getTLVbyList,c=r.getTLVbyListEx,h=r.getIdxbyList,l=r.getIdxbyListEx,f=r.getVidx,g=r.oidname,d=r.hextooidstr,p=on,v=Hr;try{e=br.asn1.x509.AlgorithmIdentifier.PSSNAME2ASN1TLV;}catch(t){}this.HEX2STAG={"0c":"utf8",13:"prn",16:"ia5","1a":"vis","1e":"bmp"},this.hex=null,this.version=0,this.foffset=0,this.aExtInfo=null,this.getVersion=function(){return null===this.hex||0!==this.version?this.version:"a003020102"!==u(this.hex,0,[0,0])?(this.version=1,this.foffset=-1,1):(this.version=3,3)},this.getSerialNumberHex=function(){return a(this.hex,0,[0,0],"02")},this.getSignatureAlgorithmField=function(){var t=c(this.hex,0,[0,1]);return this.getAlgorithmIdentifierName(t)},this.getAlgorithmIdentifierName=function(t){for(var r in e)if(t===e[r])return r;return g(a(t,0,[0],"06"))},this.getIssuer=function(){return this.getX500Name(this.getIssuerHex())},this.getIssuerHex=function(){return u(this.hex,0,[0,3+this.foffset],"30")},this.getIssuerString=function(){return p.hex2dn(this.getIssuerHex())},this.getSubject=function(){return this.getX500Name(this.getSubjectHex())},this.getSubjectHex=function(){return u(this.hex,0,[0,5+this.foffset],"30")},this.getSubjectString=function(){return p.hex2dn(this.getSubjectHex())},this.getNotBefore=function(){var t=s(this.hex,0,[0,4+this.foffset,0]);return t=t.replace(/(..)/g,"%$1"),t=decodeURIComponent(t)},this.getNotAfter=function(){var t=s(this.hex,0,[0,4+this.foffset,1]);return t=t.replace(/(..)/g,"%$1"),t=decodeURIComponent(t)},this.getPublicKeyHex=function(){return r.getTLVbyList(this.hex,0,[0,6+this.foffset],"30")},this.getPublicKeyIdx=function(){return h(this.hex,0,[0,6+this.foffset],"30")},this.getPublicKeyContentIdx=function(){var t=this.getPublicKeyIdx();return h(this.hex,t,[1,0],"30")},this.getPublicKey=function(){return Zr.getKey(this.getPublicKeyHex(),null,"pkcs8pub")},this.getSignatureAlgorithmName=function(){var t=u(this.hex,0,[1],"30");return this.getAlgorithmIdentifierName(t)},this.getSignatureValueHex=function(){return s(this.hex,0,[2],"03",!0)},this.verifySignature=function(t){var e=this.getSignatureAlgorithmField(),r=this.getSignatureValueHex(),n=u(this.hex,0,[0],"30"),i=new br.crypto.Signature({alg:e});return i.init(t),i.updateHex(n),i.verify(r)},this.parseExt=function(t){var e,o,a;if(void 0===t){if(a=this.hex,3!==this.version)return -1;e=h(a,0,[0,7,0],"30"),o=n(a,e);}else {a=Hr(t);var u=h(a,0,[0,3,0,0],"06");if("2a864886f70d01090e"!=i(a,u))return void(this.aExtInfo=new Array);e=h(a,0,[0,3,0,1,0],"30"),o=n(a,e),this.hex=a;}this.aExtInfo=new Array;for(var c=0;c<o.length;c++){var l={critical:!1},g=0;3===n(a,o[c]).length&&(l.critical=!0,g=1),l.oid=r.hextooidstr(s(a,o[c],[0],"06"));var d=h(a,o[c],[1+g]);l.vidx=f(a,d),this.aExtInfo.push(l);}},this.getExtInfo=function(t){var e=this.aExtInfo,r=t;if(t.match(/^[0-9.]+$/)||(r=br.asn1.x509.OID.name2oid(t)),""!==r)for(var n=0;n<e.length;n++)if(e[n].oid===r)return e[n]},this.getExtBasicConstraints=function(t,e){if(void 0===t&&void 0===e){var r=this.getExtInfo("basicConstraints");if(void 0===r)return;t=o(this.hex,r.vidx),e=r.critical;}var n={extname:"basicConstraints"};if(e&&(n.critical=!0),"3000"===t)return n;if("30030101ff"===t)return n.cA=!0,n;if("30060101ff02"===t.substr(0,12)){var s=i(t,10),a=parseInt(s,16);return n.cA=!0,n.pathLen=a,n}throw new Error("hExtV parse error: "+t)},this.getExtKeyUsage=function(t,e){if(void 0===t&&void 0===e){var r=this.getExtInfo("keyUsage");if(void 0===r)return;t=o(this.hex,r.vidx),e=r.critical;}var n={extname:"keyUsage"};return e&&(n.critical=!0),n.names=this.getExtKeyUsageString(t).split(","),n},this.getExtKeyUsageBin=function(t){if(void 0===t){var e=this.getExtInfo("keyUsage");if(void 0===e)return "";t=o(this.hex,e.vidx);}if(8!=t.length&&10!=t.length)throw new Error("malformed key usage value: "+t);var r="000000000000000"+parseInt(t.substr(6),16).toString(2);return 8==t.length&&(r=r.slice(-8)),10==t.length&&(r=r.slice(-16)),""==(r=r.replace(/0+$/,""))&&(r="0"),r},this.getExtKeyUsageString=function(t){for(var e=this.getExtKeyUsageBin(t),r=new Array,n=0;n<e.length;n++)"1"==e.substr(n,1)&&r.push(on.KEYUSAGE_NAME[n]);return r.join(",")},this.getExtSubjectKeyIdentifier=function(t,e){if(void 0===t&&void 0===e){var r=this.getExtInfo("subjectKeyIdentifier");if(void 0===r)return;t=o(this.hex,r.vidx),e=r.critical;}var n={extname:"subjectKeyIdentifier"};e&&(n.critical=!0);var s=i(t,0);return n.kid={hex:s},n},this.getExtAuthorityKeyIdentifier=function(t,e){if(void 0===t&&void 0===e){var r=this.getExtInfo("authorityKeyIdentifier");if(void 0===r)return;t=o(this.hex,r.vidx),e=r.critical;}var s={extname:"authorityKeyIdentifier"};e&&(s.critical=!0);for(var a=n(t,0),u=0;u<a.length;u++){var c=t.substr(a[u],2);if("80"===c&&(s.kid={hex:i(t,a[u])}),"a1"===c){var h=o(t,a[u]),l=this.getGeneralNames(h);s.issuer=l[0].dn;}"82"===c&&(s.sn={hex:i(t,a[u])});}return s},this.getExtExtKeyUsage=function(t,e){if(void 0===t&&void 0===e){var r=this.getExtInfo("extKeyUsage");if(void 0===r)return;t=o(this.hex,r.vidx),e=r.critical;}var s={extname:"extKeyUsage",array:[]};e&&(s.critical=!0);for(var a=n(t,0),u=0;u<a.length;u++)s.array.push(g(i(t,a[u])));return s},this.getExtExtKeyUsageName=function(){var t=this.getExtInfo("extKeyUsage");if(void 0===t)return t;var e=new Array,r=o(this.hex,t.vidx);if(""===r)return e;for(var s=n(r,0),a=0;a<s.length;a++)e.push(g(i(r,s[a])));return e},this.getExtSubjectAltName=function(t,e){if(void 0===t&&void 0===e){var r=this.getExtInfo("subjectAltName");if(void 0===r)return;t=o(this.hex,r.vidx),e=r.critical;}var n={extname:"subjectAltName",array:[]};return e&&(n.critical=!0),n.array=this.getGeneralNames(t),n},this.getExtIssuerAltName=function(t,e){if(void 0===t&&void 0===e){var r=this.getExtInfo("issuerAltName");if(void 0===r)return;t=o(this.hex,r.vidx),e=r.critical;}var n={extname:"issuerAltName",array:[]};return e&&(n.critical=!0),n.array=this.getGeneralNames(t),n},this.getGeneralNames=function(t){for(var e=n(t,0),r=[],i=0;i<e.length;i++){var s=this.getGeneralName(o(t,e[i]));void 0!==s&&r.push(s);}return r},this.getGeneralName=function(t){var e=t.substr(0,2),r=i(t,0),n=Nr(r);return "81"==e?{rfc822:n}:"82"==e?{dns:n}:"86"==e?{uri:n}:"87"==e?{ip:Yr(r)}:"a4"==e?{dn:this.getX500Name(r)}:void 0},this.getExtSubjectAltName2=function(){var t,e,r,s=this.getExtInfo("subjectAltName");if(void 0===s)return s;for(var a=new Array,u=o(this.hex,s.vidx),c=n(u,0),h=0;h<c.length;h++)r=u.substr(c[h],2),t=i(u,c[h]),"81"===r&&(e=Lr(t),a.push(["MAIL",e])),"82"===r&&(e=Lr(t),a.push(["DNS",e])),"84"===r&&(e=on.hex2dn(t,0),a.push(["DN",e])),"86"===r&&(e=Lr(t),a.push(["URI",e])),"87"===r&&(e=Yr(t),a.push(["IP",e]));return a},this.getExtCRLDistributionPoints=function(t,e){if(void 0===t&&void 0===e){var r=this.getExtInfo("cRLDistributionPoints");if(void 0===r)return;t=o(this.hex,r.vidx),e=r.critical;}var i={extname:"cRLDistributionPoints",array:[]};e&&(i.critical=!0);for(var s=n(t,0),a=0;a<s.length;a++){var u=o(t,s[a]);i.array.push(this.getDistributionPoint(u));}return i},this.getDistributionPoint=function(t){for(var e={},r=n(t,0),i=0;i<r.length;i++){var s=t.substr(r[i],2),a=o(t,r[i]);"a0"==s&&(e.dpname=this.getDistributionPointName(a));}return e},this.getDistributionPointName=function(t){for(var e={},r=n(t,0),i=0;i<r.length;i++){var s=t.substr(r[i],2),a=o(t,r[i]);"a0"==s&&(e.full=this.getGeneralNames(a));}return e},this.getExtCRLDistributionPointsURI=function(){var t=this.getExtInfo("cRLDistributionPoints");if(void 0===t)return t;for(var e=new Array,r=n(this.hex,t.vidx),i=0;i<r.length;i++)try{var o=Lr(s(this.hex,r[i],[0,0,0],"86"));e.push(o);}catch(t){}return e},this.getExtAIAInfo=function(){var t=this.getExtInfo("authorityInfoAccess");if(void 0===t)return t;for(var e={ocsp:[],caissuer:[]},r=n(this.hex,t.vidx),i=0;i<r.length;i++){var o=s(this.hex,r[i],[0],"06"),a=s(this.hex,r[i],[1],"86");"2b06010505073001"===o&&e.ocsp.push(Lr(a)),"2b06010505073002"===o&&e.caissuer.push(Lr(a));}return e},this.getExtAuthorityInfoAccess=function(t,e){if(void 0===t&&void 0===e){var r=this.getExtInfo("authorityInfoAccess");if(void 0===r)return;t=o(this.hex,r.vidx),e=r.critical;}var i={extname:"authorityInfoAccess",array:[]};e&&(i.critical=!0);for(var u=n(t,0),c=0;c<u.length;c++){var h=a(t,u[c],[0],"06"),l=Lr(s(t,u[c],[1],"86"));if("2b06010505073001"==h)i.array.push({ocsp:l});else {if("2b06010505073002"!=h)throw new Error("unknown method: "+h);i.array.push({caissuer:l});}}return i},this.getExtCertificatePolicies=function(t,e){if(void 0===t&&void 0===e){var r=this.getExtInfo("certificatePolicies");if(void 0===r)return;t=o(this.hex,r.vidx),e=r.critical;}var i={extname:"certificatePolicies",array:[]};e&&(i.critical=!0);for(var s=n(t,0),a=0;a<s.length;a++){var u=o(t,s[a]),c=this.getPolicyInformation(u);i.array.push(c);}return i},this.getPolicyInformation=function(t){var e={},r=s(t,0,[0],"06");e.policyoid=g(r);var i=l(t,0,[1],"30");if(-1!=i){e.array=[];for(var a=n(t,i),u=0;u<a.length;u++){var c=o(t,a[u]),h=this.getPolicyQualifierInfo(c);e.array.push(h);}}return e},this.getPolicyQualifierInfo=function(t){var e={},r=s(t,0,[0],"06");if("2b06010505070201"===r){var n=a(t,0,[1],"16");e.cps=Nr(n);}else if("2b06010505070202"===r){var i=u(t,0,[1],"30");e.unotice=this.getUserNotice(i);}return e},this.getUserNotice=function(t){for(var e={},r=n(t,0),i=0;i<r.length;i++){var s=o(t,r[i]);"30"!=s.substr(0,2)&&(e.exptext=this.getDisplayText(s));}return e},this.getDisplayText=function(t){var e={};return e.type={"0c":"utf8",16:"ia5","1a":"vis","1e":"bmp"}[t.substr(0,2)],e.str=Nr(i(t,0)),e},this.getExtCRLNumber=function(t,e){var r={extname:"cRLNumber"};if(e&&(r.critical=!0),"02"==t.substr(0,2))return r.num={hex:i(t,0)},r;throw new Error("hExtV parse error: "+t)},this.getExtCRLReason=function(t,e){var r={extname:"cRLReason"};if(e&&(r.critical=!0),"0a"==t.substr(0,2))return r.code=parseInt(i(t,0),16),r;throw new Error("hExtV parse error: "+t)},this.getExtOcspNonce=function(t,e){var r={extname:"ocspNonce"};e&&(r.critical=!0);var n=i(t,0);return r.hex=n,r},this.getExtOcspNoCheck=function(t,e){var r={extname:"ocspNoCheck"};return e&&(r.critical=!0),r},this.getExtAdobeTimeStamp=function(t,e){if(void 0===t&&void 0===e){var r=this.getExtInfo("adobeTimeStamp");if(void 0===r)return;t=o(this.hex,r.vidx),e=r.critical;}var i={extname:"adobeTimeStamp"};e&&(i.critical=!0);var s=n(t,0);if(s.length>1){var a=o(t,s[1]),u=this.getGeneralName(a);null!=u.uri&&(i.uri=u.uri);}if(s.length>2){var c=o(t,s[2]);"0101ff"==c&&(i.reqauth=!0),"010100"==c&&(i.reqauth=!1);}return i},this.getX500NameRule=function(t){for(var e=null,r=[],n=0;n<t.length;n++)for(var i=t[n],o=0;o<i.length;o++)r.push(i[o]);for(n=0;n<r.length;n++){var s=r[n],a=s.ds,u=s.value,c=s.type;if("prn"!=a&&"utf8"!=a&&"ia5"!=a)return "mixed";if("ia5"==a){if("CN"!=c)return "mixed";if(br.lang.String.isMail(u))continue;return "mixed"}if("C"==c){if("prn"==a)continue;return "mixed"}if(null==e)e=a;else if(e!==a)return "mixed"}return null==e?"prn":e},this.getX500Name=function(t){var e=this.getX500NameArray(t);return {array:e,str:this.dnarraytostr(e)}},this.getX500NameArray=function(t){for(var e=[],r=n(t,0),i=0;i<r.length;i++)e.push(this.getRDN(o(t,r[i])));return e},this.getRDN=function(t){for(var e=[],r=n(t,0),i=0;i<r.length;i++)e.push(this.getAttrTypeAndValue(o(t,r[i])));return e},this.getAttrTypeAndValue=function(t){var e={type:null,value:null,ds:null},r=n(t,0),i=s(t,r[0],[],"06"),o=s(t,r[1],[]),a=br.asn1.ASN1Util.oidHexToInt(i);return e.type=br.asn1.x509.OID.oid2atype(a),e.value=Nr(o),e.ds=this.HEX2STAG[t.substr(r[1],2)],e},this.readCertPEM=function(t){this.readCertHex(v(t));},this.readCertHex=function(t){this.hex=t,this.getVersion();try{h(this.hex,0,[0,7],"a3"),this.parseExt();}catch(t){}},this.getParam=function(){var t={};return t.version=this.getVersion(),t.serial={hex:this.getSerialNumberHex()},t.sigalg=this.getSignatureAlgorithmField(),t.issuer=this.getIssuer(),t.notbefore=this.getNotBefore(),t.notafter=this.getNotAfter(),t.subject=this.getSubject(),t.sbjpubkey=Mr(this.getPublicKeyHex(),"PUBLIC KEY"),this.aExtInfo.length>0&&(t.ext=this.getExtParamArray()),t.sighex=this.getSignatureValueHex(),t},this.getExtParamArray=function(t){null==t&&(-1!=l(this.hex,0,[0,"[3]"])&&(t=c(this.hex,0,[0,"[3]",0],"30")));for(var e=[],r=n(t,0),i=0;i<r.length;i++){var s=o(t,r[i]),a=this.getExtParam(s);null!=a&&e.push(a);}return e},this.getExtParam=function(t){var e=n(t,0).length;if(2!=e&&3!=e)throw new Error("wrong number elements in Extension: "+e+" "+t);var r=d(s(t,0,[0],"06")),i=!1;3==e&&"0101ff"==u(t,0,[1])&&(i=!0);var o=u(t,0,[e-1,0]),a=void 0;if("2.5.29.14"==r?a=this.getExtSubjectKeyIdentifier(o,i):"2.5.29.15"==r?a=this.getExtKeyUsage(o,i):"2.5.29.17"==r?a=this.getExtSubjectAltName(o,i):"2.5.29.18"==r?a=this.getExtIssuerAltName(o,i):"2.5.29.19"==r?a=this.getExtBasicConstraints(o,i):"2.5.29.31"==r?a=this.getExtCRLDistributionPoints(o,i):"2.5.29.32"==r?a=this.getExtCertificatePolicies(o,i):"2.5.29.35"==r?a=this.getExtAuthorityKeyIdentifier(o,i):"2.5.29.37"==r?a=this.getExtExtKeyUsage(o,i):"1.3.6.1.5.5.7.1.1"==r?a=this.getExtAuthorityInfoAccess(o,i):"2.5.29.20"==r?a=this.getExtCRLNumber(o,i):"2.5.29.21"==r?a=this.getExtCRLReason(o,i):"1.3.6.1.5.5.7.48.1.2"==r?a=this.getExtOcspNonce(o,i):"1.3.6.1.5.5.7.48.1.5"==r?a=this.getExtOcspNoCheck(o,i):"1.2.840.113583.1.1.9.1"==r&&(a=this.getExtAdobeTimeStamp(o,i)),null!=a)return a;var c={extname:r,extn:o};return i&&(c.critical=!0),c},this.findExt=function(t,e){for(var r=0;r<t.length;r++)if(t[r].extname==e)return t[r];return null},this.updateExtCDPFullURI=function(t,e){var r=this.findExt(t,"cRLDistributionPoints");if(null!=r&&null!=r.array)for(var n=r.array,i=0;i<n.length;i++)if(null!=n[i].dpname&&null!=n[i].dpname.full)for(var o=n[i].dpname.full,s=0;s<o.length;s++){var a=o[i];null!=a.uri&&(a.uri=e);}},this.updateExtAIAOCSP=function(t,e){var r=this.findExt(t,"authorityInfoAccess");if(null!=r&&null!=r.array)for(var n=r.array,i=0;i<n.length;i++)null!=n[i].ocsp&&(n[i].ocsp=e);},this.updateExtAIACAIssuer=function(t,e){var r=this.findExt(t,"authorityInfoAccess");if(null!=r&&null!=r.array)for(var n=r.array,i=0;i<n.length;i++)null!=n[i].caissuer&&(n[i].caissuer=e);},this.dnarraytostr=function(t){return "/"+t.map((function(t){return function e(t){return t.map((function(t){return function e(t){return t.type+"="+t.value}(t)})).join("+")}(t)})).join("/")},this.getInfo=function(){var t,e,r,n=function t(e){return JSON.stringify(e.array).replace(/[\[\]\{\}\"]/g,"")},i=function t(e){for(var r="",n=e.array,i=0;i<n.length;i++){var o=n[i];if(r+="    policy oid: "+o.policyoid+"\n",void 0!==o.array)for(var s=0;s<o.array.length;s++){var a=o.array[s];void 0!==a.cps&&(r+="    cps: "+a.cps+"\n");}}return r},o=function t(e){for(var r="",n=e.array,i=0;i<n.length;i++){var o=n[i];try{void 0!==o.dpname.full[0].uri&&(r+="    "+o.dpname.full[0].uri+"\n");}catch(t){}try{void 0!==o.dname.full[0].dn.hex&&(r+="    "+on.hex2dn(o.dpname.full[0].dn.hex)+"\n");}catch(t){}}return r},s=function t(e){for(var r="",n=e.array,i=0;i<n.length;i++){var o=n[i];void 0!==o.caissuer&&(r+="    caissuer: "+o.caissuer+"\n"),void 0!==o.ocsp&&(r+="    ocsp: "+o.ocsp+"\n");}return r};if(t="Basic Fields\n",t+="  serial number: "+this.getSerialNumberHex()+"\n",t+="  signature algorithm: "+this.getSignatureAlgorithmField()+"\n",t+="  issuer: "+this.getIssuerString()+"\n",t+="  notBefore: "+this.getNotBefore()+"\n",t+="  notAfter: "+this.getNotAfter()+"\n",t+="  subject: "+this.getSubjectString()+"\n",t+="  subject public key info: \n",t+="    key algorithm: "+(e=this.getPublicKey()).type+"\n","RSA"===e.type&&(t+="    n="+$r(e.n.toString(16)).substr(0,16)+"...\n",t+="    e="+$r(e.e.toString(16))+"\n"),null!=(r=this.aExtInfo)){t+="X509v3 Extensions:\n";for(var a=0;a<r.length;a++){var u=r[a],c=br.asn1.x509.OID.oid2name(u.oid);""===c&&(c=u.oid);var h="";if(!0===u.critical&&(h="CRITICAL"),t+="  "+c+" "+h+":\n","basicConstraints"===c){var l=this.getExtBasicConstraints();void 0===l.cA?t+="    {}\n":(t+="    cA=true",void 0!==l.pathLen&&(t+=", pathLen="+l.pathLen),t+="\n");}else if("keyUsage"===c)t+="    "+this.getExtKeyUsageString()+"\n";else if("subjectKeyIdentifier"===c)t+="    "+this.getExtSubjectKeyIdentifier().kid.hex+"\n";else if("authorityKeyIdentifier"===c){var f=this.getExtAuthorityKeyIdentifier();void 0!==f.kid&&(t+="    kid="+f.kid.hex+"\n");}else {if("extKeyUsage"===c)t+="    "+this.getExtExtKeyUsage().array.join(", ")+"\n";else if("subjectAltName"===c)t+="    "+n(this.getExtSubjectAltName())+"\n";else if("cRLDistributionPoints"===c)t+=o(this.getExtCRLDistributionPoints());else if("authorityInfoAccess"===c)t+=s(this.getExtAuthorityInfoAccess());else "certificatePolicies"===c&&(t+=i(this.getExtCertificatePolicies()));}}}return t+="signature algorithm: "+this.getSignatureAlgorithmName()+"\n",t+="signature: "+this.getSignatureValueHex().substr(0,16)+"...\n"},"string"==typeof t&&(-1!=t.indexOf("-----BEGIN")?this.readCertPEM(t):br.lang.String.isHex(t)&&this.readCertHex(t));}He.prototype.sign=function(t,e){var r=function t(r){return br.crypto.Util.hashString(r,e)}(t);return this.signWithMessageHash(r,e)},He.prototype.signWithMessageHash=function(t,e){var r=je(br.crypto.Util.getPaddedDigestInfoHex(t,e,this.n.bitLength()),16);return en(this.doPrivate(r).toString(16),this.n.bitLength())},He.prototype.signPSS=function(t,e,r){var n=function t(r){return br.crypto.Util.hashHex(r,e)}(Ur(t));return void 0===r&&(r=-1),this.signWithMessageHashPSS(n,e,r)},He.prototype.signWithMessageHashPSS=function(t,e,r){var n,i=Nr(t),o=i.length,s=this.n.bitLength()-1,a=Math.ceil(s/8),u=function t(r){return br.crypto.Util.hashHex(r,e)};if(-1===r||void 0===r)r=o;else if(-2===r)r=a-o-2;else if(r<-2)throw new Error("invalid salt length");if(a<o+r+2)throw new Error("data too long");var c="";r>0&&(c=new Array(r),(new Oe).nextBytes(c),c=String.fromCharCode.apply(String,c));var h=Nr(u(Ur("\0\0\0\0\0\0\0\0"+i+c))),l=[];for(n=0;n<a-r-o-2;n+=1)l[n]=0;var f=String.fromCharCode.apply(String,l)+""+c,g=rn(h,f.length,u),d=[];for(n=0;n<f.length;n+=1)d[n]=f.charCodeAt(n)^g.charCodeAt(n);var p=65280>>8*a-s&255;for(d[0]&=~p,n=0;n<o;n++)d.push(h.charCodeAt(n));return d.push(188),en(this.doPrivate(new F(d)).toString(16),this.n.bitLength())},He.prototype.verify=function(t,e){var r=je(e=(e=e.replace(tn,"")).replace(/[ \n]+/g,""),16);if(r.bitLength()>this.n.bitLength())return 0;var n=nn(this.doPublic(r).toString(16).replace(/^1f+00/,""));if(0==n.length)return !1;var i=n[0];return n[1]==function t(e){return br.crypto.Util.hashString(e,i)}(t)},He.prototype.verifyWithMessageHash=function(t,e){if(e.length!=Math.ceil(this.n.bitLength()/4))return !1;var r=je(e,16);if(r.bitLength()>this.n.bitLength())return 0;var n=nn(this.doPublic(r).toString(16).replace(/^1f+00/,""));if(0==n.length)return !1;n[0];return n[1]==t},He.prototype.verifyPSS=function(t,e,r,n){var i=function t(e){return br.crypto.Util.hashHex(e,r)}(Ur(t));return void 0===n&&(n=-1),this.verifyWithMessageHashPSS(i,e,r,n)},He.prototype.verifyWithMessageHashPSS=function(t,e,r,n){if(e.length!=Math.ceil(this.n.bitLength()/4))return !1;var i,o=new F(e,16),s=function t(e){return br.crypto.Util.hashHex(e,r)},a=Nr(t),u=a.length,c=this.n.bitLength()-1,h=Math.ceil(c/8);if(-1===n||void 0===n)n=u;else if(-2===n)n=h-u-2;else if(n<-2)throw new Error("invalid salt length");if(h<u+n+2)throw new Error("data too long");var l=this.doPublic(o).toByteArray();for(i=0;i<l.length;i+=1)l[i]&=255;for(;l.length<h;)l.unshift(0);if(188!==l[h-1])throw new Error("encoded message does not end in 0xbc");var f=(l=String.fromCharCode.apply(String,l)).substr(0,h-u-1),g=l.substr(f.length,u),d=65280>>8*h-c&255;if(0!=(f.charCodeAt(0)&d))throw new Error("bits beyond keysize not zero");var p=rn(g,f.length,s),v=[];for(i=0;i<f.length;i+=1)v[i]=f.charCodeAt(i)^p.charCodeAt(i);v[0]&=~d;var y=h-u-n-2;for(i=0;i<y;i+=1)if(0!==v[i])throw new Error("leftmost octets not zero");if(1!==v[y])throw new Error("0x01 marker not found");return g===Nr(s(Ur("\0\0\0\0\0\0\0\0"+a+String.fromCharCode.apply(String,v.slice(-n)))))},He.SALT_LEN_HLEN=-1,He.SALT_LEN_MAX=-2,He.SALT_LEN_RECOVER=-2,on.hex2dn=function(t,e){if(void 0===e&&(e=0),"30"!==t.substr(e,2))throw new Error("malformed DN");for(var r=new Array,n=Er.getChildIdx(t,e),i=0;i<n.length;i++)r.push(on.hex2rdn(t,n[i]));return "/"+(r=r.map((function(t){return t.replace("/","\\/")}))).join("/")},on.hex2rdn=function(t,e){if(void 0===e&&(e=0),"31"!==t.substr(e,2))throw new Error("malformed RDN");for(var r=new Array,n=Er.getChildIdx(t,e),i=0;i<n.length;i++)r.push(on.hex2attrTypeValue(t,n[i]));return (r=r.map((function(t){return t.replace("+","\\+")}))).join("+")},on.hex2attrTypeValue=function(t,e){var r=Er,n=r.getV;if(void 0===e&&(e=0),"30"!==t.substr(e,2))throw new Error("malformed attribute type and value");var i=r.getChildIdx(t,e);2!==i.length||t.substr(i[0],2);var o=n(t,i[0]),s=br.asn1.ASN1Util.oidHexToInt(o);return br.asn1.x509.OID.oid2atype(s)+"="+Nr(n(t,i[1]))},on.getPublicKeyFromCertHex=function(t){var e=new on;return e.readCertHex(t),e.getPublicKey()},on.getPublicKeyFromCertPEM=function(t){var e=new on;return e.readCertPEM(t),e.getPublicKey()},on.getPublicKeyInfoPropOfCertPEM=function(t){var e,r,n=Er.getVbyList,i={};return i.algparam=null,(e=new on).readCertPEM(t),r=e.getPublicKeyHex(),i.keyhex=n(r,0,[1],"03").substr(2),i.algoid=n(r,0,[0,0],"06"),"2a8648ce3d0201"===i.algoid&&(i.algparam=n(r,0,[0,1],"06")),i},on.KEYUSAGE_NAME=["digitalSignature","nonRepudiation","keyEncipherment","dataEncipherment","keyAgreement","keyCertSign","cRLSign","encipherOnly","decipherOnly"],void 0!==br&&br||(e.KJUR=br={}),void 0!==br.jws&&br.jws||(br.jws={}),br.jws.JWS=function(){var t=br.jws.JWS.isSafeJSONString;this.parseJWS=function(e,r){if(void 0===this.parsedJWS||!r&&void 0===this.parsedJWS.sigvalH){var n=e.match(/^([^.]+)\.([^.]+)\.([^.]+)$/);if(null==n)throw "JWS signature is not a form of 'Head.Payload.SigValue'.";var i=n[1],o=n[2],s=n[3],a=i+"."+o;if(this.parsedJWS={},this.parsedJWS.headB64U=i,this.parsedJWS.payloadB64U=o,this.parsedJWS.sigvalB64U=s,this.parsedJWS.si=a,!r){var u=Ir(s),c=je(u,16);this.parsedJWS.sigvalH=u,this.parsedJWS.sigvalBI=c;}var h=Fr(i),l=Fr(o);if(this.parsedJWS.headS=h,this.parsedJWS.payloadS=l,!t(h,this.parsedJWS,"headP"))throw "malformed JSON string for JWS Head: "+h}};},br.jws.JWS.sign=function(t,e,n,i,o){var s,a,u,c=br,h=c.jws.JWS,l=h.readSafeJSONString,f=h.isSafeJSONString,g=c.crypto,d=(g.ECDSA,g.Mac),p=g.Signature,v=JSON;if("string"!=typeof e&&"object"!=(void 0===e?"undefined":r(e)))throw "spHeader must be JSON string or object: "+e;if("object"==(void 0===e?"undefined":r(e))&&(a=e,s=v.stringify(a)),"string"==typeof e){if(!f(s=e))throw "JWS Head is not safe JSON string: "+s;a=l(s);}if(u=n,"object"==(void 0===n?"undefined":r(n))&&(u=v.stringify(n)),""!=t&&null!=t||void 0===a.alg||(t=a.alg),""!=t&&null!=t&&void 0===a.alg&&(a.alg=t,s=v.stringify(a)),t!==a.alg)throw "alg and sHeader.alg doesn't match: "+t+"!="+a.alg;var y=null;if(void 0===h.jwsalg2sigalg[t])throw "unsupported alg name: "+t;y=h.jwsalg2sigalg[t];var m=wr(s)+"."+wr(u),_="";if("Hmac"==y.substr(0,4)){if(void 0===i)throw "mac key shall be specified for HS* alg";var S=new d({alg:y,prov:"cryptojs",pass:i});S.updateString(m),_=S.doFinal();}else if(-1!=y.indexOf("withECDSA")){(w=new p({alg:y})).init(i,o),w.updateString(m);var b=w.sign();_=br.crypto.ECDSA.asn1SigToConcatSig(b);}else {var w;if("none"!=y)(w=new p({alg:y})).init(i,o),w.updateString(m),_=w.sign();}return m+"."+Rr(_)},br.jws.JWS.verify=function(t,e,n){var i,o=br,s=o.jws.JWS,a=s.readSafeJSONString,u=o.crypto,c=u.ECDSA,h=u.Mac,l=u.Signature;void 0!==r(He)&&(i=He);var f=t.split(".");if(3!==f.length)return !1;var g=f[0]+"."+f[1],d=Ir(f[2]),p=a(Fr(f[0])),v=null,y=null;if(void 0===p.alg)throw "algorithm not specified in header";if((y=(v=p.alg).substr(0,2),null!=n&&"[object Array]"===Object.prototype.toString.call(n)&&n.length>0)&&-1==(":"+n.join(":")+":").indexOf(":"+v+":"))throw "algorithm '"+v+"' not accepted in the list";if("none"!=v&&null===e)throw "key shall be specified to verify.";if("string"==typeof e&&-1!=e.indexOf("-----BEGIN ")&&(e=Zr.getKey(e)),!("RS"!=y&&"PS"!=y||e instanceof i))throw "key shall be a RSAKey obj for RS* and PS* algs";if("ES"==y&&!(e instanceof c))throw "key shall be a ECDSA obj for ES* algs";var m=null;if(void 0===s.jwsalg2sigalg[p.alg])throw "unsupported alg name: "+v;if("none"==(m=s.jwsalg2sigalg[v]))throw "not supported";if("Hmac"==m.substr(0,4)){if(void 0===e)throw "hexadecimal key shall be specified for HMAC";var _=new h({alg:m,pass:e});return _.updateString(g),d==_.doFinal()}if(-1!=m.indexOf("withECDSA")){var S,b=null;try{b=c.concatSigToASN1Sig(d);}catch(t){return !1}return (S=new l({alg:m})).init(e),S.updateString(g),S.verify(b)}return (S=new l({alg:m})).init(e),S.updateString(g),S.verify(d)},br.jws.JWS.parse=function(t){var e,r,n,i=t.split("."),o={};if(2!=i.length&&3!=i.length)throw "malformed sJWS: wrong number of '.' splitted elements";return e=i[0],r=i[1],3==i.length&&(n=i[2]),o.headerObj=br.jws.JWS.readSafeJSONString(Fr(e)),o.payloadObj=br.jws.JWS.readSafeJSONString(Fr(r)),o.headerPP=JSON.stringify(o.headerObj,null,"  "),null==o.payloadObj?o.payloadPP=Fr(r):o.payloadPP=JSON.stringify(o.payloadObj,null,"  "),void 0!==n&&(o.sigHex=Ir(n)),o},br.jws.JWS.verifyJWT=function(t,e,n){var i=br.jws,o=i.JWS,s=o.readSafeJSONString,a=o.inArray,u=o.includedArray,c=t.split("."),h=c[0],l=c[1],f=(Ir(c[2]),s(Fr(h))),g=s(Fr(l));if(void 0===f.alg)return !1;if(void 0===n.alg)throw "acceptField.alg shall be specified";if(!a(f.alg,n.alg))return !1;if(void 0!==g.iss&&"object"===r(n.iss)&&!a(g.iss,n.iss))return !1;if(void 0!==g.sub&&"object"===r(n.sub)&&!a(g.sub,n.sub))return !1;if(void 0!==g.aud&&"object"===r(n.aud))if("string"==typeof g.aud){if(!a(g.aud,n.aud))return !1}else if("object"==r(g.aud)&&!u(g.aud,n.aud))return !1;var d=i.IntDate.getNow();return void 0!==n.verifyAt&&"number"==typeof n.verifyAt&&(d=n.verifyAt),void 0!==n.gracePeriod&&"number"==typeof n.gracePeriod||(n.gracePeriod=0),!(void 0!==g.exp&&"number"==typeof g.exp&&g.exp+n.gracePeriod<d)&&(!(void 0!==g.nbf&&"number"==typeof g.nbf&&d<g.nbf-n.gracePeriod)&&(!(void 0!==g.iat&&"number"==typeof g.iat&&d<g.iat-n.gracePeriod)&&((void 0===g.jti||void 0===n.jti||g.jti===n.jti)&&!!o.verify(t,e,n.alg))))},br.jws.JWS.includedArray=function(t,e){var n=br.jws.JWS.inArray;if(null===t)return !1;if("object"!==(void 0===t?"undefined":r(t)))return !1;if("number"!=typeof t.length)return !1;for(var i=0;i<t.length;i++)if(!n(t[i],e))return !1;return !0},br.jws.JWS.inArray=function(t,e){if(null===e)return !1;if("object"!==(void 0===e?"undefined":r(e)))return !1;if("number"!=typeof e.length)return !1;for(var n=0;n<e.length;n++)if(e[n]==t)return !0;return !1},br.jws.JWS.jwsalg2sigalg={HS256:"HmacSHA256",HS384:"HmacSHA384",HS512:"HmacSHA512",RS256:"SHA256withRSA",RS384:"SHA384withRSA",RS512:"SHA512withRSA",ES256:"SHA256withECDSA",ES384:"SHA384withECDSA",PS256:"SHA256withRSAandMGF1",PS384:"SHA384withRSAandMGF1",PS512:"SHA512withRSAandMGF1",none:"none"},br.jws.JWS.isSafeJSONString=function(t,e,n){var i=null;try{return "object"!=(void 0===(i=Sr(t))?"undefined":r(i))||i.constructor===Array?0:(e&&(e[n]=i),1)}catch(t){return 0}},br.jws.JWS.readSafeJSONString=function(t){var e=null;try{return "object"!=(void 0===(e=Sr(t))?"undefined":r(e))||e.constructor===Array?null:e}catch(t){return null}},br.jws.JWS.getEncodedSignatureValueFromJWS=function(t){var e=t.match(/^[^.]+\.[^.]+\.([^.]+)$/);if(null==e)throw "JWS signature is not a form of 'Head.Payload.SigValue'.";return e[1]},br.jws.JWS.getJWKthumbprint=function(t){if("RSA"!==t.kty&&"EC"!==t.kty&&"oct"!==t.kty)throw "unsupported algorithm for JWK Thumprint";var e="{";if("RSA"===t.kty){if("string"!=typeof t.n||"string"!=typeof t.e)throw "wrong n and e value for RSA key";e+='"e":"'+t.e+'",',e+='"kty":"'+t.kty+'",',e+='"n":"'+t.n+'"}';}else if("EC"===t.kty){if("string"!=typeof t.crv||"string"!=typeof t.x||"string"!=typeof t.y)throw "wrong crv, x and y value for EC key";e+='"crv":"'+t.crv+'",',e+='"kty":"'+t.kty+'",',e+='"x":"'+t.x+'",',e+='"y":"'+t.y+'"}';}else if("oct"===t.kty){if("string"!=typeof t.k)throw "wrong k value for oct(symmetric) key";e+='"kty":"'+t.kty+'",',e+='"k":"'+t.k+'"}';}var r=Ur(e);return Rr(br.crypto.Util.hashHex(r,"sha256"))},br.jws.IntDate={},br.jws.IntDate.get=function(t){var e=br.jws.IntDate,r=e.getNow,n=e.getZulu;if("now"==t)return r();if("now + 1hour"==t)return r()+3600;if("now + 1day"==t)return r()+86400;if("now + 1month"==t)return r()+2592e3;if("now + 1year"==t)return r()+31536e3;if(t.match(/Z$/))return n(t);if(t.match(/^[0-9]+$/))return parseInt(t);throw "unsupported format: "+t},br.jws.IntDate.getZulu=function(t){return Kr(t)},br.jws.IntDate.getNow=function(){return ~~(new Date/1e3)},br.jws.IntDate.intDate2UTCString=function(t){return new Date(1e3*t).toUTCString()},br.jws.IntDate.intDate2Zulu=function(t){var e=new Date(1e3*t);return ("0000"+e.getUTCFullYear()).slice(-4)+("00"+(e.getUTCMonth()+1)).slice(-2)+("00"+e.getUTCDate()).slice(-2)+("00"+e.getUTCHours()).slice(-2)+("00"+e.getUTCMinutes()).slice(-2)+("00"+e.getUTCSeconds()).slice(-2)+"Z"},e.SecureRandom=Oe,e.rng_seed_time=Ie,e.BigInteger=F,e.RSAKey=He;var sn=br.crypto.EDSA;e.EDSA=sn;var an=br.crypto.DSA;e.DSA=an;var un=br.crypto.Signature;e.Signature=un;var cn=br.crypto.MessageDigest;e.MessageDigest=cn;var hn=br.crypto.Mac;e.Mac=hn;var ln=br.crypto.Cipher;e.Cipher=ln,e.KEYUTIL=Zr,e.ASN1HEX=Er,e.X509=on,e.CryptoJS=y,e.b64tohex=b,e.b64toBA=w,e.stoBA=xr,e.BAtos=Ar,e.BAtohex=kr,e.stohex=Pr,e.stob64=function fn(t){return S(Pr(t))},e.stob64u=function gn(t){return Cr(S(Pr(t)))},e.b64utos=function dn(t){return Ar(w(Tr(t)))},e.b64tob64u=Cr,e.b64utob64=Tr,e.hex2b64=S,e.hextob64u=Rr,e.b64utohex=Ir,e.utf8tob64u=wr,e.b64utoutf8=Fr,e.utf8tob64=function pn(t){return S(qr(Gr(t)))},e.b64toutf8=function vn(t){return decodeURIComponent(Jr(b(t)))},e.utf8tohex=Dr,e.hextoutf8=Lr,e.hextorstr=Nr,e.rstrtohex=Ur,e.hextob64=Br,e.hextob64nl=Or,e.b64nltohex=jr,e.hextopem=Mr,e.pemtohex=Hr,e.hextoArrayBuffer=function yn(t){if(t.length%2!=0)throw "input is not even length";if(null==t.match(/^[0-9A-Fa-f]+$/))throw "input is not hexadecimal";for(var e=new ArrayBuffer(t.length/2),r=new DataView(e),n=0;n<t.length/2;n++)r.setUint8(n,parseInt(t.substr(2*n,2),16));return e},e.ArrayBuffertohex=function mn(t){for(var e="",r=new DataView(t),n=0;n<t.byteLength;n++)e+=("00"+r.getUint8(n).toString(16)).slice(-2);return e},e.zulutomsec=Vr,e.zulutosec=Kr,e.zulutodate=function _n(t){return new Date(Vr(t))},e.datetozulu=function Sn(t,e,r){var n,i=t.getUTCFullYear();if(e){if(i<1950||2049<i)throw "not proper year for UTCTime: "+i;n=(""+i).slice(-2);}else n=("000"+i).slice(-4);if(n+=("0"+(t.getUTCMonth()+1)).slice(-2),n+=("0"+t.getUTCDate()).slice(-2),n+=("0"+t.getUTCHours()).slice(-2),n+=("0"+t.getUTCMinutes()).slice(-2),n+=("0"+t.getUTCSeconds()).slice(-2),r){var o=t.getUTCMilliseconds();0!==o&&(n+="."+(o=(o=("00"+o).slice(-3)).replace(/0+$/g,"")));}return n+="Z"},e.uricmptohex=qr,e.hextouricmp=Jr,e.ipv6tohex=Wr,e.hextoipv6=zr,e.hextoip=Yr,e.iptohex=function bn(t){var e="malformed IP address";if(!(t=t.toLowerCase(t)).match(/^[0-9.]+$/)){if(t.match(/^[0-9a-f:]+$/)&&-1!==t.indexOf(":"))return Wr(t);throw e}var r=t.split(".");if(4!==r.length)throw e;var n="";try{for(var i=0;i<4;i++){n+=("0"+parseInt(r[i]).toString(16)).slice(-2);}return n}catch(t){throw e}},e.encodeURIComponentAll=Gr,e.newline_toUnix=function wn(t){return t=t.replace(/\r\n/gm,"\n")},e.newline_toDos=function Fn(t){return t=(t=t.replace(/\r\n/gm,"\n")).replace(/\n/gm,"\r\n")},e.hextoposhex=$r,e.intarystrtohex=function En(t){t=(t=(t=t.replace(/^\s*\[\s*/,"")).replace(/\s*\]\s*$/,"")).replace(/\s*/g,"");try{return t.split(/,/).map((function(t,e,r){var n=parseInt(t);if(n<0||255<n)throw "integer not in range 0-255";return ("00"+n.toString(16)).slice(-2)})).join("")}catch(t){throw "malformed integer array string: "+t}},e.strdiffidx=function t(e,r){var n=e.length;e.length>r.length&&(n=r.length);for(var i=0;i<n;i++)if(e.charCodeAt(i)!=r.charCodeAt(i))return i;return e.length!=r.length?n:-1},e.KJUR=br;var xn=br.crypto;e.crypto=xn;var An=br.asn1;e.asn1=An;var kn=br.jws;e.jws=kn;var Pn=br.lang;e.lang=Pn;}).call(this,r(28).Buffer);},function(t,e,r){(function(t){
	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <http://feross.org>
	 * @license  MIT
	 */
	var n=r(30),i=r(31),o=r(32);function s(){return u.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function a(t,e){if(s()<e)throw new RangeError("Invalid typed array length");return u.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(e)).__proto__=u.prototype:(null===t&&(t=new u(e)),t.length=e),t}function u(t,e,r){if(!(u.TYPED_ARRAY_SUPPORT||this instanceof u))return new u(t,e,r);if("number"==typeof t){if("string"==typeof e)throw new Error("If encoding is specified then the first argument must be a string");return l(this,t)}return c(this,t,e,r)}function c(t,e,r,n){if("number"==typeof e)throw new TypeError('"value" argument must not be a number');return "undefined"!=typeof ArrayBuffer&&e instanceof ArrayBuffer?function i(t,e,r,n){if(e.byteLength,r<0||e.byteLength<r)throw new RangeError("'offset' is out of bounds");if(e.byteLength<r+(n||0))throw new RangeError("'length' is out of bounds");e=void 0===r&&void 0===n?new Uint8Array(e):void 0===n?new Uint8Array(e,r):new Uint8Array(e,r,n);u.TYPED_ARRAY_SUPPORT?(t=e).__proto__=u.prototype:t=f(t,e);return t}(t,e,r,n):"string"==typeof e?function s(t,e,r){"string"==typeof r&&""!==r||(r="utf8");if(!u.isEncoding(r))throw new TypeError('"encoding" must be a valid string encoding');var n=0|d(e,r),i=(t=a(t,n)).write(e,r);i!==n&&(t=t.slice(0,i));return t}(t,e,r):function c(t,e){if(u.isBuffer(e)){var r=0|g(e.length);return 0===(t=a(t,r)).length||e.copy(t,0,0,r),t}if(e){if("undefined"!=typeof ArrayBuffer&&e.buffer instanceof ArrayBuffer||"length"in e)return "number"!=typeof e.length||function n(t){return t!=t}(e.length)?a(t,0):f(t,e);if("Buffer"===e.type&&o(e.data))return f(t,e.data)}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(t,e)}function h(t){if("number"!=typeof t)throw new TypeError('"size" argument must be a number');if(t<0)throw new RangeError('"size" argument must not be negative')}function l(t,e){if(h(e),t=a(t,e<0?0:0|g(e)),!u.TYPED_ARRAY_SUPPORT)for(var r=0;r<e;++r)t[r]=0;return t}function f(t,e){var r=e.length<0?0:0|g(e.length);t=a(t,r);for(var n=0;n<r;n+=1)t[n]=255&e[n];return t}function g(t){if(t>=s())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s().toString(16)+" bytes");return 0|t}function d(t,e){if(u.isBuffer(t))return t.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;"string"!=typeof t&&(t=""+t);var r=t.length;if(0===r)return 0;for(var n=!1;;)switch(e){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":case void 0:return K(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return q(t).length;default:if(n)return K(t).length;e=(""+e).toLowerCase(),n=!0;}}function p(t,e,r){var n=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return "";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return "";if((r>>>=0)<=(e>>>=0))return "";for(t||(t="utf8");;)switch(t){case"hex":return I(this,e,r);case"utf8":case"utf-8":return A(this,e,r);case"ascii":return T(this,e,r);case"latin1":case"binary":return R(this,e,r);case"base64":return x(this,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return D(this,e,r);default:if(n)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),n=!0;}}function v(t,e,r){var n=t[e];t[e]=t[r],t[r]=n;}function y(t,e,r,n,i){if(0===t.length)return -1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,isNaN(r)&&(r=i?0:t.length-1),r<0&&(r=t.length+r),r>=t.length){if(i)return -1;r=t.length-1;}else if(r<0){if(!i)return -1;r=0;}if("string"==typeof e&&(e=u.from(e,n)),u.isBuffer(e))return 0===e.length?-1:m(t,e,r,n,i);if("number"==typeof e)return e&=255,u.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(t,e,r):Uint8Array.prototype.lastIndexOf.call(t,e,r):m(t,[e],r,n,i);throw new TypeError("val must be string, number or Buffer")}function m(t,e,r,n,i){var o,s=1,a=t.length,u=e.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(t.length<2||e.length<2)return -1;s=2,a/=2,u/=2,r/=2;}function c(t,e){return 1===s?t[e]:t.readUInt16BE(e*s)}if(i){var h=-1;for(o=r;o<a;o++)if(c(t,o)===c(e,-1===h?0:o-h)){if(-1===h&&(h=o),o-h+1===u)return h*s}else -1!==h&&(o-=o-h),h=-1;}else for(r+u>a&&(r=a-u),o=r;o>=0;o--){for(var l=!0,f=0;f<u;f++)if(c(t,o+f)!==c(e,f)){l=!1;break}if(l)return o}return -1}function _(t,e,r,n){r=Number(r)||0;var i=t.length-r;n?(n=Number(n))>i&&(n=i):n=i;var o=e.length;if(o%2!=0)throw new TypeError("Invalid hex string");n>o/2&&(n=o/2);for(var s=0;s<n;++s){var a=parseInt(e.substr(2*s,2),16);if(isNaN(a))return s;t[r+s]=a;}return s}function S(t,e,r,n){return J(K(e,t.length-r),t,r,n)}function b(t,e,r,n){return J(function i(t){for(var e=[],r=0;r<t.length;++r)e.push(255&t.charCodeAt(r));return e}(e),t,r,n)}function w(t,e,r,n){return b(t,e,r,n)}function F(t,e,r,n){return J(q(e),t,r,n)}function E(t,e,r,n){return J(function i(t,e){for(var r,n,i,o=[],s=0;s<t.length&&!((e-=2)<0);++s)n=(r=t.charCodeAt(s))>>8,i=r%256,o.push(i),o.push(n);return o}(e,t.length-r),t,r,n)}function x(t,e,r){return 0===e&&r===t.length?n.fromByteArray(t):n.fromByteArray(t.slice(e,r))}function A(t,e,r){r=Math.min(t.length,r);for(var n=[],i=e;i<r;){var o,s,a,u,c=t[i],h=null,l=c>239?4:c>223?3:c>191?2:1;if(i+l<=r)switch(l){case 1:c<128&&(h=c);break;case 2:128==(192&(o=t[i+1]))&&(u=(31&c)<<6|63&o)>127&&(h=u);break;case 3:o=t[i+1],s=t[i+2],128==(192&o)&&128==(192&s)&&(u=(15&c)<<12|(63&o)<<6|63&s)>2047&&(u<55296||u>57343)&&(h=u);break;case 4:o=t[i+1],s=t[i+2],a=t[i+3],128==(192&o)&&128==(192&s)&&128==(192&a)&&(u=(15&c)<<18|(63&o)<<12|(63&s)<<6|63&a)>65535&&u<1114112&&(h=u);}null===h?(h=65533,l=1):h>65535&&(h-=65536,n.push(h>>>10&1023|55296),h=56320|1023&h),n.push(h),i+=l;}return function f(t){var e=t.length;if(e<=C)return String.fromCharCode.apply(String,t);var r="",n=0;for(;n<e;)r+=String.fromCharCode.apply(String,t.slice(n,n+=C));return r}(n)}e.Buffer=u,e.SlowBuffer=function k(t){+t!=t&&(t=0);return u.alloc(+t)},e.INSPECT_MAX_BYTES=50,u.TYPED_ARRAY_SUPPORT=void 0!==t.TYPED_ARRAY_SUPPORT?t.TYPED_ARRAY_SUPPORT:function P(){try{var t=new Uint8Array(1);return t.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===t.foo()&&"function"==typeof t.subarray&&0===t.subarray(1,1).byteLength}catch(t){return !1}}(),e.kMaxLength=s(),u.poolSize=8192,u._augment=function(t){return t.__proto__=u.prototype,t},u.from=function(t,e,r){return c(null,t,e,r)},u.TYPED_ARRAY_SUPPORT&&(u.prototype.__proto__=Uint8Array.prototype,u.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&u[Symbol.species]===u&&Object.defineProperty(u,Symbol.species,{value:null,configurable:!0})),u.alloc=function(t,e,r){return function n(t,e,r,i){return h(e),e<=0?a(t,e):void 0!==r?"string"==typeof i?a(t,e).fill(r,i):a(t,e).fill(r):a(t,e)}(null,t,e,r)},u.allocUnsafe=function(t){return l(null,t)},u.allocUnsafeSlow=function(t){return l(null,t)},u.isBuffer=function t(e){return !(null==e||!e._isBuffer)},u.compare=function t(e,r){if(!u.isBuffer(e)||!u.isBuffer(r))throw new TypeError("Arguments must be Buffers");if(e===r)return 0;for(var n=e.length,i=r.length,o=0,s=Math.min(n,i);o<s;++o)if(e[o]!==r[o]){n=e[o],i=r[o];break}return n<i?-1:i<n?1:0},u.isEncoding=function t(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return !0;default:return !1}},u.concat=function t(e,r){if(!o(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return u.alloc(0);var n;if(void 0===r)for(r=0,n=0;n<e.length;++n)r+=e[n].length;var i=u.allocUnsafe(r),s=0;for(n=0;n<e.length;++n){var a=e[n];if(!u.isBuffer(a))throw new TypeError('"list" argument must be an Array of Buffers');a.copy(i,s),s+=a.length;}return i},u.byteLength=d,u.prototype._isBuffer=!0,u.prototype.swap16=function t(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var r=0;r<e;r+=2)v(this,r,r+1);return this},u.prototype.swap32=function t(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var r=0;r<e;r+=4)v(this,r,r+3),v(this,r+1,r+2);return this},u.prototype.swap64=function t(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var r=0;r<e;r+=8)v(this,r,r+7),v(this,r+1,r+6),v(this,r+2,r+5),v(this,r+3,r+4);return this},u.prototype.toString=function t(){var e=0|this.length;return 0===e?"":0===arguments.length?A(this,0,e):p.apply(this,arguments)},u.prototype.equals=function t(e){if(!u.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===u.compare(this,e)},u.prototype.inspect=function t(){var r="",n=e.INSPECT_MAX_BYTES;return this.length>0&&(r=this.toString("hex",0,n).match(/.{2}/g).join(" "),this.length>n&&(r+=" ... ")),"<Buffer "+r+">"},u.prototype.compare=function t(e,r,n,i,o){if(!u.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===r&&(r=0),void 0===n&&(n=e?e.length:0),void 0===i&&(i=0),void 0===o&&(o=this.length),r<0||n>e.length||i<0||o>this.length)throw new RangeError("out of range index");if(i>=o&&r>=n)return 0;if(i>=o)return -1;if(r>=n)return 1;if(this===e)return 0;for(var s=(o>>>=0)-(i>>>=0),a=(n>>>=0)-(r>>>=0),c=Math.min(s,a),h=this.slice(i,o),l=e.slice(r,n),f=0;f<c;++f)if(h[f]!==l[f]){s=h[f],a=l[f];break}return s<a?-1:a<s?1:0},u.prototype.includes=function t(e,r,n){return -1!==this.indexOf(e,r,n)},u.prototype.indexOf=function t(e,r,n){return y(this,e,r,n,!0)},u.prototype.lastIndexOf=function t(e,r,n){return y(this,e,r,n,!1)},u.prototype.write=function t(e,r,n,i){if(void 0===r)i="utf8",n=this.length,r=0;else if(void 0===n&&"string"==typeof r)i=r,n=this.length,r=0;else {if(!isFinite(r))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");r|=0,isFinite(n)?(n|=0,void 0===i&&(i="utf8")):(i=n,n=void 0);}var o=this.length-r;if((void 0===n||n>o)&&(n=o),e.length>0&&(n<0||r<0)||r>this.length)throw new RangeError("Attempt to write outside buffer bounds");i||(i="utf8");for(var s=!1;;)switch(i){case"hex":return _(this,e,r,n);case"utf8":case"utf-8":return S(this,e,r,n);case"ascii":return b(this,e,r,n);case"latin1":case"binary":return w(this,e,r,n);case"base64":return F(this,e,r,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return E(this,e,r,n);default:if(s)throw new TypeError("Unknown encoding: "+i);i=(""+i).toLowerCase(),s=!0;}},u.prototype.toJSON=function t(){return {type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var C=4096;function T(t,e,r){var n="";r=Math.min(t.length,r);for(var i=e;i<r;++i)n+=String.fromCharCode(127&t[i]);return n}function R(t,e,r){var n="";r=Math.min(t.length,r);for(var i=e;i<r;++i)n+=String.fromCharCode(t[i]);return n}function I(t,e,r){var n=t.length;(!e||e<0)&&(e=0),(!r||r<0||r>n)&&(r=n);for(var i="",o=e;o<r;++o)i+=V(t[o]);return i}function D(t,e,r){for(var n=t.slice(e,r),i="",o=0;o<n.length;o+=2)i+=String.fromCharCode(n[o]+256*n[o+1]);return i}function L(t,e,r){if(t%1!=0||t<0)throw new RangeError("offset is not uint");if(t+e>r)throw new RangeError("Trying to access beyond buffer length")}function N(t,e,r,n,i,o){if(!u.isBuffer(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(e>i||e<o)throw new RangeError('"value" argument is out of bounds');if(r+n>t.length)throw new RangeError("Index out of range")}function U(t,e,r,n){e<0&&(e=65535+e+1);for(var i=0,o=Math.min(t.length-r,2);i<o;++i)t[r+i]=(e&255<<8*(n?i:1-i))>>>8*(n?i:1-i);}function B(t,e,r,n){e<0&&(e=4294967295+e+1);for(var i=0,o=Math.min(t.length-r,4);i<o;++i)t[r+i]=e>>>8*(n?i:3-i)&255;}function O(t,e,r,n,i,o){if(r+n>t.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function j(t,e,r,n,o){return o||O(t,0,r,4),i.write(t,e,r,n,23,4),r+4}function M(t,e,r,n,o){return o||O(t,0,r,8),i.write(t,e,r,n,52,8),r+8}u.prototype.slice=function t(e,r){var n,i=this.length;if((e=~~e)<0?(e+=i)<0&&(e=0):e>i&&(e=i),(r=void 0===r?i:~~r)<0?(r+=i)<0&&(r=0):r>i&&(r=i),r<e&&(r=e),u.TYPED_ARRAY_SUPPORT)(n=this.subarray(e,r)).__proto__=u.prototype;else {var o=r-e;n=new u(o,void 0);for(var s=0;s<o;++s)n[s]=this[s+e];}return n},u.prototype.readUIntLE=function t(e,r,n){e|=0,r|=0,n||L(e,r,this.length);for(var i=this[e],o=1,s=0;++s<r&&(o*=256);)i+=this[e+s]*o;return i},u.prototype.readUIntBE=function t(e,r,n){e|=0,r|=0,n||L(e,r,this.length);for(var i=this[e+--r],o=1;r>0&&(o*=256);)i+=this[e+--r]*o;return i},u.prototype.readUInt8=function t(e,r){return r||L(e,1,this.length),this[e]},u.prototype.readUInt16LE=function t(e,r){return r||L(e,2,this.length),this[e]|this[e+1]<<8},u.prototype.readUInt16BE=function t(e,r){return r||L(e,2,this.length),this[e]<<8|this[e+1]},u.prototype.readUInt32LE=function t(e,r){return r||L(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},u.prototype.readUInt32BE=function t(e,r){return r||L(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},u.prototype.readIntLE=function t(e,r,n){e|=0,r|=0,n||L(e,r,this.length);for(var i=this[e],o=1,s=0;++s<r&&(o*=256);)i+=this[e+s]*o;return i>=(o*=128)&&(i-=Math.pow(2,8*r)),i},u.prototype.readIntBE=function t(e,r,n){e|=0,r|=0,n||L(e,r,this.length);for(var i=r,o=1,s=this[e+--i];i>0&&(o*=256);)s+=this[e+--i]*o;return s>=(o*=128)&&(s-=Math.pow(2,8*r)),s},u.prototype.readInt8=function t(e,r){return r||L(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},u.prototype.readInt16LE=function t(e,r){r||L(e,2,this.length);var n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},u.prototype.readInt16BE=function t(e,r){r||L(e,2,this.length);var n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},u.prototype.readInt32LE=function t(e,r){return r||L(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},u.prototype.readInt32BE=function t(e,r){return r||L(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},u.prototype.readFloatLE=function t(e,r){return r||L(e,4,this.length),i.read(this,e,!0,23,4)},u.prototype.readFloatBE=function t(e,r){return r||L(e,4,this.length),i.read(this,e,!1,23,4)},u.prototype.readDoubleLE=function t(e,r){return r||L(e,8,this.length),i.read(this,e,!0,52,8)},u.prototype.readDoubleBE=function t(e,r){return r||L(e,8,this.length),i.read(this,e,!1,52,8)},u.prototype.writeUIntLE=function t(e,r,n,i){(e=+e,r|=0,n|=0,i)||N(this,e,r,n,Math.pow(2,8*n)-1,0);var o=1,s=0;for(this[r]=255&e;++s<n&&(o*=256);)this[r+s]=e/o&255;return r+n},u.prototype.writeUIntBE=function t(e,r,n,i){(e=+e,r|=0,n|=0,i)||N(this,e,r,n,Math.pow(2,8*n)-1,0);var o=n-1,s=1;for(this[r+o]=255&e;--o>=0&&(s*=256);)this[r+o]=e/s&255;return r+n},u.prototype.writeUInt8=function t(e,r,n){return e=+e,r|=0,n||N(this,e,r,1,255,0),u.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[r]=255&e,r+1},u.prototype.writeUInt16LE=function t(e,r,n){return e=+e,r|=0,n||N(this,e,r,2,65535,0),u.TYPED_ARRAY_SUPPORT?(this[r]=255&e,this[r+1]=e>>>8):U(this,e,r,!0),r+2},u.prototype.writeUInt16BE=function t(e,r,n){return e=+e,r|=0,n||N(this,e,r,2,65535,0),u.TYPED_ARRAY_SUPPORT?(this[r]=e>>>8,this[r+1]=255&e):U(this,e,r,!1),r+2},u.prototype.writeUInt32LE=function t(e,r,n){return e=+e,r|=0,n||N(this,e,r,4,4294967295,0),u.TYPED_ARRAY_SUPPORT?(this[r+3]=e>>>24,this[r+2]=e>>>16,this[r+1]=e>>>8,this[r]=255&e):B(this,e,r,!0),r+4},u.prototype.writeUInt32BE=function t(e,r,n){return e=+e,r|=0,n||N(this,e,r,4,4294967295,0),u.TYPED_ARRAY_SUPPORT?(this[r]=e>>>24,this[r+1]=e>>>16,this[r+2]=e>>>8,this[r+3]=255&e):B(this,e,r,!1),r+4},u.prototype.writeIntLE=function t(e,r,n,i){if(e=+e,r|=0,!i){var o=Math.pow(2,8*n-1);N(this,e,r,n,o-1,-o);}var s=0,a=1,u=0;for(this[r]=255&e;++s<n&&(a*=256);)e<0&&0===u&&0!==this[r+s-1]&&(u=1),this[r+s]=(e/a>>0)-u&255;return r+n},u.prototype.writeIntBE=function t(e,r,n,i){if(e=+e,r|=0,!i){var o=Math.pow(2,8*n-1);N(this,e,r,n,o-1,-o);}var s=n-1,a=1,u=0;for(this[r+s]=255&e;--s>=0&&(a*=256);)e<0&&0===u&&0!==this[r+s+1]&&(u=1),this[r+s]=(e/a>>0)-u&255;return r+n},u.prototype.writeInt8=function t(e,r,n){return e=+e,r|=0,n||N(this,e,r,1,127,-128),u.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[r]=255&e,r+1},u.prototype.writeInt16LE=function t(e,r,n){return e=+e,r|=0,n||N(this,e,r,2,32767,-32768),u.TYPED_ARRAY_SUPPORT?(this[r]=255&e,this[r+1]=e>>>8):U(this,e,r,!0),r+2},u.prototype.writeInt16BE=function t(e,r,n){return e=+e,r|=0,n||N(this,e,r,2,32767,-32768),u.TYPED_ARRAY_SUPPORT?(this[r]=e>>>8,this[r+1]=255&e):U(this,e,r,!1),r+2},u.prototype.writeInt32LE=function t(e,r,n){return e=+e,r|=0,n||N(this,e,r,4,2147483647,-2147483648),u.TYPED_ARRAY_SUPPORT?(this[r]=255&e,this[r+1]=e>>>8,this[r+2]=e>>>16,this[r+3]=e>>>24):B(this,e,r,!0),r+4},u.prototype.writeInt32BE=function t(e,r,n){return e=+e,r|=0,n||N(this,e,r,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),u.TYPED_ARRAY_SUPPORT?(this[r]=e>>>24,this[r+1]=e>>>16,this[r+2]=e>>>8,this[r+3]=255&e):B(this,e,r,!1),r+4},u.prototype.writeFloatLE=function t(e,r,n){return j(this,e,r,!0,n)},u.prototype.writeFloatBE=function t(e,r,n){return j(this,e,r,!1,n)},u.prototype.writeDoubleLE=function t(e,r,n){return M(this,e,r,!0,n)},u.prototype.writeDoubleBE=function t(e,r,n){return M(this,e,r,!1,n)},u.prototype.copy=function t(e,r,n,i){if(n||(n=0),i||0===i||(i=this.length),r>=e.length&&(r=e.length),r||(r=0),i>0&&i<n&&(i=n),i===n)return 0;if(0===e.length||0===this.length)return 0;if(r<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("sourceStart out of bounds");if(i<0)throw new RangeError("sourceEnd out of bounds");i>this.length&&(i=this.length),e.length-r<i-n&&(i=e.length-r+n);var o,s=i-n;if(this===e&&n<r&&r<i)for(o=s-1;o>=0;--o)e[o+r]=this[o+n];else if(s<1e3||!u.TYPED_ARRAY_SUPPORT)for(o=0;o<s;++o)e[o+r]=this[o+n];else Uint8Array.prototype.set.call(e,this.subarray(n,n+s),r);return s},u.prototype.fill=function t(e,r,n,i){if("string"==typeof e){if("string"==typeof r?(i=r,r=0,n=this.length):"string"==typeof n&&(i=n,n=this.length),1===e.length){var o=e.charCodeAt(0);o<256&&(e=o);}if(void 0!==i&&"string"!=typeof i)throw new TypeError("encoding must be a string");if("string"==typeof i&&!u.isEncoding(i))throw new TypeError("Unknown encoding: "+i)}else "number"==typeof e&&(e&=255);if(r<0||this.length<r||this.length<n)throw new RangeError("Out of range index");if(n<=r)return this;var s;if(r>>>=0,n=void 0===n?this.length:n>>>0,e||(e=0),"number"==typeof e)for(s=r;s<n;++s)this[s]=e;else {var a=u.isBuffer(e)?e:K(new u(e,i).toString()),c=a.length;for(s=0;s<n-r;++s)this[s+r]=a[s%c];}return this};var H=/[^+\/0-9A-Za-z-_]/g;function V(t){return t<16?"0"+t.toString(16):t.toString(16)}function K(t,e){var r;e=e||1/0;for(var n=t.length,i=null,o=[],s=0;s<n;++s){if((r=t.charCodeAt(s))>55295&&r<57344){if(!i){if(r>56319){(e-=3)>-1&&o.push(239,191,189);continue}if(s+1===n){(e-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(e-=3)>-1&&o.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320);}else i&&(e-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((e-=1)<0)break;o.push(r);}else if(r<2048){if((e-=2)<0)break;o.push(r>>6|192,63&r|128);}else if(r<65536){if((e-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128);}else {if(!(r<1114112))throw new Error("Invalid code point");if((e-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128);}}return o}function q(t){return n.toByteArray(function e(t){if((t=function e(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")}(t).replace(H,"")).length<2)return "";for(;t.length%4!=0;)t+="=";return t}(t))}function J(t,e,r,n){for(var i=0;i<n&&!(i+r>=e.length||i>=t.length);++i)e[i+r]=t[i];return i}}).call(this,r(29));},function(t,e){var r;r=function(){return this}();try{r=r||new Function("return this")();}catch(t){"object"==typeof window&&(r=window);}t.exports=r;},function(t,e,r){e.byteLength=function n(t){var e=f(t),r=e[0],n=e[1];return 3*(r+n)/4-n},e.toByteArray=function i(t){var e,r,n=f(t),i=n[0],o=n[1],s=new u(function c(t,e,r){return 3*(e+r)/4-r}(0,i,o)),h=0,l=o>0?i-4:i;for(r=0;r<l;r+=4)e=a[t.charCodeAt(r)]<<18|a[t.charCodeAt(r+1)]<<12|a[t.charCodeAt(r+2)]<<6|a[t.charCodeAt(r+3)],s[h++]=e>>16&255,s[h++]=e>>8&255,s[h++]=255&e;2===o&&(e=a[t.charCodeAt(r)]<<2|a[t.charCodeAt(r+1)]>>4,s[h++]=255&e);1===o&&(e=a[t.charCodeAt(r)]<<10|a[t.charCodeAt(r+1)]<<4|a[t.charCodeAt(r+2)]>>2,s[h++]=e>>8&255,s[h++]=255&e);return s},e.fromByteArray=function o(t){for(var e,r=t.length,n=r%3,i=[],o=16383,a=0,u=r-n;a<u;a+=o)i.push(g(t,a,a+o>u?u:a+o));1===n?(e=t[r-1],i.push(s[e>>2]+s[e<<4&63]+"==")):2===n&&(e=(t[r-2]<<8)+t[r-1],i.push(s[e>>10]+s[e>>4&63]+s[e<<2&63]+"="));return i.join("")};for(var s=[],a=[],u="undefined"!=typeof Uint8Array?Uint8Array:Array,c="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",h=0,l=c.length;h<l;++h)s[h]=c[h],a[c.charCodeAt(h)]=h;function f(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=t.indexOf("=");return -1===r&&(r=e),[r,r===e?0:4-r%4]}function g(t,e,r){for(var n,i,o=[],a=e;a<r;a+=3)n=(t[a]<<16&16711680)+(t[a+1]<<8&65280)+(255&t[a+2]),o.push(s[(i=n)>>18&63]+s[i>>12&63]+s[i>>6&63]+s[63&i]);return o.join("")}a["-".charCodeAt(0)]=62,a["_".charCodeAt(0)]=63;},function(t,e){
	/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
	e.read=function(t,e,r,n,i){var o,s,a=8*i-n-1,u=(1<<a)-1,c=u>>1,h=-7,l=r?i-1:0,f=r?-1:1,g=t[e+l];for(l+=f,o=g&(1<<-h)-1,g>>=-h,h+=a;h>0;o=256*o+t[e+l],l+=f,h-=8);for(s=o&(1<<-h)-1,o>>=-h,h+=n;h>0;s=256*s+t[e+l],l+=f,h-=8);if(0===o)o=1-c;else {if(o===u)return s?NaN:1/0*(g?-1:1);s+=Math.pow(2,n),o-=c;}return (g?-1:1)*s*Math.pow(2,o-n)},e.write=function(t,e,r,n,i,o){var s,a,u,c=8*o-i-1,h=(1<<c)-1,l=h>>1,f=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,g=n?0:o-1,d=n?1:-1,p=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,s=h):(s=Math.floor(Math.log(e)/Math.LN2),e*(u=Math.pow(2,-s))<1&&(s--,u*=2),(e+=s+l>=1?f/u:f*Math.pow(2,1-l))*u>=2&&(s++,u/=2),s+l>=h?(a=0,s=h):s+l>=1?(a=(e*u-1)*Math.pow(2,i),s+=l):(a=e*Math.pow(2,l-1)*Math.pow(2,i),s=0));i>=8;t[r+g]=255&a,g+=d,a/=256,i-=8);for(s=s<<i|a,c+=i;c>0;t[r+g]=255&s,g+=d,s/=256,c-=8);t[r+g-d]|=128*p;};},function(t,e){var r={}.toString;t.exports=Array.isArray||function(t){return "[object Array]"==r.call(t)};},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.default=function n(t){var e=t.jws,r=t.KeyUtil,n=t.X509,o=t.crypto,s=t.hextob64u,a=t.b64tohex,u=t.AllowedSigningAlgs;return function(){function t(){!function e(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}(this,t);}return t.parseJwt=function t(r){i.Log.debug("JoseUtil.parseJwt");try{var n=e.JWS.parse(r);return {header:n.headerObj,payload:n.payloadObj}}catch(t){i.Log.error(t);}},t.validateJwt=function e(o,s,u,c,h,l,f){i.Log.debug("JoseUtil.validateJwt");try{if("RSA"===s.kty)if(s.e&&s.n)s=r.getKey(s);else {if(!s.x5c||!s.x5c.length)return i.Log.error("JoseUtil.validateJwt: RSA key missing key material",s),Promise.reject(new Error("RSA key missing key material"));var g=a(s.x5c[0]);s=n.getPublicKeyFromCertHex(g);}else {if("EC"!==s.kty)return i.Log.error("JoseUtil.validateJwt: Unsupported key type",s&&s.kty),Promise.reject(new Error(s.kty));if(!(s.crv&&s.x&&s.y))return i.Log.error("JoseUtil.validateJwt: EC key missing key material",s),Promise.reject(new Error("EC key missing key material"));s=r.getKey(s);}return t._validateJwt(o,s,u,c,h,l,f)}catch(t){return i.Log.error(t&&t.message||t),Promise.reject("JWT validation failed")}},t.validateJwtAttributes=function e(r,n,o,s,a,u){s||(s=0),a||(a=parseInt(Date.now()/1e3));var c=t.parseJwt(r).payload;if(!c.iss)return i.Log.error("JoseUtil._validateJwt: issuer was not provided"),Promise.reject(new Error("issuer was not provided"));if(c.iss!==n)return i.Log.error("JoseUtil._validateJwt: Invalid issuer in token",c.iss),Promise.reject(new Error("Invalid issuer in token: "+c.iss));if(!c.aud)return i.Log.error("JoseUtil._validateJwt: aud was not provided"),Promise.reject(new Error("aud was not provided"));if(!(c.aud===o||Array.isArray(c.aud)&&c.aud.indexOf(o)>=0))return i.Log.error("JoseUtil._validateJwt: Invalid audience in token",c.aud),Promise.reject(new Error("Invalid audience in token: "+c.aud));if(c.azp&&c.azp!==o)return i.Log.error("JoseUtil._validateJwt: Invalid azp in token",c.azp),Promise.reject(new Error("Invalid azp in token: "+c.azp));if(!u){var h=a+s,l=a-s;if(!c.iat)return i.Log.error("JoseUtil._validateJwt: iat was not provided"),Promise.reject(new Error("iat was not provided"));if(h<c.iat)return i.Log.error("JoseUtil._validateJwt: iat is in the future",c.iat),Promise.reject(new Error("iat is in the future: "+c.iat));if(c.nbf&&h<c.nbf)return i.Log.error("JoseUtil._validateJwt: nbf is in the future",c.nbf),Promise.reject(new Error("nbf is in the future: "+c.nbf));if(!c.exp)return i.Log.error("JoseUtil._validateJwt: exp was not provided"),Promise.reject(new Error("exp was not provided"));if(c.exp<l)return i.Log.error("JoseUtil._validateJwt: exp is in the past",c.exp),Promise.reject(new Error("exp is in the past:"+c.exp))}return Promise.resolve(c)},t._validateJwt=function r(n,o,s,a,c,h,l){return t.validateJwtAttributes(n,s,a,c,h,l).then((function(t){try{return e.JWS.verify(n,o,u)?t:(i.Log.error("JoseUtil._validateJwt: signature validation failed"),Promise.reject(new Error("signature validation failed")))}catch(t){return i.Log.error(t&&t.message||t),Promise.reject(new Error("signature validation failed"))}}))},t.hashString=function t(e,r){try{return o.Util.hashString(e,r)}catch(t){i.Log.error(t);}},t.hexToBase64Url=function t(e){try{return s(e)}catch(t){i.Log.error(t);}},t}()};var i=r(0);t.exports=e.default;},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.SigninResponse=void 0;var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),i=r(3);function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}e.SigninResponse=function(){function t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#";o(this,t);var n=i.UrlUtility.parseUrlFragment(e,r);this.error=n.error,this.error_description=n.error_description,this.error_uri=n.error_uri,this.code=n.code,this.state=n.state,this.id_token=n.id_token,this.session_state=n.session_state,this.access_token=n.access_token,this.token_type=n.token_type,this.scope=n.scope,this.profile=void 0,this.expires_in=n.expires_in;}return n(t,[{key:"expires_in",get:function t(){if(this.expires_at){var e=parseInt(Date.now()/1e3);return this.expires_at-e}},set:function t(e){var r=parseInt(e);if("number"==typeof r&&r>0){var n=parseInt(Date.now()/1e3);this.expires_at=n+r;}}},{key:"expired",get:function t(){var e=this.expires_in;if(void 0!==e)return e<=0}},{key:"scopes",get:function t(){return (this.scope||"").split(" ")}},{key:"isOpenIdConnect",get:function t(){return this.scopes.indexOf("openid")>=0||!!this.id_token}}]),t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.SignoutRequest=void 0;var n=r(0),i=r(3),o=r(9);e.SignoutRequest=function t(e){var r=e.url,s=e.id_token_hint,a=e.post_logout_redirect_uri,u=e.data,c=e.extraQueryParams,h=e.request_type;if(function l(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),!r)throw n.Log.error("SignoutRequest.ctor: No url passed"),new Error("url");for(var f in s&&(r=i.UrlUtility.addQueryParam(r,"id_token_hint",s)),a&&(r=i.UrlUtility.addQueryParam(r,"post_logout_redirect_uri",a),u&&(this.state=new o.State({data:u,request_type:h}),r=i.UrlUtility.addQueryParam(r,"state",this.state.id))),c)r=i.UrlUtility.addQueryParam(r,f,c[f]);this.url=r;};},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.SignoutResponse=void 0;var n=r(3);e.SignoutResponse=function t(e){!function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t);var i=n.UrlUtility.parseUrlFragment(e,"?");this.error=i.error,this.error_description=i.error_description,this.error_uri=i.error_uri,this.state=i.state;};},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.InMemoryWebStorage=void 0;var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),i=r(0);e.InMemoryWebStorage=function(){function t(){!function e(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}(this,t),this._data={};}return t.prototype.getItem=function t(e){return i.Log.debug("InMemoryWebStorage.getItem",e),this._data[e]},t.prototype.setItem=function t(e,r){i.Log.debug("InMemoryWebStorage.setItem",e),this._data[e]=r;},t.prototype.removeItem=function t(e){i.Log.debug("InMemoryWebStorage.removeItem",e),delete this._data[e];},t.prototype.key=function t(e){return Object.getOwnPropertyNames(this._data)[e]},n(t,[{key:"length",get:function t(){return Object.getOwnPropertyNames(this._data).length}}]),t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.UserManager=void 0;var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),i=r(0),o=r(10),s=r(39),a=r(15),u=r(45),c=r(47),h=r(18),l=r(8),f=r(20),g=r(11),d=r(4);function p(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function v(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !e||"object"!=typeof e&&"function"!=typeof e?t:e}e.UserManager=function(t){function e(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c.SilentRenewService,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:h.SessionMonitor,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:f.TokenRevocationClient,l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:g.TokenClient,y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:d.JoseUtil;p(this,e),r instanceof s.UserManagerSettings||(r=new s.UserManagerSettings(r));var m=v(this,t.call(this,r));return m._events=new u.UserManagerEvents(r),m._silentRenewService=new n(m),m.settings.automaticSilentRenew&&(i.Log.debug("UserManager.ctor: automaticSilentRenew is configured, setting up silent renew"),m.startSilentRenew()),m.settings.monitorSession&&(i.Log.debug("UserManager.ctor: monitorSession is configured, setting up session monitor"),m._sessionMonitor=new o(m)),m._tokenRevocationClient=new a(m._settings),m._tokenClient=new l(m._settings),m._joseUtil=y,m}return function r(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}(e,t),e.prototype.getUser=function t(){var e=this;return this._loadUser().then((function(t){return t?(i.Log.info("UserManager.getUser: user loaded"),e._events.load(t,!1),t):(i.Log.info("UserManager.getUser: user not found in storage"),null)}))},e.prototype.removeUser=function t(){var e=this;return this.storeUser(null).then((function(){i.Log.info("UserManager.removeUser: user removed from storage"),e._events.unload();}))},e.prototype.signinRedirect=function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};(e=Object.assign({},e)).request_type="si:r";var r={useReplaceToNavigate:e.useReplaceToNavigate};return this._signinStart(e,this._redirectNavigator,r).then((function(){i.Log.info("UserManager.signinRedirect: successful");}))},e.prototype.signinRedirectCallback=function t(e){return this._signinEnd(e||this._redirectNavigator.url).then((function(t){return t.profile&&t.profile.sub?i.Log.info("UserManager.signinRedirectCallback: successful, signed in sub: ",t.profile.sub):i.Log.info("UserManager.signinRedirectCallback: no sub"),t}))},e.prototype.signinPopup=function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};(e=Object.assign({},e)).request_type="si:p";var r=e.redirect_uri||this.settings.popup_redirect_uri||this.settings.redirect_uri;return r?(e.redirect_uri=r,e.display="popup",this._signin(e,this._popupNavigator,{startUrl:r,popupWindowFeatures:e.popupWindowFeatures||this.settings.popupWindowFeatures,popupWindowTarget:e.popupWindowTarget||this.settings.popupWindowTarget}).then((function(t){return t&&(t.profile&&t.profile.sub?i.Log.info("UserManager.signinPopup: signinPopup successful, signed in sub: ",t.profile.sub):i.Log.info("UserManager.signinPopup: no sub")),t}))):(i.Log.error("UserManager.signinPopup: No popup_redirect_uri or redirect_uri configured"),Promise.reject(new Error("No popup_redirect_uri or redirect_uri configured")))},e.prototype.signinPopupCallback=function t(e){return this._signinCallback(e,this._popupNavigator).then((function(t){return t&&(t.profile&&t.profile.sub?i.Log.info("UserManager.signinPopupCallback: successful, signed in sub: ",t.profile.sub):i.Log.info("UserManager.signinPopupCallback: no sub")),t})).catch((function(t){i.Log.error(t.message);}))},e.prototype.signinSilent=function t(){var e=this,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return r=Object.assign({},r),this._loadUser().then((function(t){return t&&t.refresh_token?(r.refresh_token=t.refresh_token,e._useRefreshToken(r)):(r.request_type="si:s",r.id_token_hint=r.id_token_hint||e.settings.includeIdTokenInSilentRenew&&t&&t.id_token,t&&e._settings.validateSubOnSilentRenew&&(i.Log.debug("UserManager.signinSilent, subject prior to silent renew: ",t.profile.sub),r.current_sub=t.profile.sub),e._signinSilentIframe(r))}))},e.prototype._useRefreshToken=function t(){var e=this,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this._tokenClient.exchangeRefreshToken(r).then((function(t){return t?t.access_token?e._loadUser().then((function(r){if(r){var n=Promise.resolve();return t.id_token&&(n=e._validateIdTokenFromTokenRefreshToken(r.profile,t.id_token)),n.then((function(){return i.Log.debug("UserManager._useRefreshToken: refresh token response success"),r.id_token=t.id_token||r.id_token,r.access_token=t.access_token,r.refresh_token=t.refresh_token||r.refresh_token,r.expires_in=t.expires_in,e.storeUser(r).then((function(){return e._events.load(r),r}))}))}return null})):(i.Log.error("UserManager._useRefreshToken: No access token returned from token endpoint"),Promise.reject("No access token returned from token endpoint")):(i.Log.error("UserManager._useRefreshToken: No response returned from token endpoint"),Promise.reject("No response returned from token endpoint"))}))},e.prototype._validateIdTokenFromTokenRefreshToken=function t(e,r){var n=this;return this._metadataService.getIssuer().then((function(t){return n.settings.getEpochTime().then((function(o){return n._joseUtil.validateJwtAttributes(r,t,n._settings.client_id,n._settings.clockSkew,o).then((function(t){return t?t.sub!==e.sub?(i.Log.error("UserManager._validateIdTokenFromTokenRefreshToken: sub in id_token does not match current sub"),Promise.reject(new Error("sub in id_token does not match current sub"))):t.auth_time&&t.auth_time!==e.auth_time?(i.Log.error("UserManager._validateIdTokenFromTokenRefreshToken: auth_time in id_token does not match original auth_time"),Promise.reject(new Error("auth_time in id_token does not match original auth_time"))):t.azp&&t.azp!==e.azp?(i.Log.error("UserManager._validateIdTokenFromTokenRefreshToken: azp in id_token does not match original azp"),Promise.reject(new Error("azp in id_token does not match original azp"))):!t.azp&&e.azp?(i.Log.error("UserManager._validateIdTokenFromTokenRefreshToken: azp not in id_token, but present in original id_token"),Promise.reject(new Error("azp not in id_token, but present in original id_token"))):void 0:(i.Log.error("UserManager._validateIdTokenFromTokenRefreshToken: Failed to validate id_token"),Promise.reject(new Error("Failed to validate id_token")))}))}))}))},e.prototype._signinSilentIframe=function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=e.redirect_uri||this.settings.silent_redirect_uri||this.settings.redirect_uri;return r?(e.redirect_uri=r,e.prompt=e.prompt||"none",this._signin(e,this._iframeNavigator,{startUrl:r,silentRequestTimeout:e.silentRequestTimeout||this.settings.silentRequestTimeout}).then((function(t){return t&&(t.profile&&t.profile.sub?i.Log.info("UserManager.signinSilent: successful, signed in sub: ",t.profile.sub):i.Log.info("UserManager.signinSilent: no sub")),t}))):(i.Log.error("UserManager.signinSilent: No silent_redirect_uri configured"),Promise.reject(new Error("No silent_redirect_uri configured")))},e.prototype.signinSilentCallback=function t(e){return this._signinCallback(e,this._iframeNavigator).then((function(t){return t&&(t.profile&&t.profile.sub?i.Log.info("UserManager.signinSilentCallback: successful, signed in sub: ",t.profile.sub):i.Log.info("UserManager.signinSilentCallback: no sub")),t}))},e.prototype.signinCallback=function t(e){var r=this;return this.readSigninResponseState(e).then((function(t){var n=t.state;t.response;return "si:r"===n.request_type?r.signinRedirectCallback(e):"si:p"===n.request_type?r.signinPopupCallback(e):"si:s"===n.request_type?r.signinSilentCallback(e):Promise.reject(new Error("invalid response_type in state"))}))},e.prototype.signoutCallback=function t(e,r){var n=this;return this.readSignoutResponseState(e).then((function(t){var i=t.state,o=t.response;return i?"so:r"===i.request_type?n.signoutRedirectCallback(e):"so:p"===i.request_type?n.signoutPopupCallback(e,r):Promise.reject(new Error("invalid response_type in state")):o}))},e.prototype.querySessionStatus=function t(){var e=this,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};(r=Object.assign({},r)).request_type="si:s";var n=r.redirect_uri||this.settings.silent_redirect_uri||this.settings.redirect_uri;return n?(r.redirect_uri=n,r.prompt="none",r.response_type=r.response_type||this.settings.query_status_response_type,r.scope=r.scope||"openid",r.skipUserInfo=!0,this._signinStart(r,this._iframeNavigator,{startUrl:n,silentRequestTimeout:r.silentRequestTimeout||this.settings.silentRequestTimeout}).then((function(t){return e.processSigninResponse(t.url).then((function(t){if(i.Log.debug("UserManager.querySessionStatus: got signin response"),t.session_state&&t.profile.sub)return i.Log.info("UserManager.querySessionStatus: querySessionStatus success for sub: ",t.profile.sub),{session_state:t.session_state,sub:t.profile.sub,sid:t.profile.sid};i.Log.info("querySessionStatus successful, user not authenticated");})).catch((function(t){if(t.session_state&&e.settings.monitorAnonymousSession&&("login_required"==t.message||"consent_required"==t.message||"interaction_required"==t.message||"account_selection_required"==t.message))return i.Log.info("UserManager.querySessionStatus: querySessionStatus success for anonymous user"),{session_state:t.session_state};throw t}))}))):(i.Log.error("UserManager.querySessionStatus: No silent_redirect_uri configured"),Promise.reject(new Error("No silent_redirect_uri configured")))},e.prototype._signin=function t(e,r){var n=this,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this._signinStart(e,r,i).then((function(t){return n._signinEnd(t.url,e)}))},e.prototype._signinStart=function t(e,r){var n=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return r.prepare(o).then((function(t){return i.Log.debug("UserManager._signinStart: got navigator window handle"),n.createSigninRequest(e).then((function(e){return i.Log.debug("UserManager._signinStart: got signin request"),o.url=e.url,o.id=e.state.id,t.navigate(o)})).catch((function(e){throw t.close&&(i.Log.debug("UserManager._signinStart: Error after preparing navigator, closing navigator window"),t.close()),e}))}))},e.prototype._signinEnd=function t(e){var r=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.processSigninResponse(e).then((function(t){i.Log.debug("UserManager._signinEnd: got signin response");var e=new a.User(t);if(n.current_sub){if(n.current_sub!==e.profile.sub)return i.Log.debug("UserManager._signinEnd: current user does not match user returned from signin. sub from signin: ",e.profile.sub),Promise.reject(new Error("login_required"));i.Log.debug("UserManager._signinEnd: current user matches user returned from signin");}return r.storeUser(e).then((function(){return i.Log.debug("UserManager._signinEnd: user stored"),r._events.load(e),e}))}))},e.prototype._signinCallback=function t(e,r){i.Log.debug("UserManager._signinCallback");var n="query"===this._settings.response_mode||!this._settings.response_mode&&l.SigninRequest.isCode(this._settings.response_type)?"?":"#";return r.callback(e,void 0,n)},e.prototype.signoutRedirect=function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};(e=Object.assign({},e)).request_type="so:r";var r=e.post_logout_redirect_uri||this.settings.post_logout_redirect_uri;r&&(e.post_logout_redirect_uri=r);var n={useReplaceToNavigate:e.useReplaceToNavigate};return this._signoutStart(e,this._redirectNavigator,n).then((function(){i.Log.info("UserManager.signoutRedirect: successful");}))},e.prototype.signoutRedirectCallback=function t(e){return this._signoutEnd(e||this._redirectNavigator.url).then((function(t){return i.Log.info("UserManager.signoutRedirectCallback: successful"),t}))},e.prototype.signoutPopup=function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};(e=Object.assign({},e)).request_type="so:p";var r=e.post_logout_redirect_uri||this.settings.popup_post_logout_redirect_uri||this.settings.post_logout_redirect_uri;return e.post_logout_redirect_uri=r,e.display="popup",e.post_logout_redirect_uri&&(e.state=e.state||{}),this._signout(e,this._popupNavigator,{startUrl:r,popupWindowFeatures:e.popupWindowFeatures||this.settings.popupWindowFeatures,popupWindowTarget:e.popupWindowTarget||this.settings.popupWindowTarget}).then((function(){i.Log.info("UserManager.signoutPopup: successful");}))},e.prototype.signoutPopupCallback=function t(e,r){void 0===r&&"boolean"==typeof e&&(r=e,e=null);return this._popupNavigator.callback(e,r,"?").then((function(){i.Log.info("UserManager.signoutPopupCallback: successful");}))},e.prototype._signout=function t(e,r){var n=this,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this._signoutStart(e,r,i).then((function(t){return n._signoutEnd(t.url)}))},e.prototype._signoutStart=function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=this,n=arguments[1],o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n.prepare(o).then((function(t){return i.Log.debug("UserManager._signoutStart: got navigator window handle"),r._loadUser().then((function(n){return i.Log.debug("UserManager._signoutStart: loaded current user from storage"),(r._settings.revokeAccessTokenOnSignout?r._revokeInternal(n):Promise.resolve()).then((function(){var s=e.id_token_hint||n&&n.id_token;return s&&(i.Log.debug("UserManager._signoutStart: Setting id_token into signout request"),e.id_token_hint=s),r.removeUser().then((function(){return i.Log.debug("UserManager._signoutStart: user removed, creating signout request"),r.createSignoutRequest(e).then((function(e){return i.Log.debug("UserManager._signoutStart: got signout request"),o.url=e.url,e.state&&(o.id=e.state.id),t.navigate(o)}))}))}))})).catch((function(e){throw t.close&&(i.Log.debug("UserManager._signoutStart: Error after preparing navigator, closing navigator window"),t.close()),e}))}))},e.prototype._signoutEnd=function t(e){return this.processSignoutResponse(e).then((function(t){return i.Log.debug("UserManager._signoutEnd: got signout response"),t}))},e.prototype.revokeAccessToken=function t(){var e=this;return this._loadUser().then((function(t){return e._revokeInternal(t,!0).then((function(r){if(r)return i.Log.debug("UserManager.revokeAccessToken: removing token properties from user and re-storing"),t.access_token=null,t.refresh_token=null,t.expires_at=null,t.token_type=null,e.storeUser(t).then((function(){i.Log.debug("UserManager.revokeAccessToken: user stored"),e._events.load(t);}))}))})).then((function(){i.Log.info("UserManager.revokeAccessToken: access token revoked successfully");}))},e.prototype._revokeInternal=function t(e,r){var n=this;if(e){var o=e.access_token,s=e.refresh_token;return this._revokeAccessTokenInternal(o,r).then((function(t){return n._revokeRefreshTokenInternal(s,r).then((function(e){return t||e||i.Log.debug("UserManager.revokeAccessToken: no need to revoke due to no token(s), or JWT format"),t||e}))}))}return Promise.resolve(!1)},e.prototype._revokeAccessTokenInternal=function t(e,r){return !e||e.indexOf(".")>=0?Promise.resolve(!1):this._tokenRevocationClient.revoke(e,r).then((function(){return !0}))},e.prototype._revokeRefreshTokenInternal=function t(e,r){return e?this._tokenRevocationClient.revoke(e,r,"refresh_token").then((function(){return !0})):Promise.resolve(!1)},e.prototype.startSilentRenew=function t(){this._silentRenewService.start();},e.prototype.stopSilentRenew=function t(){this._silentRenewService.stop();},e.prototype._loadUser=function t(){return this._userStore.get(this._userStoreKey).then((function(t){return t?(i.Log.debug("UserManager._loadUser: user storageString loaded"),a.User.fromStorageString(t)):(i.Log.debug("UserManager._loadUser: no user storageString"),null)}))},e.prototype.storeUser=function t(e){if(e){i.Log.debug("UserManager.storeUser: storing user");var r=e.toStorageString();return this._userStore.set(this._userStoreKey,r)}return i.Log.debug("storeUser.storeUser: removing user"),this._userStore.remove(this._userStoreKey)},n(e,[{key:"_redirectNavigator",get:function t(){return this.settings.redirectNavigator}},{key:"_popupNavigator",get:function t(){return this.settings.popupNavigator}},{key:"_iframeNavigator",get:function t(){return this.settings.iframeNavigator}},{key:"_userStore",get:function t(){return this.settings.userStore}},{key:"events",get:function t(){return this._events}},{key:"_userStoreKey",get:function t(){return "user:"+this.settings.authority+":"+this.settings.client_id}}]),e}(o.OidcClient);},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.UserManagerSettings=void 0;var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),i=(r(0),r(5)),o=r(40),s=r(41),a=r(43),u=r(6),c=r(1),h=r(8);function l(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function f(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !e||"object"!=typeof e&&"function"!=typeof e?t:e}e.UserManagerSettings=function(t){function e(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=r.popup_redirect_uri,i=r.popup_post_logout_redirect_uri,g=r.popupWindowFeatures,d=r.popupWindowTarget,p=r.silent_redirect_uri,v=r.silentRequestTimeout,y=r.automaticSilentRenew,m=void 0!==y&&y,_=r.validateSubOnSilentRenew,S=void 0!==_&&_,b=r.includeIdTokenInSilentRenew,w=void 0===b||b,F=r.monitorSession,E=void 0===F||F,x=r.monitorAnonymousSession,A=void 0!==x&&x,k=r.checkSessionInterval,P=void 0===k?2e3:k,C=r.stopCheckSessionOnError,T=void 0===C||C,R=r.query_status_response_type,I=r.revokeAccessTokenOnSignout,D=void 0!==I&&I,L=r.accessTokenExpiringNotificationTime,N=void 0===L?60:L,U=r.redirectNavigator,B=void 0===U?new o.RedirectNavigator:U,O=r.popupNavigator,j=void 0===O?new s.PopupNavigator:O,M=r.iframeNavigator,H=void 0===M?new a.IFrameNavigator:M,V=r.userStore,K=void 0===V?new u.WebStorageStateStore({store:c.Global.sessionStorage}):V;l(this,e);var q=f(this,t.call(this,arguments[0]));return q._popup_redirect_uri=n,q._popup_post_logout_redirect_uri=i,q._popupWindowFeatures=g,q._popupWindowTarget=d,q._silent_redirect_uri=p,q._silentRequestTimeout=v,q._automaticSilentRenew=m,q._validateSubOnSilentRenew=S,q._includeIdTokenInSilentRenew=w,q._accessTokenExpiringNotificationTime=N,q._monitorSession=E,q._monitorAnonymousSession=A,q._checkSessionInterval=P,q._stopCheckSessionOnError=T,R?q._query_status_response_type=R:arguments[0]&&arguments[0].response_type?q._query_status_response_type=h.SigninRequest.isOidc(arguments[0].response_type)?"id_token":"code":q._query_status_response_type="id_token",q._revokeAccessTokenOnSignout=D,q._redirectNavigator=B,q._popupNavigator=j,q._iframeNavigator=H,q._userStore=K,q}return function r(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}(e,t),n(e,[{key:"popup_redirect_uri",get:function t(){return this._popup_redirect_uri}},{key:"popup_post_logout_redirect_uri",get:function t(){return this._popup_post_logout_redirect_uri}},{key:"popupWindowFeatures",get:function t(){return this._popupWindowFeatures}},{key:"popupWindowTarget",get:function t(){return this._popupWindowTarget}},{key:"silent_redirect_uri",get:function t(){return this._silent_redirect_uri}},{key:"silentRequestTimeout",get:function t(){return this._silentRequestTimeout}},{key:"automaticSilentRenew",get:function t(){return this._automaticSilentRenew}},{key:"validateSubOnSilentRenew",get:function t(){return this._validateSubOnSilentRenew}},{key:"includeIdTokenInSilentRenew",get:function t(){return this._includeIdTokenInSilentRenew}},{key:"accessTokenExpiringNotificationTime",get:function t(){return this._accessTokenExpiringNotificationTime}},{key:"monitorSession",get:function t(){return this._monitorSession}},{key:"monitorAnonymousSession",get:function t(){return this._monitorAnonymousSession}},{key:"checkSessionInterval",get:function t(){return this._checkSessionInterval}},{key:"stopCheckSessionOnError",get:function t(){return this._stopCheckSessionOnError}},{key:"query_status_response_type",get:function t(){return this._query_status_response_type}},{key:"revokeAccessTokenOnSignout",get:function t(){return this._revokeAccessTokenOnSignout}},{key:"redirectNavigator",get:function t(){return this._redirectNavigator}},{key:"popupNavigator",get:function t(){return this._popupNavigator}},{key:"iframeNavigator",get:function t(){return this._iframeNavigator}},{key:"userStore",get:function t(){return this._userStore}}]),e}(i.OidcClientSettings);},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.RedirectNavigator=void 0;var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),i=r(0);e.RedirectNavigator=function(){function t(){!function e(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}(this,t);}return t.prototype.prepare=function t(){return Promise.resolve(this)},t.prototype.navigate=function t(e){return e&&e.url?(e.useReplaceToNavigate?window.location.replace(e.url):window.location=e.url,Promise.resolve()):(i.Log.error("RedirectNavigator.navigate: No url provided"),Promise.reject(new Error("No url provided")))},n(t,[{key:"url",get:function t(){return window.location.href}}]),t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.PopupNavigator=void 0;var n=r(0),i=r(42);e.PopupNavigator=function(){function t(){!function e(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}(this,t);}return t.prototype.prepare=function t(e){var r=new i.PopupWindow(e);return Promise.resolve(r)},t.prototype.callback=function t(e,r,o){n.Log.debug("PopupNavigator.callback");try{return i.PopupWindow.notifyOpener(e,r,o),Promise.resolve()}catch(t){return Promise.reject(t)}},t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.PopupWindow=void 0;var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),i=r(0),o=r(3);e.PopupWindow=function(){function t(e){var r=this;!function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this._promise=new Promise((function(t,e){r._resolve=t,r._reject=e;}));var o=e.popupWindowTarget||"_blank",s=e.popupWindowFeatures||"location=no,toolbar=no,width=500,height=500,left=100,top=100;";this._popup=window.open("",o,s),this._popup&&(i.Log.debug("PopupWindow.ctor: popup successfully created"),this._checkForPopupClosedTimer=window.setInterval(this._checkForPopupClosed.bind(this),500));}return t.prototype.navigate=function t(e){return this._popup?e&&e.url?(i.Log.debug("PopupWindow.navigate: Setting URL in popup"),this._id=e.id,this._id&&(window["popupCallback_"+e.id]=this._callback.bind(this)),this._popup.focus(),this._popup.window.location=e.url):(this._error("PopupWindow.navigate: no url provided"),this._error("No url provided")):this._error("PopupWindow.navigate: Error opening popup window"),this.promise},t.prototype._success=function t(e){i.Log.debug("PopupWindow.callback: Successful response from popup window"),this._cleanup(),this._resolve(e);},t.prototype._error=function t(e){i.Log.error("PopupWindow.error: ",e),this._cleanup(),this._reject(new Error(e));},t.prototype.close=function t(){this._cleanup(!1);},t.prototype._cleanup=function t(e){i.Log.debug("PopupWindow.cleanup"),window.clearInterval(this._checkForPopupClosedTimer),this._checkForPopupClosedTimer=null,delete window["popupCallback_"+this._id],this._popup&&!e&&this._popup.close(),this._popup=null;},t.prototype._checkForPopupClosed=function t(){this._popup&&!this._popup.closed||this._error("Popup window closed");},t.prototype._callback=function t(e,r){this._cleanup(r),e?(i.Log.debug("PopupWindow.callback success"),this._success({url:e})):(i.Log.debug("PopupWindow.callback: Invalid response from popup"),this._error("Invalid response from popup"));},t.notifyOpener=function t(e,r,n){if(window.opener){if(e=e||window.location.href){var s=o.UrlUtility.parseUrlFragment(e,n);if(s.state){var a="popupCallback_"+s.state,u=window.opener[a];u?(i.Log.debug("PopupWindow.notifyOpener: passing url message to opener"),u(e,r)):i.Log.warn("PopupWindow.notifyOpener: no matching callback found on opener");}else i.Log.warn("PopupWindow.notifyOpener: no state found in response url");}}else i.Log.warn("PopupWindow.notifyOpener: no window.opener. Can't complete notification.");},n(t,[{key:"promise",get:function t(){return this._promise}}]),t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.IFrameNavigator=void 0;var n=r(0),i=r(44);e.IFrameNavigator=function(){function t(){!function e(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}(this,t);}return t.prototype.prepare=function t(e){var r=new i.IFrameWindow(e);return Promise.resolve(r)},t.prototype.callback=function t(e){n.Log.debug("IFrameNavigator.callback");try{return i.IFrameWindow.notifyParent(e),Promise.resolve()}catch(t){return Promise.reject(t)}},t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.IFrameWindow=void 0;var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),i=r(0);e.IFrameWindow=function(){function t(e){var r=this;!function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this._promise=new Promise((function(t,e){r._resolve=t,r._reject=e;})),this._boundMessageEvent=this._message.bind(this),window.addEventListener("message",this._boundMessageEvent,!1),this._frame=window.document.createElement("iframe"),this._frame.style.visibility="hidden",this._frame.style.position="absolute",this._frame.width=0,this._frame.height=0,window.document.body.appendChild(this._frame);}return t.prototype.navigate=function t(e){if(e&&e.url){var r=e.silentRequestTimeout||1e4;i.Log.debug("IFrameWindow.navigate: Using timeout of:",r),this._timer=window.setTimeout(this._timeout.bind(this),r),this._frame.src=e.url;}else this._error("No url provided");return this.promise},t.prototype._success=function t(e){this._cleanup(),i.Log.debug("IFrameWindow: Successful response from frame window"),this._resolve(e);},t.prototype._error=function t(e){this._cleanup(),i.Log.error(e),this._reject(new Error(e));},t.prototype.close=function t(){this._cleanup();},t.prototype._cleanup=function t(){this._frame&&(i.Log.debug("IFrameWindow: cleanup"),window.removeEventListener("message",this._boundMessageEvent,!1),window.clearTimeout(this._timer),window.document.body.removeChild(this._frame),this._timer=null,this._frame=null,this._boundMessageEvent=null);},t.prototype._timeout=function t(){i.Log.debug("IFrameWindow.timeout"),this._error("Frame window timed out");},t.prototype._message=function t(e){if(i.Log.debug("IFrameWindow.message"),this._timer&&e.origin===this._origin&&e.source===this._frame.contentWindow&&"string"==typeof e.data&&(e.data.startsWith("http://")||e.data.startsWith("https://"))){var r=e.data;r?this._success({url:r}):this._error("Invalid response from frame");}},t.notifyParent=function t(e){i.Log.debug("IFrameWindow.notifyParent"),(e=e||window.location.href)&&(i.Log.debug("IFrameWindow.notifyParent: posting url message to parent"),window.parent.postMessage(e,location.protocol+"//"+location.host));},n(t,[{key:"promise",get:function t(){return this._promise}},{key:"_origin",get:function t(){return location.protocol+"//"+location.host}}]),t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.UserManagerEvents=void 0;var n=r(0),i=r(16),o=r(17);e.UserManagerEvents=function(t){function e(r){!function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e);var i=function s(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !e||"object"!=typeof e&&"function"!=typeof e?t:e}(this,t.call(this,r));return i._userLoaded=new o.Event("User loaded"),i._userUnloaded=new o.Event("User unloaded"),i._silentRenewError=new o.Event("Silent renew error"),i._userSignedIn=new o.Event("User signed in"),i._userSignedOut=new o.Event("User signed out"),i._userSessionChanged=new o.Event("User session changed"),i}return function r(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}(e,t),e.prototype.load=function e(r){var i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];n.Log.debug("UserManagerEvents.load"),t.prototype.load.call(this,r),i&&this._userLoaded.raise(r);},e.prototype.unload=function e(){n.Log.debug("UserManagerEvents.unload"),t.prototype.unload.call(this),this._userUnloaded.raise();},e.prototype.addUserLoaded=function t(e){this._userLoaded.addHandler(e);},e.prototype.removeUserLoaded=function t(e){this._userLoaded.removeHandler(e);},e.prototype.addUserUnloaded=function t(e){this._userUnloaded.addHandler(e);},e.prototype.removeUserUnloaded=function t(e){this._userUnloaded.removeHandler(e);},e.prototype.addSilentRenewError=function t(e){this._silentRenewError.addHandler(e);},e.prototype.removeSilentRenewError=function t(e){this._silentRenewError.removeHandler(e);},e.prototype._raiseSilentRenewError=function t(e){n.Log.debug("UserManagerEvents._raiseSilentRenewError",e.message),this._silentRenewError.raise(e);},e.prototype.addUserSignedIn=function t(e){this._userSignedIn.addHandler(e);},e.prototype.removeUserSignedIn=function t(e){this._userSignedIn.removeHandler(e);},e.prototype._raiseUserSignedIn=function t(){n.Log.debug("UserManagerEvents._raiseUserSignedIn"),this._userSignedIn.raise();},e.prototype.addUserSignedOut=function t(e){this._userSignedOut.addHandler(e);},e.prototype.removeUserSignedOut=function t(e){this._userSignedOut.removeHandler(e);},e.prototype._raiseUserSignedOut=function t(){n.Log.debug("UserManagerEvents._raiseUserSignedOut"),this._userSignedOut.raise();},e.prototype.addUserSessionChanged=function t(e){this._userSessionChanged.addHandler(e);},e.prototype.removeUserSessionChanged=function t(e){this._userSessionChanged.removeHandler(e);},e.prototype._raiseUserSessionChanged=function t(){n.Log.debug("UserManagerEvents._raiseUserSessionChanged"),this._userSessionChanged.raise();},e}(i.AccessTokenEvents);},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.Timer=void 0;var n=function(){function t(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}return function(e,r,n){return r&&t(e.prototype,r),n&&t(e,n),e}}(),i=r(0),o=r(1),s=r(17);function a(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function u(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return !e||"object"!=typeof e&&"function"!=typeof e?t:e}e.Timer=function(t){function e(r){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.Global.timer,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;a(this,e);var s=u(this,t.call(this,r));return s._timer=n,s._nowFunc=i||function(){return Date.now()/1e3},s}return function r(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e);}(e,t),e.prototype.init=function t(e){e<=0&&(e=1),e=parseInt(e);var r=this.now+e;if(this.expiration===r&&this._timerHandle)i.Log.debug("Timer.init timer "+this._name+" skipping initialization since already initialized for expiration:",this.expiration);else {this.cancel(),i.Log.debug("Timer.init timer "+this._name+" for duration:",e),this._expiration=r;var n=5;e<n&&(n=e),this._timerHandle=this._timer.setInterval(this._callback.bind(this),1e3*n);}},e.prototype.cancel=function t(){this._timerHandle&&(i.Log.debug("Timer.cancel: ",this._name),this._timer.clearInterval(this._timerHandle),this._timerHandle=null);},e.prototype._callback=function e(){var r=this._expiration-this.now;i.Log.debug("Timer.callback; "+this._name+" timer expires in:",r),this._expiration<=this.now&&(this.cancel(),t.prototype.raise.call(this));},n(e,[{key:"now",get:function t(){return parseInt(this._nowFunc())}},{key:"expiration",get:function t(){return this._expiration}}]),e}(s.Event);},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.SilentRenewService=void 0;var n=r(0);e.SilentRenewService=function(){function t(e){!function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this._userManager=e;}return t.prototype.start=function t(){this._callback||(this._callback=this._tokenExpiring.bind(this),this._userManager.events.addAccessTokenExpiring(this._callback),this._userManager.getUser().then((function(t){})).catch((function(t){n.Log.error("SilentRenewService.start: Error from getUser:",t.message);})));},t.prototype.stop=function t(){this._callback&&(this._userManager.events.removeAccessTokenExpiring(this._callback),delete this._callback);},t.prototype._tokenExpiring=function t(){var e=this;this._userManager.signinSilent().then((function(t){n.Log.debug("SilentRenewService._tokenExpiring: Silent token renewal successful");}),(function(t){n.Log.error("SilentRenewService._tokenExpiring: Error from signinSilent:",t.message),e._userManager.events._raiseSilentRenewError(t);}));},t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.CordovaPopupNavigator=void 0;var n=r(21);e.CordovaPopupNavigator=function(){function t(){!function e(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}(this,t);}return t.prototype.prepare=function t(e){var r=new n.CordovaPopupWindow(e);return Promise.resolve(r)},t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0}),e.CordovaIFrameNavigator=void 0;var n=r(21);e.CordovaIFrameNavigator=function(){function t(){!function e(t,r){if(!(t instanceof r))throw new TypeError("Cannot call a class as a function")}(this,t);}return t.prototype.prepare=function t(e){e.popupWindowFeatures="hidden=yes";var r=new n.CordovaPopupWindow(e);return Promise.resolve(r)},t}();},function(t,e,r){Object.defineProperty(e,"__esModule",{value:!0});e.Version="1.11.5";}])}));
} (oidcClient_min));

const useDiscovery = getSharedStateHook(null);
const getDiscovery = useDiscovery.getState;
const updateDiscovery = useDiscovery.updateState;

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

var COMPARISON_OPERATORS = ['eq', 'ne', 'gt', 'ge', 'lt', 'le'];
var LOGICAL_OPERATORS = ['and', 'or', 'not'];
var COLLECTION_OPERATORS = ['any', 'all'];
var BOOLEAN_FUNCTIONS = ['startswith', 'endswith', 'contains'];
var SUPPORTED_EXPAND_PROPERTIES = [
    'expand',
    'levels',
    'select',
    'skip',
    'top',
    'count',
    'orderby',
    'filter',
];
var FUNCTION_REGEX = /\((.*)\)/;
var INDEXOF_REGEX = /(?!indexof)\((\w+)\)/;
var StandardAggregateMethods;
(function (StandardAggregateMethods) {
    StandardAggregateMethods["sum"] = "sum";
    StandardAggregateMethods["min"] = "min";
    StandardAggregateMethods["max"] = "max";
    StandardAggregateMethods["average"] = "average";
    StandardAggregateMethods["countdistinct"] = "countdistinct";
})(StandardAggregateMethods || (StandardAggregateMethods = {}));
var ITEM_ROOT = "";
function buildQuery (_a) {
    var _b = _a === void 0 ? {} : _a, $select = _b.select, $search = _b.search, $skiptoken = _b.skiptoken, $format = _b.format, top = _b.top, skip = _b.skip, filter = _b.filter, transform = _b.transform, orderBy = _b.orderBy, key = _b.key, count = _b.count, expand = _b.expand, action = _b.action, func = _b.func;
    var path = '';
    var aliases = [];
    var params = {};
    // key is not (null, undefined)
    if (key != undefined) {
        path += "(".concat(handleValue(key, aliases), ")");
    }
    if (filter || typeof count === 'object')
        params.$filter = buildFilter(typeof count === 'object' ? count : filter, aliases);
    if (transform)
        params.$apply = buildTransforms(transform);
    if (expand)
        params.$expand = buildExpand(expand);
    if (orderBy)
        params.$orderby = buildOrderBy(orderBy);
    if (count) {
        if (typeof count === 'boolean') {
            params.$count = true;
        }
        else {
            path += '/$count';
        }
    }
    if (typeof top === 'number') {
        params.$top = top;
    }
    if (typeof skip === 'number') {
        params.$skip = skip;
    }
    if (action) {
        path += "/".concat(action);
    }
    if (func) {
        if (typeof func === 'string') {
            path += "/".concat(func);
        }
        else if (typeof func === 'object') {
            var funcName = Object.keys(func)[0];
            var funcArgs = handleValue(func[funcName], aliases);
            path += "/".concat(funcName);
            if (funcArgs !== "") {
                path += "(".concat(funcArgs, ")");
            }
        }
    }
    if (aliases.length > 0) {
        Object.assign(params, aliases.reduce(function (acc, alias) {
            var _a;
            return Object.assign(acc, (_a = {}, _a["@".concat(alias.name)] = handleValue(alias.value), _a));
        }, {}));
    }
    return buildUrl(path, __assign({ $select: $select, $search: $search, $skiptoken: $skiptoken, $format: $format }, params));
}
function renderPrimitiveValue(key, val, aliases) {
    if (aliases === void 0) { aliases = []; }
    return "".concat(key, " eq ").concat(handleValue(val, aliases));
}
function buildFilter(filters, aliases, propPrefix) {
    if (filters === void 0) { filters = {}; }
    if (aliases === void 0) { aliases = []; }
    if (propPrefix === void 0) { propPrefix = ''; }
    return (Array.isArray(filters) ? filters : [filters])
        .reduce(function (acc, filter) {
        if (filter) {
            var builtFilter = buildFilterCore(filter, aliases, propPrefix);
            if (builtFilter) {
                acc.push(builtFilter);
            }
        }
        return acc;
    }, []).join(' and ');
    function buildFilterCore(filter, aliases, propPrefix) {
        if (filter === void 0) { filter = {}; }
        if (aliases === void 0) { aliases = []; }
        if (propPrefix === void 0) { propPrefix = ''; }
        var filterExpr = "";
        if (typeof filter === 'string') {
            // Use raw filter string
            filterExpr = filter;
        }
        else if (filter && typeof filter === 'object') {
            var filtersArray = Object.keys(filter).reduce(function (result, filterKey) {
                var value = filter[filterKey];
                if (value === undefined) {
                    return result;
                }
                var propName = '';
                if (propPrefix) {
                    if (filterKey === ITEM_ROOT) {
                        propName = propPrefix;
                    }
                    else if (INDEXOF_REGEX.test(filterKey)) {
                        propName = filterKey.replace(INDEXOF_REGEX, function (_, $1) { return $1.trim() === ITEM_ROOT ? "(".concat(propPrefix, ")") : "(".concat(propPrefix, "/").concat($1.trim(), ")"); });
                    }
                    else if (FUNCTION_REGEX.test(filterKey)) {
                        propName = filterKey.replace(FUNCTION_REGEX, function (_, $1) { return $1.trim() === ITEM_ROOT ? "(".concat(propPrefix, ")") : "(".concat(propPrefix, "/").concat($1.trim(), ")"); });
                    }
                    else {
                        propName = "".concat(propPrefix, "/").concat(filterKey);
                    }
                }
                else {
                    propName = filterKey;
                }
                if (filterKey === ITEM_ROOT && Array.isArray(value)) {
                    return result.concat(value.map(function (arrayValue) { return renderPrimitiveValue(propName, arrayValue); }));
                }
                if (['number', 'string', 'boolean'].indexOf(typeof value) !== -1 ||
                    value instanceof Date ||
                    value === null) {
                    // Simple key/value handled as equals operator
                    result.push(renderPrimitiveValue(propName, value, aliases));
                }
                else if (Array.isArray(value)) {
                    var op_1 = filterKey;
                    var builtFilters = value
                        .map(function (v) { return buildFilter(v, aliases, propPrefix); })
                        .filter(function (f) { return f; })
                        .map(function (f) { return (LOGICAL_OPERATORS.indexOf(op_1) !== -1 ? "(".concat(f, ")") : f); });
                    if (builtFilters.length) {
                        if (LOGICAL_OPERATORS.indexOf(op_1) !== -1) {
                            if (builtFilters.length) {
                                if (op_1 === 'not') {
                                    result.push(parseNot(builtFilters));
                                }
                                else {
                                    result.push("(".concat(builtFilters.join(" ".concat(op_1, " ")), ")"));
                                }
                            }
                        }
                        else {
                            result.push(builtFilters.join(" ".concat(op_1, " ")));
                        }
                    }
                }
                else if (LOGICAL_OPERATORS.indexOf(propName) !== -1) {
                    var op = propName;
                    var builtFilters = Object.keys(value).map(function (valueKey) {
                        var _a;
                        return buildFilterCore((_a = {}, _a[valueKey] = value[valueKey], _a));
                    });
                    if (builtFilters.length) {
                        if (op === 'not') {
                            result.push(parseNot(builtFilters));
                        }
                        else {
                            result.push("(".concat(builtFilters.join(" ".concat(op, " ")), ")"));
                        }
                    }
                }
                else if (typeof value === 'object') {
                    if ('type' in value) {
                        result.push(renderPrimitiveValue(propName, value, aliases));
                    }
                    else {
                        var operators = Object.keys(value);
                        operators.forEach(function (op) {
                            if (value[op] === undefined) {
                                return;
                            }
                            if (COMPARISON_OPERATORS.indexOf(op) !== -1) {
                                result.push("".concat(propName, " ").concat(op, " ").concat(handleValue(value[op], aliases)));
                            }
                            else if (LOGICAL_OPERATORS.indexOf(op) !== -1) {
                                if (Array.isArray(value[op])) {
                                    result.push(value[op]
                                        .map(function (v) { return '(' + buildFilterCore(v, aliases, propName) + ')'; })
                                        .join(" ".concat(op, " ")));
                                }
                                else {
                                    result.push('(' + buildFilterCore(value[op], aliases, propName) + ')');
                                }
                            }
                            else if (COLLECTION_OPERATORS.indexOf(op) !== -1) {
                                var collectionClause = buildCollectionClause(filterKey.toLowerCase(), value[op], op, propName);
                                if (collectionClause) {
                                    result.push(collectionClause);
                                }
                            }
                            else if (op === 'has') {
                                result.push("".concat(propName, " ").concat(op, " ").concat(handleValue(value[op], aliases)));
                            }
                            else if (op === 'in') {
                                var resultingValues = Array.isArray(value[op])
                                    ? value[op]
                                    : value[op].value.map(function (typedValue) { return ({
                                        type: value[op].type,
                                        value: typedValue,
                                    }); });
                                result.push(propName + ' in (' + resultingValues.map(function (v) { return handleValue(v, aliases); }).join(',') + ')');
                            }
                            else if (BOOLEAN_FUNCTIONS.indexOf(op) !== -1) {
                                // Simple boolean functions (startswith, endswith, contains)
                                result.push("".concat(op, "(").concat(propName, ",").concat(handleValue(value[op], aliases), ")"));
                            }
                            else {
                                // Nested property
                                var filter_1 = buildFilterCore(value, aliases, propName);
                                if (filter_1) {
                                    result.push(filter_1);
                                }
                            }
                        });
                    }
                }
                else {
                    throw new Error("Unexpected value type: ".concat(value));
                }
                return result;
            }, []);
            filterExpr = filtersArray.join(' and ');
        } /* else {
            throw new Error(`Unexpected filters type: ${filter}`);
          } */
        return filterExpr;
    }
    function buildCollectionClause(lambdaParameter, value, op, propName) {
        var clause = '';
        if (typeof value === 'string' || value instanceof String) {
            clause = getStringCollectionClause(lambdaParameter, value, op, propName);
        }
        else if (value) {
            // normalize {any:[{prop1: 1}, {prop2: 1}]} --> {any:{prop1: 1, prop2: 1}}; same for 'all',
            // simple values collection: {any:[{'': 'simpleVal1'}, {'': 'simpleVal2'}]} --> {any:{'': ['simpleVal1', 'simpleVal2']}}; same for 'all',
            var filterValue = Array.isArray(value) ?
                value.reduce(function (acc, item) {
                    if (item.hasOwnProperty(ITEM_ROOT)) {
                        if (!acc.hasOwnProperty(ITEM_ROOT)) {
                            acc[ITEM_ROOT] = [];
                        }
                        acc[ITEM_ROOT].push(item[ITEM_ROOT]);
                        return acc;
                    }
                    return __assign(__assign({}, acc), item);
                }, {}) : value;
            var filter = buildFilterCore(filterValue, aliases, lambdaParameter);
            clause = "".concat(propName, "/").concat(op, "(").concat(filter ? "".concat(lambdaParameter, ":").concat(filter) : '', ")");
        }
        return clause;
    }
}
function getStringCollectionClause(lambdaParameter, value, collectionOperator, propName) {
    var clause = '';
    var conditionOperator = collectionOperator == 'all' ? 'ne' : 'eq';
    clause = "".concat(propName, "/").concat(collectionOperator, "(").concat(lambdaParameter, ": ").concat(lambdaParameter, " ").concat(conditionOperator, " '").concat(value, "')");
    return clause;
}
function escapeIllegalChars(string) {
    string = string.replace(/%/g, '%25');
    string = string.replace(/\+/g, '%2B');
    string = string.replace(/\//g, '%2F');
    string = string.replace(/\?/g, '%3F');
    string = string.replace(/#/g, '%23');
    string = string.replace(/&/g, '%26');
    string = string.replace(/'/g, "''");
    return string;
}
function handleValue(value, aliases) {
    if (typeof value === 'string') {
        return "'".concat(escapeIllegalChars(value), "'");
    }
    else if (value instanceof Date) {
        return value.toISOString();
    }
    else if (typeof value === 'number') {
        return value;
    }
    else if (Array.isArray(value)) {
        return "[".concat(value.map(function (d) { return handleValue(d); }).join(','), "]");
    }
    else if (value === null) {
        return value;
    }
    else if (typeof value === 'object') {
        switch (value.type) {
            case 'raw':
            case 'guid':
                return value.value;
            case 'duration':
                return "duration'".concat(value.value, "'");
            case 'binary':
                return "binary'".concat(value.value, "'");
            case 'alias':
                // Store
                if (Array.isArray(aliases))
                    aliases.push(value);
                return "@".concat(value.name);
            case 'json':
                return escape(JSON.stringify(value.value));
            case 'decimal':
                return "".concat(value.value, "M");
            default:
                return Object.entries(value)
                    .filter(function (_a) {
                    var v = _a[1];
                    return v !== undefined;
                })
                    .map(function (_a) {
                    var k = _a[0], v = _a[1];
                    return "".concat(k, "=").concat(handleValue(v, aliases));
                }).join(',');
        }
    }
    return value;
}
function buildExpand(expands) {
    if (typeof expands === 'number') {
        return expands;
    }
    else if (typeof expands === 'string') {
        if (expands.indexOf('/') === -1) {
            return expands;
        }
        // Change `Foo/Bar/Baz` to `Foo($expand=Bar($expand=Baz))`
        return expands
            .split('/')
            .reverse()
            .reduce(function (results, item, index, arr) {
            if (index === 0) {
                // Inner-most item
                return "$expand=".concat(item);
            }
            else if (index === arr.length - 1) {
                // Outer-most item, don't add `$expand=` prefix (added above)
                return "".concat(item, "(").concat(results, ")");
            }
            else {
                // Other items
                return "$expand=".concat(item, "(").concat(results, ")");
            }
        }, '');
    }
    else if (Array.isArray(expands)) {
        return "".concat(expands.map(function (e) { return buildExpand(e); }).join(','));
    }
    else if (typeof expands === 'object') {
        var expandKeys = Object.keys(expands);
        if (expandKeys.some(function (key) { return SUPPORTED_EXPAND_PROPERTIES.indexOf(key.toLowerCase()) !== -1; })) {
            return expandKeys
                .map(function (key) {
                var value;
                switch (key) {
                    case 'filter':
                        value = buildFilter(expands[key]);
                        break;
                    case 'orderBy':
                        value = buildOrderBy(expands[key]);
                        break;
                    case 'levels':
                    case 'count':
                    case 'skip':
                    case 'top':
                        value = "".concat(expands[key]);
                        break;
                    default:
                        value = buildExpand(expands[key]);
                }
                return "$".concat(key.toLowerCase(), "=").concat(value);
            })
                .join(';');
        }
        else {
            return expandKeys
                .map(function (key) {
                var builtExpand = buildExpand(expands[key]);
                return builtExpand ? "".concat(key, "(").concat(builtExpand, ")") : key;
            })
                .join(',');
        }
    }
    return "";
}
function buildTransforms(transforms) {
    // Wrap single object an array for simplified processing
    var transformsArray = Array.isArray(transforms) ? transforms : [transforms];
    var transformsResult = transformsArray.reduce(function (result, transform) {
        var aggregate = transform.aggregate, filter = transform.filter, groupBy = transform.groupBy, rest = __rest(transform, ["aggregate", "filter", "groupBy"]);
        // TODO: support as many of the following:
        //   topcount, topsum, toppercent,
        //   bottomsum, bottomcount, bottompercent,
        //   identity, concat, expand, search, compute, isdefined
        var unsupportedKeys = Object.keys(rest);
        if (unsupportedKeys.length) {
            throw new Error("Unsupported transform(s): ".concat(unsupportedKeys));
        }
        if (aggregate) {
            result.push("aggregate(".concat(buildAggregate(aggregate), ")"));
        }
        if (filter) {
            var builtFilter = buildFilter(filter);
            if (builtFilter) {
                result.push("filter(".concat(buildFilter(builtFilter), ")"));
            }
        }
        if (groupBy) {
            result.push("groupby(".concat(buildGroupBy(groupBy), ")"));
        }
        return result;
    }, []);
    return transformsResult.join('/') || undefined;
}
function buildAggregate(aggregate) {
    // Wrap single object in an array for simplified processing
    var aggregateArray = Array.isArray(aggregate) ? aggregate : [aggregate];
    return aggregateArray
        .map(function (aggregateItem) {
        return typeof aggregateItem === "string"
            ? aggregateItem
            : Object.keys(aggregateItem).map(function (aggregateKey) {
                var aggregateValue = aggregateItem[aggregateKey];
                // TODO: Are these always required?  Can/should we default them if so?
                if (!aggregateValue.with) {
                    throw new Error("'with' property required for '".concat(aggregateKey, "'"));
                }
                if (!aggregateValue.as) {
                    throw new Error("'as' property required for '".concat(aggregateKey, "'"));
                }
                return "".concat(aggregateKey, " with ").concat(aggregateValue.with, " as ").concat(aggregateValue.as);
            });
    })
        .join(',');
}
function buildGroupBy(groupBy) {
    if (!groupBy.properties) {
        throw new Error("'properties' property required for groupBy");
    }
    var result = "(".concat(groupBy.properties.join(','), ")");
    if (groupBy.transform) {
        result += ",".concat(buildTransforms(groupBy.transform));
    }
    return result;
}
function buildOrderBy(orderBy, prefix) {
    if (prefix === void 0) { prefix = ''; }
    if (Array.isArray(orderBy)) {
        return orderBy
            .map(function (value) {
            return (Array.isArray(value) && value.length === 2 && ['asc', 'desc'].indexOf(value[1]) !== -1) ? value.join(' ') : value;
        })
            .map(function (v) { return "".concat(prefix).concat(String(v)); }).join(',');
    }
    else if (typeof orderBy === 'object') {
        return Object.entries(orderBy)
            .map(function (_a) {
            var k = _a[0], v = _a[1];
            return buildOrderBy(v, "".concat(k, "/"));
        })
            .map(function (v) { return "".concat(prefix).concat(v); }).join(',');
    }
    return "".concat(prefix).concat(String(orderBy));
}
function buildUrl(path, params) {
    // This can be refactored using URL API. But IE does not support it.
    var queries = Object.getOwnPropertyNames(params)
        .filter(function (key) { return params[key] !== undefined && params[key] !== ''; })
        .map(function (key) { return "".concat(key, "=").concat(params[key]); });
    return queries.length ? "".concat(path, "?").concat(queries.join('&')) : path;
}
function parseNot(builtFilters) {
    return "not(".concat(builtFilters.join(' and '), ")");
}

function wrapPromise(promise, onUpdate) {
  let status = "pending";
  let result;
  const suspender = promise.then(
    (r) => {
      onUpdate?.(r);
      status = "success";
      result = r;
    },
    (e) => {
      status = "error";
      result = e;
    }
  );
  return {
    getValue: () => {
      if (status === "pending") {
        throw suspender;
      } else if (status === "error") {
        throw result;
      } else if (status === "success") {
        return result;
      }
    }
  };
}
const activePromise = { src: wrapPromise(Promise.resolve([])), wasInitiated: false };
const getWallets = () => request.get(
  `/wallets${buildQuery({ filter: [{ Signable: { eq: true } }] })}`,
  { headers: { "ngrok-skip-browser-warning": "1" } }
).then((res) => (res.value || []).map((w) => ({
  ...w,
  address: w.EthereumAddress || w.ethereumAddress,
  description: w.Description || w.description,
  id: w.Id || w.id,
  name: w.Name || w.name,
  signable: w.Signable || w.signable
})));
const useWalletsInternal = getSharedStateHook([]);
const updateWallets = () => {
  const promise = getWallets();
  activePromise.src = wrapPromise(promise, useWalletsInternal.updateState);
  return promise;
};
Object.assign(() => {
  const updateWalletsLocal = () => {
    activePromise.src = wrapPromise(getWallets(), useWalletsInternal.updateState);
  };
  return [activePromise.src.getValue(), updateWalletsLocal];
}, { getValue: () => activePromise.src.getValue() });
const useWallets = () => {
  const [wallets] = useWalletsInternal();
  return [wallets, updateWallets];
};

const useCustomers = getSharedStateHook({});
useCustomers.updateState;

const { protocol, hostname, port = "" } = window.location;
const baseRedirectUri = `${protocol}//${hostname}${port ? `:${port}` : ""}`;
const identityServerRedirectPath = "/signin-oidc";
const loginRedirectUri = `${baseRedirectUri}${identityServerRedirectPath}`;
const postLogoutRedirectUri = `${baseRedirectUri}`;

const oidcSrc = {
  instance: null
};
const OidcService = new Proxy(oidcSrc, {
  get: (t, p, s) => {
    const discovery = getDiscovery();
    if (!discovery) {
      throw new Error("Discovery not found");
    }
    if (!oidcSrc.instance) {
      oidcSrc.instance = new oidcClient_min.exports.UserManager({
        authority: discovery.Endpoints.AuthApi,
        client_id: discovery.AuthConfig.ClientId,
        redirect_uri: loginRedirectUri,
        post_logout_redirect_uri: postLogoutRedirectUri,
        response_type: discovery.AuthConfig.ResponseType,
        scope: discovery.AuthConfig.Scopes,
        userStore: new oidcClient_min.exports.WebStorageStateStore({ store: localStorage })
      });
    }
    const oidc = oidcSrc.instance;
    if (typeof p === "string" && p in oidc) {
      return Reflect.get(oidc, p);
    }
    return Reflect.get(t, p, s);
  }
});

const NavigationPaths = {
  Root: "/",
  Customers: "/customers",
  Addresses: "/addresses",
  Assets: "/assets"
};

const cn = (...args) => args.filter(Boolean).join(" ");
const convertArrayToObject = (arr, key = "id") => arr.reduce((accum, item) => ({
  ...accum,
  [item[key]]: item
}), {});

const messages$4 = defineMessages({
  wallet: {
    id: "page.common.wallet",
    defaultMessage: "Wallet:"
  },
  selectAddress: {
    id: "page.common.wallet.placeholder",
    defaultMessage: "Select address"
  },
  name: {
    id: "page.common.wallet.name",
    defaultMessage: "Name:"
  },
  address: {
    id: "page.common.wallet.address",
    defaultMessage: "Address:"
  },
  addresses: {
    id: "page.common.links.addresses",
    defaultMessage: "Addresses"
  },
  customers: {
    id: "page.common.links.customers",
    defaultMessage: "Customers"
  },
  assets: {
    id: "page.common.links.assets",
    defaultMessage: "Assets"
  },
  login: {
    id: "page.common.login",
    defaultMessage: "Login"
  },
  logout: {
    id: "page.common.logout",
    defaultMessage: "Logout"
  }
});

const wrapper$2 = "_wrapper_z3l8o_1";
const header = "_header_z3l8o_11";
const body = "_body_z3l8o_27";
const sidebar = "_sidebar_z3l8o_39";
const sidebarWrapper = "_sidebarWrapper_z3l8o_65";
const wallets$1 = "_wallets_z3l8o_81";
const sidebarContent = "_sidebarContent_z3l8o_91";
const sidebarBtn = "_sidebarBtn_z3l8o_99";
const open = "_open_z3l8o_113";
const content = "_content_z3l8o_121";
const logo = "_logo_z3l8o_145";
const link = "_link_z3l8o_173";
const route = "_route_z3l8o_181";
const active$1 = "_active_z3l8o_197";
const version = "_version_z3l8o_209";
const classes$4 = {
	wrapper: wrapper$2,
	header: header,
	body: body,
	sidebar: sidebar,
	sidebarWrapper: sidebarWrapper,
	wallets: wallets$1,
	sidebarContent: sidebarContent,
	sidebarBtn: sidebarBtn,
	open: open,
	content: content,
	logo: logo,
	link: link,
	route: route,
	active: active$1,
	version: version
};

const Page = ({
  children,
  className,
  style
}) => {
  const intl = useIntl();
  const [user, updateUser] = useUser();
  const [wallets] = useWallets();
  const [currentAddress, setCurrentAddress] = useCurrentAddress();
  const onLogout = async () => {
    updateUser(null);
    await OidcService.signoutPopup();
  };
  const login = async () => {
    await OidcService.clearStaleState();
    await OidcService.signinRedirect();
  };
  const options = react.exports.useMemo(() => wallets?.map((v) => {
    const address = v.ethereumAddress;
    return {
      value: address,
      label: v.name
    };
  }) || [], [wallets]);
  const selectValue = react.exports.useMemo(() => options.find((v) => v.value === currentAddress) || null, [currentAddress, options]);
  react.exports.useEffect(() => {
    if (options.length && !selectValue) {
      setCurrentAddress(options[0].value);
    }
  }, [options, selectValue]);
  const location = useLocation();
  return /* @__PURE__ */ jsx$1("div", {
    style,
    className: `${classes$4.wrapper} ${className || ""}`,
    children: /* @__PURE__ */ jsxs("div", {
      className: classes$4.body,
      children: [/* @__PURE__ */ jsx$1("div", {
        className: `${classes$4.sidebar} ${classes$4.open}`,
        children: /* @__PURE__ */ jsxs("div", {
          className: classes$4.sidebarWrapper,
          children: [/* @__PURE__ */ jsxs("div", {
            children: [/* @__PURE__ */ jsx$1("div", {
              className: classes$4.logo,
              children: "NFA"
            }), user ? /* @__PURE__ */ jsxs("div", {
              className: classes$4.wallets,
              children: [/* @__PURE__ */ jsx$1("div", {
                style: {
                  paddingBottom: "4px"
                },
                children: intl.formatMessage(messages$4.wallet)
              }), /* @__PURE__ */ jsx$1(Select, {
                value: selectValue,
                onChange: (val) => {
                  setCurrentAddress(val?.value ?? null);
                },
                styles: {
                  control: (og) => ({
                    ...og,
                    background: "var(--tertiary)",
                    borderColor: "var(--tertiary)"
                  }),
                  placeholder: (og) => ({
                    ...og,
                    color: "var(--primaryText)",
                    fontSize: "1rem"
                  }),
                  option: (og, opt) => ({
                    ...og,
                    color: opt.isSelected ? "var(--primaryText)" : "var(--text)",
                    fontSize: "1rem",
                    wordBreak: "break-word"
                  }),
                  singleValue: (og) => ({
                    ...og,
                    color: "var(--primaryText)",
                    fontSize: "1rem"
                  })
                },
                theme: (theme) => ({
                  ...theme,
                  borderRadius: 0,
                  colors: {
                    ...theme.colors,
                    primary25: "var(--primary10)",
                    primary: "var(--light)"
                  }
                }),
                placeholder: selectValue?.label || intl.formatMessage(messages$4.selectAddress),
                controlShouldRenderValue: false,
                formatOptionLabel: (option) => /* @__PURE__ */ jsxs("div", {
                  children: [/* @__PURE__ */ jsxs("div", {
                    children: [/* @__PURE__ */ jsx$1("div", {
                      style: {
                        fontSize: "0.9em",
                        fontStyle: "italic"
                      },
                      children: intl.formatMessage(messages$4.name)
                    }), /* @__PURE__ */ jsx$1("div", {
                      children: option.label
                    })]
                  }), /* @__PURE__ */ jsxs("div", {
                    children: [/* @__PURE__ */ jsx$1("div", {
                      style: {
                        fontSize: "0.9em",
                        fontWeight: "600"
                      },
                      children: intl.formatMessage(messages$4.address)
                    }), /* @__PURE__ */ jsx$1("div", {
                      children: option.value
                    })]
                  })]
                }),
                options
              })]
            }) : null, user && /* @__PURE__ */ jsxs(Fragment, {
              children: [/* @__PURE__ */ jsx$1(NavLink, {
                className: classes$4.link,
                to: NavigationPaths.Customers,
                children: /* @__PURE__ */ jsx$1("div", {
                  className: cn(classes$4.route, matchPath({
                    path: NavigationPaths.Customers
                  }, location.pathname) && classes$4.active),
                  children: intl.formatMessage(messages$4.customers)
                })
              }), /* @__PURE__ */ jsx$1(NavLink, {
                className: classes$4.link,
                to: NavigationPaths.Addresses,
                children: /* @__PURE__ */ jsx$1("div", {
                  className: cn(classes$4.route, matchPath({
                    path: NavigationPaths.Addresses
                  }, location.pathname) && classes$4.active),
                  children: intl.formatMessage(messages$4.addresses)
                })
              }), /* @__PURE__ */ jsx$1(NavLink, {
                className: classes$4.link,
                to: NavigationPaths.Assets,
                children: /* @__PURE__ */ jsx$1("div", {
                  className: cn(classes$4.route, matchPath({
                    path: NavigationPaths.Assets
                  }, location.pathname) && classes$4.active),
                  children: intl.formatMessage(messages$4.assets)
                })
              })]
            })]
          }), /* @__PURE__ */ jsxs("div", {
            className: `${classes$4.sidebarContent} ${classes$4.sidebarBtn}`,
            children: [user ? /* @__PURE__ */ jsx$1("button", {
              onClick: onLogout,
              children: intl.formatMessage(messages$4.logout)
            }) : /* @__PURE__ */ jsx$1("button", {
              onClick: login,
              children: intl.formatMessage(messages$4.login)
            }), /* @__PURE__ */ jsx$1("div", {
              className: classes$4.version,
              children: appJson.version
            })]
          })]
        })
      }), /* @__PURE__ */ jsx$1("div", {
        className: classes$4.content,
        children
      })]
    })
  });
};

var main = {exports: {}};

(function (module) {
	module.exports =
	/******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	/******/
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	/******/
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	/******/
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	/******/
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	/******/
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	/******/
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	/******/
	/******/
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	/******/
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	/******/
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	/******/
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ (function(module, exports, __webpack_require__) {

		module.exports = __webpack_require__(1);


	/***/ }),
	/* 1 */
	/***/ (function(module, exports, __webpack_require__) {
		
		Object.defineProperty(exports, '__esModule', {
		  value: true
		});
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
		
		var _Highlighter = __webpack_require__(2);
		
		var _Highlighter2 = _interopRequireDefault(_Highlighter);

		exports['default'] = _Highlighter2['default'];
		module.exports = exports['default'];

	/***/ }),
	/* 2 */
	/***/ (function(module, exports, __webpack_require__) {
		
		Object.defineProperty(exports, '__esModule', {
		  value: true
		});
		
		var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
		
		exports['default'] = Highlighter;
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
		
		function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
		
		var _highlightWordsCore = __webpack_require__(3);
		
		var _propTypes = __webpack_require__(4);
		
		var _propTypes2 = _interopRequireDefault(_propTypes);
		
		var _react = __webpack_require__(14);
		
		var _memoizeOne = __webpack_require__(15);
		
		var _memoizeOne2 = _interopRequireDefault(_memoizeOne);
		
		Highlighter.propTypes = {
		  activeClassName: _propTypes2['default'].string,
		  activeIndex: _propTypes2['default'].number,
		  activeStyle: _propTypes2['default'].object,
		  autoEscape: _propTypes2['default'].bool,
		  className: _propTypes2['default'].string,
		  findChunks: _propTypes2['default'].func,
		  highlightClassName: _propTypes2['default'].oneOfType([_propTypes2['default'].object, _propTypes2['default'].string]),
		  highlightStyle: _propTypes2['default'].object,
		  highlightTag: _propTypes2['default'].oneOfType([_propTypes2['default'].node, _propTypes2['default'].func, _propTypes2['default'].string]),
		  sanitize: _propTypes2['default'].func,
		  searchWords: _propTypes2['default'].arrayOf(_propTypes2['default'].oneOfType([_propTypes2['default'].string, _propTypes2['default'].instanceOf(RegExp)])).isRequired,
		  textToHighlight: _propTypes2['default'].string.isRequired,
		  unhighlightClassName: _propTypes2['default'].string,
		  unhighlightStyle: _propTypes2['default'].object
		};
		
		/**
		 * Highlights all occurrences of search terms (searchText) within a string (textToHighlight).
		 * This function returns an array of strings and <span>s (wrapping highlighted words).
		 */
		
		function Highlighter(_ref) {
		  var _ref$activeClassName = _ref.activeClassName;
		  var activeClassName = _ref$activeClassName === undefined ? '' : _ref$activeClassName;
		  var _ref$activeIndex = _ref.activeIndex;
		  var activeIndex = _ref$activeIndex === undefined ? -1 : _ref$activeIndex;
		  var activeStyle = _ref.activeStyle;
		  var autoEscape = _ref.autoEscape;
		  var _ref$caseSensitive = _ref.caseSensitive;
		  var caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive;
		  var className = _ref.className;
		  var findChunks = _ref.findChunks;
		  var _ref$highlightClassName = _ref.highlightClassName;
		  var highlightClassName = _ref$highlightClassName === undefined ? '' : _ref$highlightClassName;
		  var _ref$highlightStyle = _ref.highlightStyle;
		  var highlightStyle = _ref$highlightStyle === undefined ? {} : _ref$highlightStyle;
		  var _ref$highlightTag = _ref.highlightTag;
		  var highlightTag = _ref$highlightTag === undefined ? 'mark' : _ref$highlightTag;
		  var sanitize = _ref.sanitize;
		  var searchWords = _ref.searchWords;
		  var textToHighlight = _ref.textToHighlight;
		  var _ref$unhighlightClassName = _ref.unhighlightClassName;
		  var unhighlightClassName = _ref$unhighlightClassName === undefined ? '' : _ref$unhighlightClassName;
		  var unhighlightStyle = _ref.unhighlightStyle;
		
		  var rest = _objectWithoutProperties(_ref, ['activeClassName', 'activeIndex', 'activeStyle', 'autoEscape', 'caseSensitive', 'className', 'findChunks', 'highlightClassName', 'highlightStyle', 'highlightTag', 'sanitize', 'searchWords', 'textToHighlight', 'unhighlightClassName', 'unhighlightStyle']);
		
		  var chunks = (0, _highlightWordsCore.findAll)({
		    autoEscape: autoEscape,
		    caseSensitive: caseSensitive,
		    findChunks: findChunks,
		    sanitize: sanitize,
		    searchWords: searchWords,
		    textToHighlight: textToHighlight
		  });
		  var HighlightTag = highlightTag;
		  var highlightIndex = -1;
		  var highlightClassNames = '';
		  var highlightStyles = undefined;
		
		  var lowercaseProps = function lowercaseProps(object) {
		    var mapped = {};
		    for (var key in object) {
		      mapped[key.toLowerCase()] = object[key];
		    }
		    return mapped;
		  };
		  var memoizedLowercaseProps = (0, _memoizeOne2['default'])(lowercaseProps);
		
		  return (0, _react.createElement)('span', _extends({
		    className: className
		  }, rest, {
		    children: chunks.map(function (chunk, index) {
		      var text = textToHighlight.substr(chunk.start, chunk.end - chunk.start);
		
		      if (chunk.highlight) {
		        highlightIndex++;
		
		        var highlightClass = undefined;
		        if (typeof highlightClassName === 'object') {
		          if (!caseSensitive) {
		            highlightClassName = memoizedLowercaseProps(highlightClassName);
		            highlightClass = highlightClassName[text.toLowerCase()];
		          } else {
		            highlightClass = highlightClassName[text];
		          }
		        } else {
		          highlightClass = highlightClassName;
		        }
		
		        var isActive = highlightIndex === +activeIndex;
		
		        highlightClassNames = highlightClass + ' ' + (isActive ? activeClassName : '');
		        highlightStyles = isActive === true && activeStyle != null ? Object.assign({}, highlightStyle, activeStyle) : highlightStyle;
		
		        var props = {
		          children: text,
		          className: highlightClassNames,
		          key: index,
		          style: highlightStyles
		        };
		
		        // Don't attach arbitrary props to DOM elements; this triggers React DEV warnings (https://fb.me/react-unknown-prop)
		        // Only pass through the highlightIndex attribute for custom components.
		        if (typeof HighlightTag !== 'string') {
		          props.highlightIndex = highlightIndex;
		        }
		
		        return (0, _react.createElement)(HighlightTag, props);
		      } else {
		        return (0, _react.createElement)('span', {
		          children: text,
		          className: unhighlightClassName,
		          key: index,
		          style: unhighlightStyle
		        });
		      }
		    })
		  }));
		}
		
		module.exports = exports['default'];

	/***/ }),
	/* 3 */
	/***/ (function(module, exports) {

		module.exports =
		/******/ (function(modules) { // webpackBootstrap
		/******/ 	// The module cache
		/******/ 	var installedModules = {};
		/******/
		/******/ 	// The require function
		/******/ 	function __webpack_require__(moduleId) {
		/******/
		/******/ 		// Check if module is in cache
		/******/ 		if(installedModules[moduleId])
		/******/ 			return installedModules[moduleId].exports;
		/******/
		/******/ 		// Create a new module (and put it into the cache)
		/******/ 		var module = installedModules[moduleId] = {
		/******/ 			exports: {},
		/******/ 			id: moduleId,
		/******/ 			loaded: false
		/******/ 		};
		/******/
		/******/ 		// Execute the module function
		/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
		/******/
		/******/ 		// Flag the module as loaded
		/******/ 		module.loaded = true;
		/******/
		/******/ 		// Return the exports of the module
		/******/ 		return module.exports;
		/******/ 	}
		/******/
		/******/
		/******/ 	// expose the modules object (__webpack_modules__)
		/******/ 	__webpack_require__.m = modules;
		/******/
		/******/ 	// expose the module cache
		/******/ 	__webpack_require__.c = installedModules;
		/******/
		/******/ 	// __webpack_public_path__
		/******/ 	__webpack_require__.p = "";
		/******/
		/******/ 	// Load entry module and return exports
		/******/ 	return __webpack_require__(0);
		/******/ })
		/************************************************************************/
		/******/ ([
		/* 0 */
		/***/ (function(module, exports, __webpack_require__) {
		
			module.exports = __webpack_require__(1);
		
		
		/***/ }),
		/* 1 */
		/***/ (function(module, exports, __webpack_require__) {
			
			Object.defineProperty(exports, "__esModule", {
			  value: true
			});
			
			var _utils = __webpack_require__(2);
			
			Object.defineProperty(exports, 'combineChunks', {
			  enumerable: true,
			  get: function get() {
			    return _utils.combineChunks;
			  }
			});
			Object.defineProperty(exports, 'fillInChunks', {
			  enumerable: true,
			  get: function get() {
			    return _utils.fillInChunks;
			  }
			});
			Object.defineProperty(exports, 'findAll', {
			  enumerable: true,
			  get: function get() {
			    return _utils.findAll;
			  }
			});
			Object.defineProperty(exports, 'findChunks', {
			  enumerable: true,
			  get: function get() {
			    return _utils.findChunks;
			  }
			});
		
		/***/ }),
		/* 2 */
		/***/ (function(module, exports) {
			
			Object.defineProperty(exports, "__esModule", {
			  value: true
			});
			/**
			 * Creates an array of chunk objects representing both higlightable and non highlightable pieces of text that match each search word.
			 * @return Array of "chunks" (where a Chunk is { start:number, end:number, highlight:boolean })
			 */
			exports.findAll = function findAll(_ref) {
			  var autoEscape = _ref.autoEscape,
			      _ref$caseSensitive = _ref.caseSensitive,
			      caseSensitive = _ref$caseSensitive === undefined ? false : _ref$caseSensitive,
			      _ref$findChunks = _ref.findChunks,
			      findChunks = _ref$findChunks === undefined ? defaultFindChunks : _ref$findChunks,
			      sanitize = _ref.sanitize,
			      searchWords = _ref.searchWords,
			      textToHighlight = _ref.textToHighlight;
			  return fillInChunks({
			    chunksToHighlight: combineChunks({
			      chunks: findChunks({
			        autoEscape: autoEscape,
			        caseSensitive: caseSensitive,
			        sanitize: sanitize,
			        searchWords: searchWords,
			        textToHighlight: textToHighlight
			      })
			    }),
			    totalLength: textToHighlight ? textToHighlight.length : 0
			  });
			};
			
			/**
			 * Takes an array of {start:number, end:number} objects and combines chunks that overlap into single chunks.
			 * @return {start:number, end:number}[]
			 */
			var combineChunks = exports.combineChunks = function combineChunks(_ref2) {
			  var chunks = _ref2.chunks;
			
			  chunks = chunks.sort(function (first, second) {
			    return first.start - second.start;
			  }).reduce(function (processedChunks, nextChunk) {
			    // First chunk just goes straight in the array...
			    if (processedChunks.length === 0) {
			      return [nextChunk];
			    } else {
			      // ... subsequent chunks get checked to see if they overlap...
			      var prevChunk = processedChunks.pop();
			      if (nextChunk.start <= prevChunk.end) {
			        // It may be the case that prevChunk completely surrounds nextChunk, so take the
			        // largest of the end indeces.
			        var endIndex = Math.max(prevChunk.end, nextChunk.end);
			        processedChunks.push({ start: prevChunk.start, end: endIndex });
			      } else {
			        processedChunks.push(prevChunk, nextChunk);
			      }
			      return processedChunks;
			    }
			  }, []);
			
			  return chunks;
			};
			
			/**
			 * Examine text for any matches.
			 * If we find matches, add them to the returned array as a "chunk" object ({start:number, end:number}).
			 * @return {start:number, end:number}[]
			 */
			var defaultFindChunks = function defaultFindChunks(_ref3) {
			  var autoEscape = _ref3.autoEscape,
			      caseSensitive = _ref3.caseSensitive,
			      _ref3$sanitize = _ref3.sanitize,
			      sanitize = _ref3$sanitize === undefined ? identity : _ref3$sanitize,
			      searchWords = _ref3.searchWords,
			      textToHighlight = _ref3.textToHighlight;
			
			  textToHighlight = sanitize(textToHighlight);
			
			  return searchWords.filter(function (searchWord) {
			    return searchWord;
			  }) // Remove empty words
			  .reduce(function (chunks, searchWord) {
			    searchWord = sanitize(searchWord);
			
			    if (autoEscape) {
			      searchWord = escapeRegExpFn(searchWord);
			    }
			
			    var regex = new RegExp(searchWord, caseSensitive ? 'g' : 'gi');
			
			    var match = void 0;
			    while (match = regex.exec(textToHighlight)) {
			      var start = match.index;
			      var end = regex.lastIndex;
			      // We do not return zero-length matches
			      if (end > start) {
			        chunks.push({ start: start, end: end });
			      }
			
			      // Prevent browsers like Firefox from getting stuck in an infinite loop
			      // See http://www.regexguru.com/2008/04/watch-out-for-zero-length-matches/
			      if (match.index == regex.lastIndex) {
			        regex.lastIndex++;
			      }
			    }
			
			    return chunks;
			  }, []);
			};
			// Allow the findChunks to be overridden in findAll,
			// but for backwards compatibility we export as the old name
			exports.findChunks = defaultFindChunks;
			
			/**
			 * Given a set of chunks to highlight, create an additional set of chunks
			 * to represent the bits of text between the highlighted text.
			 * @param chunksToHighlight {start:number, end:number}[]
			 * @param totalLength number
			 * @return {start:number, end:number, highlight:boolean}[]
			 */
			
			var fillInChunks = exports.fillInChunks = function fillInChunks(_ref4) {
			  var chunksToHighlight = _ref4.chunksToHighlight,
			      totalLength = _ref4.totalLength;
			
			  var allChunks = [];
			  var append = function append(start, end, highlight) {
			    if (end - start > 0) {
			      allChunks.push({
			        start: start,
			        end: end,
			        highlight: highlight
			      });
			    }
			  };
			
			  if (chunksToHighlight.length === 0) {
			    append(0, totalLength, false);
			  } else {
			    var lastIndex = 0;
			    chunksToHighlight.forEach(function (chunk) {
			      append(lastIndex, chunk.start, false);
			      append(chunk.start, chunk.end, true);
			      lastIndex = chunk.end;
			    });
			    append(lastIndex, totalLength, false);
			  }
			  return allChunks;
			};
			
			function identity(value) {
			  return value;
			}
			
			function escapeRegExpFn(str) {
			  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
			}
		
		/***/ })
		/******/ ]);
		

	/***/ }),
	/* 4 */
	/***/ (function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 */
		
		{
		  // By explicitly using `prop-types` you are opting into new production behavior.
		  // http://fb.me/prop-types-in-prod
		  module.exports = __webpack_require__(13)();
		}
		
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)));

	/***/ }),
	/* 5 */
	/***/ (function(module, exports) {

		// shim for using process in browser
		var process = module.exports = {};
		
		// cached from whatever global is present so that test runners that stub it
		// don't break things.  But we need to wrap it in a try catch in case it is
		// wrapped in strict mode code which doesn't define any globals.  It's inside a
		// function because try/catches deoptimize in certain engines.
		
		var cachedSetTimeout;
		var cachedClearTimeout;
		
		function defaultSetTimout() {
		    throw new Error('setTimeout has not been defined');
		}
		function defaultClearTimeout () {
		    throw new Error('clearTimeout has not been defined');
		}
		(function () {
		    try {
		        if (typeof setTimeout === 'function') {
		            cachedSetTimeout = setTimeout;
		        } else {
		            cachedSetTimeout = defaultSetTimout;
		        }
		    } catch (e) {
		        cachedSetTimeout = defaultSetTimout;
		    }
		    try {
		        if (typeof clearTimeout === 'function') {
		            cachedClearTimeout = clearTimeout;
		        } else {
		            cachedClearTimeout = defaultClearTimeout;
		        }
		    } catch (e) {
		        cachedClearTimeout = defaultClearTimeout;
		    }
		} ());
		function runTimeout(fun) {
		    if (cachedSetTimeout === setTimeout) {
		        //normal enviroments in sane situations
		        return setTimeout(fun, 0);
		    }
		    // if setTimeout wasn't available but was latter defined
		    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
		        cachedSetTimeout = setTimeout;
		        return setTimeout(fun, 0);
		    }
		    try {
		        // when when somebody has screwed with setTimeout but no I.E. maddness
		        return cachedSetTimeout(fun, 0);
		    } catch(e){
		        try {
		            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
		            return cachedSetTimeout.call(null, fun, 0);
		        } catch(e){
		            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
		            return cachedSetTimeout.call(this, fun, 0);
		        }
		    }
		
		
		}
		function runClearTimeout(marker) {
		    if (cachedClearTimeout === clearTimeout) {
		        //normal enviroments in sane situations
		        return clearTimeout(marker);
		    }
		    // if clearTimeout wasn't available but was latter defined
		    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
		        cachedClearTimeout = clearTimeout;
		        return clearTimeout(marker);
		    }
		    try {
		        // when when somebody has screwed with setTimeout but no I.E. maddness
		        return cachedClearTimeout(marker);
		    } catch (e){
		        try {
		            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
		            return cachedClearTimeout.call(null, marker);
		        } catch (e){
		            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
		            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
		            return cachedClearTimeout.call(this, marker);
		        }
		    }
		
		
		
		}
		var queue = [];
		var draining = false;
		var currentQueue;
		var queueIndex = -1;
		
		function cleanUpNextTick() {
		    if (!draining || !currentQueue) {
		        return;
		    }
		    draining = false;
		    if (currentQueue.length) {
		        queue = currentQueue.concat(queue);
		    } else {
		        queueIndex = -1;
		    }
		    if (queue.length) {
		        drainQueue();
		    }
		}
		
		function drainQueue() {
		    if (draining) {
		        return;
		    }
		    var timeout = runTimeout(cleanUpNextTick);
		    draining = true;
		
		    var len = queue.length;
		    while(len) {
		        currentQueue = queue;
		        queue = [];
		        while (++queueIndex < len) {
		            if (currentQueue) {
		                currentQueue[queueIndex].run();
		            }
		        }
		        queueIndex = -1;
		        len = queue.length;
		    }
		    currentQueue = null;
		    draining = false;
		    runClearTimeout(timeout);
		}
		
		process.nextTick = function (fun) {
		    var args = new Array(arguments.length - 1);
		    if (arguments.length > 1) {
		        for (var i = 1; i < arguments.length; i++) {
		            args[i - 1] = arguments[i];
		        }
		    }
		    queue.push(new Item(fun, args));
		    if (queue.length === 1 && !draining) {
		        runTimeout(drainQueue);
		    }
		};
		
		// v8 likes predictible objects
		function Item(fun, array) {
		    this.fun = fun;
		    this.array = array;
		}
		Item.prototype.run = function () {
		    this.fun.apply(null, this.array);
		};
		process.title = 'browser';
		process.browser = true;
		process.env = {};
		process.argv = [];
		process.version = ''; // empty string to avoid regexp issues
		process.versions = {};
		
		function noop() {}
		
		process.on = noop;
		process.addListener = noop;
		process.once = noop;
		process.off = noop;
		process.removeListener = noop;
		process.removeAllListeners = noop;
		process.emit = noop;
		process.prependListener = noop;
		process.prependOnceListener = noop;
		
		process.listeners = function (name) { return [] };
		
		process.binding = function (name) {
		    throw new Error('process.binding is not supported');
		};
		
		process.cwd = function () { return '/' };
		process.chdir = function (dir) {
		    throw new Error('process.chdir is not supported');
		};
		process.umask = function() { return 0; };


	/***/ }),
	/* 6 */
	/***/ (function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 */
		
		var emptyFunction = __webpack_require__(7);
		var invariant = __webpack_require__(8);
		var warning = __webpack_require__(9);
		var assign = __webpack_require__(10);
		
		var ReactPropTypesSecret = __webpack_require__(11);
		var checkPropTypes = __webpack_require__(12);
		
		module.exports = function(isValidElement, throwOnDirectAccess) {
		  /* global Symbol */
		  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
		  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
		
		  /**
		   * Returns the iterator method function contained on the iterable object.
		   *
		   * Be sure to invoke the function with the iterable as context:
		   *
		   *     var iteratorFn = getIteratorFn(myIterable);
		   *     if (iteratorFn) {
		   *       var iterator = iteratorFn.call(myIterable);
		   *       ...
		   *     }
		   *
		   * @param {?object} maybeIterable
		   * @return {?function}
		   */
		  function getIteratorFn(maybeIterable) {
		    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
		    if (typeof iteratorFn === 'function') {
		      return iteratorFn;
		    }
		  }
		
		  /**
		   * Collection of methods that allow declaration and validation of props that are
		   * supplied to React components. Example usage:
		   *
		   *   var Props = require('ReactPropTypes');
		   *   var MyArticle = React.createClass({
		   *     propTypes: {
		   *       // An optional string prop named "description".
		   *       description: Props.string,
		   *
		   *       // A required enum prop named "category".
		   *       category: Props.oneOf(['News','Photos']).isRequired,
		   *
		   *       // A prop named "dialog" that requires an instance of Dialog.
		   *       dialog: Props.instanceOf(Dialog).isRequired
		   *     },
		   *     render: function() { ... }
		   *   });
		   *
		   * A more formal specification of how these methods are used:
		   *
		   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
		   *   decl := ReactPropTypes.{type}(.isRequired)?
		   *
		   * Each and every declaration produces a function with the same signature. This
		   * allows the creation of custom validation functions. For example:
		   *
		   *  var MyLink = React.createClass({
		   *    propTypes: {
		   *      // An optional string or URI prop named "href".
		   *      href: function(props, propName, componentName) {
		   *        var propValue = props[propName];
		   *        if (propValue != null && typeof propValue !== 'string' &&
		   *            !(propValue instanceof URI)) {
		   *          return new Error(
		   *            'Expected a string or an URI for ' + propName + ' in ' +
		   *            componentName
		   *          );
		   *        }
		   *      }
		   *    },
		   *    render: function() {...}
		   *  });
		   *
		   * @internal
		   */
		
		  var ANONYMOUS = '<<anonymous>>';
		
		  // Important!
		  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
		  var ReactPropTypes = {
		    array: createPrimitiveTypeChecker('array'),
		    bool: createPrimitiveTypeChecker('boolean'),
		    func: createPrimitiveTypeChecker('function'),
		    number: createPrimitiveTypeChecker('number'),
		    object: createPrimitiveTypeChecker('object'),
		    string: createPrimitiveTypeChecker('string'),
		    symbol: createPrimitiveTypeChecker('symbol'),
		
		    any: createAnyTypeChecker(),
		    arrayOf: createArrayOfTypeChecker,
		    element: createElementTypeChecker(),
		    instanceOf: createInstanceTypeChecker,
		    node: createNodeChecker(),
		    objectOf: createObjectOfTypeChecker,
		    oneOf: createEnumTypeChecker,
		    oneOfType: createUnionTypeChecker,
		    shape: createShapeTypeChecker,
		    exact: createStrictShapeTypeChecker,
		  };
		
		  /**
		   * inlined Object.is polyfill to avoid requiring consumers ship their own
		   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
		   */
		  /*eslint-disable no-self-compare*/
		  function is(x, y) {
		    // SameValue algorithm
		    if (x === y) {
		      // Steps 1-5, 7-10
		      // Steps 6.b-6.e: +0 != -0
		      return x !== 0 || 1 / x === 1 / y;
		    } else {
		      // Step 6.a: NaN == NaN
		      return x !== x && y !== y;
		    }
		  }
		  /*eslint-enable no-self-compare*/
		
		  /**
		   * We use an Error-like object for backward compatibility as people may call
		   * PropTypes directly and inspect their output. However, we don't use real
		   * Errors anymore. We don't inspect their stack anyway, and creating them
		   * is prohibitively expensive if they are created too often, such as what
		   * happens in oneOfType() for any type before the one that matched.
		   */
		  function PropTypeError(message) {
		    this.message = message;
		    this.stack = '';
		  }
		  // Make `instanceof Error` still work for returned errors.
		  PropTypeError.prototype = Error.prototype;
		
		  function createChainableTypeChecker(validate) {
		    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
		      componentName = componentName || ANONYMOUS;
		      propFullName = propFullName || propName;
		
		      if (secret !== ReactPropTypesSecret) {
		        if (throwOnDirectAccess) {
		          // New behavior only for users of `prop-types` package
		          invariant(
		            false,
		            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
		            'Use `PropTypes.checkPropTypes()` to call them. ' +
		            'Read more at http://fb.me/use-check-prop-types'
		          );
		        }
		      }
		      if (props[propName] == null) {
		        if (isRequired) {
		          if (props[propName] === null) {
		            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
		          }
		          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
		        }
		        return null;
		      } else {
		        return validate(props, propName, componentName, location, propFullName);
		      }
		    }
		
		    var chainedCheckType = checkType.bind(null, false);
		    chainedCheckType.isRequired = checkType.bind(null, true);
		
		    return chainedCheckType;
		  }
		
		  function createPrimitiveTypeChecker(expectedType) {
		    function validate(props, propName, componentName, location, propFullName, secret) {
		      var propValue = props[propName];
		      var propType = getPropType(propValue);
		      if (propType !== expectedType) {
		        // `propValue` being instance of, say, date/regexp, pass the 'object'
		        // check, but we can offer a more precise error message here rather than
		        // 'of type `object`'.
		        var preciseType = getPreciseType(propValue);
		
		        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
		      }
		      return null;
		    }
		    return createChainableTypeChecker(validate);
		  }
		
		  function createAnyTypeChecker() {
		    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
		  }
		
		  function createArrayOfTypeChecker(typeChecker) {
		    function validate(props, propName, componentName, location, propFullName) {
		      if (typeof typeChecker !== 'function') {
		        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
		      }
		      var propValue = props[propName];
		      if (!Array.isArray(propValue)) {
		        var propType = getPropType(propValue);
		        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
		      }
		      for (var i = 0; i < propValue.length; i++) {
		        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
		        if (error instanceof Error) {
		          return error;
		        }
		      }
		      return null;
		    }
		    return createChainableTypeChecker(validate);
		  }
		
		  function createElementTypeChecker() {
		    function validate(props, propName, componentName, location, propFullName) {
		      var propValue = props[propName];
		      if (!isValidElement(propValue)) {
		        var propType = getPropType(propValue);
		        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
		      }
		      return null;
		    }
		    return createChainableTypeChecker(validate);
		  }
		
		  function createInstanceTypeChecker(expectedClass) {
		    function validate(props, propName, componentName, location, propFullName) {
		      if (!(props[propName] instanceof expectedClass)) {
		        var expectedClassName = expectedClass.name || ANONYMOUS;
		        var actualClassName = getClassName(props[propName]);
		        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
		      }
		      return null;
		    }
		    return createChainableTypeChecker(validate);
		  }
		
		  function createEnumTypeChecker(expectedValues) {
		    if (!Array.isArray(expectedValues)) {
		      return emptyFunction.thatReturnsNull;
		    }
		
		    function validate(props, propName, componentName, location, propFullName) {
		      var propValue = props[propName];
		      for (var i = 0; i < expectedValues.length; i++) {
		        if (is(propValue, expectedValues[i])) {
		          return null;
		        }
		      }
		
		      var valuesString = JSON.stringify(expectedValues);
		      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
		    }
		    return createChainableTypeChecker(validate);
		  }
		
		  function createObjectOfTypeChecker(typeChecker) {
		    function validate(props, propName, componentName, location, propFullName) {
		      if (typeof typeChecker !== 'function') {
		        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
		      }
		      var propValue = props[propName];
		      var propType = getPropType(propValue);
		      if (propType !== 'object') {
		        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
		      }
		      for (var key in propValue) {
		        if (propValue.hasOwnProperty(key)) {
		          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
		          if (error instanceof Error) {
		            return error;
		          }
		        }
		      }
		      return null;
		    }
		    return createChainableTypeChecker(validate);
		  }
		
		  function createUnionTypeChecker(arrayOfTypeCheckers) {
		    if (!Array.isArray(arrayOfTypeCheckers)) {
		      return emptyFunction.thatReturnsNull;
		    }
		
		    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
		      var checker = arrayOfTypeCheckers[i];
		      if (typeof checker !== 'function') {
		        warning(
		          false,
		          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
		          'received %s at index %s.',
		          getPostfixForTypeWarning(checker),
		          i
		        );
		        return emptyFunction.thatReturnsNull;
		      }
		    }
		
		    function validate(props, propName, componentName, location, propFullName) {
		      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
		        var checker = arrayOfTypeCheckers[i];
		        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
		          return null;
		        }
		      }
		
		      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
		    }
		    return createChainableTypeChecker(validate);
		  }
		
		  function createNodeChecker() {
		    function validate(props, propName, componentName, location, propFullName) {
		      if (!isNode(props[propName])) {
		        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
		      }
		      return null;
		    }
		    return createChainableTypeChecker(validate);
		  }
		
		  function createShapeTypeChecker(shapeTypes) {
		    function validate(props, propName, componentName, location, propFullName) {
		      var propValue = props[propName];
		      var propType = getPropType(propValue);
		      if (propType !== 'object') {
		        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
		      }
		      for (var key in shapeTypes) {
		        var checker = shapeTypes[key];
		        if (!checker) {
		          continue;
		        }
		        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
		        if (error) {
		          return error;
		        }
		      }
		      return null;
		    }
		    return createChainableTypeChecker(validate);
		  }
		
		  function createStrictShapeTypeChecker(shapeTypes) {
		    function validate(props, propName, componentName, location, propFullName) {
		      var propValue = props[propName];
		      var propType = getPropType(propValue);
		      if (propType !== 'object') {
		        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
		      }
		      // We need to check all keys in case some are required but missing from
		      // props.
		      var allKeys = assign({}, props[propName], shapeTypes);
		      for (var key in allKeys) {
		        var checker = shapeTypes[key];
		        if (!checker) {
		          return new PropTypeError(
		            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
		            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
		            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
		          );
		        }
		        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
		        if (error) {
		          return error;
		        }
		      }
		      return null;
		    }
		
		    return createChainableTypeChecker(validate);
		  }
		
		  function isNode(propValue) {
		    switch (typeof propValue) {
		      case 'number':
		      case 'string':
		      case 'undefined':
		        return true;
		      case 'boolean':
		        return !propValue;
		      case 'object':
		        if (Array.isArray(propValue)) {
		          return propValue.every(isNode);
		        }
		        if (propValue === null || isValidElement(propValue)) {
		          return true;
		        }
		
		        var iteratorFn = getIteratorFn(propValue);
		        if (iteratorFn) {
		          var iterator = iteratorFn.call(propValue);
		          var step;
		          if (iteratorFn !== propValue.entries) {
		            while (!(step = iterator.next()).done) {
		              if (!isNode(step.value)) {
		                return false;
		              }
		            }
		          } else {
		            // Iterator will provide entry [k,v] tuples rather than values.
		            while (!(step = iterator.next()).done) {
		              var entry = step.value;
		              if (entry) {
		                if (!isNode(entry[1])) {
		                  return false;
		                }
		              }
		            }
		          }
		        } else {
		          return false;
		        }
		
		        return true;
		      default:
		        return false;
		    }
		  }
		
		  function isSymbol(propType, propValue) {
		    // Native Symbol.
		    if (propType === 'symbol') {
		      return true;
		    }
		
		    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
		    if (propValue['@@toStringTag'] === 'Symbol') {
		      return true;
		    }
		
		    // Fallback for non-spec compliant Symbols which are polyfilled.
		    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
		      return true;
		    }
		
		    return false;
		  }
		
		  // Equivalent of `typeof` but with special handling for array and regexp.
		  function getPropType(propValue) {
		    var propType = typeof propValue;
		    if (Array.isArray(propValue)) {
		      return 'array';
		    }
		    if (propValue instanceof RegExp) {
		      // Old webkits (at least until Android 4.0) return 'function' rather than
		      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
		      // passes PropTypes.object.
		      return 'object';
		    }
		    if (isSymbol(propType, propValue)) {
		      return 'symbol';
		    }
		    return propType;
		  }
		
		  // This handles more types than `getPropType`. Only used for error messages.
		  // See `createPrimitiveTypeChecker`.
		  function getPreciseType(propValue) {
		    if (typeof propValue === 'undefined' || propValue === null) {
		      return '' + propValue;
		    }
		    var propType = getPropType(propValue);
		    if (propType === 'object') {
		      if (propValue instanceof Date) {
		        return 'date';
		      } else if (propValue instanceof RegExp) {
		        return 'regexp';
		      }
		    }
		    return propType;
		  }
		
		  // Returns a string that is postfixed to a warning about an invalid type.
		  // For example, "undefined" or "of type array"
		  function getPostfixForTypeWarning(value) {
		    var type = getPreciseType(value);
		    switch (type) {
		      case 'array':
		      case 'object':
		        return 'an ' + type;
		      case 'boolean':
		      case 'date':
		      case 'regexp':
		        return 'a ' + type;
		      default:
		        return type;
		    }
		  }
		
		  // Returns class name of the object, if any.
		  function getClassName(propValue) {
		    if (!propValue.constructor || !propValue.constructor.name) {
		      return ANONYMOUS;
		    }
		    return propValue.constructor.name;
		  }
		
		  ReactPropTypes.checkPropTypes = checkPropTypes;
		  ReactPropTypes.PropTypes = ReactPropTypes;
		
		  return ReactPropTypes;
		};
		
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)));

	/***/ }),
	/* 7 */
	/***/ (function(module, exports) {
		
		/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 *
		 * 
		 */
		
		function makeEmptyFunction(arg) {
		  return function () {
		    return arg;
		  };
		}
		
		/**
		 * This function accepts and discards inputs; it has no side effects. This is
		 * primarily useful idiomatically for overridable function endpoints which
		 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
		 */
		var emptyFunction = function emptyFunction() {};
		
		emptyFunction.thatReturns = makeEmptyFunction;
		emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
		emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
		emptyFunction.thatReturnsNull = makeEmptyFunction(null);
		emptyFunction.thatReturnsThis = function () {
		  return this;
		};
		emptyFunction.thatReturnsArgument = function (arg) {
		  return arg;
		};
		
		module.exports = emptyFunction;

	/***/ }),
	/* 8 */
	/***/ (function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 *
		 */
		
		function invariant(condition, format, a, b, c, d, e, f) {
		
		  if (!condition) {
		    var error;
		    if (format === undefined) {
		      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
		    } else {
		      var args = [a, b, c, d, e, f];
		      var argIndex = 0;
		      error = new Error(format.replace(/%s/g, function () {
		        return args[argIndex++];
		      }));
		      error.name = 'Invariant Violation';
		    }
		
		    error.framesToPop = 1; // we don't care about invariant's own frame
		    throw error;
		  }
		}
		
		module.exports = invariant;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)));

	/***/ }),
	/* 9 */
	/***/ (function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright (c) 2014-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 *
		 */
		
		var emptyFunction = __webpack_require__(7);
		
		/**
		 * Similar to invariant but only logs a warning if the condition is not met.
		 * This can be used to log issues in development environments in critical
		 * paths. Removing the logging code for production environments will keep the
		 * same logic and follow the same code paths.
		 */
		
		var warning = emptyFunction;
		
		module.exports = warning;
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)));

	/***/ }),
	/* 10 */
	/***/ (function(module, exports) {
		/* eslint-disable no-unused-vars */
		var getOwnPropertySymbols = Object.getOwnPropertySymbols;
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		var propIsEnumerable = Object.prototype.propertyIsEnumerable;
		
		function toObject(val) {
			if (val === null || val === undefined) {
				throw new TypeError('Object.assign cannot be called with null or undefined');
			}
		
			return Object(val);
		}
		
		function shouldUseNative() {
			try {
				if (!Object.assign) {
					return false;
				}
		
				// Detect buggy property enumeration order in older V8 versions.
		
				// https://bugs.chromium.org/p/v8/issues/detail?id=4118
				var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
				test1[5] = 'de';
				if (Object.getOwnPropertyNames(test1)[0] === '5') {
					return false;
				}
		
				// https://bugs.chromium.org/p/v8/issues/detail?id=3056
				var test2 = {};
				for (var i = 0; i < 10; i++) {
					test2['_' + String.fromCharCode(i)] = i;
				}
				var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
					return test2[n];
				});
				if (order2.join('') !== '0123456789') {
					return false;
				}
		
				// https://bugs.chromium.org/p/v8/issues/detail?id=3056
				var test3 = {};
				'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
					test3[letter] = letter;
				});
				if (Object.keys(Object.assign({}, test3)).join('') !==
						'abcdefghijklmnopqrst') {
					return false;
				}
		
				return true;
			} catch (err) {
				// We don't expect any of the above to throw, but better to be safe.
				return false;
			}
		}
		
		module.exports = shouldUseNative() ? Object.assign : function (target, source) {
			var from;
			var to = toObject(target);
			var symbols;
		
			for (var s = 1; s < arguments.length; s++) {
				from = Object(arguments[s]);
		
				for (var key in from) {
					if (hasOwnProperty.call(from, key)) {
						to[key] = from[key];
					}
				}
		
				if (getOwnPropertySymbols) {
					symbols = getOwnPropertySymbols(from);
					for (var i = 0; i < symbols.length; i++) {
						if (propIsEnumerable.call(from, symbols[i])) {
							to[symbols[i]] = from[symbols[i]];
						}
					}
				}
			}
		
			return to;
		};


	/***/ }),
	/* 11 */
	/***/ (function(module, exports) {
		
		var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
		
		module.exports = ReactPropTypesSecret;


	/***/ }),
	/* 12 */
	/***/ (function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright (c) 2013-present, Facebook, Inc.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 */
		
		/**
		 * Assert that the values match with the type specs.
		 * Error messages are memorized and will only be shown once.
		 *
		 * @param {object} typeSpecs Map of name to a ReactPropType
		 * @param {object} values Runtime values that need to be type-checked
		 * @param {string} location e.g. "prop", "context", "child context"
		 * @param {string} componentName Name of the component for error messages.
		 * @param {?Function} getStack Returns the component stack.
		 * @private
		 */
		function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
		}
		
		module.exports = checkPropTypes;
		
		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)));

	/***/ }),
	/* 13 */
	/***/ (function(module, exports, __webpack_require__) {
		
		var emptyFunction = __webpack_require__(7);
		var invariant = __webpack_require__(8);
		var ReactPropTypesSecret = __webpack_require__(11);
		
		module.exports = function() {
		  function shim(props, propName, componentName, location, propFullName, secret) {
		    if (secret === ReactPropTypesSecret) {
		      // It is still safe when called from React.
		      return;
		    }
		    invariant(
		      false,
		      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
		      'Use PropTypes.checkPropTypes() to call them. ' +
		      'Read more at http://fb.me/use-check-prop-types'
		    );
		  }		  shim.isRequired = shim;
		  function getShim() {
		    return shim;
		  }		  // Important!
		  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
		  var ReactPropTypes = {
		    array: shim,
		    bool: shim,
		    func: shim,
		    number: shim,
		    object: shim,
		    string: shim,
		    symbol: shim,
		
		    any: shim,
		    arrayOf: getShim,
		    element: shim,
		    instanceOf: getShim,
		    node: shim,
		    objectOf: getShim,
		    oneOf: getShim,
		    oneOfType: getShim,
		    shape: getShim,
		    exact: getShim
		  };
		
		  ReactPropTypes.checkPropTypes = emptyFunction;
		  ReactPropTypes.PropTypes = ReactPropTypes;
		
		  return ReactPropTypes;
		};


	/***/ }),
	/* 14 */
	/***/ (function(module, exports) {

		module.exports = react.exports;

	/***/ }),
	/* 15 */
	/***/ (function(module, exports) {
		
		var simpleIsEqual = function simpleIsEqual(a, b) {
		  return a === b;
		};
		
		function index (resultFn) {
		  var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : simpleIsEqual;
		
		  var lastThis = void 0;
		  var lastArgs = [];
		  var lastResult = void 0;
		  var calledOnce = false;
		
		  var isNewArgEqualToLast = function isNewArgEqualToLast(newArg, index) {
		    return isEqual(newArg, lastArgs[index]);
		  };
		
		  var result = function result() {
		    for (var _len = arguments.length, newArgs = Array(_len), _key = 0; _key < _len; _key++) {
		      newArgs[_key] = arguments[_key];
		    }
		
		    if (calledOnce && lastThis === this && newArgs.length === lastArgs.length && newArgs.every(isNewArgEqualToLast)) {
		      return lastResult;
		    }
		
		    calledOnce = true;
		    lastThis = this;
		    lastArgs = newArgs;
		    lastResult = resultFn.apply(this, newArgs);
		    return lastResult;
		  };
		
		  return result;
		}
		
		module.exports = index;


	/***/ })
	/******/ ]);
	
} (main));

const Highlighter = /*@__PURE__*/getDefaultExportFromCjs(main.exports);

var dayjs_min = {exports: {}};

(function (module, exports) {
	!function(t,e){module.exports=e();}(commonjsGlobal,(function(){var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",f="month",h="quarter",c="year",d="date",l="Invalid Date",$=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(t){var e=["th","st","nd","rd"],n=t%100;return "["+t+(e[(n-20)%10]||e[n]||e[0])+"]"}},m=function(t,e,n){var r=String(t);return !r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return (e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return -t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return +(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return {M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},g="en",D={};D[g]=M;var p=function(t){return t instanceof _},S=function t(e,n,r){var i;if(!e)return g;if("string"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split("-");if(!i&&u.length>1)return t(u[0])}else {var a=e.name;D[a]=e,i=a;}return !r&&i&&(g=i),i||!r&&g},w=function(t,e){if(p(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=v;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t);}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init();},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},m.$utils=function(){return O},m.isValid=function(){return !(this.$d.toString()===l)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),l=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return O.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v="set"+(this.$u?"UTC":"");switch(h){case c:return r?l(1,0):l(31,11);case f:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+"Hours",0);case u:return $(v+"Minutes",1);case s:return $(v+"Seconds",2);case i:return $(v+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h="set"+(this.$u?"UTC":""),l=(n={},n[a]=h+"Date",n[d]=h+"Date",n[f]=h+"Month",n[c]=h+"FullYear",n[u]=h+"Hours",n[s]=h+"Minutes",n[i]=h+"Seconds",n[r]=h+"Milliseconds",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d;}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,l=this;r=Number(r);var $=O.p(h),y=function(t){var e=w(l);return O.w(e.date(e.date()+Math.round(t*r)),l)};if($===f)return this.set(f,this.$M+r);if($===c)return this.set(c,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=O.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,f=n.months,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},c=function(t){return O.s(s%12||12,t,"0")},d=n.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},$={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,"0"),MMM:h(n.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,"0"),d:String(this.$W),dd:h(n.weekdaysMin,this.$W,o,2),ddd:h(n.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,"0"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,"0"),s:String(this.$s),ss:O.s(this.$s,2,"0"),SSS:O.s(this.$ms,3,"0"),Z:i};return r.replace(y,(function(t,e){return e||$[t]||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,v=this-M,g=O.m(this,M);return g=($={},$[c]=g/12,$[f]=g,$[h]=g/3,$[o]=(v-m)/6048e5,$[a]=(v-m)/864e5,$[u]=v/n,$[s]=v/e,$[i]=v/t,$)[y]||v,l?g:O.a(g)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),T=_.prototype;return w.prototype=T,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",f],["$y",c],["$D",d]].forEach((function(t){T[t[1]]=function(e){return this.$g(e,t[0],t[1])};})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=D[g],w.Ls=D,w.p={},w}));
} (dayjs_min));

const dayjs = dayjs_min.exports;

/*!
 *  decimal.js v10.4.3
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */


// -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //


  // The maximum exponent magnitude.
  // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.
var EXP_LIMIT = 9e15,                      // 0 to 9e15

  // The limit on the value of `precision`, and on the value of the first argument to
  // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
  MAX_DIGITS = 1e9,                        // 0 to 1e9

  // Base conversion alphabet.
  NUMERALS = '0123456789abcdef',

  // The natural logarithm of 10 (1025 digits).
  LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',

  // Pi (1025 digits).
  PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',


  // The initial configuration properties of the Decimal constructor.
  DEFAULTS = {

    // These values must be integers within the stated ranges (inclusive).
    // Most of these values can be changed at run-time using the `Decimal.config` method.

    // The maximum number of significant digits of the result of a calculation or base conversion.
    // E.g. `Decimal.config({ precision: 20 });`
    precision: 20,                         // 1 to MAX_DIGITS

    // The rounding mode used when rounding to `precision`.
    //
    // ROUND_UP         0 Away from zero.
    // ROUND_DOWN       1 Towards zero.
    // ROUND_CEIL       2 Towards +Infinity.
    // ROUND_FLOOR      3 Towards -Infinity.
    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
    //
    // E.g.
    // `Decimal.rounding = 4;`
    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
    rounding: 4,                           // 0 to 8

    // The modulo mode used when calculating the modulus: a mod n.
    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
    // The remainder (r) is calculated as: r = a - n * q.
    //
    // UP         0 The remainder is positive if the dividend is negative, else is negative.
    // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
    // FLOOR      3 The remainder has the same sign as the divisor (Python %).
    // HALF_EVEN  6 The IEEE 754 remainder function.
    // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
    //
    // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
    // division (9) are commonly used for the modulus operation. The other rounding modes can also
    // be used, but they may not give useful results.
    modulo: 1,                             // 0 to 9

    // The exponent value at and beneath which `toString` returns exponential notation.
    // JavaScript numbers: -7
    toExpNeg: -7,                          // 0 to -EXP_LIMIT

    // The exponent value at and above which `toString` returns exponential notation.
    // JavaScript numbers: 21
    toExpPos:  21,                         // 0 to EXP_LIMIT

    // The minimum exponent value, beneath which underflow to zero occurs.
    // JavaScript numbers: -324  (5e-324)
    minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT

    // The maximum exponent value, above which overflow to Infinity occurs.
    // JavaScript numbers: 308  (1.7976931348623157e+308)
    maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT

    // Whether to use cryptographically-secure random number generation, if available.
    crypto: false                          // true/false
  },


// ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //


  inexact, quadrant,
  external = true,

  decimalError = '[DecimalError] ',
  invalidArgument = decimalError + 'Invalid argument: ',
  precisionLimitExceeded = decimalError + 'Precision limit exceeded',
  cryptoUnavailable = decimalError + 'crypto unavailable',
  tag = '[object Decimal]',

  mathfloor = Math.floor,
  mathpow = Math.pow,

  isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
  isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
  isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
  isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,

  BASE = 1e7,
  LOG_BASE = 7,
  MAX_SAFE_INTEGER = 9007199254740991,

  LN10_PRECISION = LN10.length - 1,
  PI_PRECISION = PI.length - 1,

  // Decimal.prototype object
  P = { toStringTag: tag };


// Decimal prototype methods


/*
 *  absoluteValue             abs
 *  ceil
 *  clampedTo                 clamp
 *  comparedTo                cmp
 *  cosine                    cos
 *  cubeRoot                  cbrt
 *  decimalPlaces             dp
 *  dividedBy                 div
 *  dividedToIntegerBy        divToInt
 *  equals                    eq
 *  floor
 *  greaterThan               gt
 *  greaterThanOrEqualTo      gte
 *  hyperbolicCosine          cosh
 *  hyperbolicSine            sinh
 *  hyperbolicTangent         tanh
 *  inverseCosine             acos
 *  inverseHyperbolicCosine   acosh
 *  inverseHyperbolicSine     asinh
 *  inverseHyperbolicTangent  atanh
 *  inverseSine               asin
 *  inverseTangent            atan
 *  isFinite
 *  isInteger                 isInt
 *  isNaN
 *  isNegative                isNeg
 *  isPositive                isPos
 *  isZero
 *  lessThan                  lt
 *  lessThanOrEqualTo         lte
 *  logarithm                 log
 *  [maximum]                 [max]
 *  [minimum]                 [min]
 *  minus                     sub
 *  modulo                    mod
 *  naturalExponential        exp
 *  naturalLogarithm          ln
 *  negated                   neg
 *  plus                      add
 *  precision                 sd
 *  round
 *  sine                      sin
 *  squareRoot                sqrt
 *  tangent                   tan
 *  times                     mul
 *  toBinary
 *  toDecimalPlaces           toDP
 *  toExponential
 *  toFixed
 *  toFraction
 *  toHexadecimal             toHex
 *  toNearest
 *  toNumber
 *  toOctal
 *  toPower                   pow
 *  toPrecision
 *  toSignificantDigits       toSD
 *  toString
 *  truncated                 trunc
 *  valueOf                   toJSON
 */


/*
 * Return a new Decimal whose value is the absolute value of this Decimal.
 *
 */
P.absoluteValue = P.abs = function () {
  var x = new this.constructor(this);
  if (x.s < 0) x.s = 1;
  return finalise(x);
};


/*
 * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
 * direction of positive Infinity.
 *
 */
P.ceil = function () {
  return finalise(new this.constructor(this), this.e + 1, 2);
};


/*
 * Return a new Decimal whose value is the value of this Decimal clamped to the range
 * delineated by `min` and `max`.
 *
 * min {number|string|Decimal}
 * max {number|string|Decimal}
 *
 */
P.clampedTo = P.clamp = function (min, max) {
  var k,
    x = this,
    Ctor = x.constructor;
  min = new Ctor(min);
  max = new Ctor(max);
  if (!min.s || !max.s) return new Ctor(NaN);
  if (min.gt(max)) throw Error(invalidArgument + max);
  k = x.cmp(min);
  return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);
};


/*
 * Return
 *   1    if the value of this Decimal is greater than the value of `y`,
 *  -1    if the value of this Decimal is less than the value of `y`,
 *   0    if they have the same value,
 *   NaN  if the value of either Decimal is NaN.
 *
 */
P.comparedTo = P.cmp = function (y) {
  var i, j, xdL, ydL,
    x = this,
    xd = x.d,
    yd = (y = new x.constructor(y)).d,
    xs = x.s,
    ys = y.s;

  // Either NaN or Infinity?
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }

  // Either zero?
  if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;

  // Signs differ?
  if (xs !== ys) return xs;

  // Compare exponents.
  if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;

  xdL = xd.length;
  ydL = yd.length;

  // Compare digit by digit.
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
  }

  // Compare lengths.
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};


/*
 * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-1, 1]
 *
 * cos(0)         = 1
 * cos(-0)        = 1
 * cos(Infinity)  = NaN
 * cos(-Infinity) = NaN
 * cos(NaN)       = NaN
 *
 */
P.cosine = P.cos = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.d) return new Ctor(NaN);

  // cos(0) = cos(-0) = 1
  if (!x.d[0]) return new Ctor(1);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;

  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};


/*
 *
 * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 *  cbrt(0)  =  0
 *  cbrt(-0) = -0
 *  cbrt(1)  =  1
 *  cbrt(-1) = -1
 *  cbrt(N)  =  N
 *  cbrt(-I) = -I
 *  cbrt(I)  =  I
 *
 * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
 *
 */
P.cubeRoot = P.cbrt = function () {
  var e, m, n, r, rep, s, sd, t, t3, t3plusx,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);
  external = false;

  // Initial estimate.
  s = x.s * mathpow(x.s * x, 1 / 3);

   // Math.cbrt underflow/overflow?
   // Pass x to Math.pow as integer, then adjust the exponent of the result.
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e = x.e;

    // Adjust n exponent so it is a multiple of 3 away from x exponent.
    if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
    s = mathpow(n, 1 / 3);

    // Rarely, e may be one less than the result exponent value.
    e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));

    if (s == 1 / 0) {
      n = '5e' + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf('e') + 1) + e;
    }

    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }

  sd = (e = Ctor.precision) + 3;

  // Halley's method.
  // TODO? Compare Newton's method.
  for (;;) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);

    // TODO? Replace with for-loop and checkRoundingDigits.
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);

      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
      // , i.e. approaching a rounding boundary, continue the iteration.
      if (n == '9999' || !rep && n == '4999') {

        // On the first iteration only, check to see if rounding up gives the exact result as the
        // nines may infinitely repeat.
        if (!rep) {
          finalise(t, e + 1, 0);

          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }

        sd += 4;
        rep = 1;
      } else {

        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
        // If not, then there are further digits and m will be truthy.
        if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

          // Truncate to the first rounding digit.
          finalise(r, e + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }

        break;
      }
    }
  }

  external = true;

  return finalise(r, e, Ctor.rounding, m);
};


/*
 * Return the number of decimal places of the value of this Decimal.
 *
 */
P.decimalPlaces = P.dp = function () {
  var w,
    d = this.d,
    n = NaN;

  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;

    // Subtract the number of trailing zeros of the last word.
    w = d[w];
    if (w) for (; w % 10 == 0; w /= 10) n--;
    if (n < 0) n = 0;
  }

  return n;
};


/*
 *  n / 0 = I
 *  n / N = N
 *  n / I = 0
 *  0 / n = 0
 *  0 / 0 = N
 *  0 / N = N
 *  0 / I = 0
 *  N / n = N
 *  N / 0 = N
 *  N / N = N
 *  N / I = N
 *  I / n = I
 *  I / 0 = I
 *  I / N = N
 *  I / I = N
 *
 * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 */
P.dividedBy = P.div = function (y) {
  return divide(this, new this.constructor(y));
};


/*
 * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
 * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.
 *
 */
P.dividedToIntegerBy = P.divToInt = function (y) {
  var x = this,
    Ctor = x.constructor;
  return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};


/*
 * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
 *
 */
P.equals = P.eq = function (y) {
  return this.cmp(y) === 0;
};


/*
 * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
 * direction of negative Infinity.
 *
 */
P.floor = function () {
  return finalise(new this.constructor(this), this.e + 1, 3);
};


/*
 * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
 * false.
 *
 */
P.greaterThan = P.gt = function (y) {
  return this.cmp(y) > 0;
};


/*
 * Return true if the value of this Decimal is greater than or equal to the value of `y`,
 * otherwise return false.
 *
 */
P.greaterThanOrEqualTo = P.gte = function (y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
};


/*
 * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this
 * Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [1, Infinity]
 *
 * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...
 *
 * cosh(0)         = 1
 * cosh(-0)        = 1
 * cosh(Infinity)  = Infinity
 * cosh(-Infinity) = Infinity
 * cosh(NaN)       = NaN
 *
 *  x        time taken (ms)   result
 * 1000      9                 9.8503555700852349694e+433
 * 10000     25                4.4034091128314607936e+4342
 * 100000    171               1.4033316802130615897e+43429
 * 1000000   3817              1.5166076984010437725e+434294
 * 10000000  abandoned after 2 minute wait
 *
 * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))
 *
 */
P.hyperbolicCosine = P.cosh = function () {
  var k, n, pr, rm, len,
    x = this,
    Ctor = x.constructor,
    one = new Ctor(1);

  if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero()) return one;

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;

  // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
  // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))

  // Estimate the optimum number of times to use the argument reduction.
  // TODO? Estimation reused from cosine() and may not be optimal here.
  if (len < 32) {
    k = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n = '2.3283064365386962890625e-10';
  }

  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);

  // Reverse argument reduction
  var cosh2_x,
    i = k,
    d8 = new Ctor(8);
  for (; i--;) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }

  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};


/*
 * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this
 * Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-Infinity, Infinity]
 *
 * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...
 *
 * sinh(0)         = 0
 * sinh(-0)        = -0
 * sinh(Infinity)  = Infinity
 * sinh(-Infinity) = -Infinity
 * sinh(NaN)       = NaN
 *
 * x        time taken (ms)
 * 10       2 ms
 * 100      5 ms
 * 1000     14 ms
 * 10000    82 ms
 * 100000   886 ms            1.4033316802130615897e+43429
 * 200000   2613 ms
 * 300000   5407 ms
 * 400000   8824 ms
 * 500000   13026 ms          8.7080643612718084129e+217146
 * 1000000  48543 ms
 *
 * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))
 *
 */
P.hyperbolicSine = P.sinh = function () {
  var k, pr, rm, len,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;

  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {

    // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
    // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
    // 3 multiplications and 1 addition

    // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
    // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
    // 4 multiplications and 2 additions

    // Estimate the optimum number of times to use the argument reduction.
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;

    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);

    // Reverse argument reduction
    var sinh2_x,
      d5 = new Ctor(5),
      d16 = new Ctor(16),
      d20 = new Ctor(20);
    for (; k--;) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(x, pr, rm, true);
};


/*
 * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this
 * Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-1, 1]
 *
 * tanh(x) = sinh(x) / cosh(x)
 *
 * tanh(0)         = 0
 * tanh(-0)        = -0
 * tanh(Infinity)  = 1
 * tanh(-Infinity) = -1
 * tanh(NaN)       = NaN
 *
 */
P.hyperbolicTangent = P.tanh = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(x.s);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;

  return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};


/*
 * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
 * this Decimal.
 *
 * Domain: [-1, 1]
 * Range: [0, pi]
 *
 * acos(x) = pi/2 - asin(x)
 *
 * acos(0)       = pi/2
 * acos(-0)      = pi/2
 * acos(1)       = 0
 * acos(-1)      = pi
 * acos(1/2)     = pi/3
 * acos(-1/2)    = 2*pi/3
 * acos(|x| > 1) = NaN
 * acos(NaN)     = NaN
 *
 */
P.inverseCosine = P.acos = function () {
  var halfPi,
    x = this,
    Ctor = x.constructor,
    k = x.abs().cmp(1),
    pr = Ctor.precision,
    rm = Ctor.rounding;

  if (k !== -1) {
    return k === 0
      // |x| is 1
      ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)
      // |x| > 1 or x is NaN
      : new Ctor(NaN);
  }

  if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

  // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return halfPi.minus(x);
};


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the
 * value of this Decimal.
 *
 * Domain: [1, Infinity]
 * Range: [0, Infinity]
 *
 * acosh(x) = ln(x + sqrt(x^2 - 1))
 *
 * acosh(x < 1)     = NaN
 * acosh(NaN)       = NaN
 * acosh(Infinity)  = Infinity
 * acosh(-Infinity) = NaN
 * acosh(0)         = NaN
 * acosh(-0)        = NaN
 * acosh(1)         = 0
 * acosh(-1)        = NaN
 *
 */
P.inverseHyperbolicCosine = P.acosh = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;

  x = x.times(x).minus(1).sqrt().plus(x);

  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.ln();
};


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
 * of this Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-Infinity, Infinity]
 *
 * asinh(x) = ln(x + sqrt(x^2 + 1))
 *
 * asinh(NaN)       = NaN
 * asinh(Infinity)  = Infinity
 * asinh(-Infinity) = -Infinity
 * asinh(0)         = 0
 * asinh(-0)        = -0
 *
 */
P.inverseHyperbolicSine = P.asinh = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite() || x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;

  x = x.times(x).plus(1).sqrt().plus(x);

  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.ln();
};


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the
 * value of this Decimal.
 *
 * Domain: [-1, 1]
 * Range: [-Infinity, Infinity]
 *
 * atanh(x) = 0.5 * ln((1 + x) / (1 - x))
 *
 * atanh(|x| > 1)   = NaN
 * atanh(NaN)       = NaN
 * atanh(Infinity)  = NaN
 * atanh(-Infinity) = NaN
 * atanh(0)         = 0
 * atanh(-0)        = -0
 * atanh(1)         = Infinity
 * atanh(-1)        = -Infinity
 *
 */
P.inverseHyperbolicTangent = P.atanh = function () {
  var pr, rm, wpr, xsd,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();

  if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);

  Ctor.precision = wpr = xsd - x.e;

  x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);

  Ctor.precision = pr + 4;
  Ctor.rounding = 1;

  x = x.ln();

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.times(0.5);
};


/*
 * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this
 * Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-pi/2, pi/2]
 *
 * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))
 *
 * asin(0)       = 0
 * asin(-0)      = -0
 * asin(1/2)     = pi/6
 * asin(-1/2)    = -pi/6
 * asin(1)       = pi/2
 * asin(-1)      = -pi/2
 * asin(|x| > 1) = NaN
 * asin(NaN)     = NaN
 *
 * TODO? Compare performance of Taylor series.
 *
 */
P.inverseSine = P.asin = function () {
  var halfPi, k,
    pr, rm,
    x = this,
    Ctor = x.constructor;

  if (x.isZero()) return new Ctor(x);

  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;

  if (k !== -1) {

    // |x| is 1
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }

    // |x| > 1 or x is NaN
    return new Ctor(NaN);
  }

  // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

  Ctor.precision = pr + 6;
  Ctor.rounding = 1;

  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return x.times(2);
};


/*
 * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value
 * of this Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-pi/2, pi/2]
 *
 * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
 *
 * atan(0)         = 0
 * atan(-0)        = -0
 * atan(1)         = pi/4
 * atan(-1)        = -pi/4
 * atan(Infinity)  = pi/2
 * atan(-Infinity) = -pi/2
 * atan(NaN)       = NaN
 *
 */
P.inverseTangent = P.atan = function () {
  var i, j, k, n, px, t, r, wpr, x2,
    x = this,
    Ctor = x.constructor,
    pr = Ctor.precision,
    rm = Ctor.rounding;

  if (!x.isFinite()) {
    if (!x.s) return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }

  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;

  // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

  // Argument reduction
  // Ensure |x| < 0.42
  // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

  k = Math.min(28, wpr / LOG_BASE + 2 | 0);

  for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

  external = false;

  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;

  // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
  for (; i !== -1;) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));

    px = px.times(x2);
    r = t.plus(px.div(n += 2));

    if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);
  }

  if (k) r = r.times(2 << (k - 1));

  external = true;

  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};


/*
 * Return true if the value of this Decimal is a finite number, otherwise return false.
 *
 */
P.isFinite = function () {
  return !!this.d;
};


/*
 * Return true if the value of this Decimal is an integer, otherwise return false.
 *
 */
P.isInteger = P.isInt = function () {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};


/*
 * Return true if the value of this Decimal is NaN, otherwise return false.
 *
 */
P.isNaN = function () {
  return !this.s;
};


/*
 * Return true if the value of this Decimal is negative, otherwise return false.
 *
 */
P.isNegative = P.isNeg = function () {
  return this.s < 0;
};


/*
 * Return true if the value of this Decimal is positive, otherwise return false.
 *
 */
P.isPositive = P.isPos = function () {
  return this.s > 0;
};


/*
 * Return true if the value of this Decimal is 0 or -0, otherwise return false.
 *
 */
P.isZero = function () {
  return !!this.d && this.d[0] === 0;
};


/*
 * Return true if the value of this Decimal is less than `y`, otherwise return false.
 *
 */
P.lessThan = P.lt = function (y) {
  return this.cmp(y) < 0;
};


/*
 * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
 *
 */
P.lessThanOrEqualTo = P.lte = function (y) {
  return this.cmp(y) < 1;
};


/*
 * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * If no base is specified, return log[10](arg).
 *
 * log[base](arg) = ln(arg) / ln(base)
 *
 * The result will always be correctly rounded if the base of the log is 10, and 'almost always'
 * otherwise:
 *
 * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen
 * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error
 * between the result and the correctly rounded result will be one ulp (unit in the last place).
 *
 * log[-b](a)       = NaN
 * log[0](a)        = NaN
 * log[1](a)        = NaN
 * log[NaN](a)      = NaN
 * log[Infinity](a) = NaN
 * log[b](0)        = -Infinity
 * log[b](-0)       = -Infinity
 * log[b](-a)       = NaN
 * log[b](1)        = 0
 * log[b](Infinity) = Infinity
 * log[b](NaN)      = NaN
 *
 * [base] {number|string|Decimal} The base of the logarithm.
 *
 */
P.logarithm = P.log = function (base) {
  var isBase10, d, denominator, k, inf, num, sd, r,
    arg = this,
    Ctor = arg.constructor,
    pr = Ctor.precision,
    rm = Ctor.rounding,
    guard = 5;

  // Default base is 10.
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;

    // Return NaN if base is negative, or non-finite, or is 0 or 1.
    if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);

    isBase10 = base.eq(10);
  }

  d = arg.d;

  // Is arg negative, non-finite, 0 or 1?
  if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
  }

  // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
  // integer power of 10.
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k = d[0]; k % 10 === 0;) k /= 10;
      inf = k !== 1;
    }
  }

  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);

  // The result will have 5 rounding digits.
  r = divide(num, denominator, sd, 1);

  // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
  // calculate 10 further digits.
  //
  // If the result is known to have an infinite decimal expansion, repeat this until it is clear
  // that the result is above or below the boundary. Otherwise, if after calculating the 10
  // further digits, the last 14 are nines, round up and assume the result is exact.
  // Also assume the result is exact if the last 14 are zero.
  //
  // Example of a result that will be incorrectly rounded:
  // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
  // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
  // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
  // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
  // place is still 2.6.
  if (checkRoundingDigits(r.d, k = pr, rm)) {

    do {
      sd += 10;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide(num, denominator, sd, 1);

      if (!inf) {

        // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }

        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }

  external = true;

  return finalise(r, pr, rm);
};


/*
 * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.
 *
 * arguments {number|string|Decimal}
 *
P.max = function () {
  Array.prototype.push.call(arguments, this);
  return maxOrMin(this.constructor, arguments, 'lt');
};
 */


/*
 * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.
 *
 * arguments {number|string|Decimal}
 *
P.min = function () {
  Array.prototype.push.call(arguments, this);
  return maxOrMin(this.constructor, arguments, 'gt');
};
 */


/*
 *  n - 0 = n
 *  n - N = N
 *  n - I = -I
 *  0 - n = -n
 *  0 - 0 = 0
 *  0 - N = N
 *  0 - I = -I
 *  N - n = N
 *  N - 0 = N
 *  N - N = N
 *  N - I = N
 *  I - n = I
 *  I - 0 = I
 *  I - N = N
 *  I - I = N
 *
 * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 */
P.minus = P.sub = function (y) {
  var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // If either is not finite...
  if (!x.d || !y.d) {

    // Return NaN if either is NaN.
    if (!x.s || !y.s) y = new Ctor(NaN);

    // Return y negated if x is finite and y is Infinity.
    else if (x.d) y.s = -y.s;

    // Return x if y is finite and x is Infinity.
    // Return x if both are Infinity with different signs.
    // Return NaN if both are Infinity with the same sign.
    else y = new Ctor(y.d || x.s !== y.s ? x : NaN);

    return y;
  }

  // If signs differ...
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }

  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;

  // If either is zero...
  if (!xd[0] || !yd[0]) {

    // Return y negated if x is zero and y is non-zero.
    if (yd[0]) y.s = -y.s;

    // Return x if y is zero and x is non-zero.
    else if (xd[0]) y = new Ctor(x);

    // Return zero if both are zero.
    // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
    else return new Ctor(rm === 3 ? -0 : 0);

    return external ? finalise(y, pr, rm) : y;
  }

  // x and y are finite, non-zero numbers with the same sign.

  // Calculate base 1e7 exponents.
  e = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);

  xd = xd.slice();
  k = xe - e;

  // If base 1e7 exponents differ...
  if (k) {
    xLTy = k < 0;

    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }

    // Numbers with massively different exponents would result in a very high number of
    // zeros needing to be prepended, but this can be avoided while still ensuring correct
    // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

    if (k > i) {
      k = i;
      d.length = 1;
    }

    // Prepend zeros to equalise exponents.
    d.reverse();
    for (i = k; i--;) d.push(0);
    d.reverse();

  // Base 1e7 exponents equal.
  } else {

    // Check digits to determine which is the bigger number.

    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy) len = i;

    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }

    k = 0;
  }

  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }

  len = xd.length;

  // Append zeros to `xd` if shorter.
  // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.
  for (i = yd.length - len; i > 0; --i) xd[len++] = 0;

  // Subtract yd from xd.
  for (i = yd.length; i > k;) {

    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }

    xd[i] -= yd[i];
  }

  // Remove trailing zeros.
  for (; xd[--len] === 0;) xd.pop();

  // Remove leading zeros and adjust exponent accordingly.
  for (; xd[0] === 0; xd.shift()) --e;

  // Zero?
  if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);

  y.d = xd;
  y.e = getBase10Exponent(xd, e);

  return external ? finalise(y, pr, rm) : y;
};


/*
 *   n % 0 =  N
 *   n % N =  N
 *   n % I =  n
 *   0 % n =  0
 *  -0 % n = -0
 *   0 % 0 =  N
 *   0 % N =  N
 *   0 % I =  0
 *   N % n =  N
 *   N % 0 =  N
 *   N % N =  N
 *   N % I =  N
 *   I % n =  N
 *   I % 0 =  N
 *   I % N =  N
 *   I % I =  N
 *
 * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 * The result depends on the modulo mode.
 *
 */
P.modulo = P.mod = function (y) {
  var q,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // Return NaN if x is Infinity or NaN, or y is NaN or 0.
  if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);

  // Return x if y is Infinity or x is 0.
  if (!y.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }

  // Prevent rounding of intermediate calculations.
  external = false;

  if (Ctor.modulo == 9) {

    // Euclidian division: q = sign(y) * floor(x / abs(y))
    // result = x - q * y    where  0 <= result < abs(y)
    q = divide(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide(x, y, 0, Ctor.modulo, 1);
  }

  q = q.times(y);

  external = true;

  return x.minus(q);
};


/*
 * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
 * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 */
P.naturalExponential = P.exp = function () {
  return naturalExponential(this);
};


/*
 * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
 * rounded to `precision` significant digits using rounding mode `rounding`.
 *
 */
P.naturalLogarithm = P.ln = function () {
  return naturalLogarithm(this);
};


/*
 * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
 * -1.
 *
 */
P.negated = P.neg = function () {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};


/*
 *  n + 0 = n
 *  n + N = N
 *  n + I = I
 *  0 + n = n
 *  0 + 0 = 0
 *  0 + N = N
 *  0 + I = I
 *  N + n = N
 *  N + 0 = N
 *  N + N = N
 *  N + I = N
 *  I + n = I
 *  I + 0 = I
 *  I + N = N
 *  I + I = I
 *
 * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 */
P.plus = P.add = function (y) {
  var carry, d, e, i, k, len, pr, rm, xd, yd,
    x = this,
    Ctor = x.constructor;

  y = new Ctor(y);

  // If either is not finite...
  if (!x.d || !y.d) {

    // Return NaN if either is NaN.
    if (!x.s || !y.s) y = new Ctor(NaN);

    // Return x if y is finite and x is Infinity.
    // Return x if both are Infinity with the same sign.
    // Return NaN if both are Infinity with different signs.
    // Return y if x is finite and y is Infinity.
    else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);

    return y;
  }

   // If signs differ...
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }

  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;

  // If either is zero...
  if (!xd[0] || !yd[0]) {

    // Return x if y is zero.
    // Return y if y is non-zero.
    if (!yd[0]) y = new Ctor(x);

    return external ? finalise(y, pr, rm) : y;
  }

  // x and y are finite, non-zero numbers with the same sign.

  // Calculate base 1e7 exponents.
  k = mathfloor(x.e / LOG_BASE);
  e = mathfloor(y.e / LOG_BASE);

  xd = xd.slice();
  i = k - e;

  // If base 1e7 exponents differ...
  if (i) {

    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }

    // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;

    if (i > len) {
      i = len;
      d.length = 1;
    }

    // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
    d.reverse();
    for (; i--;) d.push(0);
    d.reverse();
  }

  len = xd.length;
  i = yd.length;

  // If yd is longer than xd, swap xd and yd so xd points to the longer array.
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }

  // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
  for (carry = 0; i;) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }

  if (carry) {
    xd.unshift(carry);
    ++e;
  }

  // Remove trailing zeros.
  // No need to check for zero, as +x + +y != 0 && -x + -y != 0
  for (len = xd.length; xd[--len] == 0;) xd.pop();

  y.d = xd;
  y.e = getBase10Exponent(xd, e);

  return external ? finalise(y, pr, rm) : y;
};


/*
 * Return the number of significant digits of the value of this Decimal.
 *
 * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
 *
 */
P.precision = P.sd = function (z) {
  var k,
    x = this;

  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

  if (x.d) {
    k = getPrecision(x.d);
    if (z && x.e + 1 > k) k = x.e + 1;
  } else {
    k = NaN;
  }

  return k;
};


/*
 * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
 * rounding mode `rounding`.
 *
 */
P.round = function () {
  var x = this,
    Ctor = x.constructor;

  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};


/*
 * Return a new Decimal whose value is the sine of the value in radians of this Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-1, 1]
 *
 * sin(x) = x - x^3/3! + x^5/5! - ...
 *
 * sin(0)         = 0
 * sin(-0)        = -0
 * sin(Infinity)  = NaN
 * sin(-Infinity) = NaN
 * sin(NaN)       = NaN
 *
 */
P.sine = P.sin = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;

  x = sine(Ctor, toLessThanHalfPi(Ctor, x));

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};


/*
 * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 *  sqrt(-n) =  N
 *  sqrt(N)  =  N
 *  sqrt(-I) =  N
 *  sqrt(I)  =  I
 *  sqrt(0)  =  0
 *  sqrt(-0) = -0
 *
 */
P.squareRoot = P.sqrt = function () {
  var m, n, sd, r, rep, t,
    x = this,
    d = x.d,
    e = x.e,
    s = x.s,
    Ctor = x.constructor;

  // Negative/NaN/Infinity/zero?
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }

  external = false;

  // Initial estimate.
  s = Math.sqrt(+x);

  // Math.sqrt underflow/overflow?
  // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);

    if ((n.length + e) % 2 == 0) n += '0';
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

    if (s == 1 / 0) {
      n = '5e' + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf('e') + 1) + e;
    }

    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }

  sd = (e = Ctor.precision) + 3;

  // Newton-Raphson iteration.
  for (;;) {
    t = r;
    r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);

    // TODO? Replace with for-loop and checkRoundingDigits.
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);

      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
      // 4999, i.e. approaching a rounding boundary, continue the iteration.
      if (n == '9999' || !rep && n == '4999') {

        // On the first iteration only, check to see if rounding up gives the exact result as the
        // nines may infinitely repeat.
        if (!rep) {
          finalise(t, e + 1, 0);

          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }

        sd += 4;
        rep = 1;
      } else {

        // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
        // If not, then there are further digits and m will be truthy.
        if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

          // Truncate to the first rounding digit.
          finalise(r, e + 1, 1);
          m = !r.times(r).eq(x);
        }

        break;
      }
    }
  }

  external = true;

  return finalise(r, e, Ctor.rounding, m);
};


/*
 * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-Infinity, Infinity]
 *
 * tan(0)         = 0
 * tan(-0)        = -0
 * tan(Infinity)  = NaN
 * tan(-Infinity) = NaN
 * tan(NaN)       = NaN
 *
 */
P.tangent = P.tan = function () {
  var pr, rm,
    x = this,
    Ctor = x.constructor;

  if (!x.isFinite()) return new Ctor(NaN);
  if (x.isZero()) return new Ctor(x);

  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;

  x = x.sin();
  x.s = 1;
  x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

  Ctor.precision = pr;
  Ctor.rounding = rm;

  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};


/*
 *  n * 0 = 0
 *  n * N = N
 *  n * I = I
 *  0 * n = 0
 *  0 * 0 = 0
 *  0 * N = N
 *  0 * I = N
 *  N * n = N
 *  N * 0 = N
 *  N * N = N
 *  N * I = N
 *  I * n = I
 *  I * 0 = N
 *  I * N = N
 *  I * I = I
 *
 * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 */
P.times = P.mul = function (y) {
  var carry, e, i, k, r, rL, t, xdL, ydL,
    x = this,
    Ctor = x.constructor,
    xd = x.d,
    yd = (y = new Ctor(y)).d;

  y.s *= x.s;

   // If either is NaN, Infinity or 0...
  if (!xd || !xd[0] || !yd || !yd[0]) {

    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd

      // Return NaN if either is NaN.
      // Return NaN if x is 0 and y is Infinity, or y is 0 and x is Infinity.
      ? NaN

      // Return Infinity if either is Infinity.
      // Return 0 if either is 0.
      : !xd || !yd ? y.s / 0 : y.s * 0);
  }

  e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;

  // Ensure xd points to the longer array.
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }

  // Initialise the result array with zeros.
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--;) r.push(0);

  // Multiply!
  for (i = ydL; --i >= 0;) {
    carry = 0;
    for (k = xdL + i; k > i;) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }

    r[k] = (r[k] + carry) % BASE | 0;
  }

  // Remove trailing zeros.
  for (; !r[--rL];) r.pop();

  if (carry) ++e;
  else r.shift();

  y.d = r;
  y.e = getBase10Exponent(r, e);

  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};


/*
 * Return a string representing the value of this Decimal in base 2, round to `sd` significant
 * digits using rounding mode `rm`.
 *
 * If the optional `sd` argument is present then return binary exponential notation.
 *
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P.toBinary = function (sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};


/*
 * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
 * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
 *
 * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
 *
 * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P.toDecimalPlaces = P.toDP = function (dp, rm) {
  var x = this,
    Ctor = x.constructor;

  x = new Ctor(x);
  if (dp === void 0) return x;

  checkInt32(dp, 0, MAX_DIGITS);

  if (rm === void 0) rm = Ctor.rounding;
  else checkInt32(rm, 0, 8);

  return finalise(x, dp + x.e + 1, rm);
};


/*
 * Return a string representing the value of this Decimal in exponential notation rounded to
 * `dp` fixed decimal places using rounding mode `rounding`.
 *
 * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P.toExponential = function (dp, rm) {
  var str,
    x = this,
    Ctor = x.constructor;

  if (dp === void 0) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }

  return x.isNeg() && !x.isZero() ? '-' + str : str;
};


/*
 * Return a string representing the value of this Decimal in normal (fixed-point) notation to
 * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
 * omitted.
 *
 * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
 *
 * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 * (-0).toFixed(3) is '0.000'.
 * (-0.5).toFixed(0) is '-0'.
 *
 */
P.toFixed = function (dp, rm) {
  var str, y,
    x = this,
    Ctor = x.constructor;

  if (dp === void 0) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }

  // To determine whether to add the minus sign look at the value before it was rounded,
  // i.e. look at `x` rather than `y`.
  return x.isNeg() && !x.isZero() ? '-' + str : str;
};


/*
 * Return an array representing the value of this Decimal as a simple fraction with an integer
 * numerator and an integer denominator.
 *
 * The denominator will be a positive non-zero value less than or equal to the specified maximum
 * denominator. If a maximum denominator is not specified, the denominator will be the lowest
 * value necessary to represent the number exactly.
 *
 * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.
 *
 */
P.toFraction = function (maxD) {
  var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,
    x = this,
    xd = x.d,
    Ctor = x.constructor;

  if (!xd) return new Ctor(x);

  n1 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);

  d = new Ctor(d1);
  e = d.e = getPrecision(xd) - x.e - 1;
  k = e % LOG_BASE;
  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);

  if (maxD == null) {

    // d is 10**e, the minimum max-denominator needed.
    maxD = e > 0 ? d : n1;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
    maxD = n.gt(d) ? (e > 0 ? d : n1) : n;
  }

  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e = xd.length * LOG_BASE * 2;

  for (;;)  {
    q = divide(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1) break;
    d0 = d1;
    d1 = d2;
    d2 = n1;
    n1 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }

  d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n1));
  d0 = d0.plus(d2.times(d1));
  n0.s = n1.s = x.s;

  // Determine which fraction is closer to x, n0/d0 or n1/d1?
  r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1
      ? [n1, d1] : [n0, d0];

  Ctor.precision = pr;
  external = true;

  return r;
};


/*
 * Return a string representing the value of this Decimal in base 16, round to `sd` significant
 * digits using rounding mode `rm`.
 *
 * If the optional `sd` argument is present then return binary exponential notation.
 *
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P.toHexadecimal = P.toHex = function (sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};


/*
 * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding
 * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.
 *
 * The return value will always have the same sign as this Decimal, unless either this Decimal
 * or `y` is NaN, in which case the return value will be also be NaN.
 *
 * The return value is not affected by the value of `precision`.
 *
 * y {number|string|Decimal} The magnitude to round to a multiple of.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 * 'toNearest() rounding mode not an integer: {rm}'
 * 'toNearest() rounding mode out of range: {rm}'
 *
 */
P.toNearest = function (y, rm) {
  var x = this,
    Ctor = x.constructor;

  x = new Ctor(x);

  if (y == null) {

    // If x is not finite, return x.
    if (!x.d) return x;

    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }

    // If x is not finite, return x if y is not NaN, else NaN.
    if (!x.d) return y.s ? x : y;

    // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.
    if (!y.d) {
      if (y.s) y.s = x.s;
      return y;
    }
  }

  // If y is not zero, calculate the nearest multiple of y to x.
  if (y.d[0]) {
    external = false;
    x = divide(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);

  // If y is zero, return zero with the sign of x.
  } else {
    y.s = x.s;
    x = y;
  }

  return x;
};


/*
 * Return the value of this Decimal converted to a number primitive.
 * Zero keeps its sign.
 *
 */
P.toNumber = function () {
  return +this;
};


/*
 * Return a string representing the value of this Decimal in base 8, round to `sd` significant
 * digits using rounding mode `rm`.
 *
 * If the optional `sd` argument is present then return binary exponential notation.
 *
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P.toOctal = function (sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};


/*
 * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded
 * to `precision` significant digits using rounding mode `rounding`.
 *
 * ECMAScript compliant.
 *
 *   pow(x, NaN)                           = NaN
 *   pow(x, 0)                            = 1

 *   pow(NaN, non-zero)                    = NaN
 *   pow(abs(x) > 1, +Infinity)            = +Infinity
 *   pow(abs(x) > 1, -Infinity)            = +0
 *   pow(abs(x) == 1, Infinity)           = NaN
 *   pow(abs(x) < 1, +Infinity)            = +0
 *   pow(abs(x) < 1, -Infinity)            = +Infinity
 *   pow(+Infinity, y > 0)                 = +Infinity
 *   pow(+Infinity, y < 0)                 = +0
 *   pow(-Infinity, odd integer > 0)       = -Infinity
 *   pow(-Infinity, even integer > 0)      = +Infinity
 *   pow(-Infinity, odd integer < 0)       = -0
 *   pow(-Infinity, even integer < 0)      = +0
 *   pow(+0, y > 0)                        = +0
 *   pow(+0, y < 0)                        = +Infinity
 *   pow(-0, odd integer > 0)              = -0
 *   pow(-0, even integer > 0)             = +0
 *   pow(-0, odd integer < 0)              = -Infinity
 *   pow(-0, even integer < 0)             = +Infinity
 *   pow(finite x < 0, finite non-integer) = NaN
 *
 * For non-integer or very large exponents pow(x, y) is calculated using
 *
 *   x^y = exp(y*ln(x))
 *
 * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the
 * probability of an incorrectly rounded result
 * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14
 * i.e. 1 in 250,000,000,000,000
 *
 * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).
 *
 * y {number|string|Decimal} The power to which to raise this Decimal.
 *
 */
P.toPower = P.pow = function (y) {
  var e, k, pr, r, rm, s,
    x = this,
    Ctor = x.constructor,
    yn = +(y = new Ctor(y));

  // Either Infinity, NaN or 0?
  if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));

  x = new Ctor(x);

  if (x.eq(1)) return x;

  pr = Ctor.precision;
  rm = Ctor.rounding;

  if (y.eq(1)) return finalise(x, pr, rm);

  // y exponent
  e = mathfloor(y.e / LOG_BASE);

  // If y is a small integer use the 'exponentiation by squaring' algorithm.
  if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }

  s = x.s;

  // if x is negative
  if (s < 0) {

    // if y is not an integer
    if (e < y.d.length - 1) return new Ctor(NaN);

    // Result is positive if x is negative and the last digit of integer y is even.
    if ((y.d[e] & 1) == 0) s = 1;

    // if x.eq(-1)
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s;
      return x;
    }
  }

  // Estimate result exponent.
  // x^y = 10^e,  where e = y * log10(x)
  // log10(x) = log10(x_significand) + x_exponent
  // log10(x_significand) = ln(x_significand) / ln(10)
  k = mathpow(+x, yn);
  e = k == 0 || !isFinite(k)
    ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))
    : new Ctor(k + '').e;

  // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

  // Overflow/underflow?
  if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);

  external = false;
  Ctor.rounding = x.s = 1;

  // Estimate the extra guard digits needed to ensure five correct rounding digits from
  // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
  // new Decimal(2.32456).pow('2087987436534566.46411')
  // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
  k = Math.min(12, (e + '').length);

  // r = x^y = exp(y*ln(x))
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);

  // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)
  if (r.d) {

    // Truncate to the required precision plus five rounding digits.
    r = finalise(r, pr + 5, 1);

    // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
    // the result.
    if (checkRoundingDigits(r.d, pr, rm)) {
      e = pr + 10;

      // Truncate to the increased precision plus five rounding digits.
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);

      // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }

  r.s = s;
  external = true;
  Ctor.rounding = rm;

  return finalise(r, pr, rm);
};


/*
 * Return a string representing the value of this Decimal rounded to `sd` significant digits
 * using rounding mode `rounding`.
 *
 * Return exponential notation if `sd` is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 */
P.toPrecision = function (sd, rm) {
  var str,
    x = this,
    Ctor = x.constructor;

  if (sd === void 0) {
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }

  return x.isNeg() && !x.isZero() ? '-' + str : str;
};


/*
 * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
 * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
 * omitted.
 *
 * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
 * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
 *
 * 'toSD() digits out of range: {sd}'
 * 'toSD() digits not an integer: {sd}'
 * 'toSD() rounding mode not an integer: {rm}'
 * 'toSD() rounding mode out of range: {rm}'
 *
 */
P.toSignificantDigits = P.toSD = function (sd, rm) {
  var x = this,
    Ctor = x.constructor;

  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  }

  return finalise(new Ctor(x), sd, rm);
};


/*
 * Return a string representing the value of this Decimal.
 *
 * Return exponential notation if this Decimal has a positive exponent equal to or greater than
 * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
 *
 */
P.toString = function () {
  var x = this,
    Ctor = x.constructor,
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

  return x.isNeg() && !x.isZero() ? '-' + str : str;
};


/*
 * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.
 *
 */
P.truncated = P.trunc = function () {
  return finalise(new this.constructor(this), this.e + 1, 1);
};


/*
 * Return a string representing the value of this Decimal.
 * Unlike `toString`, negative zero will include the minus sign.
 *
 */
P.valueOf = P.toJSON = function () {
  var x = this,
    Ctor = x.constructor,
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

  return x.isNeg() ? '-' + str : str;
};


// Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.


/*
 *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,
 *                           finiteToString, naturalExponential, naturalLogarithm
 *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,
 *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random
 *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm
 *  convertBase              toStringBinary, parseOther
 *  cos                      P.cos
 *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,
 *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,
 *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,
 *                           taylorSeries, atan2, parseOther
 *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,
 *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,
 *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,
 *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,
 *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,
 *                           P.truncated, divide, getLn10, getPi, naturalExponential,
 *                           naturalLogarithm, ceil, floor, round, trunc
 *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,
 *                           toStringBinary
 *  getBase10Exponent        P.minus, P.plus, P.times, parseOther
 *  getLn10                  P.logarithm, naturalLogarithm
 *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2
 *  getPrecision             P.precision, P.toFraction
 *  getZeroString            digitsToString, finiteToString
 *  intPow                   P.toPower, parseOther
 *  isOdd                    toLessThanHalfPi
 *  maxOrMin                 max, min
 *  naturalExponential       P.naturalExponential, P.toPower
 *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,
 *                           P.toPower, naturalExponential
 *  nonFiniteToString        finiteToString, toStringBinary
 *  parseDecimal             Decimal
 *  parseOther               Decimal
 *  sin                      P.sin
 *  taylorSeries             P.cosh, P.sinh, cos, sin
 *  toLessThanHalfPi         P.cos, P.sin
 *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal
 *  truncate                 intPow
 *
 *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,
 *                           naturalLogarithm, config, parseOther, random, Decimal
 */


function digitsToString(d) {
  var i, k, ws,
    indexOfLastWord = d.length - 1,
    str = '',
    w = d[0];

  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + '';
      k = LOG_BASE - ws.length;
      if (k) str += getZeroString(k);
      str += ws;
    }

    w = d[i];
    ws = w + '';
    k = LOG_BASE - ws.length;
    if (k) str += getZeroString(k);
  } else if (w === 0) {
    return '0';
  }

  // Remove trailing zeros of last w.
  for (; w % 10 === 0;) w /= 10;

  return str + w;
}


function checkInt32(i, min, max) {
  if (i !== ~~i || i < min || i > max) {
    throw Error(invalidArgument + i);
  }
}


/*
 * Check 5 rounding digits if `repeating` is null, 4 otherwise.
 * `repeating == null` if caller is `log` or `pow`,
 * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.
 */
function checkRoundingDigits(d, i, rm, repeating) {
  var di, k, r, rd;

  // Get the length of the first word of the array d.
  for (k = d[0]; k >= 10; k /= 10) --i;

  // Is the rounding digit in the first word of d?
  if (--i < 0) {
    i += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i + 1) / LOG_BASE);
    i %= LOG_BASE;
  }

  // i is the index (0 - 6) of the rounding digit.
  // E.g. if within the word 3487563 the first rounding digit is 5,
  // then i = 4, k = 1000, rd = 3487563 % 1000 = 563
  k = mathpow(10, LOG_BASE - i);
  rd = d[di] % k | 0;

  if (repeating == null) {
    if (i < 3) {
      if (i == 0) rd = rd / 100 | 0;
      else if (i == 1) rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&
        (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||
          (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i < 4) {
      if (i == 0) rd = rd / 1000 | 0;
      else if (i == 1) rd = rd / 100 | 0;
      else if (i == 2) rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k ||
      (!repeating && rm > 3) && rd + 1 == k / 2) &&
        (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
    }
  }

  return r;
}


// Convert string of `baseIn` to an array of numbers of `baseOut`.
// Eg. convertBase('255', 10, 16) returns [15, 15].
// Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
function convertBase(str, baseIn, baseOut) {
  var j,
    arr = [0],
    arrL,
    i = 0,
    strL = str.length;

  for (; i < strL;) {
    for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i++));
    for (j = 0; j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === void 0) arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }

  return arr.reverse();
}


/*
 * cos(x) = 1 - x^2/2! + x^4/4! - ...
 * |x| < pi/2
 *
 */
function cosine(Ctor, x) {
  var k, len, y;

  if (x.isZero()) return x;

  // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1
  // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1

  // Estimate the optimum number of times to use the argument reduction.
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = '2.3283064365386962890625e-10';
  }

  Ctor.precision += k;

  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));

  // Reverse argument reduction
  for (var i = k; i--;) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }

  Ctor.precision -= k;

  return x;
}


/*
 * Perform division in the specified base.
 */
var divide = (function () {

  // Assumes non-zero x and k, and hence non-zero result.
  function multiplyInteger(x, k, base) {
    var temp,
      carry = 0,
      i = x.length;

    for (x = x.slice(); i--;) {
      temp = x[i] * k + carry;
      x[i] = temp % base | 0;
      carry = temp / base | 0;
    }

    if (carry) x.unshift(carry);

    return x;
  }

  function compare(a, b, aL, bL) {
    var i, r;

    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }

    return r;
  }

  function subtract(a, b, aL, base) {
    var i = 0;

    // Subtract b from a.
    for (; aL--;) {
      a[aL] -= i;
      i = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i * base + a[aL] - b[aL];
    }

    // Remove leading zeros.
    for (; !a[0] && a.length > 1;) a.shift();
  }

  return function (x, y, pr, rm, dp, base) {
    var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,
      yL, yz,
      Ctor = x.constructor,
      sign = x.s == y.s ? 1 : -1,
      xd = x.d,
      yd = y.d;

    // Either NaN, Infinity or 0?
    if (!xd || !xd[0] || !yd || !yd[0]) {

      return new Ctor(// Return NaN if either NaN, or both Infinity or 0.
        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :

        // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
        xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);
    }

    if (base) {
      logBase = 1;
      e = x.e - y.e;
    } else {
      base = BASE;
      logBase = LOG_BASE;
      e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
    }

    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign);
    qd = q.d = [];

    // Result exponent may be one less than e.
    // The digit array of a Decimal from toStringBinary may have trailing zeros.
    for (i = 0; yd[i] == (xd[i] || 0); i++);

    if (yd[i] > (xd[i] || 0)) e--;

    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y.e) + 1;
    } else {
      sd = pr;
    }

    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {

      // Convert precision in number of base 10 digits to base 1e7 digits.
      sd = sd / logBase + 2 | 0;
      i = 0;

      // divisor < 1e7
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;

        // k is the carry.
        for (; (i < xL || k) && sd--; i++) {
          t = k * base + (xd[i] || 0);
          qd[i] = t / yd | 0;
          k = t % yd | 0;
        }

        more = k || i < xL;

      // divisor >= 1e7
      } else {

        // Normalise xd and yd so highest order digit of yd is >= base/2
        k = base / (yd[0] + 1) | 0;

        if (k > 1) {
          yd = multiplyInteger(yd, k, base);
          xd = multiplyInteger(xd, k, base);
          yL = yd.length;
          xL = xd.length;
        }

        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;

        // Add zeros to make remainder as long as divisor.
        for (; remL < yL;) rem[remL++] = 0;

        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];

        if (yd[1] >= base / 2) ++yd0;

        do {
          k = 0;

          // Compare divisor and remainder.
          cmp = compare(yd, rem, yL, remL);

          // If divisor < remainder.
          if (cmp < 0) {

            // Calculate trial digit, k.
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

            // k will be how many times the divisor goes into the current remainder.
            k = rem0 / yd0 | 0;

            //  Algorithm:
            //  1. product = divisor * trial digit (k)
            //  2. if product > remainder: product -= divisor, k--
            //  3. remainder -= product
            //  4. if product was < remainder at 2:
            //    5. compare new remainder and divisor
            //    6. If remainder > divisor: remainder -= divisor, k++

            if (k > 1) {
              if (k >= base) k = base - 1;

              // product = divisor * trial digit.
              prod = multiplyInteger(yd, k, base);
              prodL = prod.length;
              remL = rem.length;

              // Compare product and remainder.
              cmp = compare(prod, rem, prodL, remL);

              // product > remainder.
              if (cmp == 1) {
                k--;

                // Subtract divisor from product.
                subtract(prod, yL < prodL ? yz : yd, prodL, base);
              }
            } else {

              // cmp is -1.
              // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
              // to avoid it. If k is 1 there is a need to compare yd and rem again below.
              if (k == 0) cmp = k = 1;
              prod = yd.slice();
            }

            prodL = prod.length;
            if (prodL < remL) prod.unshift(0);

            // Subtract product from remainder.
            subtract(rem, prod, remL, base);

            // If product was < previous remainder.
            if (cmp == -1) {
              remL = rem.length;

              // Compare divisor and new remainder.
              cmp = compare(yd, rem, yL, remL);

              // If divisor < new remainder, subtract divisor from remainder.
              if (cmp < 1) {
                k++;

                // Subtract divisor from remainder.
                subtract(rem, yL < remL ? yz : yd, remL, base);
              }
            }

            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }    // if cmp === 1, k will be 0

          // Add the next digit, k, to the result array.
          qd[i++] = k;

          // Update the remainder.
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }

        } while ((xi++ < xL || rem[0] !== void 0) && sd--);

        more = rem[0] !== void 0;
      }

      // Leading zero?
      if (!qd[0]) qd.shift();
    }

    // logBase is 1 when divide is being used for base conversion.
    if (logBase == 1) {
      q.e = e;
      inexact = more;
    } else {

      // To calculate q.e, first get the number of digits of qd[0].
      for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
      q.e = i + e * logBase - 1;

      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }

    return q;
  };
})();


/*
 * Round `x` to `sd` significant digits using rounding mode `rm`.
 * Check for over/under-flow.
 */
 function finalise(x, sd, rm, isTruncated) {
  var digits, i, j, k, rd, roundUp, w, xd, xdi,
    Ctor = x.constructor;

  // Don't round if sd is null or undefined.
  out: if (sd != null) {
    xd = x.d;

    // Infinity/NaN.
    if (!xd) return x;

    // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
    // w: the word of xd containing rd, a base 1e7 number.
    // xdi: the index of w within xd.
    // digits: the number of digits of w.
    // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
    // they had leading zeros)
    // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).

    // Get the length of the first word of the digits array xd.
    for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
    i = sd - digits;

    // Is the rounding digit in the first word of xd?
    if (i < 0) {
      i += LOG_BASE;
      j = sd;
      w = xd[xdi = 0];

      // Get the rounding digit at index j of w.
      rd = w / mathpow(10, digits - j - 1) % 10 | 0;
    } else {
      xdi = Math.ceil((i + 1) / LOG_BASE);
      k = xd.length;
      if (xdi >= k) {
        if (isTruncated) {

          // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.
          for (; k++ <= xdi;) xd.push(0);
          w = rd = 0;
          digits = 1;
          i %= LOG_BASE;
          j = i - LOG_BASE + 1;
        } else {
          break out;
        }
      } else {
        w = k = xd[xdi];

        // Get the number of digits of w.
        for (digits = 1; k >= 10; k /= 10) digits++;

        // Get the index of rd within w.
        i %= LOG_BASE;

        // Get the index of rd within w, adjusted for leading zeros.
        // The number of leading zeros of w is given by LOG_BASE - digits.
        j = i - LOG_BASE + digits;

        // Get the rounding digit at index j of w.
        rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
      }
    }

    // Are there any non-zero digits after the rounding digit?
    isTruncated = isTruncated || sd < 0 ||
      xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));

    // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right
    // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression
    // will give 714.

    roundUp = rm < 4
      ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
      : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&

        // Check whether the digit to the left of the rounding digit is odd.
        ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||
          rm == (x.s < 0 ? 8 : 7));

    if (sd < 1 || !xd[0]) {
      xd.length = 0;
      if (roundUp) {

        // Convert sd to decimal places.
        sd -= x.e + 1;

        // 1, 0.1, 0.01, 0.001, 0.0001 etc.
        xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
        x.e = -sd || 0;
      } else {

        // Zero.
        xd[0] = x.e = 0;
      }

      return x;
    }

    // Remove excess digits.
    if (i == 0) {
      xd.length = xdi;
      k = 1;
      xdi--;
    } else {
      xd.length = xdi + 1;
      k = mathpow(10, LOG_BASE - i);

      // E.g. 56700 becomes 56000 if 7 is the rounding digit.
      // j > 0 means i > number of leading zeros of w.
      xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
    }

    if (roundUp) {
      for (;;) {

        // Is the digit to be rounded up in the first word of xd?
        if (xdi == 0) {

          // i will be the length of xd[0] before k is added.
          for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
          j = xd[0] += k;
          for (k = 1; j >= 10; j /= 10) k++;

          // if i != k the length has increased.
          if (i != k) {
            x.e++;
            if (xd[0] == BASE) xd[0] = 1;
          }

          break;
        } else {
          xd[xdi] += k;
          if (xd[xdi] != BASE) break;
          xd[xdi--] = 0;
          k = 1;
        }
      }
    }

    // Remove trailing zeros.
    for (i = xd.length; xd[--i] === 0;) xd.pop();
  }

  if (external) {

    // Overflow?
    if (x.e > Ctor.maxE) {

      // Infinity.
      x.d = null;
      x.e = NaN;

    // Underflow?
    } else if (x.e < Ctor.minE) {

      // Zero.
      x.e = 0;
      x.d = [0];
      // Ctor.underflow = true;
    } // else Ctor.underflow = false;
  }

  return x;
}


function finiteToString(x, isExp, sd) {
  if (!x.isFinite()) return nonFiniteToString(x);
  var k,
    e = x.e,
    str = digitsToString(x.d),
    len = str.length;

  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + '.' + str.slice(1);
    }

    str = str + (x.e < 0 ? 'e' : 'e+') + x.e;
  } else if (e < 0) {
    str = '0.' + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0) str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
  } else {
    if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len) str += '.';
      str += getZeroString(k);
    }
  }

  return str;
}


// Calculate the base 10 exponent from the base 1e7 exponent.
function getBase10Exponent(digits, e) {
  var w = digits[0];

  // Add the number of digits of the first word of the digits array.
  for ( e *= LOG_BASE; w >= 10; w /= 10) e++;
  return e;
}


function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {

    // Reset global state in case the exception is caught.
    external = true;
    if (pr) Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10), sd, 1, true);
}


function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}


function getPrecision(digits) {
  var w = digits.length - 1,
    len = w * LOG_BASE + 1;

  w = digits[w];

  // If non-zero...
  if (w) {

    // Subtract the number of trailing zeros of the last word.
    for (; w % 10 == 0; w /= 10) len--;

    // Add the number of digits of the first word.
    for (w = digits[0]; w >= 10; w /= 10) len++;
  }

  return len;
}


function getZeroString(k) {
  var zs = '';
  for (; k--;) zs += '0';
  return zs;
}


/*
 * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an
 * integer of type number.
 *
 * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.
 *
 */
function intPow(Ctor, x, n, pr) {
  var isTruncated,
    r = new Ctor(1),

    // Max n of 9007199254740991 takes 53 loop iterations.
    // Maximum digits array length; leaves [28, 34] guard digits.
    k = Math.ceil(pr / LOG_BASE + 4);

  external = false;

  for (;;) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k)) isTruncated = true;
    }

    n = mathfloor(n / 2);
    if (n === 0) {

      // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0) ++r.d[n];
      break;
    }

    x = x.times(x);
    truncate(x.d, k);
  }

  external = true;

  return r;
}


function isOdd(n) {
  return n.d[n.d.length - 1] & 1;
}


/*
 * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.
 */
function maxOrMin(Ctor, args, ltgt) {
  var y,
    x = new Ctor(args[0]),
    i = 0;

  for (; ++i < args.length;) {
    y = new Ctor(args[i]);
    if (!y.s) {
      x = y;
      break;
    } else if (x[ltgt](y)) {
      x = y;
    }
  }

  return x;
}


/*
 * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant
 * digits.
 *
 * Taylor/Maclaurin series.
 *
 * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
 *
 * Argument reduction:
 *   Repeat x = x / 32, k += 5, until |x| < 0.1
 *   exp(x) = exp(x / 2^k)^(2^k)
 *
 * Previously, the argument was initially reduced by
 * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
 * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
 * found to be slower than just dividing repeatedly by 32 as above.
 *
 * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
 * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
 * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
 *
 *  exp(Infinity)  = Infinity
 *  exp(-Infinity) = 0
 *  exp(NaN)       = NaN
 *  exp(0)        = 1
 *
 *  exp(x) is non-terminating for any finite, non-zero x.
 *
 *  The result will always be correctly rounded.
 *
 */
function naturalExponential(x, sd) {
  var denominator, guard, j, pow, sum, t, wpr,
    rep = 0,
    i = 0,
    k = 0,
    Ctor = x.constructor,
    rm = Ctor.rounding,
    pr = Ctor.precision;

  // 0/NaN/Infinity?
  if (!x.d || !x.d[0] || x.e > 17) {

    return new Ctor(x.d
      ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0
      : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }

  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }

  t = new Ctor(0.03125);

  // while abs(x) >= 0.1
  while (x.e > -2) {

    // x = x / 2^5
    x = x.times(t);
    k += 5;
  }

  // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision
  // necessary to ensure the first 4 rounding digits are correct.
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow = sum = new Ctor(1);
  Ctor.precision = wpr;

  for (;;) {
    pow = finalise(pow.times(x), wpr, 1);
    denominator = denominator.times(++i);
    t = sum.plus(divide(pow, denominator, wpr, 1));

    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      j = k;
      while (j--) sum = finalise(sum.times(sum), wpr, 1);

      // Check to see if the first 4 rounding digits are [49]999.
      // If so, repeat the summation with a higher precision, otherwise
      // e.g. with precision: 18, rounding: 1
      // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)
      // `wpr - guard` is the index of first rounding digit.
      if (sd == null) {

        if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow = t = new Ctor(1);
          i = 0;
          rep++;
        } else {
          return finalise(sum, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum;
      }
    }

    sum = t;
  }
}


/*
 * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant
 * digits.
 *
 *  ln(-n)        = NaN
 *  ln(0)         = -Infinity
 *  ln(-0)        = -Infinity
 *  ln(1)         = 0
 *  ln(Infinity)  = Infinity
 *  ln(-Infinity) = NaN
 *  ln(NaN)       = NaN
 *
 *  ln(n) (n != 1) is non-terminating.
 *
 */
function naturalLogarithm(y, sd) {
  var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,
    n = 1,
    guard = 10,
    x = y,
    xd = x.d,
    Ctor = x.constructor,
    rm = Ctor.rounding,
    pr = Ctor.precision;

  // Is x negative or Infinity, NaN, 0 or 1?
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }

  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }

  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);

  if (Math.abs(e = x.e) < 1.5e15) {

    // Argument reduction.
    // The series converges faster the closer the argument is to 1, so using
    // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
    // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
    // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
    // later be divided by this number, then separate out the power of 10 using
    // ln(a*10^b) = ln(a) + b*ln(10).

    // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
    //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
    // max n is 6 (gives 0.7 - 1.3)
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }

    e = x.e;

    if (c0 > 1) {
      x = new Ctor('0.' + c);
      e++;
    } else {
      x = new Ctor(c0 + '.' + c.slice(1));
    }
  } else {

    // The argument reduction method above may result in overflow if the argument y is a massive
    // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
    // function using ln(x*10^e) = ln(x) + e*ln(10).
    t = getLn10(Ctor, wpr + 2, pr).times(e + '');
    x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;

    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }

  // x1 is x reduced to a value near 1.
  x1 = x;

  // Taylor series.
  // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
  // where x = (y - 1)/(y + 1)    (|x| < 1)
  sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;

  for (;;) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));

    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      sum = sum.times(2);

      // Reverse the argument reduction. Check that e is not 0 because, besides preventing an
      // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.
      if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
      sum = divide(sum, new Ctor(n), wpr, 1);

      // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has
      // been repeated previously) and the first 4 rounding digits 9999?
      // If so, restart the summation with a higher precision, otherwise
      // e.g. with precision: 12, rounding: 1
      // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.
      // `wpr - guard` is the index of first rounding digit.
      if (sd == null) {
        if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum;
      }
    }

    sum = t;
    denominator += 2;
  }
}


// Infinity, NaN.
function nonFiniteToString(x) {
  // Unsigned.
  return String(x.s * x.s / 0);
}


/*
 * Parse the value of a new Decimal `x` from string `str`.
 */
function parseDecimal(x, str) {
  var e, i, len;

  // Decimal point?
  if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

  // Exponential form?
  if ((i = str.search(/e/i)) > 0) {

    // Determine exponent.
    if (e < 0) e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {

    // Integer.
    e = str.length;
  }

  // Determine leading zeros.
  for (i = 0; str.charCodeAt(i) === 48; i++);

  // Determine trailing zeros.
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len);
  str = str.slice(i, len);

  if (str) {
    len -= i;
    x.e = e = e - i - 1;
    x.d = [];

    // Transform base

    // e is the base 10 exponent.
    // i is where to slice str to get the first word of the digits array.
    i = (e + 1) % LOG_BASE;
    if (e < 0) i += LOG_BASE;

    if (i < len) {
      if (i) x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }

    for (; i--;) str += '0';
    x.d.push(+str);

    if (external) {

      // Overflow?
      if (x.e > x.constructor.maxE) {

        // Infinity.
        x.d = null;
        x.e = NaN;

      // Underflow?
      } else if (x.e < x.constructor.minE) {

        // Zero.
        x.e = 0;
        x.d = [0];
        // x.constructor.underflow = true;
      } // else x.constructor.underflow = false;
    }
  } else {

    // Zero.
    x.e = 0;
    x.d = [0];
  }

  return x;
}


/*
 * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.
 */
function parseOther(x, str) {
  var base, Ctor, divisor, i, isFloat, len, p, xd, xe;

  if (str.indexOf('_') > -1) {
    str = str.replace(/(\d)_(?=\d)/g, '$1');
    if (isDecimal.test(str)) return parseDecimal(x, str);
  } else if (str === 'Infinity' || str === 'NaN') {
    if (!+str) x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }

  if (isHex.test(str))  {
    base = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str))  {
    base = 2;
  } else if (isOctal.test(str))  {
    base = 8;
  } else {
    throw Error(invalidArgument + str);
  }

  // Is there a binary exponent part?
  i = str.search(/p/i);

  if (i > 0) {
    p = +str.slice(i + 1);
    str = str.substring(2, i);
  } else {
    str = str.slice(2);
  }

  // Convert `str` as an integer then divide the result by `base` raised to a power such that the
  // fraction part will be restored.
  i = str.indexOf('.');
  isFloat = i >= 0;
  Ctor = x.constructor;

  if (isFloat) {
    str = str.replace('.', '');
    len = str.length;
    i = len - i;

    // log[10](16) = 1.2041... , log[10](88) = 1.9444....
    divisor = intPow(Ctor, new Ctor(base), i, i * 2);
  }

  xd = convertBase(str, base, BASE);
  xe = xd.length - 1;

  // Remove trailing zeros.
  for (i = xe; xd[i] === 0; --i) xd.pop();
  if (i < 0) return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;

  // At what precision to perform the division to ensure exact conversion?
  // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)
  // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412
  // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.
  // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount
  // Therefore using 4 * the number of digits of str will always be enough.
  if (isFloat) x = divide(x, divisor, len * 4);

  // Multiply by the binary exponent part if present.
  if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;

  return x;
}


/*
 * sin(x) = x - x^3/3! + x^5/5! - ...
 * |x| < pi/2
 *
 */
function sine(Ctor, x) {
  var k,
    len = x.d.length;

  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }

  // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)
  // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)
  // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))

  // Estimate the optimum number of times to use the argument reduction.
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;

  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);

  // Reverse argument reduction
  var sin2_x,
    d5 = new Ctor(5),
    d16 = new Ctor(16),
    d20 = new Ctor(20);
  for (; k--;) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }

  return x;
}


// Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.
function taylorSeries(Ctor, n, x, y, isHyperbolic) {
  var j, t, u, x2,
    pr = Ctor.precision,
    k = Math.ceil(pr / LOG_BASE);

  external = false;
  x2 = x.times(x);
  u = new Ctor(y);

  for (;;) {
    t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y);

    if (t.d[k] !== void 0) {
      for (j = k; t.d[j] === u.d[j] && j--;);
      if (j == -1) break;
    }

    j = u;
    u = y;
    y = t;
    t = j;
  }

  external = true;
  t.d.length = k + 1;

  return t;
}


// Exponent e must be positive and non-zero.
function tinyPow(b, e) {
  var n = b;
  while (--e) n *= b;
  return n;
}


// Return the absolute value of `x` reduced to less than or equal to half pi.
function toLessThanHalfPi(Ctor, x) {
  var t,
    isNeg = x.s < 0,
    pi = getPi(Ctor, Ctor.precision, 1),
    halfPi = pi.times(0.5);

  x = x.abs();

  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }

  t = x.divToInt(pi);

  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t.times(pi));

    // 0 <= x < pi
    if (x.lte(halfPi)) {
      quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);
      return x;
    }

    quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);
  }

  return x.minus(pi).abs();
}


/*
 * Return the value of Decimal `x` as a string in base `baseOut`.
 *
 * If the optional `sd` argument is present include a binary exponent suffix.
 */
function toStringBinary(x, baseOut, sd, rm) {
  var base, e, i, k, len, roundUp, str, xd, y,
    Ctor = x.constructor,
    isExp = sd !== void 0;

  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }

  if (!x.isFinite()) {
    str = nonFiniteToString(x);
  } else {
    str = finiteToString(x);
    i = str.indexOf('.');

    // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:
    // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))
    // minBinaryExponent = floor(decimalExponent * log[2](10))
    // log[2](10) = 3.321928094887362347870319429489390175864

    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }

    // Convert the number as an integer then divide the result by its base raised to a power such
    // that the fraction part will be restored.

    // Non-integer.
    if (i >= 0) {
      str = str.replace('.', '');
      y = new Ctor(1);
      y.e = str.length - i;
      y.d = convertBase(finiteToString(y), 10, base);
      y.e = y.d.length;
    }

    xd = convertBase(str, 10, base);
    e = len = xd.length;

    // Remove trailing zeros.
    for (; xd[--len] == 0;) xd.pop();

    if (!xd[0]) {
      str = isExp ? '0p+0' : '0';
    } else {
      if (i < 0) {
        e--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e;
        x = divide(x, y, sd, rm, 0, base);
        xd = x.d;
        e = x.e;
        roundUp = inexact;
      }

      // The rounding digit, i.e. the digit after the digit that may be rounded up.
      i = xd[sd];
      k = base / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;

      roundUp = rm < 4
        ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))
        : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||
          rm === (x.s < 0 ? 8 : 7));

      xd.length = sd;

      if (roundUp) {

        // Rounding up may mean the previous digit has to be rounded up and so on.
        for (; ++xd[--sd] > base - 1;) {
          xd[sd] = 0;
          if (!sd) {
            ++e;
            xd.unshift(1);
          }
        }
      }

      // Determine trailing zeros.
      for (len = xd.length; !xd[len - 1]; --len);

      // E.g. [4, 11, 15] becomes 4bf.
      for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);

      // Add binary exponent suffix?
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i = baseOut == 16 ? 4 : 3;
            for (--len; len % i; len++) str += '0';
            xd = convertBase(str, base, baseOut);
            for (len = xd.length; !xd[len - 1]; --len);

            // xd[0] will always be be 1
            for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);
          } else {
            str = str.charAt(0) + '.' + str.slice(1);
          }
        }

        str =  str + (e < 0 ? 'p' : 'p+') + e;
      } else if (e < 0) {
        for (; ++e;) str = '0' + str;
        str = '0.' + str;
      } else {
        if (++e > len) for (e -= len; e-- ;) str += '0';
        else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;
  }

  return x.s < 0 ? '-' + str : str;
}


// Does not strip trailing zeros.
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}


// Decimal methods


/*
 *  abs
 *  acos
 *  acosh
 *  add
 *  asin
 *  asinh
 *  atan
 *  atanh
 *  atan2
 *  cbrt
 *  ceil
 *  clamp
 *  clone
 *  config
 *  cos
 *  cosh
 *  div
 *  exp
 *  floor
 *  hypot
 *  ln
 *  log
 *  log2
 *  log10
 *  max
 *  min
 *  mod
 *  mul
 *  pow
 *  random
 *  round
 *  set
 *  sign
 *  sin
 *  sinh
 *  sqrt
 *  sub
 *  sum
 *  tan
 *  tanh
 *  trunc
 */


/*
 * Return a new Decimal whose value is the absolute value of `x`.
 *
 * x {number|string|Decimal}
 *
 */
function abs(x) {
  return new this(x).abs();
}


/*
 * Return a new Decimal whose value is the arccosine in radians of `x`.
 *
 * x {number|string|Decimal}
 *
 */
function acos(x) {
  return new this(x).acos();
}


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function acosh(x) {
  return new this(x).acosh();
}


/*
 * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 * y {number|string|Decimal}
 *
 */
function add(x, y) {
  return new this(x).plus(y);
}


/*
 * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 *
 */
function asin(x) {
  return new this(x).asin();
}


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function asinh(x) {
  return new this(x).asinh();
}


/*
 * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 *
 */
function atan(x) {
  return new this(x).atan();
}


/*
 * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
 * `precision` significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function atanh(x) {
  return new this(x).atanh();
}


/*
 * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
 * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
 *
 * Domain: [-Infinity, Infinity]
 * Range: [-pi, pi]
 *
 * y {number|string|Decimal} The y-coordinate.
 * x {number|string|Decimal} The x-coordinate.
 *
 * atan2(0, -0)               = pi
 * atan2(0, +0)               = 0
 * atan2(0, -x)               = pi for x > 0
 * atan2(0, x)                = 0 for x > 0
 * atan2(-y, 0)               = -pi/2 for y > 0
 * atan2(y, 0)                = pi/2 for y > 0
 * atan2(y, -Infinity)        = pi for finite y > 0
 * atan2(y, +Infinity)        = 0 for finite y > 0
 * atan2(Infinity, x)         = pi/2 for finite x
 * atan2(Infinity, -Infinity) = 3*pi/4
 * atan2(Infinity, +Infinity) = pi/4
 * atan2(NaN, x) = NaN
 * atan2(y, NaN) = NaN
 *
 */
function atan2(y, x) {
  y = new this(y);
  x = new this(x);
  var r,
    pr = this.precision,
    rm = this.rounding,
    wpr = pr + 4;

  // Either NaN
  if (!y.s || !x.s) {
    r = new this(NaN);

  // Both Infinity
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;

  // x is Infinity or y is 0
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;

  // y is Infinity or x is 0
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;

  // Both non-zero and finite
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide(y, x, wpr, 1));
  }

  return r;
}


/*
 * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 *
 */
function cbrt(x) {
  return new this(x).cbrt();
}


/*
 * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.
 *
 * x {number|string|Decimal}
 *
 */
function ceil(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}


/*
 * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.
 *
 * x {number|string|Decimal}
 * min {number|string|Decimal}
 * max {number|string|Decimal}
 *
 */
function clamp(x, min, max) {
  return new this(x).clamp(min, max);
}


/*
 * Configure global settings for a Decimal constructor.
 *
 * `obj` is an object with one or more of the following properties,
 *
 *   precision  {number}
 *   rounding   {number}
 *   toExpNeg   {number}
 *   toExpPos   {number}
 *   maxE       {number}
 *   minE       {number}
 *   modulo     {number}
 *   crypto     {boolean|number}
 *   defaults   {true}
 *
 * E.g. Decimal.config({ precision: 20, rounding: 4 })
 *
 */
function config(obj) {
  if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
  var i, p, v,
    useDefaults = obj.defaults === true,
    ps = [
      'precision', 1, MAX_DIGITS,
      'rounding', 0, 8,
      'toExpNeg', -EXP_LIMIT, 0,
      'toExpPos', 0, EXP_LIMIT,
      'maxE', 0, EXP_LIMIT,
      'minE', -EXP_LIMIT, 0,
      'modulo', 0, 9
    ];

  for (i = 0; i < ps.length; i += 3) {
    if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
      else throw Error(invalidArgument + p + ': ' + v);
    }
  }

  if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != 'undefined' && crypto &&
          (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ': ' + v);
    }
  }

  return this;
}


/*
 * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function cos(x) {
  return new this(x).cos();
}


/*
 * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function cosh(x) {
  return new this(x).cosh();
}


/*
 * Create and return a Decimal constructor with the same configuration properties as this Decimal
 * constructor.
 *
 */
function clone(obj) {
  var i, p, ps;

  /*
   * The Decimal constructor and exported function.
   * Return a new Decimal instance.
   *
   * v {number|string|Decimal} A numeric value.
   *
   */
  function Decimal(v) {
    var e, i, t,
      x = this;

    // Decimal called without new.
    if (!(x instanceof Decimal)) return new Decimal(v);

    // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
    // which points to Object.
    x.constructor = Decimal;

    // Duplicate.
    if (isDecimalInstance(v)) {
      x.s = v.s;

      if (external) {
        if (!v.d || v.e > Decimal.maxE) {

          // Infinity.
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal.minE) {

          // Zero.
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }

      return;
    }

    t = typeof v;

    if (t === 'number') {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }

      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }

      // Fast path for small integers.
      if (v === ~~v && v < 1e7) {
        for (e = 0, i = v; i >= 10; i /= 10) e++;

        if (external) {
          if (e > Decimal.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e < Decimal.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e;
            x.d = [v];
          }
        } else {
          x.e = e;
          x.d = [v];
        }

        return;

      // Infinity, NaN.
      } else if (v * 0 !== 0) {
        if (!v) x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }

      return parseDecimal(x, v.toString());

    } else if (t !== 'string') {
      throw Error(invalidArgument + v);
    }

    // Minus sign?
    if ((i = v.charCodeAt(0)) === 45) {
      v = v.slice(1);
      x.s = -1;
    } else {
      // Plus sign?
      if (i === 43) v = v.slice(1);
      x.s = 1;
    }

    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
  }

  Decimal.prototype = P;

  Decimal.ROUND_UP = 0;
  Decimal.ROUND_DOWN = 1;
  Decimal.ROUND_CEIL = 2;
  Decimal.ROUND_FLOOR = 3;
  Decimal.ROUND_HALF_UP = 4;
  Decimal.ROUND_HALF_DOWN = 5;
  Decimal.ROUND_HALF_EVEN = 6;
  Decimal.ROUND_HALF_CEIL = 7;
  Decimal.ROUND_HALF_FLOOR = 8;
  Decimal.EUCLID = 9;

  Decimal.config = Decimal.set = config;
  Decimal.clone = clone;
  Decimal.isDecimal = isDecimalInstance;

  Decimal.abs = abs;
  Decimal.acos = acos;
  Decimal.acosh = acosh;        // ES6
  Decimal.add = add;
  Decimal.asin = asin;
  Decimal.asinh = asinh;        // ES6
  Decimal.atan = atan;
  Decimal.atanh = atanh;        // ES6
  Decimal.atan2 = atan2;
  Decimal.cbrt = cbrt;          // ES6
  Decimal.ceil = ceil;
  Decimal.clamp = clamp;
  Decimal.cos = cos;
  Decimal.cosh = cosh;          // ES6
  Decimal.div = div;
  Decimal.exp = exp;
  Decimal.floor = floor;
  Decimal.hypot = hypot;        // ES6
  Decimal.ln = ln;
  Decimal.log = log;
  Decimal.log10 = log10;        // ES6
  Decimal.log2 = log2;          // ES6
  Decimal.max = max;
  Decimal.min = min;
  Decimal.mod = mod;
  Decimal.mul = mul;
  Decimal.pow = pow;
  Decimal.random = random;
  Decimal.round = round;
  Decimal.sign = sign;          // ES6
  Decimal.sin = sin;
  Decimal.sinh = sinh;          // ES6
  Decimal.sqrt = sqrt;
  Decimal.sub = sub;
  Decimal.sum = sum;
  Decimal.tan = tan;
  Decimal.tanh = tanh;          // ES6
  Decimal.trunc = trunc;        // ES6

  if (obj === void 0) obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];
      for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
    }
  }

  Decimal.config(obj);

  return Decimal;
}


/*
 * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 * y {number|string|Decimal}
 *
 */
function div(x, y) {
  return new this(x).div(y);
}


/*
 * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} The power to which to raise the base of the natural log.
 *
 */
function exp(x) {
  return new this(x).exp();
}


/*
 * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.
 *
 * x {number|string|Decimal}
 *
 */
function floor(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}


/*
 * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,
 * rounded to `precision` significant digits using rounding mode `rounding`.
 *
 * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)
 *
 * arguments {number|string|Decimal}
 *
 */
function hypot() {
  var i, n,
    t = new this(0);

  external = false;

  for (i = 0; i < arguments.length;) {
    n = new this(arguments[i++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }

  external = true;

  return t.sqrt();
}


/*
 * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),
 * otherwise return false.
 *
 */
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}


/*
 * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 *
 */
function ln(x) {
  return new this(x).ln();
}


/*
 * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base
 * is specified, rounded to `precision` significant digits using rounding mode `rounding`.
 *
 * log[y](x)
 *
 * x {number|string|Decimal} The argument of the logarithm.
 * y {number|string|Decimal} The base of the logarithm.
 *
 */
function log(x, y) {
  return new this(x).log(y);
}


/*
 * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 *
 */
function log2(x) {
  return new this(x).log(2);
}


/*
 * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 *
 */
function log10(x) {
  return new this(x).log(10);
}


/*
 * Return a new Decimal whose value is the maximum of the arguments.
 *
 * arguments {number|string|Decimal}
 *
 */
function max() {
  return maxOrMin(this, arguments, 'lt');
}


/*
 * Return a new Decimal whose value is the minimum of the arguments.
 *
 * arguments {number|string|Decimal}
 *
 */
function min() {
  return maxOrMin(this, arguments, 'gt');
}


/*
 * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits
 * using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 * y {number|string|Decimal}
 *
 */
function mod(x, y) {
  return new this(x).mod(y);
}


/*
 * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 * y {number|string|Decimal}
 *
 */
function mul(x, y) {
  return new this(x).mul(y);
}


/*
 * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} The base.
 * y {number|string|Decimal} The exponent.
 *
 */
function pow(x, y) {
  return new this(x).pow(y);
}


/*
 * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with
 * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros
 * are produced).
 *
 * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.
 *
 */
function random(sd) {
  var d, e, k, n,
    i = 0,
    r = new this(1),
    rd = [];

  if (sd === void 0) sd = this.precision;
  else checkInt32(sd, 1, MAX_DIGITS);

  k = Math.ceil(sd / LOG_BASE);

  if (!this.crypto) {
    for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;

  // Browsers supporting crypto.getRandomValues.
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));

    for (; i < k;) {
      n = d[i];

      // 0 <= n < 4294967296
      // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).
      if (n >= 4.29e9) {
        d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {

        // 0 <= n <= 4289999999
        // 0 <= (n % 1e7) <= 9999999
        rd[i++] = n % 1e7;
      }
    }

  // Node.js supporting crypto.randomBytes.
  } else if (crypto.randomBytes) {

    // buffer
    d = crypto.randomBytes(k *= 4);

    for (; i < k;) {

      // 0 <= n < 2147483648
      n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);

      // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).
      if (n >= 2.14e9) {
        crypto.randomBytes(4).copy(d, i);
      } else {

        // 0 <= n <= 2139999999
        // 0 <= (n % 1e7) <= 9999999
        rd.push(n % 1e7);
        i += 4;
      }
    }

    i = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }

  k = rd[--i];
  sd %= LOG_BASE;

  // Convert trailing digits to zeros according to sd.
  if (k && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i] = (k / n | 0) * n;
  }

  // Remove trailing words which are zero.
  for (; rd[i] === 0; i--) rd.pop();

  // Zero?
  if (i < 0) {
    e = 0;
    rd = [0];
  } else {
    e = -1;

    // Remove leading words which are zero and adjust exponent accordingly.
    for (; rd[0] === 0; e -= LOG_BASE) rd.shift();

    // Count the digits of the first word of rd to determine leading zeros.
    for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;

    // Adjust the exponent for leading zeros of the first word of rd.
    if (k < LOG_BASE) e -= LOG_BASE - k;
  }

  r.e = e;
  r.d = rd;

  return r;
}


/*
 * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.
 *
 * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).
 *
 * x {number|string|Decimal}
 *
 */
function round(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}


/*
 * Return
 *   1    if x > 0,
 *  -1    if x < 0,
 *   0    if x is 0,
 *  -0    if x is -0,
 *   NaN  otherwise
 *
 * x {number|string|Decimal}
 *
 */
function sign(x) {
  x = new this(x);
  return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;
}


/*
 * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits
 * using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function sin(x) {
  return new this(x).sin();
}


/*
 * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function sinh(x) {
  return new this(x).sinh();
}


/*
 * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 *
 */
function sqrt(x) {
  return new this(x).sqrt();
}


/*
 * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits
 * using rounding mode `rounding`.
 *
 * x {number|string|Decimal}
 * y {number|string|Decimal}
 *
 */
function sub(x, y) {
  return new this(x).sub(y);
}


/*
 * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * Only the result is rounded, not the intermediate calculations.
 *
 * arguments {number|string|Decimal}
 *
 */
function sum() {
  var i = 0,
    args = arguments,
    x = new this(args[i]);

  external = false;
  for (; x.s && ++i < args.length;) x = x.plus(args[i]);
  external = true;

  return finalise(x, this.precision, this.rounding);
}


/*
 * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
 * digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function tan(x) {
  return new this(x).tan();
}


/*
 * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
 * significant digits using rounding mode `rounding`.
 *
 * x {number|string|Decimal} A value in radians.
 *
 */
function tanh(x) {
  return new this(x).tanh();
}


/*
 * Return a new Decimal whose value is `x` truncated to an integer.
 *
 * x {number|string|Decimal}
 *
 */
function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}


P[Symbol.for('nodejs.util.inspect.custom')] = P.toString;
P[Symbol.toStringTag] = 'Decimal';

// Create and configure initial Decimal constructor.
var Decimal = P.constructor = clone(DEFAULTS);

// Create the internal constants from their string values.
LN10 = new Decimal(LN10);
PI = new Decimal(PI);

var localizedFormat$1 = {exports: {}};

(function (module, exports) {
	!function(e,t){module.exports=t();}(commonjsGlobal,(function(){var e={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"};return function(t,o,n){var r=o.prototype,i=r.format;n.en.formats=e,r.format=function(t){void 0===t&&(t="YYYY-MM-DDTHH:mm:ssZ");var o=this.$locale().formats,n=function(t,o){return t.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,n,r){var i=r&&r.toUpperCase();return n||o[r]||e[r]||o[i].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,o){return t||o.slice(1)}))}))}(t,void 0===o?{}:o);return i.call(this,n)};}}));
} (localizedFormat$1));

const localizedFormat = localizedFormat$1.exports;

const getExpireDateText = (expireDate) => {
  const expires = expireDate ? dayjs(expireDate) : null;
  if (!expires)
    return "No supply";
  const now = dayjs();
  const diff = expires.diff(dayjs(), "day");
  const expired = expires.toDate().getTime() < now.toDate().getTime() ? "Expired" : null;
  return expired || (diff > 0 ? `${diff} ${diff === 1 ? "day" : "days"}` : "today");
};
const isExpired = (expireDate) => {
  const expires = expireDate ? dayjs(expireDate) : null;
  if (!expires)
    return false;
  const now = dayjs();
  return expires.toDate().getTime() < now.toDate().getTime();
};

const messages$3 = defineMessages({
  addAddress: {
    id: "page.customers.form.addresses.add",
    defaultMessage: "Add address"
  },
  nameLabel: {
    id: "page.customers.form.customerName",
    defaultMessage: "Customer name"
  },
  internalIdLabel: {
    id: "page.customers.form.internalId",
    defaultMessage: "Internal ID"
  },
  externalIdLabel: {
    id: "page.customers.form.externalId",
    defaultMessage: "External ID"
  },
  addresses: {
    id: "page.customers.form.addresses.label",
    defaultMessage: "Addresses"
  },
  addAddressLabel: {
    id: "page.customers.form.addresses.select.label",
    defaultMessage: "Select address to add"
  },
  assetNameLabel: {
    id: "page.customers.form.assetName.label",
    defaultMessage: "Asset name"
  },
  assetAmountMintedLabel: {
    id: "page.customers.form.asset.amountMinted.label",
    defaultMessage: "Amount of Units Minted"
  },
  assetIdIntLabel: {
    id: "page.customers.form.assetId.int",
    defaultMessage: "int"
  },
  assetIdHexLabel: {
    id: "page.customers.form.assetId.hex",
    defaultMessage: "hex"
  },
  assetIdLabel: {
    id: "page.customers.form.assetId.label",
    defaultMessage: "Asset ID"
  },
  controllerName: {
    id: "page.customers.form.controller.label",
    defaultMessage: "Controller name"
  },
  controllerAddress: {
    id: "page.customers.form.controller.address",
    defaultMessage: "Controller address"
  },
  supplyExpireDate: {
    id: "page.customers.form.controller.supplyExpireDate",
    defaultMessage: "Supply expire date"
  },
  state: {
    id: "page.customers.form.state",
    defaultMessage: "State"
  },
  submit: {
    id: "page.customers.form.submit",
    defaultMessage: "Submit and Initialize"
  },
  next: {
    id: "page.customers.form.next",
    defaultMessage: "Next"
  },
  createNewSupply: {
    id: "page.customers.form.createNewSupply",
    defaultMessage: "Create new supply"
  },
  updateSupply: {
    id: "page.customers.form.updateSupplyDate",
    defaultMessage: "Update supply expire date"
  },
  updateSupplyDesc: {
    id: "page.customers.form.updateSupplyDate.description",
    defaultMessage: "To finish updating supply expire date confirm transaction in Tx.Mobile"
  },
  activate: {
    id: "page.customers.form.activate",
    defaultMessage: "Activate"
  },
  initialize: {
    id: "page.customers.form.initialize",
    defaultMessage: "Initialize"
  },
  createError: {
    id: "page.customers.form.create.error",
    defaultMessage: "Failed to create a customer"
  },
  updateError: {
    id: "page.customers.form.updateSupply.error",
    defaultMessage: "Failed to update supply expire date"
  },
  updateErrorDesc: {
    id: "page.customers.form.updateSupply.desc",
    defaultMessage: "Try again later"
  },
  nextError: {
    id: "page.customers.form.create.nextError",
    defaultMessage: "Failed to update a customer"
  },
  nextDescError: {
    id: "page.customers.form.create.nextError.desc",
    defaultMessage: "Try again in a few seconds"
  },
  tryLater: {
    id: "page.customers.form.create.error.desc",
    defaultMessage: "Try again later"
  }
});

const formWrapper = "_formWrapper_1t20n_1";
const selectWrapper = "_selectWrapper_1t20n_15";
const assetIdAddon = "_assetIdAddon_1t20n_27";
const assetIdSize = "_assetIdSize_1t20n_37";
const field = "_field_1t20n_45";
const updateSupply = "_updateSupply_1t20n_53";
const actionButton = "_actionButton_1t20n_61";
const classes$3 = {
	formWrapper: formWrapper,
	selectWrapper: selectWrapper,
	assetIdAddon: assetIdAddon,
	assetIdSize: assetIdSize,
	field: field,
	updateSupply: updateSupply,
	actionButton: actionButton
};

dayjs.extend(localizedFormat);
const layout = {
  labelCol: {
    span: 8
  },
  wrapperCol: {
    span: 16
  }
};
const statesList = {
  draft: {
    label: "Draft",
    value: "draft"
  },
  new: {
    label: "New",
    value: "new"
  },
  incomplete: {
    label: "Incomplete",
    value: "incomplete"
  },
  active: {
    label: "Active",
    value: "active"
  }
};
const states = Object.values(statesList);
const debounce = (func, wait) => {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
};
const nameRules = [{
  required: true,
  message: "Required"
}, {
  max: 50,
  min: 2,
  message: "Must be between 2 and 50 characters"
}];
const internalIdRules = [{
  min: 2,
  max: 10,
  message: "Must be between 2 and 10 characters"
}, {
  required: true,
  message: "Required"
}, {
  pattern: /^[a-zA-Z0-9-_.]+$/,
  message: "Internal ID can only contain latin characters, numbers and - _ . symbols"
}];
const externalIdRules = [{
  min: 1,
  max: 10,
  message: "Must be between 2 and 10 characters"
}, {
  required: false,
  pattern: /^[a-zA-Z0-9-_.]+$/,
  message: "External ID can only contain latin characters, numbers and - _ . symbols"
}];
const CustomersForm = ({
  customer: providedCustomer,
  onClose
}) => {
  const [form] = Form$1.useForm();
  const intl = useIntl();
  const [notify, contextHolder] = notification$1.useNotification();
  const addresses = Form$1.useWatch("addresses", form);
  const name = Form$1.useWatch("name", form);
  const internalId = Form$1.useWatch("id", form);
  const [currentAddress] = useCurrentAddress();
  const [customers, updateCustomers] = useCustomers();
  const [addressToAdd, setAddressToAdd] = react.exports.useState(null);
  const [isLoading, setLoading] = react.exports.useState(false);
  const [isSaving, setSaving] = react.exports.useState(false);
  const [isValidating, setValidating] = react.exports.useState(false);
  const [localCustomerId, setLocalCustomerId] = react.exports.useState(null);
  const [isNextAvailable, setNextAvailable] = react.exports.useState(false);
  const [nextDelayed, setNextDelayed] = react.exports.useState(false);
  const [modal, modalContext] = Modal$1.useModal();
  const customer = react.exports.useMemo(() => providedCustomer || (localCustomerId ? customers[localCustomerId] : void 0), [customers, localCustomerId, providedCustomer]);
  react.exports.useEffect(() => {
    form.resetFields();
  }, [customer, form]);
  const createCustomer = async () => {
    const valid = await form.validateFields();
    if (!valid)
      return;
    const values = form.getFieldsValue();
    try {
      return request.post("/customers", {
        customerName: values.name,
        internalId: values.id,
        externalId: values.externalId,
        walletAddress: currentAddress
      });
    } catch (error) {
      notify.error({
        message: intl.formatMessage(messages$3.createError),
        description: error?.message ?? intl.formatMessage(messages$3.tryLater),
        placement: "bottomRight"
      });
    }
  };
  const updateCustomer = async () => {
    const valid = await form.validateFields();
    if (!valid)
      return;
    const values = form.getFieldsValue();
    const touched = form.isFieldsTouched();
    if (touched) {
      return request.patch(`/customers/${customer?.id}`, {
        customerName: values.name,
        externalId: values.externalId
      });
    }
    return true;
  };
  react.exports.useEffect(() => {
    if (isNextAvailable)
      setNextDelayed(false);
  }, [isNextAvailable]);
  const next = async (id) => {
    const stepResponse = await request.post("/next", {
      customerId: id || customer.id
    }).catch(() => {
      notify.error({
        message: intl.formatMessage(messages$3.nextError),
        description: intl.formatMessage(messages$3.nextDescError),
        placement: "bottomRight"
      });
      setLoading(false);
      return null;
    });
    if (!stepResponse) {
      setLoading(false);
      return;
    }
    updateCustomers((prev) => ({
      ...prev,
      [stepResponse.id]: stepResponse
    }));
    setNextAvailable(false);
    setLoading(false);
  };
  const onFinish = async () => {
    try {
      setLoading(true);
      if (!customer?.id) {
        const createResponse = await createCustomer();
        if (!createResponse) {
          setLoading(false);
          return;
        }
        updateCustomers((prev) => ({
          ...prev,
          [createResponse.id]: createResponse
        }));
        setLocalCustomerId(createResponse.id);
        await next(createResponse.id);
      } else {
        if (isSupplyExpired && customer?.status === "active") {
          const newResponse = await request.post("/supplies/new", {
            customerId: customer.id
          }).catch(() => {
            notify.error({
              message: intl.formatMessage(messages$3.nextError),
              description: intl.formatMessage(messages$3.nextDescError),
              placement: "bottomRight"
            });
            return null;
          });
          if (!newResponse) {
            setLoading(false);
            return;
          }
          updateCustomers((prev) => ({
            ...prev,
            [customer?.id]: newResponse
          }));
          setNextAvailable(false);
          setLoading(false);
          return;
        }
        await next();
      }
      setLoading(false);
    } catch {
      setLoading(false);
    }
  };
  const onAddressChange = react.exports.useCallback(debounce((fieldName) => {
    form.setFieldValue(["addresses", ...fieldName], "0");
  }, 200), []);
  const onSave = async () => {
    try {
      setSaving(true);
      if (customer?.id) {
        const updated = await updateCustomer();
        if (!updated)
          return;
        if (typeof updated === "object") {
          const updCustomer = "customer" in updated ? updated.customer : updated;
          updateCustomers((prev) => ({
            ...prev,
            [updCustomer.id]: updCustomer
          }));
        }
      } else {
        const created = await createCustomer();
        if (!created)
          return;
        updateCustomers((prev) => ({
          ...prev,
          [created.id]: created
        }));
      }
      setSaving(false);
      onClose();
    } catch {
      setSaving(false);
    }
  };
  const onCancel = () => {
    if (form.isFieldsTouched()) {
      modal.confirm({
        title: "Confirm",
        icon: /* @__PURE__ */ jsx$1(ExclamationCircleOutlined$1, {}),
        content: "Some fields were changed but not saved. Do you want to close anyway?",
        okText: "Yes",
        onOk: () => {
          onClose();
        },
        cancelText: "No"
      });
    } else {
      onClose();
    }
  };
  const delayTimerId = react.exports.useRef(null);
  const checkNext = async () => {
    const resp = await request.post("/next/isAllowed", {
      customerId: customer?.id
    });
    if (!customer?.transactions?.supplyTransaction && customer?.transactions?.mintTransaction && resp.allowed) {
      setNextDelayed(true);
      delayTimerId.current = setTimeout(() => setNextAvailable(true), 1e4);
    } else {
      setNextAvailable(resp.allowed);
    }
    return resp;
  };
  react.exports.useEffect(() => () => {
    clearTimeout(delayTimerId.current);
  }, []);
  react.exports.useEffect(() => {
    if (!isNextAvailable && customer?.id)
      checkNext();
    const timerId = setInterval(async () => {
      if (!customer?.id || customer?.status === "active" || isNextAvailable || nextDelayed)
        return;
      const resp = await checkNext();
      if (resp.allowed)
        clearInterval(timerId);
    }, 3e3);
    return () => clearInterval(timerId);
  }, [customer?.id, customer?.status, isNextAvailable, nextDelayed]);
  const nameErrors = form.getFieldError("name").filter(Boolean).length;
  const idErrors = form.getFieldError("id").filter(Boolean).length;
  const extIdErrors = form.getFieldError("externalId").filter(Boolean).length;
  react.exports.useEffect(() => {
    if (!customer?.id) {
      if (name && internalId && !idErrors && !nameErrors && !extIdErrors && !isValidating) {
        setNextAvailable(true);
      } else {
        setNextAvailable(false);
      }
    }
  }, [customer?.id, form, name, internalId, nameErrors, isValidating, idErrors, extIdErrors]);
  const isUnique = async (str) => {
    if (!str)
      return true;
    const resp = await request.get(`/customers/${str}/unique`, {
      headers: {
        "ngrok-skip-browser-warning": "1"
      }
    });
    return resp.unique;
  };
  const isSupplyExpired = customer?.status === "active" && isExpired(dayjs(customer?.supply?.endDate).toISOString());
  const isAssetCreated = Boolean(customer?.transactions?.controllerTransaction || customer?.transactions?.assetTransaction && isNextAvailable);
  const isControllerCreated = Boolean(customer?.transactions?.controllerAssetTransaction || customer?.transactions?.controllerTransaction && isNextAvailable);
  const isControllerAssetChanged = Boolean(customer?.transactions?.supplyTransaction || customer?.transactions?.controllerAssetTransaction && isNextAvailable);
  const areUnitsCreated = Boolean(customer?.transactions?.supplyTransaction || customer?.transactions?.controllerAssetTransaction && isNextAvailable);
  const isSupplyCreated = Boolean(customer?.status === "active" || customer?.transactions?.supplyTransaction && isNextAvailable);
  const steps = [!customer?.id, !customer?.transactions?.assetTransaction && customer?.id, customer?.transactions?.assetTransaction && !customer?.transactions?.controllerTransaction, customer?.transactions?.controllerTransaction && !customer?.transactions?.mintTransaction, customer?.transactions?.mintTransaction && (!customer?.transactions?.supplyTransaction || isSupplyExpired), customer?.status !== "active" && customer?.transactions?.supplyTransaction];
  const getButtonText = () => {
    if (!customer?.id) {
      return messages$3.submit;
    }
    if ((customer?.transactions?.supplyTransaction || isSupplyCreated) && customer?.status !== "active") {
      return messages$3.activate;
    }
    if (!customer?.transactions?.assetTransaction) {
      return messages$3.initialize;
    }
    if (isSupplyExpired) {
      return messages$3.createNewSupply;
    }
    return messages$3.next;
  };
  const actionButton = /* @__PURE__ */ jsx$1(Button$2, {
    className: classes$3.actionButton,
    type: "primary",
    disabled: !isNextAvailable || isSaving,
    onClick: onFinish,
    loading: isLoading,
    children: intl.formatMessage(getButtonText())
  });
  const [isUpdatingSupply, setUpdatingSupply] = react.exports.useState(false);
  react.exports.useEffect(() => {
    if (customer?.transactions?.updateSupplyTransaction) {
      const intId = setInterval(() => {
        request.post(`/supplies/${customer?.id}/isUpdated`).then(({
          updated,
          customer: newCustomer
        }) => {
          if (updated) {
            clearInterval(intId);
            updateCustomers((prev) => ({
              ...prev,
              [newCustomer.id]: newCustomer
            }));
          }
        });
      }, 5e3);
      return () => clearInterval(intId);
    }
  }, [customer?.transactions?.updateSupplyTransaction]);
  const updateSupplyDate = async () => {
    setUpdatingSupply(true);
    const upd = await request.patch(`/supplies/${customer?.id}/extend`).catch(() => {
      setUpdatingSupply(false);
      notify.error({
        message: intl.formatMessage(messages$3.updateError),
        description: intl.formatMessage(messages$3.updateErrorDesc),
        placement: "bottomRight"
      });
      return null;
    });
    setUpdatingSupply(false);
    if (!upd)
      return;
    updateCustomers((prev) => ({
      ...prev,
      [customer.id]: upd
    }));
  };
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [contextHolder, /* @__PURE__ */ jsx$1(Modal$1, {
      style: {
        padding: 24
      },
      title: customer ? "Customer" : "New customer",
      centered: true,
      width: 700,
      open: true,
      onOk: onSave,
      okText: "Save",
      cancelText: "Close",
      okButtonProps: {
        loading: isSaving,
        disabled: isLoading
      },
      onCancel,
      children: /* @__PURE__ */ jsxs(Form$1, {
        ...layout,
        className: classes$3.formWrapper,
        form,
        name: "customer",
        onFinish,
        children: [/* @__PURE__ */ jsx$1(Form$1.Item, {
          initialValue: customer?.customerName,
          name: "name",
          label: intl.formatMessage(messages$3.nameLabel),
          rules: nameRules,
          children: /* @__PURE__ */ jsx$1(Input$2, {})
        }), /* @__PURE__ */ jsx$1(Form$1.Item, {
          name: "id",
          initialValue: customer?.internalId,
          label: intl.formatMessage(messages$3.internalIdLabel),
          rules: [{
            validator: async (_rule, value, callback) => {
              if (!/^[a-zA-Z0-9-_.]{2,10}$/.test(value) || customer?.id)
                return;
              let unique = true;
              try {
                setValidating(true);
                unique = await isUnique(value);
              } catch {
                setValidating(false);
              }
              setValidating(false);
              if (!unique) {
                callback("Internal ID must be unique");
                throw new Error("Internal ID must be unique");
              }
            }
          }, ...internalIdRules],
          children: /* @__PURE__ */ jsx$1(Input$2, {
            disabled: Boolean(customer?.id)
          })
        }), /* @__PURE__ */ jsx$1(Form$1.Item, {
          initialValue: customer?.externalId,
          name: "externalId",
          label: intl.formatMessage(messages$3.externalIdLabel),
          rules: externalIdRules,
          children: /* @__PURE__ */ jsx$1(Input$2, {})
        }), Boolean(customer?.addresses?.length && isSupplyCreated) && /* @__PURE__ */ jsx$1(Form$1.Item, {
          label: intl.formatMessage(messages$3.addresses),
          children: /* @__PURE__ */ jsx$1(Form$1.List, {
            name: "addresses",
            initialValue: customer?.addresses?.map((address) => ({
              address,
              amount: customer?.asset?.amountOfMintedUnits || 0
            })),
            children: (fields, {
              remove
            }) => /* @__PURE__ */ jsxs(Fragment, {
              children: [/* @__PURE__ */ jsx$1(Table$1, {
                size: "small",
                style: {
                  marginBottom: 12
                },
                pagination: false,
                bordered: true,
                rowKey: (record) => record.address,
                columns: [{
                  title: "Address",
                  width: "100px",
                  key: "address",
                  dataIndex: "address",
                  render: (address) => /* @__PURE__ */ jsx$1("div", {
                    style: {
                      width: 200
                    },
                    children: address
                  })
                }, {
                  title: "Amount",
                  key: "amount",
                  dataIndex: "amount"
                }, {
                  width: 14 + 32,
                  title: " ",
                  render: () => customer?.status === "active" ? /* @__PURE__ */ jsx$1(MinusCircleOutlined$1, {
                    onClick: () => {
                    }
                  }) : null
                }],
                dataSource: addresses
              }), customer?.status === "active" && /* @__PURE__ */ jsx$1(Form$1.Item, {
                noStyle: true,
                children: /* @__PURE__ */ jsxs("div", {
                  className: classes$3.selectWrapper,
                  children: [/* @__PURE__ */ jsx$1(Input$2, {
                    placeholder: intl.formatMessage(messages$3.addAddressLabel),
                    className: classes$3.field,
                    value: addressToAdd || "",
                    onChange: (e) => setAddressToAdd(e.target.value)
                  }), /* @__PURE__ */ jsx$1(Button$2, {
                    disabled: !addressToAdd,
                    type: "primary",
                    onClick: () => {
                      form.setFieldValue("addresses", [...addresses || [], {
                        address: addressToAdd,
                        amount: ""
                      }]);
                      onAddressChange([addresses?.length ?? 0, "amount"]);
                      setAddressToAdd(null);
                    },
                    icon: /* @__PURE__ */ jsx$1(PlusOutlined$1, {}),
                    children: intl.formatMessage(messages$3.addAddress)
                  })]
                })
              })]
            })
          })
        }), Boolean(customer?.asset?.assetName && isAssetCreated) && /* @__PURE__ */ jsx$1(Form$1.Item, {
          label: intl.formatMessage(messages$3.assetNameLabel),
          children: /* @__PURE__ */ jsx$1(Input$2, {
            value: customer?.asset?.assetName,
            disabled: true,
            placeholder: intl.formatMessage(messages$3.assetNameLabel)
          })
        }), Boolean(+(customer?.asset?.amountOfMintedUnits || 0) && isAssetCreated) && /* @__PURE__ */ jsx$1(Form$1.Item, {
          label: intl.formatMessage(messages$3.assetAmountMintedLabel),
          children: /* @__PURE__ */ jsx$1(Input$2, {
            disabled: true,
            value: customer?.asset?.amountOfMintedUnits
          })
        }), Boolean(customer?.asset?.assetId && isAssetCreated) && /* @__PURE__ */ jsx$1(Form$1.Item, {
          label: intl.formatMessage(messages$3.assetIdLabel),
          children: /* @__PURE__ */ jsxs(Input$2.Group, {
            children: [/* @__PURE__ */ jsx$1("div", {
              className: classes$3.field,
              children: /* @__PURE__ */ jsx$1(Form$1.Item, {
                noStyle: true,
                children: /* @__PURE__ */ jsx$1(Input$2, {
                  addonBefore: /* @__PURE__ */ jsx$1(Typography$1.Text, {
                    className: classes$3.assetIdAddon,
                    children: intl.formatMessage(messages$3.assetIdIntLabel)
                  }),
                  className: classes$3.assetIdSize,
                  disabled: true,
                  value: new Decimal(customer?.asset?.assetId || 0).toFixed()
                })
              })
            }), /* @__PURE__ */ jsx$1("div", {
              children: /* @__PURE__ */ jsx$1(Form$1.Item, {
                noStyle: true,
                children: /* @__PURE__ */ jsx$1(Input$2, {
                  addonBefore: /* @__PURE__ */ jsx$1(Typography$1.Text, {
                    className: classes$3.assetIdAddon,
                    children: intl.formatMessage(messages$3.assetIdHexLabel)
                  }),
                  className: classes$3.assetIdSize,
                  disabled: true,
                  value: customer?.asset?.assetId
                })
              })
            })]
          })
        }), Boolean(customer?.controller?.controllerName && isControllerCreated) && /* @__PURE__ */ jsx$1(Form$1.Item, {
          name: "controllerName",
          initialValue: customer?.controller?.controllerName,
          label: intl.formatMessage(messages$3.controllerName),
          children: /* @__PURE__ */ jsx$1(Input$2, {
            value: customer?.controller?.controllerName,
            disabled: true,
            placeholder: intl.formatMessage(messages$3.controllerName)
          })
        }), Boolean(customer?.controller?.controllerAddress && isControllerCreated) && /* @__PURE__ */ jsx$1(Form$1.Item, {
          label: intl.formatMessage(messages$3.controllerAddress),
          children: /* @__PURE__ */ jsx$1(Input$2, {
            disabled: true,
            value: customer?.controller?.controllerAddress
          })
        }), Boolean(customer?.supply?.endDate && customer?.status === "active") && /* @__PURE__ */ jsxs(Form$1.Item, {
          label: intl.formatMessage(messages$3.supplyExpireDate),
          children: [/* @__PURE__ */ jsx$1(Input$2, {
            disabled: true,
            value: dayjs(customer?.supply?.endDate).format("LL")
          }), Boolean(customer?.transactions?.updateSupplyTransaction) && /* @__PURE__ */ jsx$1("div", {
            children: /* @__PURE__ */ jsx$1(Typography$1.Text, {
              className: classes$3.updateSupply,
              type: "secondary",
              children: intl.formatMessage(messages$3.updateSupplyDesc)
            })
          }), !isSupplyExpired && /* @__PURE__ */ jsx$1(Button$2, {
            className: classes$3.updateSupply,
            loading: isUpdatingSupply,
            disabled: Boolean(customer?.transactions?.updateSupplyTransaction),
            onClick: updateSupplyDate,
            type: "primary",
            children: intl.formatMessage(messages$3.updateSupply)
          })]
        }), /* @__PURE__ */ jsxs(Form$1.Item, {
          label: intl.formatMessage(messages$3.state),
          children: [/* @__PURE__ */ jsx$1("div", {
            children: /* @__PURE__ */ jsx$1(Segmented$1, {
              style: {
                borderBottomRightRadius: 0,
                borderBottomLeftRadius: 0
              },
              value: isSupplyExpired ? "incomplete" : customer?.status || "draft",
              options: states
            })
          }), /* @__PURE__ */ jsxs(Card$1, {
            style: {
              borderTopLeftRadius: 0
            },
            children: [/* @__PURE__ */ jsx$1("div", {
              children: /* @__PURE__ */ jsxs(Typography$1.Text, {
                type: "secondary",
                children: [/* @__PURE__ */ jsx$1(Checkbox$1, {
                  checked: customer?.id || name && internalId && !nameErrors && !idErrors && !extIdErrors
                }), "\xA0Fill the form"]
              })
            }), /* @__PURE__ */ jsx$1("div", {
              children: /* @__PURE__ */ jsxs(Typography$1.Text, {
                type: "secondary",
                children: [/* @__PURE__ */ jsx$1(Checkbox$1, {
                  checked: Boolean(customer?.id)
                }), "\xA0Submit or save it"]
              })
            }), /* @__PURE__ */ jsx$1("div", {
              children: /* @__PURE__ */ jsxs(Typography$1.Text, {
                type: "secondary",
                children: [/* @__PURE__ */ jsx$1(Checkbox$1, {
                  checked: Boolean(customer?.transactions?.assetTransaction)
                }), "\xA0Initialize the process"]
              })
            }), steps[0] || steps[1] ? actionButton : null, /* @__PURE__ */ jsx$1("div", {
              children: /* @__PURE__ */ jsxs(Typography$1.Text, {
                type: "secondary",
                children: [/* @__PURE__ */ jsx$1(Checkbox$1, {
                  checked: isAssetCreated
                }), "\xA0Open Tx.Mobile"]
              })
            }), /* @__PURE__ */ jsx$1("div", {
              children: /* @__PURE__ */ jsxs(Typography$1.Text, {
                type: "secondary",
                children: [/* @__PURE__ */ jsx$1(Checkbox$1, {
                  checked: isAssetCreated
                }), "\xA0Confirm create Asset transaction"]
              })
            }), steps[2] ? actionButton : null, /* @__PURE__ */ jsx$1("div", {
              children: /* @__PURE__ */ jsxs(Typography$1.Text, {
                type: "secondary",
                children: [/* @__PURE__ */ jsx$1(Checkbox$1, {
                  checked: isControllerCreated
                }), "\xA0Confirm create Controller transaction"]
              })
            }), steps[3] ? actionButton : null, /* @__PURE__ */ jsx$1("div", {
              children: /* @__PURE__ */ jsxs(Typography$1.Text, {
                type: "secondary",
                children: [/* @__PURE__ */ jsx$1(Checkbox$1, {
                  checked: isControllerAssetChanged
                }), "\xA0Confirm change asset Controller transaction"]
              })
            }), /* @__PURE__ */ jsx$1("div", {
              children: /* @__PURE__ */ jsxs(Typography$1.Text, {
                type: "secondary",
                children: [/* @__PURE__ */ jsx$1(Checkbox$1, {
                  checked: areUnitsCreated
                }), "\xA0Confirm create Units transaction"]
              })
            }), steps[4] ? actionButton : null, /* @__PURE__ */ jsx$1("div", {
              children: /* @__PURE__ */ jsxs(Typography$1.Text, {
                type: "secondary",
                children: [/* @__PURE__ */ jsx$1(Checkbox$1, {
                  checked: isSupplyCreated && !isSupplyExpired
                }), "\xA0Confirm create supply transaction"]
              })
            }), /* @__PURE__ */ jsx$1("div", {
              children: /* @__PURE__ */ jsxs(Typography$1.Text, {
                type: "secondary",
                children: [/* @__PURE__ */ jsx$1(Checkbox$1, {
                  checked: Boolean(customer?.status === "active" && !isSupplyExpired)
                }), "\xA0Activate the customer"]
              })
            }), steps[5] ? actionButton : null]
          })]
        })]
      })
    }), modalContext]
  });
};

function useWindowSize() {
  const [windowSize, setWindowSize] = react.exports.useState({
    width: void 0,
    height: void 0
  });
  react.exports.useEffect(() => {
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    }
    window.addEventListener("resize", handleResize);
    handleResize();
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  return windowSize;
}

const messages$2 = defineMessages({
  addAddress: {
    id: "page.customers.form.addAddress",
    defaultMessage: "Add address"
  },
  searchPlaceholder: {
    id: "page.customers.table.search.placeholder",
    defaultMessage: "Search {field}"
  },
  search: {
    id: "page.customers.table.search.btn",
    defaultMessage: "Search"
  },
  reset: {
    id: "page.customers.table.search.reset",
    defaultMessage: "Reset"
  },
  close: {
    id: "common.close",
    defaultMessage: "Close"
  },
  title: {
    id: "page.customers.title",
    defaultMessage: "Customers"
  },
  add: {
    id: "page.customers.addCustomer",
    defaultMessage: "Add customer"
  },
  updateStatuses: {
    id: "page.customers.addCustomer",
    defaultMessage: "Update supply statuses"
  },
  customerId: {
    id: "page.customers.table.customerId",
    defaultMessage: "Customer ID"
  },
  customerName: {
    id: "page.customers.table.name",
    defaultMessage: "Customer Name"
  },
  amount: {
    id: "page.customers.table.supply",
    defaultMessage: "Amount"
  },
  supply: {
    id: "page.customers.table.supply",
    defaultMessage: "Supply expires in"
  },
  actions: {
    id: "page.customers.table.actions",
    defaultMessage: "Actions"
  },
  transfer: {
    id: "page.customers.table.actions.transfer",
    defaultMessage: "Transfer"
  },
  mint: {
    id: "page.customers.table.actions.mint",
    defaultMessage: "Mint"
  },
  destroy: {
    id: "page.customers.table.actions.destroy",
    defaultMessage: "Destroy"
  },
  updatingSupplies: {
    id: "page.customers.table.actions.updatingSupplyStatuses",
    defaultMessage: "Updating supply statuses"
  }
});

const wrapper$1 = "_wrapper_nctd4_1";
const title = "_title_nctd4_17";
const pageActions = "_pageActions_nctd4_41";
const pageAction = "_pageAction_nctd4_41";
const headerRow = "_headerRow_nctd4_61";
const oddRow = "_oddRow_nctd4_69";
const action = "_action_nctd4_79";
const highlight = "_highlight_nctd4_87";
const table = "_table_nctd4_105";
const progress = "_progress_nctd4_115";
const classes$2 = {
	wrapper: wrapper$1,
	title: title,
	pageActions: pageActions,
	pageAction: pageAction,
	headerRow: headerRow,
	oddRow: oddRow,
	action: action,
	highlight: highlight,
	table: table,
	progress: progress
};

const antd_override = '';

const CustomersPage = () => {
  const intl = useIntl();
  const [address] = useCurrentAddress();
  const [customers, updateCustomers] = useCustomers();
  const [isLoading, setLoading] = react.exports.useState(false);
  const [searchText, setSearchText] = react.exports.useState("");
  const [searchedColumn, setSearchedColumn] = react.exports.useState("");
  const searchInput = react.exports.useRef(null);
  const [openAddModal, setOpenAddModal] = react.exports.useState(false);
  const getCustomers = () => {
    setLoading(true);
    request.get("/customers", {
      headers: {
        "ngrok-skip-browser-warning": "1"
      }
    }).then((res) => {
      setLoading(false);
      updateCustomers((prev) => ({
        ...prev,
        ...convertArrayToObject(res.customers, "id")
      }));
    }).catch(() => {
      setLoading(false);
    });
  };
  const data = react.exports.useMemo(() => Object.values(customers).sort((a, b) => a.dateOfCreation > b.dateOfCreation ? -1 : 1).map((customer) => ({
    customerId: customer.internalId || customer.id,
    id: customer.id,
    key: customer.id,
    name: customer.customerName,
    supplyExpire: getExpireDateText(customer?.status === "active" ? dayjs(customer?.supply?.endDate).toISOString() : null),
    amount: +(customer.asset?.amountOfMintedUnits || 0) || customer?.status === "active" ? `${intl.formatNumber(+(customer.asset?.amountOfMintedUnits || 0))} ${customer.asset?.unitsOfMeasure || ""}` || "0" : "",
    isActive: customer.status === "active"
  })), [customers]);
  const handleSearch = (selectedKeys, confirm, dataIndex) => {
    confirm();
    setSearchText(selectedKeys[0]);
    setSearchedColumn(dataIndex);
  };
  react.exports.useEffect(() => {
    getCustomers();
  }, []);
  const handleReset = (clearFilters) => {
    clearFilters();
    setSearchText("");
  };
  const getColumnSearchProps = (dataIndex) => ({
    filterDropdown: ({
      setSelectedKeys,
      selectedKeys,
      confirm,
      clearFilters,
      close
    }) => /* @__PURE__ */ jsxs("div", {
      style: {
        padding: 8
      },
      onKeyDown: (e) => e.stopPropagation(),
      children: [/* @__PURE__ */ jsx$1(Input$2, {
        ref: searchInput,
        placeholder: intl.formatMessage(messages$2.search, {
          field: dataIndex
        }),
        value: selectedKeys[0],
        onChange: (e) => setSelectedKeys(e.target.value ? [e.target.value] : []),
        onPressEnter: () => handleSearch(selectedKeys, confirm, dataIndex),
        style: {
          marginBottom: 8,
          display: "block"
        }
      }), /* @__PURE__ */ jsxs(Space$1, {
        children: [/* @__PURE__ */ jsx$1(Button$2, {
          type: "primary",
          onClick: () => handleSearch(selectedKeys, confirm, dataIndex),
          icon: /* @__PURE__ */ jsx$1(SearchOutlined$1, {}),
          size: "small",
          style: {
            width: 90
          },
          children: intl.formatMessage(messages$2.search)
        }), /* @__PURE__ */ jsx$1(Button$2, {
          onClick: () => {
            clearFilters && handleReset(clearFilters);
            handleSearch([], confirm, dataIndex);
          },
          size: "small",
          style: {
            width: 90
          },
          children: intl.formatMessage(messages$2.reset)
        }), /* @__PURE__ */ jsx$1(Button$2, {
          type: "link",
          size: "small",
          onClick: () => {
            close();
          },
          children: intl.formatMessage(messages$2.close)
        })]
      })]
    }),
    filterIcon: (filtered) => /* @__PURE__ */ jsx$1(SearchOutlined$1, {
      style: {
        color: filtered ? "var(--highlight)" : "var(--primaryText)"
      }
    }),
    onFilter: (value, record) => record[dataIndex].toString().toLowerCase().includes(value.toLowerCase()),
    onFilterDropdownOpenChange: (visible) => {
      if (visible) {
        setTimeout(() => searchInput.current?.select(), 100);
      }
    },
    render: (text) => searchedColumn === dataIndex ? /* @__PURE__ */ jsx$1(Highlighter, {
      highlightStyle: {
        backgroundColor: "#ffc069",
        padding: 0
      },
      searchWords: [searchText],
      autoEscape: true,
      textToHighlight: text ? text.toString() : ""
    }) : text
  });
  const [selectedCustomerId, setSelectedCustomerId] = react.exports.useState(null);
  const selectedCustomer = react.exports.useMemo(() => selectedCustomerId ? customers[selectedCustomerId] ?? null : null, [customers, selectedCustomerId]);
  const columns = [
    {
      title: intl.formatMessage(messages$2.customerId),
      dataIndex: "customerId",
      key: "customerId",
      filterSearch: true,
      render: (id, item) => /* @__PURE__ */ jsx$1(Button$2, {
        className: cn(classes$2.action, classes$2.highlight),
        type: "ghost",
        onClick: () => {
          setOpenAddModal(true);
          setSelectedCustomerId(item.id);
        },
        children: id
      })
    },
    {
      title: intl.formatMessage(messages$2.customerName),
      dataIndex: "name",
      key: "name",
      filterSearch: true,
      ...getColumnSearchProps("name")
    },
    {
      title: intl.formatMessage(messages$2.amount),
      dataIndex: "amount",
      key: "amount"
    },
    {
      title: intl.formatMessage(messages$2.supply),
      dataIndex: "supplyExpire",
      key: "supplyExpire"
    },
    {
      title: intl.formatMessage(messages$2.actions),
      key: "actions",
      width: "25%",
      render: (_v, item) => /* @__PURE__ */ jsxs(Space$1, {
        size: "middle",
        style: {
          flexWrap: "wrap"
        },
        children: [/* @__PURE__ */ jsx$1(Button$2, {
          className: classes$2.action,
          disabled: !item.isActive,
          type: "text",
          children: intl.formatMessage(messages$2.transfer)
        }), /* @__PURE__ */ jsx$1(Button$2, {
          className: classes$2.action,
          disabled: !item.isActive,
          type: "text",
          children: intl.formatMessage(messages$2.mint)
        }), /* @__PURE__ */ jsx$1(Button$2, {
          className: classes$2.action,
          disabled: !item.isActive,
          type: "text",
          children: intl.formatMessage(messages$2.destroy)
        })]
      })
    }
  ];
  const {
    height: windowHeight
  } = useWindowSize();
  const activeCustomers = react.exports.useMemo(() => data.filter(({
    isActive
  }) => isActive), [data]);
  const [updatingStatuses, setUpdatingStatuses] = react.exports.useState(false);
  const [showUpdateProgress, setShowUpdateProgress] = react.exports.useState(false);
  const [progress, setProgress] = react.exports.useState(0);
  const updateProgress = (to, step) => {
    let intId;
    let r;
    return Object.assign(new Promise((resolve) => {
      r = resolve;
      intId = setInterval(() => {
        setProgress((prev) => {
          const val = Math.round(prev + step);
          if (val >= to) {
            setProgress(to);
            clearInterval(intId);
            resolve(true);
          }
          return prev + step;
        });
      }, 200);
    }), {
      stop: () => {
        clearInterval(intId);
        r(false);
      }
    });
  };
  const updateCustomerSupplyStatuses = async () => {
    setProgress(0);
    setUpdatingStatuses(true);
    if (activeCustomers.length > 1)
      setShowUpdateProgress(true);
    await activeCustomers.reduce(async (accum, {
      id
    }, i) => {
      await accum;
      const newCustomerPromise = request.post(`/supplies/${id}/status`).catch(() => null);
      const current = Math.round(i / activeCustomers.length * 100);
      const next = Math.round((i + 1 / activeCustomers.length) * 100) - 1;
      const step = (next - current) / 15;
      const fastStep = (next - current) / 3;
      const {
        stop
      } = updateProgress(next, step);
      const newCustomer = await newCustomerPromise;
      stop();
      await updateProgress(next, fastStep);
      if (!newCustomer)
        return;
      updateCustomers((v) => ({
        ...v,
        [id]: newCustomer
      }));
    }, Promise.resolve());
    setShowUpdateProgress(false);
    setUpdatingStatuses(false);
  };
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsxs("div", {
      className: classes$2.wrapper,
      children: [/* @__PURE__ */ jsxs("div", {
        className: classes$2.title,
        children: [intl.formatMessage(messages$2.title), /* @__PURE__ */ jsxs("div", {
          className: classes$2.pageActions,
          children: [/* @__PURE__ */ jsx$1(Button$2, {
            className: classes$2.pageAction,
            type: "primary",
            disabled: !activeCustomers.length,
            loading: updatingStatuses,
            onClick: updateCustomerSupplyStatuses,
            children: intl.formatMessage(messages$2.updateStatuses)
          }), /* @__PURE__ */ jsx$1(Button$2, {
            type: "primary",
            disabled: !address,
            onClick: () => {
              setSelectedCustomerId(null);
              setOpenAddModal(true);
            },
            children: intl.formatMessage(messages$2.add)
          })]
        })]
      }), openAddModal && /* @__PURE__ */ jsx$1(CustomersForm, {
        onClose: () => {
          setOpenAddModal(false);
          setSelectedCustomerId(null);
        },
        customer: selectedCustomer
      }), /* @__PURE__ */ jsx$1(Table$1, {
        loading: isLoading,
        bordered: true,
        scroll: {
          y: windowHeight ? windowHeight * 0.8 : void 0
        },
        showSorterTooltip: false,
        pagination: false,
        onHeaderRow: () => ({
          className: classes$2.headerRow
        }),
        rowKey: (record) => record.customerId,
        className: classes$2.table,
        columns,
        rowClassName: (_record, index) => index % 2 ? "" : classes$2.oddRow,
        dataSource: data
      })]
    }), /* @__PURE__ */ jsx$1(Modal$1, {
      open: showUpdateProgress,
      footer: null,
      closable: false,
      title: intl.formatMessage(messages$2.updatingSupplies),
      width: 500,
      children: /* @__PURE__ */ jsx$1("div", {
        className: classes$2.progress,
        children: /* @__PURE__ */ jsx$1(Progress$1, {
          percent: Math.floor(progress),
          type: "circle"
        })
      })
    })]
  });
};

/**
 * Actions represent the type of change to a location value.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action
 */
var Action;

(function (Action) {
  /**
   * A POP indicates a change to an arbitrary index in the history stack, such
   * as a back or forward navigation. It does not describe the direction of the
   * navigation, only that the current index changed.
   *
   * Note: This is the default action for newly created history objects.
   */
  Action["Pop"] = "POP";
  /**
   * A PUSH indicates a new entry being added to the history stack, such as when
   * a link is clicked and a new page loads. When this happens, all subsequent
   * entries in the stack are lost.
   */

  Action["Push"] = "PUSH";
  /**
   * A REPLACE indicates the entry at the current index in the history stack
   * being replaced by a new one.
   */

  Action["Replace"] = "REPLACE";
})(Action || (Action = {}));

var readOnly = function (obj) {
  return obj;
};

var BeforeUnloadEventType = 'beforeunload';
var PopStateEventType = 'popstate';
/**
 * Browser history stores the location in regular URLs. This is the standard for
 * most web apps, but it requires some configuration on the server to ensure you
 * serve the same app at multiple URLs.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
 */

function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$window = _options.window,
      window = _options$window === void 0 ? document.defaultView : _options$window;
  var globalHistory = window.history;

  function getIndexAndLocation() {
    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;
    var state = globalHistory.state || {};
    return [state.idx, readOnly({
      pathname: pathname,
      search: search,
      hash: hash,
      state: state.usr || null,
      key: state.key || 'default'
    })];
  }

  var blockedPopTx = null;

  function handlePop() {
    if (blockedPopTx) {
      blockers.call(blockedPopTx);
      blockedPopTx = null;
    } else {
      var nextAction = Action.Pop;

      var _getIndexAndLocation = getIndexAndLocation(),
          nextIndex = _getIndexAndLocation[0],
          nextLocation = _getIndexAndLocation[1];

      if (blockers.length) {
        if (nextIndex != null) {
          var delta = index - nextIndex;

          if (delta) {
            // Revert the POP
            blockedPopTx = {
              action: nextAction,
              location: nextLocation,
              retry: function retry() {
                go(delta * -1);
              }
            };
            go(delta);
          }
        }
      } else {
        applyTx(nextAction);
      }
    }
  }

  window.addEventListener(PopStateEventType, handlePop);
  var action = Action.Pop;

  var _getIndexAndLocation2 = getIndexAndLocation(),
      index = _getIndexAndLocation2[0],
      location = _getIndexAndLocation2[1];

  var listeners = createEvents();
  var blockers = createEvents();

  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends$2({}, globalHistory.state, {
      idx: index
    }), '');
  }

  function createHref(to) {
    return typeof to === 'string' ? to : createPath(to);
  } // state defaults to `null` because `window.history.state` does


  function getNextLocation(to, state) {
    if (state === void 0) {
      state = null;
    }

    return readOnly(_extends$2({
      pathname: location.pathname,
      hash: '',
      search: ''
    }, typeof to === 'string' ? parsePath(to) : to, {
      state: state,
      key: createKey()
    }));
  }

  function getHistoryStateAndUrl(nextLocation, index) {
    return [{
      usr: nextLocation.state,
      key: nextLocation.key,
      idx: index
    }, createHref(nextLocation)];
  }

  function allowTx(action, location, retry) {
    return !blockers.length || (blockers.call({
      action: action,
      location: location,
      retry: retry
    }), false);
  }

  function applyTx(nextAction) {
    action = nextAction;

    var _getIndexAndLocation3 = getIndexAndLocation();

    index = _getIndexAndLocation3[0];
    location = _getIndexAndLocation3[1];
    listeners.call({
      action: action,
      location: location
    });
  }

  function push(to, state) {
    var nextAction = Action.Push;
    var nextLocation = getNextLocation(to, state);

    function retry() {
      push(to, state);
    }

    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),
          historyState = _getHistoryStateAndUr[0],
          url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading
      // try...catch because iOS limits us to 100 pushState calls :/


      try {
        globalHistory.pushState(historyState, '', url);
      } catch (error) {
        // They are going to lose state here, but there is no real
        // way to warn them about it since the page will refresh...
        window.location.assign(url);
      }

      applyTx(nextAction);
    }
  }

  function replace(to, state) {
    var nextAction = Action.Replace;
    var nextLocation = getNextLocation(to, state);

    function retry() {
      replace(to, state);
    }

    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),
          historyState = _getHistoryStateAndUr2[0],
          url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading


      globalHistory.replaceState(historyState, '', url);
      applyTx(nextAction);
    }
  }

  function go(delta) {
    globalHistory.go(delta);
  }

  var history = {
    get action() {
      return action;
    },

    get location() {
      return location;
    },

    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    back: function back() {
      go(-1);
    },
    forward: function forward() {
      go(1);
    },
    listen: function listen(listener) {
      return listeners.push(listener);
    },
    block: function block(blocker) {
      var unblock = blockers.push(blocker);

      if (blockers.length === 1) {
        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
      }

      return function () {
        unblock(); // Remove the beforeunload listener so the document may
        // still be salvageable in the pagehide event.
        // See https://html.spec.whatwg.org/#unloading-documents

        if (!blockers.length) {
          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
        }
      };
    }
  };
  return history;
}

function promptBeforeUnload(event) {
  // Cancel the event.
  event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.

  event.returnValue = '';
}

function createEvents() {
  var handlers = [];
  return {
    get length() {
      return handlers.length;
    },

    push: function push(fn) {
      handlers.push(fn);
      return function () {
        handlers = handlers.filter(function (handler) {
          return handler !== fn;
        });
      };
    },
    call: function call(arg) {
      handlers.forEach(function (fn) {
        return fn && fn(arg);
      });
    }
  };
}

function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
/**
 * Creates a string URL path from the given pathname, search, and hash components.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath
 */


function createPath(_ref) {
  var _ref$pathname = _ref.pathname,
      pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,
      _ref$search = _ref.search,
      search = _ref$search === void 0 ? '' : _ref$search,
      _ref$hash = _ref.hash,
      hash = _ref$hash === void 0 ? '' : _ref$hash;
  if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;
  if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;
  return pathname;
}
/**
 * Parses a string URL path into its separate pathname, search, and hash components.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath
 */

function parsePath(path) {
  var parsedPath = {};

  if (path) {
    var hashIndex = path.indexOf('#');

    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }

    var searchIndex = path.indexOf('?');

    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }

    if (path) {
      parsedPath.pathname = path;
    }
  }

  return parsedPath;
}

const discoveryService = "https://disco.coreledger.net/api/discovery/v1.0/config";
const history = createBrowserHistory();
const pause = (ms) => new Promise((resolve) => {
  setTimeout(resolve, ms);
});
const animationDelay = () => pause(2500);
const initMainContexts = async () => {
  const delay = animationDelay();
  const discovery = await request.get(`${discoveryService}/notrzr.net?dev=true`).then((res) => Array.isArray(res) ? res : [res]);
  if (discovery[0])
    updateDiscovery(discovery[0]);
  const isReturningFromIS = matchPath(
    {
      path: identityServerRedirectPath
    },
    history.location.pathname
  );
  if (isReturningFromIS) {
    await OidcService.signinCallback();
  }
  const user = await OidcService.getUser();
  if (!user) {
    await OidcService.clearStaleState();
    await delay;
    return;
  }
  if (isReturningFromIS) {
    history.replace("/");
  }
  await OidcService.startSilentRenew();
  updateUser(user);
  try {
    await updateWallets();
  } catch (err) {
    if (err?.response?.status === 401) {
      await OidcService.removeUser();
      await OidcService.clearStaleState();
      updateUser(null);
    }
  }
  await delay;
};

const messages$1 = defineMessages({
  title: {
    id: "page.addresses.title",
    defaultMessage: "Addresses"
  },
  active: {
    id: "page.addresses.address.active",
    defaultMessage: "Active"
  },
  activate: {
    id: "page.addresses.address.activate",
    defaultMessage: "Activate"
  },
  walletName: {
    id: "page.addresses.address.walletName",
    defaultMessage: "Wallet name: "
  },
  address: {
    id: "page.addresses.address.address",
    defaultMessage: "Address: "
  },
  noAddresses: {
    id: "page.addresses.noAddresses",
    defaultMessage: "Register a signable address on WLM"
  },
  close: {
    id: "common.close",
    defaultMessage: "Close"
  }
});

const wrapper = "_wrapper_1n7mx_1";
const wallets = "_wallets_1n7mx_19";
const center = "_center_1n7mx_41";
const emptyWrapper = "_emptyWrapper_1n7mx_49";
const modalWrapper = "_modalWrapper_1n7mx_63";
const active = "_active_1n7mx_71";
const walletDetails = "_walletDetails_1n7mx_89";
const walletDetailsAddress = "_walletDetailsAddress_1n7mx_107";
const walletDetailsQR = "_walletDetailsQR_1n7mx_115";
const walletWrapper = "_walletWrapper_1n7mx_123";
const classes$1 = {
	wrapper: wrapper,
	wallets: wallets,
	center: center,
	emptyWrapper: emptyWrapper,
	modalWrapper: modalWrapper,
	active: active,
	walletDetails: walletDetails,
	walletDetailsAddress: walletDetailsAddress,
	walletDetailsQR: walletDetailsQR,
	walletWrapper: walletWrapper
};

const skeletonContent = new Array(5).fill({
  address: "",
  name: "",
  description: ""
});
const Addresses = () => {
  const intl = useIntl();
  const [isLoading, setLoading] = react.exports.useState(true);
  const [wallets, updateWallets] = useWallets();
  const [currentAddress, setCurrentAddress] = useCurrentAddress();
  const [selectedWallet, setSelectedWallet] = react.exports.useState(null);
  react.exports.useEffect(() => {
    updateWallets().then(() => {
      setLoading(false);
    }).catch(() => {
      setLoading(false);
    });
  }, []);
  const qrData = react.exports.useMemo(() => JSON.stringify({
    T: "V",
    A: selectedWallet?.address
  }), [selectedWallet]);
  const showSkeleton = isLoading && !wallets?.length;
  return /* @__PURE__ */ jsxs("div", {
    className: classes$1.wrapper,
    children: [/* @__PURE__ */ jsx$1("div", {
      children: /* @__PURE__ */ jsx$1(Typography$1.Title, {
        children: intl.formatMessage(messages$1.title)
      })
    }), /* @__PURE__ */ jsx$1("div", {
      className: classes$1.wallets,
      children: wallets?.length || isLoading ? (showSkeleton ? skeletonContent : wallets)?.map((wallet, i) => showSkeleton ? /* @__PURE__ */ jsx$1("div", {
        className: classes$1.walletWrapper,
        children: /* @__PURE__ */ jsx$1(Skeleton$1, {
          loading: isLoading,
          active: isLoading,
          paragraph: {
            rows: 2
          }
        }, i)
      }) : /* @__PURE__ */ jsxs("div", {
        className: classes$1.walletWrapper,
        onClick: () => !isLoading && setSelectedWallet(wallet),
        children: [/* @__PURE__ */ jsx$1(Typography$1.Text, {
          className: classes$1.active,
          style: {
            opacity: !isLoading && wallet.address === currentAddress ? 1 : 0
          },
          children: intl.formatMessage(messages$1.active)
        }), /* @__PURE__ */ jsx$1(Typography$1.Title, {
          style: {
            marginTop: 0
          },
          level: 5,
          children: wallet.address
        }), /* @__PURE__ */ jsx$1("div", {
          children: /* @__PURE__ */ jsxs(Typography$1.Text, {
            children: [/* @__PURE__ */ jsx$1(Typography$1.Text, {
              strong: true,
              children: intl.formatMessage(messages$1.walletName)
            }), wallet.Name]
          })
        }), /* @__PURE__ */ jsx$1(Typography$1.Text, {
          style: {
            opacity: wallet.description ? 1 : 0,
            userSelect: "none"
          },
          italic: true,
          children: wallet.description
        })]
      }, wallet.address || i)) : /* @__PURE__ */ jsx$1("div", {
        className: classes$1.emptyWrapper,
        children: /* @__PURE__ */ jsx$1(Typography$1.Title, {
          className: classes$1.center,
          level: 2,
          children: intl.formatMessage(messages$1.noAddresses)
        })
      })
    }), /* @__PURE__ */ jsx$1(Modal$1, {
      className: classes$1.modalWrapper,
      title: selectedWallet?.name || "",
      centered: true,
      open: Boolean(selectedWallet),
      footer: false,
      cancelText: intl.formatMessage(messages$1.close),
      onCancel: () => setSelectedWallet(null),
      children: selectedWallet && /* @__PURE__ */ jsxs("div", {
        className: classes$1.walletDetails,
        children: [/* @__PURE__ */ jsx$1("div", {
          className: classes$1.walletDetailsAddress,
          children: /* @__PURE__ */ jsxs(Typography$1.Text, {
            children: [/* @__PURE__ */ jsx$1(Typography$1.Text, {
              strong: true,
              children: intl.formatMessage(messages$1.address)
            }), selectedWallet.address]
          })
        }), /* @__PURE__ */ jsx$1("div", {
          children: /* @__PURE__ */ jsx$1(Switch$1, {
            checked: selectedWallet.address === currentAddress,
            onChange: (checked) => {
              if (checked)
                setCurrentAddress(selectedWallet.address);
            },
            checkedChildren: /* @__PURE__ */ jsxs(Fragment, {
              children: [/* @__PURE__ */ jsx$1(CheckOutlined$1, {}), /* @__PURE__ */ jsx$1("span", {
                style: {
                  marginLeft: 4
                },
                children: intl.formatMessage(messages$1.active)
              })]
            }),
            unCheckedChildren: intl.formatMessage(messages$1.activate),
            defaultChecked: true
          })
        }), /* @__PURE__ */ jsx$1("div", {
          className: classes$1.walletDetailsQR,
          children: /* @__PURE__ */ jsx$1(QRCode, {
            value: qrData,
            size: 255
          })
        })]
      })
    })]
  });
};

const messages = defineMessages({
  loginRequired: {
    id: "page.main.loginRequired",
    defaultMessage: "You must be logged in to manage NFA"
  }
});

const pageWrapper = "_pageWrapper_6kevh_1";
const classes = {
	pageWrapper: pageWrapper
};

let initialized = false;
const initPromise = initMainContexts().then(() => {
  initialized = true;
});
function App() {
  const intl = useIntl();
  const [user] = useUser();
  if (!initialized) {
    throw initPromise;
  }
  return /* @__PURE__ */ jsx$1(BrowserRouter, {
    children: /* @__PURE__ */ jsx$1(Page, {
      children: /* @__PURE__ */ jsxs(Routes, {
        children: [/* @__PURE__ */ jsx$1(Route, {
          path: NavigationPaths.Root,
          element: /* @__PURE__ */ jsx$1("div", {
            className: classes.pageWrapper,
            children: /* @__PURE__ */ jsx$1("div", {
              children: user ? /* @__PURE__ */ jsx$1(Navigate, {
                to: NavigationPaths.Customers
              }) : intl.formatMessage(messages.loginRequired)
            })
          })
        }), /* @__PURE__ */ jsx$1(Route, {
          path: NavigationPaths.Customers,
          element: /* @__PURE__ */ jsxs(Fragment, {
            children: [!user && /* @__PURE__ */ jsx$1(Navigate, {
              to: NavigationPaths.Root
            }), /* @__PURE__ */ jsx$1(CustomersPage, {})]
          })
        }), /* @__PURE__ */ jsx$1(Route, {
          path: NavigationPaths.Addresses,
          element: /* @__PURE__ */ jsxs("div", {
            className: classes.pageWrapper,
            children: [!user && /* @__PURE__ */ jsx$1(Navigate, {
              to: NavigationPaths.Root
            }), /* @__PURE__ */ jsx$1(Addresses, {})]
          })
        }), /* @__PURE__ */ jsx$1(Route, {
          path: NavigationPaths.Assets,
          element: /* @__PURE__ */ jsxs("div", {
            className: classes.pageWrapper,
            children: [!user && /* @__PURE__ */ jsx$1(Navigate, {
              to: NavigationPaths.Root
            }), /* @__PURE__ */ jsx$1("div", {
              children: /* @__PURE__ */ jsx$1("h1", {
                children: "Assets"
              })
            }), /* @__PURE__ */ jsx$1("div", {
              children: user ? "Functionality is not available at the moment but it might be later" : "You must be logged in to manage NFA"
            })]
          })
        })]
      })
    })
  });
}

export { App as default };
